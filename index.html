<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="favicon.png">
    <title>Proyección Expensas - Barrio El Centauro</title>
    <!-- Librería SheetJS (js-xlsx) para leer/escribir Excel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Librería Chart.js para gráficos -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Plugin doughnut 3D shadow -->
    <script>
    /* Plugin: doughnutShadow3D
       Añade una sombra suave debajo de cada porción para simular profundidad 3 D.
       Seguro para todos los datasets (evita NaN en createRadialGradient). */
    const doughnutShadow3D = {
      id: 'doughnutShadow3D',
      afterDatasetDraw(chart, args, opts) {
        const {ctx} = chart;
        if (args.meta.type !== 'doughnut') return;

        args.meta.data.forEach(segment => {
          const {x, y, startAngle, endAngle, innerRadius, outerRadius} = segment;
          if (!isFinite(x) || !isFinite(y) || !isFinite(innerRadius) || !isFinite(outerRadius)) return;

          ctx.save();
          ctx.fillStyle = 'rgba(0,0,0,0.15)';      // shadow color
          ctx.translate(0, 4);                     // vertical offset
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.arc(x, y, outerRadius, startAngle, endAngle);
          ctx.arc(x, y, innerRadius, endAngle, startAngle, true);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        });
      }
    };
    // Registrar plugin globalmente
    if (window.Chart && !Chart.registry.plugins.get('doughnutShadow3D')) {
      Chart.register(doughnutShadow3D);
    }
    </script>

    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts (Inter) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- Reset Básico y Fuentes --- */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; /* Base font size */ }
        body {
            font-family: 'Inter', 'Segoe UI', sans-serif;
            line-height: 1.7; /* Improved readability */
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* --- Variables de Color (Paleta Refinada) --- */
        :root {
            --bg-color: #f8f9fa;              /* Slightly off-white */
            --text-color: #343a40;            /* Darker gray */
            --primary-color: #007bff;          /* Classic blue */
            --primary-color-darker: #0056b3;   /* Darker blue for hover */
            --secondary-color: #6c757d;        /* Standard gray */
            --secondary-color-darker: #5a6268; /* Darker gray for hover */
            --accent-color: #28a745;           /* Vibrant green */
            --accent-color-darker: #218838;    /* Darker green for hover */
            --danger-color: #dc3545;           /* Red */
            --danger-color-darker: #c82333;    /* Darker red */
            --warning-color: #ffc107;           /* Yellow */
            --warning-color-darker: #e0a800;   /* Darker yellow */
            --info-color: #17a2b8;             /* Teal */
            --info-color-darker: #138496;      /* Darker teal */
            --success-color: var(--accent-color); /* Alias for consistency */
            --success-color-darker: var(--accent-color-darker); /* Alias */

            --border-color: #dee2e6;           /* Light gray border */
            --header-bg: #ffffff;              /* White header */
            --card-bg: #ffffff;                /* White cards */
            --shadow-color: rgba(0, 0, 0, 0.08); /* Softer shadow */
            --input-bg: #ffffff;
            --input-border: #ced4da;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(0, 123, 255, 0.25);
            --button-text: #ffffff;
            --button-warning-text: #212529; /* Dark text for yellow button */
            --table-header-bg: #eef2f7;        /* Lighter table header */
            --table-row-hover: #f1f3f5;        /* Subtle hover */
            --expandable-row-bg: #f8f9fa;      /* Same as body bg for subtle diff */
            --clickable-row-hover: #e9ecef;    /* Slightly darker hover for clickable rows */
            --disabled-bg: #e9ecef;
            --disabled-text: #6c757d;
            --disabled-border: #ced4da;

            /* >>> COLORES REAL/ESTIMADO <<< */
            --real-month-bg: #d1f7d9; /* Light, fresh green */
            --real-month-text: #0f5132; /* Dark green text for light green bg */
            --estimated-month-bg: #ffe8d6; /* Soft Orange/Peach */
            --estimated-month-text: #854408; /* Dark orange/brown text for light orange bg */
            --estimated-month-border: #ffda6a;

             /* >>> CHATBOT COLORS <<< */
            --chatbot-icon-bg: linear-gradient(135deg, var(--primary-color), var(--info-color));
            --chatbot-icon-hover-bg: linear-gradient(135deg, var(--primary-color-darker), var(--info-color-darker));
            --chatbot-header-bg: var(--primary-color);
            --chatbot-user-msg-bg: var(--primary-color);
            --chatbot-user-msg-text: var(--button-text);
            --chatbot-bot-msg-bg: var(--table-row-hover);
            --chatbot-bot-msg-text: var(--text-color);
            --chatbot-bg: var(--card-bg);
            --chatbot-suggestion-bg: var(--primary-color-darker);
            --chatbot-suggestion-text: var(--button-text);
            --chatbot-suggestion-hover-bg: var(--primary-color);
        }

        body.dark-mode {
            --bg-color: #1a1a1a;              /* Very dark gray */
            --text-color: #e0e0e0;            /* Light gray text */
            --primary-color: #58a6ff;          /* Brighter blue */
            --primary-color-darker: #79b8ff;   /* Lighter blue for hover */
            --secondary-color: #8b949e;        /* Lighter gray */
            --secondary-color-darker: #a0a8b0; /* Lighter gray hover */
            --accent-color: #56d364;           /* Brighter green */
            --accent-color-darker: #6bde7a;    /* Lighter green hover */
            --danger-color: #f85149;           /* Bright red */
            --danger-color-darker: #fa6a61;    /* Lighter red */
            --warning-color: #f0b41e;          /* Bright yellow */
            --warning-color-darker: #f2c037;   /* Lighter yellow */
            --info-color: #6cb6f1;             /* Bright teal */
            --info-color-darker: #85c3f4;      /* Lighter teal */
            --success-color: var(--accent-color);
            --success-color-darker: var(--accent-color-darker);

            --border-color: #444c56;           /* Darker border */
            --header-bg: #2c2c2c;              /* Dark card background */
            --card-bg: #2c2c2c;                /* Dark card background */
            --shadow-color: rgba(255, 255, 255, 0.05); /* Subtle white shadow */
            --input-bg: #3a3f44;
            --input-border: #5a6268;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(88, 166, 255, 0.25);
            --button-text: #1a1a1a; /* Dark text on bright buttons */
            --button-warning-text: #1a1a1a;
            --table-header-bg: #343a40;        /* Darker header */
            --table-row-hover: #3e444a;        /* Subtle dark hover */
            --expandable-row-bg: #343a40;      /* Darker expandable row bg */
            --clickable-row-hover: #495057;    /* Darker hover for clickable */
            --disabled-bg: #495057;
            --disabled-text: #adb5bd;
            --disabled-border: #5a6268;

            /* >>> COLORES REAL/ESTIMADO OSCURO <<< */
            --real-month-bg: #1c4a2b; /* Darker Green */
            --real-month-text: #a3cfbb; /* Lighter green text for dark green bg */
            --estimated-month-bg: #7c3e00; /* Dark Orange */
            --estimated-month-text: #ffc999; /* Lighter orange text for dark orange bg */
            --estimated-month-border: #f0b41e;

             /* >>> CHATBOT COLORS DARK <<< */
            --chatbot-icon-bg: linear-gradient(135deg, var(--primary-color), var(--info-color));
            --chatbot-icon-hover-bg: linear-gradient(135deg, var(--primary-color-darker), var(--info-color-darker));
            --chatbot-header-bg: var(--primary-color);
            --chatbot-user-msg-bg: var(--primary-color);
            --chatbot-user-msg-text: #111;
            --chatbot-bot-msg-bg: var(--table-row-hover);
            --chatbot-bot-msg-text: var(--text-color);
            --chatbot-bg: var(--card-bg);
            --chatbot-suggestion-bg: var(--primary-color-darker);
            --chatbot-suggestion-text: #111;
            --chatbot-suggestion-hover-bg: var(--primary-color);
        }
        /* Cell specific styles */
        td.real-month-cell, th.real-month-cell { background-color: var(--real-month-bg) !important; color: var(--real-month-text) !important; }
        td.estimated-month-cell, th.estimated-month-cell { background-color: var(--estimated-month-bg) !important; color: var(--estimated-month-text) !important; }
        input.real-month-cell { background-color: var(--real-month-bg) !important; color: var(--real-month-text) !important; border-color: var(--real-month-bg) !important; }
        input.estimated-month-cell { background-color: var(--estimated-month-bg) !important; color: var(--estimated-month-text) !important; border-color: var(--estimated-month-border) !important; }


        /* --- Estilos Generales --- */
        .container { width: 95%; max-width: 1700px; margin: 0 auto; padding: 25px 20px; }
        h1, h2, h3, h4 { color: var(--primary-color); margin-bottom: 1em; font-weight: 600; }
        h1 { font-size: 2.2rem; text-align: center; }
        h2 { font-size: 1.8rem; border-bottom: 2px solid var(--accent-color); padding-bottom: 0.4em; }
        h3 { font-size: 1.4rem; margin-top: 1.8em; }
        h4 { font-size: 1.15rem; color: var(--secondary-color); margin-top: 1.2em; margin-bottom: 0.6em; }
        a { color: var(--primary-color); text-decoration: none; transition: color 0.2s ease; }
        a:hover { color: var(--primary-color-darker); text-decoration: underline; }

        button {
            padding: 12px 22px;
            border: 1px solid transparent;
            border-radius: 6px;
            background-color: var(--primary-color);
            color: var(--button-text);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out, transform 0.1s ease, box-shadow 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            line-height: 1.5;
            text-align: center;
        }
        button:hover {
            background-color: var(--primary-color-darker);
            border-color: var(--primary-color-darker);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        button:focus {
            outline: none;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        button:disabled {
            background-color: var(--disabled-bg);
            color: var(--disabled-text);
            border-color: var(--disabled-border);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        button i { margin-right: 2px; }
        .header-actions button { padding: 8px 12px; font-size: 0.9rem; } /* Para botones de localStorage */


        /* Button variants */
        .button-primary { background-color: var(--primary-color); border-color: var(--primary-color); color: var(--button-text); }
        .button-primary:hover { background-color: var(--primary-color-darker); border-color: var(--primary-color-darker); }
        .button-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: var(--button-text); }
        .button-secondary:hover { background-color: var(--secondary-color-darker); border-color: var(--secondary-color-darker); }
        .button-success { background-color: var(--success-color); border-color: var(--success-color); color: var(--button-text); }
        .button-success:hover { background-color: var(--success-color-darker); border-color: var(--success-color-darker); }
        .button-danger { background-color: var(--danger-color); border-color: var(--danger-color); color: var(--button-text); }
        .button-danger:hover { background-color: var(--danger-color-darker); border-color: var(--danger-color-darker); }
        .button-warning { background-color: var(--warning-color); border-color: var(--warning-color); color: var(--button-warning-text); }
        .button-warning:hover { background-color: var(--warning-color-darker); border-color: var(--warning-color-darker); }
        .button-info { background-color: var(--info-color); border-color: var(--info-color); color: var(--button-text); }
        .button-info:hover { background-color: var(--info-color-darker); border-color: var(--info-color-darker); }
        .button-sm { padding: 6px 12px; font-size: 0.85rem; gap: 6px;}

        /* --- Header --- */
        header {
            background-color: var(--header-bg);
            padding: 15px 0;
            box-shadow: 0 2px 5px var(--shadow-color);
            position: sticky; top: 0; z-index: 1000;
            border-bottom: 1px solid var(--border-color);
        }
        header .container { display: flex; justify-content: space-between; align-items: center; padding-top: 0; padding-bottom: 0; }
        .app-title { font-size: 1.6rem; font-weight: 700; color: var(--primary-color); margin-right: auto; /* Empuja otros elementos a la derecha */}
        .header-actions { display: flex; align-items: center; gap: 15px; }
        #theme-toggle { font-size: 1.3rem; background: none; border: none; color: var(--text-color); cursor: pointer; padding: 5px; border-radius: 50%; transition: background-color 0.2s;}
        #theme-toggle:hover { background-color: var(--table-row-hover); }

        /* --- Navegación / Pestañas --- */
        .tabs {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 5px;
        }
        .tab-link {
            padding: 12px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-bottom: -1px; /* Overlap bottom border */
            background-color: transparent;
            color: var(--secondary-color);
            font-size: 1rem;
            font-weight: 600;
            border-radius: 6px 6px 0 0;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .tab-link:hover {
             color: var(--primary-color);
             background-color: var(--table-row-hover);
        }
        .tab-link.active {
            background-color: var(--card-bg);
            border-color: var(--border-color);
            border-bottom-color: var(--card-bg);
            color: var(--primary-color);
            font-weight: 700;
        }
        .tab-content {
            display: none;
            padding: 30px;
            border: 1px solid var(--border-color);
            border-top: none;
            background-color: var(--card-bg);
            border-radius: 0 0 6px 6px;
            box-shadow: 0 5px 15px var(--shadow-color);
        }
        .tab-content.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Formularios y Entradas --- */
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-color); font-size: 0.95rem;}
        input[type="text"], input[type="number"], input[type="file"], select, textarea {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid var(--input-border);
            border-radius: 6px;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        input:focus, select:focus, textarea:focus {
            border-color: var(--input-focus-border);
            outline: 0;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        input:disabled, select:disabled, textarea:disabled {
             background-color: var(--disabled-bg);
             color: var(--disabled-text);
             border-color: var(--disabled-border);
             cursor: not-allowed;
        }
        input[type="number"] { text-align: right; -moz-appearance: textfield; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { margin: 0; }
        input[type="file"] { padding: 8px; line-height: 1.5; }
        .input-group { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
        .input-group label { margin-bottom: 0; font-weight: normal;}
        .input-group input[type="radio"] { width: auto; margin-right: 5px; }
        .input-small { width: 150px; display: inline-block; margin-left: 10px; }

        /* --- Tablas --- */
        .table-container { overflow-x: auto; margin-top: 25px; border: 1px solid var(--border-color); border-radius: 6px; }
        table { width: 100%; border-collapse: collapse; background-color: var(--card-bg); font-size: 0.9rem; }
        th, td {
            padding: 12px 15px;
            border: none;
            border-bottom: 1px solid var(--border-color);
            text-align: left;
            vertical-align: middle;
            white-space: nowrap;
        }
        th {
            background-color: var(--table-header-bg);
            font-weight: 600;
            position: sticky; top: 0; z-index: 10; /* Mantener en 10 para que no tape el header del sitio */
            border-bottom-width: 2px;
        }
        /* Sub-header para tablas con múltiples niveles */
        th.sub-header { position: sticky; top: 45px; z-index: 9; /* Debajo del header principal de la tabla */ }

        tbody tr:last-child td { border-bottom: none; }
        tbody tr:hover { background-color: var(--table-row-hover); }
        th:first-child, td:first-child { border-left: none; padding-left: 20px; }
        th:last-child, td:last-child { border-right: none; padding-right: 20px; }

        td.number-cell { text-align: right; font-variant-numeric: tabular-nums; }
        td.input-cell input { width: 100px; padding: 6px; font-size: 0.9rem; text-align: right; }
        td.input-cell input:disabled { background-color: transparent; border: none; color: var(--disabled-text);}
        .text-muted { color: var(--secondary-color); font-style: italic; font-size: 0.9em;}

        /* --- Tablas Desplegables --- */
        .collapsible-table tbody tr.rubro-total-row { font-weight: bold; cursor: pointer; background-color: var(--expandable-row-bg); transition: background-color 0.2s; }
        .collapsible-table tbody tr.rubro-total-row:hover { background-color: var(--clickable-row-hover); }
        .collapsible-table tbody tr.rubro-total-row td:first-child::before {
            content: '\f078'; /* FontAwesome caret-down */
            font-family: 'Font Awesome 6 Free'; font-weight: 900; margin-right: 12px; display: inline-block; transition: transform 0.2s ease-in-out; color: var(--primary-color);
        }
        .collapsible-table tbody tr.rubro-total-row.collapsed td:first-child::before { transform: rotate(-90deg); }
        .collapsible-table tbody tr.detail-row { display: table-row; background-color: var(--card-bg); transition: background-color 0.3s; }
        .collapsible-table tbody tr.detail-row.hidden { display: none; }
        .collapsible-table tbody tr.detail-row td { font-size: 0.85rem; color: var(--secondary-color); border-color: var(--border-color); }
        .collapsible-table tbody tr.detail-row td:first-child { padding-left: 40px; }
        body.dark-mode .collapsible-table tbody tr.detail-row { background-color: #353535; }
        .collapsible-table tfoot tr { font-weight: bold; background-color: var(--table-header-bg); border-top: 2px solid var(--border-color); }
        /* Estilos específicos para la tabla de Cash Flow */
        #cashflow-table td.input-cell input { width: 120px; } /* Hacer inputs de CF un poco más anchos */
        #cashflow-table tbody tr.category-total-row { font-weight: bold; background-color: var(--table-header-bg); } /* Para "Saldo Inicial", "Flujo Neto", "Saldo Final" */
        #cashflow-table tbody tr.category-total-row td { color: var(--primary-color-darker); }
        body.dark-mode #cashflow-table tbody tr.category-total-row td { color: var(--primary-color); }
        #cashflow-table tbody tr.cf-rubro-total-row td:first-child::before { content: '\f078'; /* ... */ }
        #cashflow-table tbody tr.cf-rubro-total-row.collapsed td:first-child::before { transform: rotate(-90deg); }
        #cashflow-table tbody tr.cf-detail-row.hidden { display: none; }
        #cashflow-table tbody tr.cf-detail-row td:first-child { padding-left: 40px; }


        .table-actions {
            margin-bottom: 15px;
             display: flex;
             justify-content: flex-end;
             gap: 10px;
             flex-wrap: wrap;
        }

        #dashboard-summary { border-collapse: separate; border-spacing: 0; }
        #dashboard-summary th, #dashboard-summary td { text-align: center; white-space: normal; }
        #dashboard-summary tbody td, #dashboard-summary tfoot td { padding: 10px 8px; }
        #dashboard-summary .month-header { font-weight: bold; }

        .chart-container {
            margin-top: 35px; padding: 30px;
            background-color: var(--card-bg); border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-color);
            position: relative; min-height: 200px;
        }
        .chart-container canvas { max-width: 100%; height: 380px !important; }
        .chart-no-data { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--secondary-color); font-style: italic; font-size: 1.1rem; text-align: center; }

        #file-upload-area {
            border: 2px dashed var(--primary-color);
            padding: 45px; text-align: center; background-color: var(--bg-color);
            border-radius: 8px; margin-bottom: 25px; transition: background-color 0.2s ease, border-color 0.2s ease; cursor: pointer;
        }
        #file-upload-area:hover { background-color: var(--table-row-hover); border-color: var(--primary-color-darker); }
        #file-upload-area p { margin-bottom: 15px; font-size: 1.1rem; color: var(--secondary-color); }
        #file-upload-area i.fa-file-excel { font-size: 3rem; margin-bottom: 10px; color: var(--accent-color); }
        #file-upload-feedback { margin-top: 15px; font-weight: bold; white-space: pre-wrap; font-size: 0.95rem; min-height: 2em; }

        #reserve-fund-panel { margin-top: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 20px;}
        #reserve-fund-panel .month-config { padding: 0; border-radius: 0; background-color: transparent; transition: none; }
        #reserve-fund-panel .month-config label { width: 100%; margin-bottom: 5px; font-weight: 600;}
        #reserve-fund-panel .month-config input { width: 100%; }
        #reserve-fund-panel .month-config span { margin-left: 5px; color: var(--secondary-color); font-size: 0.9em; }


        .config-section {
            border: 1px solid var(--border-color); border-radius: 8px; padding: 25px;
            margin-bottom: 30px; background-color: var(--card-bg);
            box-shadow: 0 3px 7px var(--shadow-color);
        }
        .config-section h4 { border-bottom: 1px solid var(--border-color); padding-bottom: 0.6em; margin-bottom: 1.2em;}
        .management-list { list-style: none; padding: 0; max-height: 350px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 6px; padding: 10px; background-color: var(--bg-color); }
        body.dark-mode .management-list { background-color: #3a3f44; }
        .management-list li { display: flex; justify-content: space-between; align-items: center; padding: 10px 8px; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s; }
        .management-list li:last-child { border-bottom: none;}
        .management-list li:hover { background-color: var(--table-row-hover); }
        .management-list li span { flex-grow: 1; margin-right: 15px; font-weight: 500; }
        .management-list li select { width: 200px; font-size: 0.88rem; padding: 6px 8px; flex-shrink: 0; }
        .management-list li button { flex-shrink: 0; }

         #coefficient-editor { margin-top: 25px; }
         #coefficient-editor h4 { margin-bottom: 15px;}
         #coefficient-values-editor {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
             gap: 20px;
             padding: 20px;
             border: 1px solid var(--border-color);
             border-radius: 6px;
             background-color: var(--bg-color);
         }
         body.dark-mode #coefficient-values-editor { background-color: #3a3f44; }

         #coefficient-values-editor .form-group { margin-bottom: 0; }
         #coefficient-values-editor .form-group label { margin-bottom: 5px; font-weight: 600; width: 100%;}
         #coefficient-values-editor .form-group input { width: 100%; max-width: none; }
         #coefficient-values-editor .text-muted { grid-column: 1 / -1; text-align: center; padding: 20px; }


        /* --- Snackbar --- */
        #snackbar {
            visibility: hidden; min-width: 300px; max-width: 90%;
            background-color: var(--success-color);
            color: var(--button-text); text-align: center;
            border-radius: 6px; padding: 18px 25px; position: fixed; z-index: 1001;
            left: 50%; transform: translateX(-50%); bottom: 30px;
            font-size: 1.05rem; font-weight: 500;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            opacity: 0; transition: visibility 0s 0.5s, opacity 0.5s ease-out, bottom 0.5s ease-out;
        }
        #snackbar.show {
            visibility: visible; opacity: 1; bottom: 60px;
            transition: opacity 0.5s ease-in, bottom 0.5s ease-in;
        }
        #snackbar.error { background-color: var(--danger-color); color: var(--button-text); }
        #snackbar.warning { background-color: var(--warning-color); color: var(--button-warning-text); }
        #snackbar.info { background-color: var(--info-color); color: var(--button-text); }

        /* --- Chatbot Styles --- */
        #chatbot-icon {
            position: fixed;
            bottom: 25px;
            right: 25px;
            background: var(--chatbot-icon-bg);
            color: var(--button-text);
            width: 65px; /* Slightly larger */
            height: 65px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px; /* Slightly larger icon */
            cursor: pointer;
            box-shadow: 0 5px 15px var(--shadow-color);
            z-index: 1010; /* Above snackbar */
            transition: background 0.3s, transform 0.2s ease-out;
        }
        #chatbot-icon:hover {
            background: var(--chatbot-icon-hover-bg);
            transform: scale(1.1) rotate(10deg); /* Add subtle rotation */
        }
        #chatbot-icon i {
            transition: transform 0.3s;
        }
        #chatbot-icon:hover i {
             transform: scale(1.1);
        }

        #chatbot-window {
            position: fixed;
            bottom: 105px; /* Position above the icon */
            right: 25px;
            width: 370px; /* Slightly wider */
            max-width: calc(100% - 40px); /* Ensure padding on small screens */
            height: 500px; /* Slightly taller */
            max-height: calc(100vh - 120px); /* Prevent overlap with header */
            background-color: var(--chatbot-bg);
            border: 1px solid var(--border-color);
            border-radius: 12px; /* Smoother corners */
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
            z-index: 1009; /* Below icon when open */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            opacity: 1;
            transform: translateY(0) scale(1);
            transform-origin: bottom right;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }
        #chatbot-window.hidden {
            opacity: 0;
            transform: translateY(20px) scale(0.9);
            pointer-events: none;
        }

        #chatbot-header {
            background-color: var(--chatbot-header-bg);
            color: var(--button-text);
            padding: 12px 18px; /* More padding */
            font-weight: 700; /* Bolder title */
            font-size: 1.1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(0,0,0,0.1); /* Subtle border */
        }
        #chatbot-header span::before { /* Add Bot icon */
            font-family: "Font Awesome 6 Free";
            content: "\f135"; /* robot icon */
            font-weight: 900;
            margin-right: 10px;
        }

        #chatbot-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.8); /* Slightly transparent */
            font-size: 1.3rem;
            cursor: pointer;
            padding: 5px;
            transition: color 0.2s, transform 0.2s;
        }
         #chatbot-close:hover {
            color: #fff;
            transform: rotate(90deg);
         }

        #chatbot-messages {
            flex-grow: 1;
            padding: 15px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 12px; /* Increased gap */
             /* Custom Scrollbar (Webkit) */
            &::-webkit-scrollbar { width: 6px; }
            &::-webkit-scrollbar-track { background: transparent; }
            &::-webkit-scrollbar-thumb { background-color: var(--secondary-color); border-radius: 10px; border: 1px solid var(--chatbot-bg); }
        }
        .user-message, .bot-message {
            padding: 10px 15px; /* More padding */
            border-radius: 18px; /* More rounded */
            max-width: 85%; /* Allow slightly wider messages */
            word-wrap: break-word;
            font-size: 0.95rem; /* Slightly larger text */
            line-height: 1.5;
            position: relative;
            white-space: pre-wrap; /* To respect newlines in bot messages */
        }
        .user-message {
            background-color: var(--chatbot-user-msg-bg);
            color: var(--chatbot-user-msg-text);
            align-self: flex-end;
            border-bottom-right-radius: 5px; /* Tail effect */
        }
        .bot-message {
            background-color: var(--chatbot-bot-msg-bg);
            color: var(--chatbot-bot-msg-text);
            align-self: flex-start;
            border-bottom-left-radius: 5px; /* Tail effect */
        }
         .bot-message::before { /* Bot avatar */
            content: "";
            display: block;
            position: absolute;
            left: -30px; /* Position to the left */
            top: 50%;
            transform: translateY(-50%);
            width: 22px;
            height: 22px;
            background-color: var(--info-color); /* Or another color */
            border-radius: 50%;
            font-size: 12px;
            line-height: 22px;
            text-align: center;
            color: white;
        }
        .bot-message .suggestion-button {
            background-color: var(--chatbot-suggestion-bg);
            color: var(--chatbot-suggestion-text);
            border: 1px solid var(--primary-color);
            padding: 6px 10px;
            margin: 5px 5px 0 0;
            border-radius: 15px;
            cursor: pointer;
            font-size: 0.85rem;
            display: inline-block;
        }
        .bot-message .suggestion-button:hover {
            background-color: var(--chatbot-suggestion-hover-bg);
        }

        #chatbot-input-area {
            display: flex;
            padding: 12px; /* More padding */
            border-top: 1px solid var(--border-color);
            background-color: var(--bg-color); /* Subtle different background */
        }
        #chatbot-input {
            flex-grow: 1;
            border: 1px solid var(--input-border);
            border-radius: 25px; /* Fully rounded */
            padding: 10px 18px; /* More padding */
            margin-right: 10px;
            font-size: 1rem;
            background-color: var(--input-bg);
            color: var(--text-color);
        }
         #chatbot-input::placeholder {
             color: var(--secondary-color);
             opacity: 0.8;
         }
        #chatbot-input:focus {
            border-color: var(--input-focus-border);
            box-shadow: 0 0 0 0.2rem var(--input-focus-shadow);
            outline: none;
        }
        #chatbot-send {
            background: var(--chatbot-icon-bg); /* Match icon gradient */
            color: var(--button-text);
            border: none;
            border-radius: 50%;
            width: 45px; /* Larger button */
            height: 45px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background 0.3s, transform 0.1s;
            flex-shrink: 0; /* Prevent shrinking */
            padding:0;
            font-size: 1.1rem;
        }
        #chatbot-send:hover {
            background: var(--chatbot-icon-hover-bg);
            transform: scale(1.1);
        }
         #chatbot-send:active {
             transform: scale(0.95);
         }


        /* --- Footer --- */
        footer {
            margin-top: auto; padding: 20px 0; text-align: center; font-size: 0.95em;
            color: var(--secondary-color); background-color: var(--header-bg);
            border-top: 1px solid var(--border-color);
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 1200px) { .container { width: 98%; } .chart-container canvas { height: 320px !important; } }
        @media (max-width: 992px) {
             h1 { font-size: 2rem; } h2 { font-size: 1.6rem; } h3 { font-size: 1.3rem; }
             .tabs { justify-content: flex-start; }
             .tab-link { padding: 10px 18px; font-size: 0.95rem;}
             table { font-size: 0.88rem; } th,td {padding: 10px 12px;}
             .management-list li select { width: 150px; }
        }
        @media (max-width: 768px) {
            body { line-height: 1.6; }
            .app-title { font-size: 1.3rem;} #theme-toggle { font-size: 1.1rem;}
            .header-actions { gap: 8px;} .header-actions button {padding: 6px 8px; font-size: 0.8rem;}
            .chart-container { padding: 20px;} .chart-container canvas { height: 280px !important; }
            .input-group { flex-direction: column; align-items: stretch; gap: 10px;}
            .input-small { margin-left: 0; margin-top: 8px; width: 100%; }
            #reserve-fund-panel, #coefficient-values-editor, #ipc-inputs { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px;}
            #reserve-fund-panel .month-config label { width: 100%; text-align: left; margin-bottom: 5px; }
            #reserve-fund-panel .month-config input { width: 100%; }
            table { font-size: 0.85rem; } th, td { padding: 9px 8px; white-space: normal; }
            th:first-child, td:first-child { padding-left: 15px; }
            th:last-child, td:last-child { padding-right: 15px; }
            td.input-cell input { width: 80px; padding: 5px; }
            #cashflow-table td.input-cell input { width: 90px; }
            .management-list li { flex-wrap: wrap; gap: 8px; }
            .management-list li span { flex-basis: 100%; margin-right: 0; }
            .management-list li select { width: calc(100% - 50px); margin-top: 5px; }
            .management-list li button { margin-left: auto; }
            button { font-size: 0.95rem; padding: 10px 18px;}
            .tabs { gap: 2px; }
            .tab-link { padding: 8px 10px; font-size: 0.85rem;}
             .table-actions { justify-content: center; }

             /* Chatbot Responsive */
            #chatbot-window {
                 width: calc(100% - 30px); /* Almost full width */
                 height: 75vh; /* Taller on mobile */
                 bottom: 85px; /* Adjust position relative to icon */
                 right: 15px;
                 max-height: calc(100vh - 100px);
            }
             #chatbot-icon {
                 width: 55px; height: 55px; font-size: 24px;
                 bottom: 15px; right: 15px;
             }
            .bot-message::before { /* Hide avatar on smaller screens */
                 display: none;
            }
            .user-message, .bot-message { max-width: 90%; font-size: 0.9rem; }
        }
        @media (max-width: 576px) {
            h1 { font-size: 1.7rem; }
            .app-title { font-size: 1.2rem; }
            header .container { justify-content: space-between; }
            .tab-link { padding: 8px 10px; font-size: 0.85rem;}
            th, td { padding: 8px 6px; }
            th:first-child, td:first-child { padding-left: 10px; }
            th:last-child, td:last-child { padding-right: 10px; }
            .chart-container canvas { height: 220px !important; }
            #snackbar { min-width: 90%; bottom: 20px; font-size: 1rem; padding: 15px 20px; }
            #snackbar.show { bottom: 40px; }
            #file-upload-area { padding: 30px; }
            .management-list li select { width: 100%; }
            #cashflow-table td.input-cell input { width: 70px; }
             #reserve-fund-panel, #coefficient-values-editor, #ipc-inputs { grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px;}
             /* Chatbot Responsive small */
            #chatbot-window { height: 70vh; }
        }
    
/* ---------- OPERATING RESULT CARD ---------- */
.operating-result-card{
    margin-top:35px;
    padding:24px;
    background-color:var(--card-bg, #f8f9fa);
    border-left:6px solid var(--info-color, #0d6efd);
    border-radius:8px;
    box-shadow:0 4px 12px rgba(0,0,0,.08);
}
.operating-result-card h3{
    margin:0 0 16px;
    font-size:1.25rem;
}

.operating-result-negative{color:var(--danger-color-darker, #dc3545);}
.number-cell{text-align:right;padding:0 .5rem;}











/* ---------- Colores definitivos Resultado operativo ---------- */
.operating-result-positive{
    color:#198754 !important;
    font-weight:700;
}
.operating-result-negative-real{
    color:#ff6b6b !important; /* rojo suave */
    font-weight:700;
}
.operating-result-negative-estimated{
    color:#c1121f !important; /* rojo intenso */
    font-weight:700;
}


/* ---------- Colores para datos reales vs estimados ---------- */
.real-month-cell{
    background-color:#d1e7dd !important; /* verde claro */
}
.estimated-month-cell{
    background-color:#fff4e6 !important; /* naranja suave */
}

</style>
</head>
<body>
    <header>
        <div class="container">
            <span class="app-title">Proyección Expensas - El Centauro</span>
            <div class="header-actions">
                <button id="export-storage" title="Descargar datos (localStorage)"><i class="fas fa-download"></i></button>
                <input type="file" id="import-storage-input" accept=".json" style="display:none;">
                <button id="import-storage" title="Cargar datos (localStorage)"><i class="fas fa-upload"></i></button>
                <button id="theme-toggle" title="Cambiar tema"><i class="fas fa-moon"></i></button>
            </div>
        </div>
    </header>

    <div class="container">
        <div class="tabs">
            <button class="tab-link active" onclick="openTab(event, 'dashboard')"><i class="fas fa-tachometer-alt"></i> Dashboard</button>
            <button class="tab-link" onclick="openTab(event, 'upload')"><i class="fas fa-upload"></i> Cargar Datos</button>
            <button class="tab-link" onclick="openTab(event, 'cashflow')"><i class="fas fa-exchange-alt"></i> Cash Flow</button>
            <button class="tab-link" onclick="openTab(event, 'reserve')"><i class="fas fa-piggy-bank"></i> Fondo Reserva</button>
            <button class="tab-link" onclick="openTab(event, 'settings')"><i class="fas fa-cog"></i> Configuración</button>
            <button class="tab-link" onclick="openTab(event, 'reports')"><i class="fas fa-download"></i> Reportes</button>
        </div>

        <!-- ==================== DASHBOARD ==================== -->
        <div id="dashboard" class="tab-content active">
            <h2><i class="fas fa-tachometer-alt"></i> Dashboard Anual - <span id="dashboard-year"></span> (<span id="dashboard-scenario">Base</span>)</h2>
            <div class="form-group input-group">
                <label for="scenario-selector" style="flex-shrink: 0;">Escenario:</label>
                <select id="scenario-selector" style="flex-grow: 1;"></select>
                <button onclick="createScenario()" class="button-primary button-sm" title="Crear Escenario Nuevo"><i class="fas fa-plus"></i> Crear</button>
                <button onclick="cloneScenario()" class="button-secondary button-sm" title="Clonar Escenario Actual"><i class="fas fa-clone"></i> Clonar</button>
                <button onclick="deleteScenario()" class="button-danger button-sm" title="Eliminar Escenario Actual"><i class="fas fa-trash"></i> Eliminar</button>
                <button id="btnBorrarDatos" class="button-warning button-sm" title="Borrar Datos del Escenario Actual (Gastos, Ingresos, Status, CashFlow)" onclick="clearScenarioData()" ><i class="fas fa-broom"></i> Borrar Datos</button>
                <button onclick="recalculateEstimates()" class="button-info button-sm" title="Proyectar meses estimados basados en último mes real y coeficientes (acumulativo)"><i class="fas fa-calculator"></i> Calcular Estimados</button>
            </div>

            <h4>Resumen Mensual General</h4>
             <p class="text-muted" style="font-size: 0.9em;">Las celdas de Gasto, Fondo y Cuotas se colorean según el origen general del mes: <span style="background-color: var(--real-month-bg); padding: 1px 4px; border-radius: 3px; color: var(--real-month-text);">REAL</span> (todos los detalles de gastos e ingresos de ese mes son reales) o <span style="background-color: var(--estimated-month-bg); padding: 1px 4px; border-radius: 3px; color: var(--estimated-month-text);">ESTIMADO</span> (algún detalle de gasto o ingreso de ese mes es estimado).</p>
            <div class="table-container">
                <table id="dashboard-summary">
                    <thead>
                        <tr>
                            <th>Mes</th>
                            <th>Gasto ($)</th>
                            <th>Fondo ($)</th>
                            <th>Cuota s/Gs ($/UF)</th>
                            <th>IPC (%)</th>
                            <th>Cuota IPC ($/UF)</th>
                            <th>Expensa Real ($/UF)</th>
                        </tr>
                    </thead>
                    <tbody><!-- Contenido generado por JS --></tbody>
                    <tfoot><!-- Contenido generado por JS --></tfoot>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Detalle de Gastos Proyectados ($)</h4>
             <p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar los detalles. Las celdas mensuales de detalle se colorean según su origen: <span style="background-color: var(--real-month-bg); padding: 1px 4px; border-radius: 3px; color: var(--real-month-text);">REAL</span> (cargado desde Excel con número) o <span style="background-color: var(--estimated-month-bg); padding: 1px 4px; border-radius: 3px; color: var(--estimated-month-text);">ESTIMADO</span> (cargado sin número o proyectado/calculado).</p>

            <div class="table-actions">
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('gastos', false)" title="Expandir todos los detalles de gastos"><i class="fas fa-expand"></i> Expandir Todo</button>
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('gastos', true)" title="Colapsar todos los detalles de gastos"><i class="fas fa-compress"></i> Colapsar Todo</button>
            </div>

            <div class="table-container">
                <table id="gastos-detail-table" class="collapsible-table">
                     <thead>
                        <tr>
                            <th>Rubro / Detalle</th>
                            <th>Coef. Aplicado</th>
                            <!-- Meses y Total Anual generados por JS -->
                         </tr>
                     </thead>
                     <tbody><!-- Contenido generado por JS --></tbody>
                     <tfoot><!-- Contenido generado por JS --></tfoot>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Detalle de Ingresos Proyectados ($)</h4>
             <p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar. Los valores aquí son la base de cálculo (valor individual o por UF). El Total de Ingresos en el Resumen General puede incluir la multiplicación por UF. Las celdas mensuales de detalle se colorean según su origen: <span style="background-color: var(--real-month-bg); padding: 1px 4px; border-radius: 3px; color: var(--real-month-text);">REAL</span> (cargado desde Excel con número) o <span style="background-color: var(--estimated-month-bg); padding: 1px 4px; border-radius: 3px; color: var(--estimated-month-text);">ESTIMADO</span> (cargado sin número).</p>

             <div class="table-actions">
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('ingresos', false)" title="Expandir todos los detalles de ingresos"><i class="fas fa-expand"></i> Expandir Todo</button>
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('ingresos', true)" title="Colapsar todos los detalles de ingresos"><i class="fas fa-compress"></i> Colapsar Todo</button>
            </div>

            <div class="table-container">
                 <table id="ingresos-detail-table" class="collapsible-table">
                      <thead>
                         <tr>
                            <th>Rubro / Detalle</th>
                             <!-- Meses y Total Anual generados por JS -->
                         </tr>
                       </thead>
                      <tbody><!-- Contenido generado por JS --></tbody>
                      <tfoot><!-- Contenido generado por JS --></tfoot>
                 </table>
            </div>

            
        <!-- ======== OPERATING RESULT CARD ======== -->
        <div id="operating-result-card" class="operating-result-card" style="display:none;">
            <h3><i class="fas fa-balance-scale"></i> Resultado operativo</h3>
            <div class="table-container">
                <table id="operating-result-table">
                    <thead>
                        <tr><th>Mes</th></tr>
                    </thead>
                    <tbody></tbody>
                    <tfoot>
                        <tr><th>Total Anual</th></tr>
                    </tfoot>
                </table>
            </div>
        </div>
    
<div class="chart-container">
                 <h3>Evolutivo Expensa Mensual ($/UF)</h3>
                 <canvas id="evolutivoCuotaChart"></canvas>
                 <div class="chart-no-data" style="display: none;">No hay datos suficientes para graficar.</div>
            </div>

            <div style="display: flex; gap: 25px; flex-wrap: wrap; margin-top: 35px;">
                <div class="chart-container" style="flex: 1; min-width: 320px;">
                    <h3>Participación Gastos (%)</h3>
                    <canvas id="participacionGastosChart"></canvas>
                    <div class="chart-no-data" style="display: none;">No hay datos de gastos<br>para mostrar el gráfico.</div>
                </div>
                <div class="chart-container" style="flex: 1; min-width: 320px;">
                    <h3>Participación Ingresos (%)</h3>
                    <canvas id="participacionIngresosChart"></canvas>
                    <div class="chart-no-data" style="display: none;">No hay datos de ingresos<br>para mostrar el gráfico.</div>
                </div>
            </div>
        </div>

        <!-- ==================== UPLOAD ==================== -->
        <div id="upload" class="tab-content">
            <h2><i class="fas fa-upload"></i> Cargar Datos Reales / Base</h2>
            <div class="form-group input-group">
                <label for="exercise-year">Año del Ejercicio:</label>
                <input type="number" id="exercise-year" min="2020" max="2099" value="2024" style="width: 120px;">
                <button onclick="createNewExercise()" class="button-success"><i class="fas fa-calendar-plus"></i> Crear/Seleccionar Año</button>
             </div>
            <p>Sube tu archivo Excel con las hojas <strong>"Gastos"</strong> e <strong>"Ingresos"</strong>. Los rubros nuevos se añadirán automáticamente a la sección de Configuración.</p>
            <p><strong>Importante:</strong>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>Las celdas con **números** en las hojas "Gastos" e "Ingresos" marcarán ese mes/detalle como '<strong style="color: var(--accent-color)">REAL</strong>'. Las celdas vacías o con texto se considerarán '<strong style="color: var(--warning-color)">ESTIMADO</strong>' (y se tratarán como 0 para los cálculos iniciales).</li>
                    <li>Los rubros de Ingreso llamados "<strong id="cuota-rubro-name-info">Expensas Ordinarias</strong>" y "<strong>Expensas Extraordinarias</strong>" tendrán sus valores base multiplicados por la cantidad de UF (definida en Configuración) al calcular el *total* de ingresos en el Resumen General. La columna "Expensa Real ($/UF)" en el resumen muestra el valor del rubro "<strong id="cuota-rubro-name-info2">Expensas Ordinarias</strong>" <strong style="color: var(--primary-color)">dividido por la cantidad de UF</strong>.</li>
                </ul>
            </p>
            <div id="file-upload-area" onclick="document.getElementById('excel-file-input').click()">
                 <p><i class="fas fa-file-excel"></i><br>Arrastra tu archivo Excel aquí (.xlsx, .xls) o haz clic para seleccionar</p>
                 <input type="file" id="excel-file-input" accept=".xlsx, .xls" style="display: none;" onchange="handleFileUpload(this.files)">
                 <button type="button" class="button-primary" onclick="event.stopPropagation(); document.getElementById('excel-file-input').click()" style="pointer-events: auto;"><i class="fas fa-folder-open"></i> Seleccionar Archivo</button>
                 <button type="button" onclick="event.stopPropagation(); loadSampleData()" style="margin-left: 10px; pointer-events: auto;" class="button-secondary"><i class="fas fa-database"></i> Cargar Datos Ejemplo</button>
            </div>
            <div id="file-upload-feedback"></div>
            <a href="#" onclick="event.preventDefault(); downloadTemplate();" title="Descargar archivo Excel con estructura de ejemplo"><i class="fas fa-download"></i> Descargar Plantilla Ejemplo</a>
        </div>

        <!-- ==================== CASH FLOW ==================== -->
        <div id="cashflow" class="tab-content">
            <h2><i class="fas fa-exchange-alt"></i> Flujo de Caja (Cash Flow) - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
            <p class="text-muted">Gestiona los movimientos de efectivo mes a mes. Los valores ingresados aquí son independientes de la Proyección de Expensas y representan el flujo de caja real o estimado.
            El Saldo Inicial de Enero es editable; los saldos iniciales de los meses siguientes se calculan automáticamente. Las celdas editables se marcan como <span style="background-color: var(--real-month-bg); padding: 1px 4px; border-radius: 3px; color: var(--real-month-text);">REAL</span> al ingresar un número, o <span style="background-color: var(--estimated-month-bg); padding: 1px 4px; border-radius: 3px; color: var(--estimated-month-text);">ESTIMADO</span> si están vacías o con texto (tratadas como 0).</p>

            <div class="config-section">
                <h4><i class="fas fa-list-ul"></i> Gestión de Rubros de Cash Flow</h4>
                <p class="text-muted" style="font-size:0.9em">Define los rubros para "Otros Ingresos Efectivos" y "Egresos Efectivos" que aparecerán en la tabla de Cash Flow. Los cambios aquí se reflejarán en la tabla de abajo y se aplicarán al escenario actual.</p>
                <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                    <div style="flex: 1; min-width: 320px;">
                        <h5><i class="fas fa-plus-circle" style="color:var(--success-color)"></i> Otros Ingresos CF</h5>
                        <div class="form-group input-group">
                            <input type="text" id="new-cf-ingreso-rubro-name" placeholder="Nombre nuevo rubro de ingreso CF" style="flex-grow: 1;">
                            <button onclick="addRubroCF('ingresos')" class="button-sm button-success" title="Añadir este rubro a Otros Ingresos CF"><i class="fas fa-plus"></i> Añadir</button>
                        </div>
                        <ul id="cf-ingreso-rubro-list" class="management-list"></ul>
                    </div>
                    <div style="flex: 1; min-width: 320px;">
                         <h5><i class="fas fa-minus-circle" style="color:var(--danger-color)"></i> Egresos CF</h5>
                         <div class="form-group input-group">
                             <input type="text" id="new-cf-egreso-rubro-name" placeholder="Nombre nuevo rubro de egreso CF" style="flex-grow: 1;">
                             <button onclick="addRubroCF('egresos')" class="button-sm button-success" title="Añadir este rubro a Egresos CF"><i class="fas fa-plus"></i> Añadir</button>
                         </div>
                         <ul id="cf-egreso-rubro-list" class="management-list"></ul>
                    </div>
                </div>
                <button onclick="saveRubrosCF()" style="margin-top: 20px; width: 100%;" class="button-success button-lg"><i class="fas fa-save"></i> Guardar Rubros CF y Recalcular</button>
            </div>

            <h4 style="margin-top: 30px;">Tabla de Flujo de Caja Mensual ($)</h4>
            <p class="text-muted" style="font-size:0.9em">Haz clic en las filas de "Otros Ingresos Efectivos" o "Egresos Efectivos" para expandir/colapsar sus rubros y editar los valores mensuales.</p>
            <div class="table-actions">
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetailsCF(false)" title="Expandir Todos los Rubros CF"><i class="fas fa-expand"></i> Expandir Rubros CF</button>
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetailsCF(true)" title="Colapsar Todos los Rubros CF"><i class="fas fa-compress"></i> Colapsar Rubros CF</button>
            </div>
            <div class="table-container">
                <table id="cashflow-table" class="collapsible-table">
                    <thead>
                        <tr>
                            <th style="width: 25%;">Concepto</th>
                            <!-- Meses y Total Anual generados por JS -->
                        </tr>
                    </thead>
                    <tbody><!-- Contenido generado por JS --></tbody>
                    <tfoot><!-- Contenido generado por JS --></tfoot>
                </table>
            </div>

            <div class="chart-container" style="margin-top: 35px;">
                <h3>Evolución Saldo de Caja ($)</h3>
                <canvas id="cashFlowChart"></canvas>
                <div class="chart-no-data" style="display: none;">No hay datos suficientes para graficar el Cash Flow.</div>
            </div>
        </div>

        <!-- ==================== RESERVE FUND ==================== -->
        <div id="reserve" class="tab-content">
             <h2><i class="fas fa-piggy-bank"></i> Configurar Fondo de Reserva - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
             <div class="form-group">
                 <label>Método de Cálculo del Fondo:</label>
                 <div class="input-group">
                     <input type="radio" id="reserve-type-percent" name="reserve-type" value="percent" checked onchange="updateReserveUI()">
                     <label for="reserve-type-percent">Porcentaje (%) sobre Gastos Mensuales</label>
                     <input type="radio" id="reserve-type-fixed" name="reserve-type" value="fixed" onchange="updateReserveUI()">
                     <label for="reserve-type-fixed">Valor Fijo Mensual ($)</label>
                 </div>
             </div>
             <div id="reserve-fund-panel">
                 <!-- Inputs generados por JS -->
             </div>
             <button onclick="saveReserveFund()" style="margin-top: 25px; width: 100%; padding: 15px;" class="button-success button-lg" title="Guardar los valores mensuales y el tipo de cálculo del fondo">
                 <i class="fas fa-save"></i> GUARDAR FONDO DE RESERVA Y RECALCULAR
            </button>
        </div>

        <!-- ==================== SETTINGS ==================== -->
        <div id="settings" class="tab-content">
             <h2><i class="fas fa-cog"></i> Configuración General y de Cálculo</h2>

             <div class="config-section">
                 <h4><i class="fas fa-building"></i> Ajustes Generales del Barrio</h4>
                 <div class="form-group">
                     <label for="cantidad-unidades">Cantidad Total de Unidades Funcionales (UF):</label>
                     <input type="number" id="cantidad-unidades" min="1" value="100" style="width: 180px;" title="Número total de UF para calcular cuotas base">
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-list-alt"></i> Gestión de Rubros (Categorías de Proyección de Expensas)</h4>
                 <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                     <div style="flex: 1; min-width: 320px;">
                         <h5><i class="fas fa-arrow-down" style="color:var(--danger-color)"></i> Rubros de GASTOS (Expensas)</h5>
                         <div class="form-group input-group">
                             <input type="text" id="new-gasto-rubro-name" placeholder="Nombre nuevo rubro de gasto" style="flex-grow: 1;">
                             <button onclick="addRubro('gastos')" class="button-sm button-success" title="Añadir este nuevo rubro a la lista de gastos"><i class="fas fa-plus"></i> Añadir</button>
                         </div>
                         <ul id="gasto-rubro-list" class="management-list"></ul>
                     </div>
                     <div style="flex: 1; min-width: 320px;">
                          <h5><i class="fas fa-arrow-up" style="color:var(--success-color)"></i> Rubros de INGRESOS (Expensas)</h5>
                          <div class="form-group input-group">
                              <input type="text" id="new-ingreso-rubro-name" placeholder="Nombre nuevo rubro de ingreso" style="flex-grow: 1;">
                              <button onclick="addRubro('ingresos')" class="button-sm button-success" title="Añadir este nuevo rubro a la lista de ingresos"><i class="fas fa-plus"></i> Añadir</button>
                          </div>
                          <ul id="ingreso-rubro-list" class="management-list"></ul>
                     </div>
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-percentage"></i> Gestión de Coeficientes de Ajuste (para Gastos Estimados de Expensas)</h4>
                 <p class="text-muted" style="font-size: 0.9em;">Define tipos de coeficientes (ej. Inflación, Aumento Gremial) y asigna uno a cada rubro de Gasto de Expensas. Al usar "Calcular Estimados" en el Dashboard, el sistema proyectará los meses sin datos '<strong style="color: var(--accent-color)">REAL</strong>' (marcados en color <span style="background-color: var(--estimated-month-bg); padding: 1px 4px; border-radius: 3px; color: var(--estimated-month-text);">ESTIMADO</span>) multiplicando el último valor '<strong style="color: var(--accent-color)">REAL</strong>' por el coeficiente acumulado correspondiente a cada mes futuro.</p>
                 <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                     <div style="flex: 1; min-width: 280px;">
                         <h5>Tipos de Coeficientes Disponibles</h5>
                         <div class="form-group input-group">
                             <input type="text" id="new-coefficient-type-name" placeholder="Nuevo tipo (ej: Aumento Sindicato)" style="flex-grow: 1;">
                             <button onclick="addCoefficientType()" class="button-sm button-success" title="Añadir este nuevo tipo de coeficiente a la lista"><i class="fas fa-plus"></i> Añadir Tipo</button>
                         </div>
                         <ul id="coefficient-type-list" class="management-list"></ul>
                     </div>
                     <div id="coefficient-editor" style="flex: 2; min-width: 450px;">
                          <h5><i class="fas fa-edit"></i> Editar Valores Mensuales para: <span id="editing-coefficient-name" style="color: var(--primary-color); font-weight: bold;"></span></h5>
                          <div id="coefficient-values-editor">
                              <p class="text-muted">Selecciona un tipo de coeficiente de la lista de la izquierda para editar/ver sus valores porcentuales (%) mes a mes.</p>
                          </div>
                         <p id="ipc-editor-note" class="text-muted" style="font-size: 0.85em; margin-top:10px; display:none;">Los valores de IPC se gestionan en la sección "Índices IPC Mensuales de Referencia (%)" más abajo y se muestran aquí solo para visualización.</p>
                     </div>
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-chart-line"></i> Índices IPC Mensuales de Referencia (%)</h4>
                 <p class="text-muted">Introduce el porcentaje (%) de IPC estimado o real para cada mes. Se usa únicamente para calcular la columna "Cuota IPC ($/UF)" como referencia en el Dashboard y está disponible como tipo de coeficiente ("IPC"). Sus valores son gestionados en esta sección y se reflejan en la lista de tipos de coeficientes.</p>
                 <div id="ipc-inputs" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 20px;">
                     <!-- Inputs generados por JS -->
                 </div>
             </div>

             <button onclick="saveSettings()" style="margin-top: 20px; width: 100%; padding: 15px;" class="button-success button-lg" title="Guardar todos los cambios realizados en esta pestaña (UF, Rubros, Coeficientes, IPC) y recalcular el escenario actual">
                 <i class="fas fa-save"></i> GUARDAR TODA LA CONFIGURACIÓN Y RECALCULAR
             </button>
        </div>

        <!-- ==================== REPORTS ==================== -->
        <div id="reports" class="tab-content">
             <h2><i class="fas fa-download"></i> Descargar Reportes - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
             <p>Genera y descarga los datos del ejercicio y escenario actual en formato Excel, incluyendo detalles y resumen con formato mejorado. El reporte también incluirá una hoja con el detalle del Cash Flow si hay datos.</p>
             <button onclick="exportToExcel()" class="button-success" title="Descargar un archivo .xlsx con el detalle y resumen del escenario actual"><i class="fas fa-file-excel"></i> Descargar Reporte Completo (.xlsx)</button>

             <h3 style="margin-top: 35px;">Exportar Gráficos Individuales</h3>
             <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                 <button onclick="exportChart('evolutivoCuotaChart', 'evolutivo_expensa.png')" class="button-secondary" title="Descargar el gráfico de evolución de expensas como imagen PNG"><i class="fas fa-chart-line"></i> Gráfico Evolutivo (PNG)</button>
                 <button onclick="exportChart('participacionGastosChart', 'participacion_gastos.png')" class="button-secondary" title="Descargar el gráfico de torta de gastos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Gastos (PNG)</button>
                 <button onclick="exportChart('participacionIngresosChart', 'participacion_ingresos.png')" class="button-secondary" title="Descargar el gráfico de torta de ingresos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Ingresos (PNG)</button>
                 <button onclick="exportChart('cashFlowChart', 'evolucion_cashflow.png')" class="button-secondary" title="Descargar el gráfico de evolución de cash flow como imagen PNG"><i class="fas fa-chart-area"></i> Gráfico Cash Flow (PNG)</button>
             </div>
        </div>
    </div> <!-- /container -->

    <footer>
        <div class="container">
            &copy; <span id="footer-year"></span> Proyección Expensas El Centauro. v3.1.0 (Cash Flow Integrado)
        </div>
    </footer>
    <div id="snackbar">Mensaje</div>

    <!-- ==================== CHATBOT UI ==================== -->
    <div id="chatbot-icon" title="Pregúntale a Centaurito">
        <i class="fas fa-robot"></i>
    </div>

    <div id="chatbot-window" class="hidden">
        <div id="chatbot-header">
            <span>Centaurito</span>
            <button id="chatbot-close" title="Cerrar chat"><i class="fas fa-times"></i></button>
        </div>
        <div id="chatbot-messages">
            <!-- Mensajes iniciales se añadirán desde JS -->
        </div>
        <div id="chatbot-input-area">
            <input type="text" id="chatbot-input" placeholder="Ej: gasto total enero, IPC acumulado...">
            <button id="chatbot-send" title="Enviar mensaje"><i class="fas fa-paper-plane"></i></button>
        </div>
    </div>
    <!-- ==================== END CHATBOT UI ==================== -->


    <!-- ==================== SCRIPT PRINCIPAL (CON CASH FLOW) ==================== -->
    <script>
        // --- Constantes y Estado Global ---
        const MONTHS = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
        const FULL_MONTHS = ["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"];
        const GASTOS_SHEET_NAME = "Gastos";
        const INGRESOS_SHEET_NAME = "Ingresos";
        const STORAGE_KEY = 'expensasAppCentauroState_v3.1.0_CashFlow'; // Clave actualizada
        const CUOTA_RUBRO_NAME = "Expensas Ordinarias";
        const EXTRA_CUOTA_RUBRO_NAME = "Expensas Extraordinarias";
        const SPECIAL_INGRESO_RUBROS = [CUOTA_RUBRO_NAME, EXTRA_CUOTA_RUBRO_NAME];

        let appState = getDefaultAppState();

        let evolutivoCuotaChart_instance = null;
        let participacionGastosChart_instance = null;
        let participacionIngresosChart_instance = null;
        let cashFlowChart_instance = null; // Nuevo gráfico

        // Variable global para el estado de espera de clarificación del bot
        let waitingForClarification = null;

        // --- INICIO: Mejoras del Bot (Normalización y Sinónimos EXTENDIDOS) ---
        const BOT_SYNONYMS = {
            // Saludos y Conversación General
            "hola": ["hola", "buen dia", "buenas", "que tal", "hey"],
            "adios": ["adios", "chau", "hasta luego", "nos vemos"],
            "gracias": ["gracias", "muchas gracias", "ok", "dale", "listo", "entendido", "perfecto", "joya"],
            "ayuda": ["ayuda", "que podes hacer", "que haces", "info", "informacion", "explicame", "comandos"],

            // Métricas y Conceptos Clave
            "gasto": ["gasto", "gastos", "costo", "costos", "egreso", "egresos", "salida", "salidas", "cuanto salio", "cuanto costo", "importe de egreso"],
            "ingreso": ["ingreso", "ingresos", "entrada", "entradas", "recaudacion", "recaudado", "cuanto entro", "importe de ingreso"],
            "cuota": ["cuota", "cuotas", "expensa", "expensas", "valor de expensa", "valor de cuota"],
            "ipc": ["ipc", "inflacion", "inflación", "indice de precios", "indice de precios al consumidor", "ajuste por inflacion"],
            "fondo de reserva": ["fondo de reserva", "fondo reserva", "reserva", "el fondo", "plata del fondo"],
            "estado": ["estado", "status", "es real", "es estimado", "tipo de dato", "origen del valor"],
            "coeficiente": ["coeficiente", "coeficientes", "ajuste", "ajustes", "porcentaje de ajuste", "tasa de ajuste", "coeficiente de ajuste"],
            "unidades funcionales": ["uf", "ufs", "unidades funcionales", "cantidad de unidades", "total de uf", "numero de uf"],
            "cash flow": ["cash flow", "flujo de caja", "flujo de fondos", "disponibilidades", "caja", "bancos"],
            "saldo inicial": ["saldo inicial", "saldo de inicio", "arranque de caja"],
            "saldo final": ["saldo final", "cierre de caja", "saldo al cierre"],
            "flujo neto": ["flujo neto", "resultado del mes cf", "variacion de caja"],
            "otros ingresos cf": ["otros ingresos cf", "ingresos de caja", "entradas efectivas"],
            "egresos cf": ["egresos cf", "salidas de caja", "pagos efectivos"],


            // Acciones y Calificadores
            "total": ["total", "global", "completo", "sumatoria", "consolidado", "suma de"],
            "promedio": ["promedio", "media", "valor medio", "promedio mensual"],
            "diferencia": ["diferencia", "variacion", "cambio", "cuanto cambio", "cuanto vario", "aumento en", "disminucion en", "comparar valores de"],
            "comparacion": ["compara", "comparar", "vs", "versus", "contra", "respecto a"],
            "mayor": ["mayor", "mas caro", "mas alto", "mas grande", "el pico de", "maximo"],
            "menor": ["menor", "mas barato", "mas bajo", "mas chico", "minimo"],
            "valor": ["valor", "importe", "monto", "cuanto es", "cuanto fue"],
            "detalle de": ["detalle de", "desglose de", "items de"],

            // Métricas Específicas de Cuotas
            "cuota real": ["cuota real", "expensa real", "cuota base", "expensa base", "cuota ordinaria pura"],
            "cuota ipc": ["cuota ipc", "expensa ipc", "cuota ajustada por ipc", "expensa con ipc"],
            "cuota sobre gastos": ["cuota sobre gastos", "cuota s/gastos", "cuota calculada", "expensa calculada"],

            // Periodos
            "anual": ["anual", "año completo", "todo el año", "para todo el año", "del año"],
            "mensual": ["mensual", "por mes", "cada mes"],
            "este mes": ["este mes", "mes actual", "el corriente"],
            "mes pasado": ["mes pasado", "mes anterior"],
            "proximo mes": ["proximo mes", "mes siguiente", "mes que viene"],

            "sin coeficiente": ["sin coeficiente", "ningun coeficiente", "none", "sin ajuste"],
            "ipc coeficiente": ["ipc", "inflacion"],
        };


        function normalizeBotQuery(text) {
            if (typeof text !== 'string') return "";
            return text.toLowerCase()
                       .normalize("NFD").replace(/[\u0300-\u036f]/g, "") // Quitar tildes
                       .replace(/[^a-z0-9\s\-\/\.]/g, " ") // Quitar símbolos, dejar números, letras, guiones, barras, puntos
                       .replace(/\s+/g, " ") // Múltiples espacios a uno
                       .trim();
        }
        // --- FIN: Mejoras del Bot ---


        // --- Gestión de Estado ---
        function getDefaultAppState() {
            const defaultYear = new Date().getFullYear();
            const baseScenarioStructure = {
                year: defaultYear,
                scenarioName: 'Base',
                rubroOrder: { gastos: [], ingresos: [] },
                data: { gastos: {}, ingresos: {} },
                monthStatus: { gastos: {}, ingresos: {} }, // Para expensas
                reserveFund: { type: 'percent', values: Array(12).fill(5) },
                cashFlow: { // NUEVA SECCIÓN PARA CASH FLOW
                    saldoInicialCaja: Array(12).fill(0), // Enero editable, resto calculado
                    rubrosIngresosCFData: {}, // { "Nombre Rubro CF Ingreso": { detailOrder: ["Valor"], detailsData: { "Valor": Array(12).fill(0) } } }
                    rubrosEgresosCFData: {},   // { "Nombre Rubro CF Egreso": { detailOrder: ["Valor"], detailsData: { "Valor": Array(12).fill(0) } } }
                    monthStatusCF: { // Estado REAL/ESTIMADO para CF
                        saldoInicialCajaEnero: 'Estimado',
                        ingresos: {}, // { "Nombre Rubro CF Ingreso": { "Valor": Array(12).fill('Estimado') } }
                        egresos: {}   // { "Nombre Rubro CF Egreso": { "Valor": Array(12).fill('Estimado') } }
                    },
                    calculatedCF: {
                        totalOtrosIngresosCFMes: Array(12).fill(0),
                        totalEgresosCFMes: Array(12).fill(0),
                        flujoNetoMesCF: Array(12).fill(0),
                        saldoFinalCajaMes: Array(12).fill(0),
                        annualTotalsCF: { otrosIngresos: 0, egresos: 0, flujoNeto: 0 },
                        monthOverallStatusCF: Array(12).fill('Estimado'),
                        rubroDetailCollapsedCF: {} // { "ingresos_Rubro Ejemplo": true, "egresos_Otro Ejemplo": false }
                    }
                },
                calculated: {
                    gastoAjustado: {}, totalGastoRubroMes: {}, totalGastoProyectadoMes: Array(12).fill(0),
                    ingresoAjustado: {}, totalIngresoRubroMes: {}, totalIngresoProyectadoMes: Array(12).fill(0),
                    fondoReservaMes: Array(12).fill(0),
                    cuotaSobreGastosMes: Array(12).fill(0),
                    ipcManual: Array(12).fill(0),
                    cuotaIpcMes: Array(12).fill(0),
                    cuotaRealBaseMes: Array(12).fill(0),
                    annualTotals: { gastos: {__TOTAL__:0}, ingresos: {__TOTAL__:0}, fondoReserva: 0, cuotaSobreGastos: 0, cuotaIpc: 0, cuotaRealBase: 0 },
                    monthOverallStatus: Array(12).fill('Estimado')
                }
            };
            const defaultSettings = {
                 cantidadUnidades: 100,
                 rubros: { gastos: [], ingresos: [] }, // Para expensas
                 rubroConfig: {}, // Para expensas
                 rubrosCF: { // NUEVA SECCIÓN PARA RUBROS DE CASH FLOW
                     ingresos: ["Cobranzas Especiales CF", "Ingresos Financieros CF"],
                     egresos: ["Pagos Proveedores Atrasados CF", "Inversiones Realizadas CF"]
                 },
                 coefficientTypes: {
                     "None": { name: "Sin Coeficiente", values: Array(12).fill(0), isDefault: true },
                     "IPC": { name: "IPC", values: Array(12).fill(0), isDefault: true },
                     "UTEDYC": { name: "UTEDYC (Ejemplo)", values: [0, 0, 10, 0, 0, 8, 0, 0, 7, 0, 0, 5], isDefault: true },
                 },
                 ipcManual: [5, 4, 6, 3, 4, 5, 3, 4, 5, 6, 4, 5]
            };
            return {
                 currentYear: defaultYear,
                 scenarios: {},
                 activeScenarioKey: null,
                 settings: defaultSettings,
                 uiState: { editingCoefficientType: null },
                 darkMode: false,
                 BaseScenarioStructureTemplate: baseScenarioStructure
             };
         }

        function loadState() {
             try {
                 const savedState = localStorage.getItem(STORAGE_KEY);
                 if (savedState) {
                     const loadedState = JSON.parse(savedState);
                     const defaultAppState = getDefaultAppState();

                     appState = { ...defaultAppState }; // Start with a fresh default structure

                     // Merge top-level properties
                     for (const key in loadedState) {
                         if (Object.hasOwnProperty.call(loadedState, key) && key !== 'scenarios' && key !== 'settings') {
                             appState[key] = loadedState[key];
                         }
                     }
                     // Deep merge settings
                     appState.settings = deepMerge(defaultAppState.settings, loadedState.settings || {});

                     // Deep merge scenarios, ensuring the cashFlow structure is present
                     appState.scenarios = {};
                     if (loadedState.scenarios) {
                        for (const key in loadedState.scenarios) {
                            if (Object.hasOwnProperty.call(loadedState.scenarios, key)) {
                                // Start with the default template for each scenario to ensure all fields exist
                                let mergedScenario = deepMerge(JSON.parse(JSON.stringify(defaultAppState.BaseScenarioStructureTemplate)), loadedState.scenarios[key]);

                                // Ensure CF specific structures are well-formed if they were missing or partial in old save
                                mergedScenario.cashFlow = mergedScenario.cashFlow || JSON.parse(JSON.stringify(defaultAppState.BaseScenarioStructureTemplate.cashFlow));
                                mergedScenario.cashFlow.calculatedCF = mergedScenario.cashFlow.calculatedCF || JSON.parse(JSON.stringify(defaultAppState.BaseScenarioStructureTemplate.cashFlow.calculatedCF));
                                mergedScenario.cashFlow.monthStatusCF = mergedScenario.cashFlow.monthStatusCF || JSON.parse(JSON.stringify(defaultAppState.BaseScenarioStructureTemplate.cashFlow.monthStatusCF));
                                 if (!mergedScenario.cashFlow.calculatedCF.rubroDetailCollapsedCF) {
                                    mergedScenario.cashFlow.calculatedCF.rubroDetailCollapsedCF = {};
                                }

                                appState.scenarios[key] = mergedScenario;
                            }
                        }
                     }

                     if (appState.settings && Array.isArray(appState.settings.ipcManual)) {
                        appState.settings.ipcManual = appState.settings.ipcManual.map(v => parseFloat(v) || 0);
                     }
                 } else {
                     appState = getDefaultAppState();
                 }
             } catch (e) {
                 console.error(`Error cargando estado desde localStorage con key "${STORAGE_KEY}":`, e);
                 showSnackbar(`Error cargando estado guardado. Usando valores por defecto.`, true, 'error', 8000);
                 appState = getDefaultAppState();
             }
        }

        function saveState() {
             try {
                 localStorage.setItem(STORAGE_KEY, JSON.stringify(appState));
             } catch (e) {
                 console.error(`Error guardando estado a localStorage con key "${STORAGE_KEY}":`, e);
                 showSnackbar("Error al guardar estado en el navegador.", true, 'error', 6000);
             }
         }

        function deepMerge(target, source) {
            const output = { ...target };
            if (isObject(target) && isObject(source)) {
                Object.keys(source).forEach(key => {
                    const targetValue = target[key];
                    const sourceValue = source[key];
                    if (isObject(sourceValue) && isObject(targetValue) && !Array.isArray(targetValue) && targetValue !== null && sourceValue !== null) {
                        output[key] = deepMerge(targetValue, sourceValue);
                    } else if (sourceValue !== undefined) { // Prefer source value unless it's undefined
                        output[key] = sourceValue;
                    }
                });
            } else if (source !== undefined) { // If target is not an object, or source is primitive/array
                 return source;
            }
            return output;
        }


        function isObject(item) {
             return (item !== null && typeof item === 'object' && !Array.isArray(item));
        }

        // --- Utilidades Generales y de UI Pequeñas ---
        function formatCurrency(value) {
             const num = Number(value);
             if (isNaN(num) || !isFinite(num)) return "$ 0,00";
             try {
                 return `$ ${num.toLocaleString('es-AR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
             } catch (e) { return `$ ${num.toFixed(2).replace('.', ',').replace(/\B(?=(\d{3})+(?!\d))/g, '.')}`; }
        }
        function formatPercent(value, decimals = 1) {
            const num = Number(value);
             if (isNaN(num) || !isFinite(num)) return "0,0%";
             return `${num.toLocaleString('es-AR', { minimumFractionDigits: decimals, maximumFractionDigits: decimals })}%`;
        }

        function formatNumberForExcel(value) {
            const num = Number(value);
            if (isNaN(num) || !isFinite(num)) return 0;
            return num;
        }


        function hexToRgba(hex, alpha) {
            hex = String(hex || '#000000').trim().replace('#', '');
            if (!/^[0-9A-F]{3,6}$/i.test(hex)) hex = '000000';
            if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            if (isNaN(r) || isNaN(g) || isNaN(b)) return `rgba(0,0,0,${alpha})`;
            const validAlpha = typeof alpha === 'number' ? Math.max(0, Math.min(1, alpha)) : 1;
            return `rgba(${r}, ${g}, ${b}, ${validAlpha})`;
        }

        function showSnackbar(message, isError = false, level = null, duration = 4000) {
             const snackbar = document.getElementById('snackbar');
             if (!snackbar) return;
             snackbar.textContent = message;
             let effectiveLevel = level ?? (isError ? 'error' : 'success');
             snackbar.className = 'show';
             snackbar.classList.remove('error', 'warning', 'info');
             if (effectiveLevel === 'error') snackbar.classList.add('error');
             else if (effectiveLevel === 'warning') snackbar.classList.add('warning');
             else if (effectiveLevel === 'info') snackbar.classList.add('info');
             if (snackbar.timer) clearTimeout(snackbar.timer);
             snackbar.timer = setTimeout(() => { snackbar.className = ''; snackbar.timer = null; }, duration);
         }

        function destroyChart(canvasId) {
             if (window[`${canvasId}_instance`]) {
                window[`${canvasId}_instance`].destroy();
                window[`${canvasId}_instance`] = null;
             }
         }

        function displayChartNoData(canvasId, show) {
            const container = document.getElementById(canvasId)?.parentElement;
            const noDataElement = container?.querySelector('.chart-no-data');
            if (noDataElement) noDataElement.style.display = show ? 'block' : 'none';
            const canvasElement = document.getElementById(canvasId);
            if (canvasElement) canvasElement.style.display = show ? 'none' : 'block';
        }

        function generateColors(count, palette, alpha = 1) {
            const colors = [];
            for (let i = 0; i < count; i++) colors.push(hexToRgba(palette[i % palette.length], alpha));
            return colors;
         }

        function commonChartOptions(mainYAxisID = 'y', additionalScales = {}) {
            const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
            const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
            return {
                responsive: true, maintainAspectRatio: false,
                scales: {
                    [mainYAxisID]: { beginAtZero: false, ticks: { color: textColor, padding: 10, callback: value => formatCurrency(value).replace(",00", "") }, grid: { color: borderColor, drawTicks: false }, border: { color: borderColor } },
                    x: { ticks: { color: textColor, padding: 10 }, grid: { display: false }, border: { color: borderColor } },
                    ...additionalScales
                },
                plugins: {
                    legend: { position: 'bottom', labels: { color: textColor, boxWidth: 15, padding: 20 } },
                    tooltip: {
                        backgroundColor: hexToRgba(getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim(), 0.9),
                        titleColor: textColor, bodyColor: textColor, borderColor: getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim(), borderWidth: 1, padding: 10,
                        callbacks: {
                             title: tooltipItems => tooltipItems[0]?.label ? FULL_MONTHS[MONTHS.indexOf(tooltipItems[0].label)] : '',
                             label: context => `${context.dataset.label || ''}${context.dataset.label ? ': ' : ''}${formatCurrency(context.parsed.y)}`
                        }
                    }
                },
                interaction: { mode: 'index', intersect: false },
            };
         }

        function pieChartOptions(labelPrefix = '') {
             const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
             const cardBg = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim();
             const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
             const baseFontSize = parseFloat(getComputedStyle(document.body).fontSize);
             const legendFontSize = Math.round(baseFontSize * 1.2);

             return {
                 responsive: true, maintainAspectRatio: false, cutout: '30%',
                 plugins: {
                     legend: {
                         position: 'right',
                         labels: {
                            color: textColor, boxWidth: 15, padding: 15,
                            font: { size: Math.round(legendFontSize * 0.85) },
                             generateLabels: chart => {
                                const data = chart.data; if (!data.labels.length || !data.datasets.length) return [];
                                const { labels } = data; const dataset = data.datasets[0];
                                const total = dataset.data.reduce((a, b) => a + b, 0);
                                return labels.map((label, i) => ({
                                    text: `${label} (${total > 0 ? ((dataset.data[i] / total) * 100).toFixed(1) + '%' : '0.0%'})`,
                                    fillStyle: dataset.backgroundColor[i], strokeStyle: dataset.borderColor || dataset.backgroundColor[i],
                                    lineWidth: dataset.borderWidth || 0,
                                    hidden: !chart.getDataVisibility(i),
                                    index: i
                                }));
                             }
                         }
                     },
                     tooltip: {
                         backgroundColor: hexToRgba(cardBg, 0.9), titleColor: textColor, bodyColor: textColor, borderColor: borderColor, borderWidth: 1, padding: 10,
                         callbacks: {
                            label: context => {
                                 let label = context.label || '';
                                 if (context.parsed !== null) {
                                     const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                     label = `${label}: ${formatCurrency(context.parsed)} (${total > 0 ? ((context.parsed / total) * 100).toFixed(1) + '%' : '0.0%'})`;
                                 } return label;
                            }
                         }
                     }
                 }
             };
         }

        function updateReserveUI() {
            const panel = document.getElementById('reserve-fund-panel'); if (!panel) return;
            const isPercent = document.getElementById('reserve-type-percent').checked;
            const inputs = panel.querySelectorAll('input[type="number"]');
            const uiUnitLabel = isPercent ? '%' : '$'; const uiCurrentStep = isPercent ? '0.1' : '100';
            inputs.forEach((input, i) => {
                input.step = uiCurrentStep; input.placeholder = uiUnitLabel;
                input.title = `Valor de fondo de reserva para ${FULL_MONTHS[i]} (${uiUnitLabel})`;
                 const scenario = getCurrentScenarioData();
                 if (scenario && scenario.reserveFund && scenario.reserveFund.values[i] !== undefined) {
                    // Value is already set by renderReserveFundInputsInPanel or updateReserveFundPanel
                 } else {
                     input.value = isPercent ? 5 : 0;
                 }
            });
        }

        function renderReserveFundInputsInPanel(panelElement, reserveFundData) {
             panelElement.innerHTML = '';
             const uiUnitLabel = reserveFundData.type === 'percent' ? '%' : '$';
             const uiCurrentStep = reserveFundData.type === 'percent' ? '0.1' : '100';
             const reserveValues = (Array.isArray(reserveFundData.values) && reserveFundData.values.length === 12) ? reserveFundData.values.map(v => parseFloat(v || 0)) : Array(12).fill(reserveFundData.type === 'percent' ? 5 : 0);
             for (let i = 0; i < 12; i++) {
                 const monthDiv = document.createElement('div'); monthDiv.classList.add('form-group');
                 const label = document.createElement('label'); label.textContent = FULL_MONTHS[i]; label.htmlFor = `reserve-month-${i}`;
                 const input = document.createElement('input'); input.type = 'number'; input.id = `reserve-month-${i}`; input.dataset.month = i;
                 input.value = reserveValues[i]; input.step = uiCurrentStep; input.min = '0'; input.placeholder = uiUnitLabel; input.style.textAlign = 'right';
                 input.title = `Valor de fondo de reserva para ${FULL_MONTHS[i]} (${uiUnitLabel})`;
                 monthDiv.appendChild(label); monthDiv.appendChild(input); panelElement.appendChild(monthDiv);
             }
        }

        function ensureCollapsibleTableHeaderFooterCells(thead, tfoot, type) {
             let theadRow = thead.querySelector('tr'); if (!theadRow) theadRow = thead.insertRow();
             const expectedHeaderCellCount = (type === 'gastos' ? 2 : 1) + MONTHS.length + 1;
             let headersNeedRebuild = theadRow.cells.length !== expectedHeaderCellCount || theadRow.cells[0]?.textContent !== "Rubro / Detalle" || (type === 'gastos' && theadRow.cells[1]?.textContent !== "Coef. Aplicado") || theadRow.cells[theadRow.cells.length - 1]?.textContent !== "Total Anual";
             if (headersNeedRebuild) {
                 theadRow.innerHTML = ''; theadRow.insertCell().textContent = "Rubro / Detalle";
                 if (type === 'gastos') theadRow.insertCell().textContent = "Coef. Aplicado";
                 MONTHS.forEach(month => { const th=theadRow.insertCell(); th.textContent=month; th.classList.add('number-cell'); });
                 const thTotal = theadRow.insertCell(); thTotal.textContent="Total Anual"; thTotal.classList.add('number-cell');
             }

            let tfootRow = tfoot.querySelector('tr');
            if (!tfootRow) {
                tfootRow = tfoot.insertRow();
            }

            const footerDescCols = type === 'gastos' ? 2 : 1;
            const expectedPhysicalCellsInFoot = 1 + 12 + 1;

            if (tfootRow.cells.length !== expectedPhysicalCellsInFoot || tfootRow.cells[0]?.colSpan !== footerDescCols) {
                tfootRow.innerHTML = '';
                const labelCell = tfootRow.insertCell();
                labelCell.colSpan = footerDescCols;
                labelCell.textContent = `TOTAL GENERAL ${type.toUpperCase()}`;

                for (let i = 0; i < 12 + 1; i++) {
                    const cell = tfootRow.insertCell();
                    cell.classList.add('number-cell');
                    cell.textContent = formatCurrency(0);
                }
            }
        }

        function updateCollapsibleTableFooters(scenarioData) {
            const processFooter = (type) => {
                const table = document.getElementById(`${type}-detail-table`);
                if (!table) return;
                const tfoot = table.querySelector('tfoot');
                if (!tfoot || !tfoot.rows[0]) return;

                const tfootRow = tfoot.rows[0];
                const dataCellStartIndex = 1;

                let monthlyTotals, annualTotal;
                if (scenarioData && scenarioData.calculated) {
                    monthlyTotals = (type === 'gastos' ? scenarioData.calculated.totalGastoProyectadoMes : scenarioData.calculated.totalIngresoProyectadoMes) || Array(12).fill(0);
                    annualTotal = (type === 'gastos' ? scenarioData.calculated.annualTotals?.gastos?.__TOTAL__ : scenarioData.calculated.annualTotals?.ingresos?.__TOTAL__) || 0;
                } else {
                    monthlyTotals = Array(12).fill(0);
                    annualTotal = 0;
                }

                for (let i = 0; i < 12; i++) {
                    if (tfootRow.cells[dataCellStartIndex + i]) {
                        tfootRow.cells[dataCellStartIndex + i].textContent = formatCurrency(monthlyTotals[i]);
                    }
                }
                if (tfootRow.cells[dataCellStartIndex + 12]) {
                    tfootRow.cells[dataCellStartIndex + 12].textContent = formatCurrency(annualTotal);
                }
            };
            processFooter('gastos');
            processFooter('ingresos');
        }


        function updateRubroList(type, listElementId) { // Para rubros de Expensas
            const listElement = document.getElementById(listElementId); if (!listElement) return; listElement.innerHTML = '';
            const rubros = appState.settings.rubros[type] || [];
            const coefTypes = appState.settings.coefficientTypes || {};
            rubros.forEach(rubroName => {
                const li = document.createElement('li');
                const span = document.createElement('span'); span.textContent = rubroName; li.appendChild(span);
                if (type === 'gastos') {
                    const select = document.createElement('select'); select.dataset.rubro = rubroName;
                    Object.keys(coefTypes).forEach(key => { const option = document.createElement('option'); option.value = key; option.textContent = coefTypes[key].name; select.appendChild(option); });
                    const currentCoef = appState.settings.rubroConfig[rubroName]?.coefficientType || 'None';
                    select.value = coefTypes[currentCoef] ? currentCoef : 'None';
                    select.addEventListener('change', handleCoefficientAssignmentChange);
                    li.appendChild(select);
                }
                const btnRemove = document.createElement('button'); btnRemove.innerHTML = '<i class="fas fa-trash-alt"></i>'; btnRemove.classList.add('button-danger', 'button-sm'); btnRemove.title = `Eliminar rubro ${rubroName}`;
                btnRemove.onclick = () => removeRubro(type, rubroName);
                li.appendChild(btnRemove);
                listElement.appendChild(li);
            });
        }

        function updateRubroCFList(type) { // Para rubros de Cash Flow
            const listElementId = `cf-${type === 'ingresos' ? 'ingreso' : 'egreso'}-rubro-list`;
            const listElement = document.getElementById(listElementId);
            if (!listElement) return;
            listElement.innerHTML = '';
            const rubros = appState.settings.rubrosCF[type] || [];

            if (rubros.length === 0) {
                listElement.innerHTML = '<li class="text-muted" style="justify-content:center;">No hay rubros definidos.</li>';
            }

            rubros.forEach(rubroName => {
                const li = document.createElement('li');
                const span = document.createElement('span');
                span.textContent = rubroName;
                li.appendChild(span);

                const btnRemove = document.createElement('button');
                btnRemove.innerHTML = '<i class="fas fa-trash-alt"></i>';
                btnRemove.classList.add('button-danger', 'button-sm');
                btnRemove.title = `Eliminar rubro de CF ${rubroName}`;
                btnRemove.onclick = () => removeRubroCF(type, rubroName);
                li.appendChild(btnRemove);
                listElement.appendChild(li);
            });
        }


        function updateCoefficientTypeList() {
            const listElement = document.getElementById('coefficient-type-list'); if (!listElement) return; listElement.innerHTML = '';
            const coefTypes = appState.settings.coefficientTypes || {};
            Object.entries(coefTypes).forEach(([key, type]) => {
                const li = document.createElement('li');
                const span = document.createElement('span'); span.textContent = type.name;
                span.style.cursor = 'pointer';
                span.onclick = () => editCoefficientType(key);
                li.appendChild(span);
                if (!type.isDefault) {
                    const btnRemove = document.createElement('button'); btnRemove.innerHTML = '<i class="fas fa-trash-alt"></i>'; btnRemove.classList.add('button-danger', 'button-sm'); btnRemove.title = `Eliminar tipo ${type.name}`;
                    btnRemove.onclick = () => removeCoefficientType(key);
                    li.appendChild(btnRemove);
                }
                listElement.appendChild(li);
            });
        }

        function renderCoefficientValuesEditor(typeKey) {
            const editorDiv = document.getElementById('coefficient-values-editor');
            const nameSpan = document.getElementById('editing-coefficient-name');
            const ipcNote = document.getElementById('ipc-editor-note');
            if (!editorDiv || !nameSpan || !ipcNote) return;

            editorDiv.innerHTML = '';
            ipcNote.style.display = 'none';

            const typeData = appState.settings.coefficientTypes?.[typeKey];

            if (!typeData) {
                nameSpan.textContent = (typeKey || 'Ninguno');
                editorDiv.innerHTML = `<p class="text-muted">Selecciona un tipo de coeficiente de la lista de la izquierda para editar/ver sus valores.</p>`;
                appState.uiState.editingCoefficientType = null;
                return;
            }

            nameSpan.textContent = typeData.name;

            if (typeKey === 'None') {
                 editorDiv.innerHTML = `<p class="text-muted">"${typeData.name}" aplica un multiplicador de 1 (0% de ajuste) a todos los meses. No es editable.</p>`;
                 return;
            }

            const values = Array.isArray(typeData.values) && typeData.values.length === 12 ? typeData.values.map(v => parseFloat(v) || 0) : Array(12).fill(0);
            const isIPC = typeKey === 'IPC';

            values.forEach((val, i) => {
                const monthDiv = document.createElement('div'); monthDiv.classList.add('form-group');
                const label = document.createElement('label'); label.textContent = FULL_MONTHS[i]; label.htmlFor = `coef-val-${typeKey}-${i}`;
                const input = document.createElement('input'); input.type = 'number'; input.id = `coef-val-${typeKey}-${i}`;
                input.dataset.month = i; input.dataset.typeKey = typeKey; input.value = val;
                input.step = '0.1'; input.min = '-100'; input.placeholder = '%'; input.style.textAlign = 'right';
                input.title = `Valor para ${FULL_MONTHS[i]} de ${typeData.name} (%)`;

                if (isIPC) {
                    input.disabled = true;
                } else {
                    input.addEventListener('change', handleCoefficientValueChange);
                }
                monthDiv.appendChild(label); monthDiv.appendChild(input); editorDiv.appendChild(monthDiv);
            });

            if (isIPC) {
                ipcNote.style.display = 'block';
            }
        }


        function updateIPCManualInputs() {
             const ipcDiv = document.getElementById('ipc-inputs'); if (!ipcDiv) return; ipcDiv.innerHTML = '';
             appState.settings.ipcManual = Array.isArray(appState.settings.ipcManual) && appState.settings.ipcManual.length === 12 ? appState.settings.ipcManual.map(v => parseFloat(v || 0)) : Array(12).fill(0);
             const ipcValues = appState.settings.ipcManual;

             for (let i = 0; i < 12; i++) {
                 const monthDiv = document.createElement('div'); monthDiv.classList.add('form-group');
                 const label = document.createElement('label'); label.textContent = FULL_MONTHS[i]; label.htmlFor = `ipc-month-${i}`;
                 const input = document.createElement('input'); input.type = 'number'; input.id = `ipc-month-${i}`;
                 input.dataset.month = i; input.value = ipcValues[i]; input.step = '0.1'; input.min = '0'; input.placeholder = '%'; input.style.textAlign = 'right'; input.title = `IPC para ${FULL_MONTHS[i]} (%)`;
                 input.addEventListener('change', (event) => {
                     const monthIndex = parseInt(event.target.dataset.month); const value = parseFloat(event.target.value);
                     if (!isNaN(monthIndex) && monthIndex >= 0 && monthIndex < 12) {
                         const validatedValue = (!isNaN(value) && value >= 0) ? value : 0;
                         appState.settings.ipcManual[monthIndex] = validatedValue;
                         if(appState.settings.coefficientTypes['IPC'] && appState.settings.coefficientTypes['IPC'].values?.length === 12) {
                            appState.settings.coefficientTypes['IPC'].values[monthIndex] = validatedValue;
                         }
                         if(appState.uiState.editingCoefficientType === 'IPC') {
                            renderCoefficientValuesEditor('IPC');
                         }
                     } else event.target.value = appState.settings.ipcManual[monthIndex] ?? 0;
                 });
                 monthDiv.appendChild(label); monthDiv.appendChild(input); ipcDiv.appendChild(monthDiv);
             }
        }

        function getMonthOverallStatus(monthIndex, scenarioData) {
            if (!scenarioData || !scenarioData.monthStatus) return 'Estimado';
            let isOverallReal = true;
            let hasAnyDetail = false;
            function checkTypeStatus(type) {
                if (!isOverallReal) return;
                if (scenarioData.monthStatus[type] && Object.keys(scenarioData.monthStatus[type]).length > 0) {
                    for (const rubroName in scenarioData.monthStatus[type]) {
                        if (!isOverallReal) return;
                        const rubroStatus = scenarioData.monthStatus[type][rubroName];
                        if (rubroStatus && Object.keys(rubroStatus).length > 0) {
                            for (const detailName in rubroStatus) {
                                hasAnyDetail = true;
                                if (!isOverallReal) return;
                                const detailMonthStatusArray = rubroStatus[detailName];
                                if (Array.isArray(detailMonthStatusArray) && detailMonthStatusArray.length === 12) {
                                    const statusForMonth = detailMonthStatusArray[monthIndex];
                                    if (statusForMonth !== 'REAL') {
                                        isOverallReal = false; return;
                                    }
                                } else { isOverallReal = false; return; }
                            }
                        }
                    }
                }
            }
            checkTypeStatus('gastos');
            if (!isOverallReal) return 'Estimado';
            checkTypeStatus('ingresos');
            if (!hasAnyDetail && (Object.keys(scenarioData.monthStatus?.gastos || {}).length === 0 && Object.keys(scenarioData.monthStatus?.ingresos || {}).length === 0) ) {
                 return 'Estimado';
            }
            return isOverallReal ? 'REAL' : 'Estimado';
        }

        function validateAndSetActiveScenario() {
            let activeKeyIsValid = false; let fallbackNeeded = true;
            if (appState.activeScenarioKey && appState.scenarios?.[appState.activeScenarioKey]) {
                 const scenario = appState.scenarios[appState.activeScenarioKey];
                 const activeYear = parseInt(appState.activeScenarioKey.split('_')[0]);
                 if (!isNaN(activeYear) && scenario.year === activeYear) { appState.currentYear = activeYear; activeKeyIsValid = true; fallbackNeeded = false; }
                 else { appState.activeScenarioKey = null; }
            } else if (appState.activeScenarioKey !== null) appState.activeScenarioKey = null;

            if (!activeKeyIsValid) {
                const defaultYear = new Date().getFullYear();
                const scenariosForCurrentYear = Object.keys(appState.scenarios || {}).filter(k => appState.scenarios[k]?.year === appState.currentYear);
                const scenariosForDefaultYear = Object.keys(appState.scenarios || {}).filter(k => appState.scenarios[k]?.year === defaultYear);
                let fallbackKey = null;
                if (appState.scenarios?.[`${appState.currentYear}_Base`]) fallbackKey = `${appState.currentYear}_Base`;
                else if (scenariosForCurrentYear.length > 0) fallbackKey = scenariosForCurrentYear.sort((a,b) => (appState.scenarios[a]?.scenarioName || '').localeCompare(appState.scenarios[b]?.scenarioName || ''))[0];
                else if (appState.scenarios?.[`${defaultYear}_Base`]) fallbackKey = `${defaultYear}_Base`;
                else if (scenariosForDefaultYear.length > 0) fallbackKey = scenariosForDefaultYear.sort((a,b) => (appState.scenarios[a]?.scenarioName || '').localeCompare(appState.scenarios[b]?.scenarioName || ''))[0];
                else { const allKeys = Object.keys(appState.scenarios || {}).sort(); if (allKeys.length > 0 && appState.scenarios[allKeys[0]]) fallbackKey = allKeys[0]; }

                if (fallbackKey && appState.scenarios?.[fallbackKey]) {
                    appState.activeScenarioKey = fallbackKey;
                    appState.currentYear = appState.scenarios[fallbackKey].year || parseInt(fallbackKey.split('_')[0]) || defaultYear;
                    fallbackNeeded = false;
                }
            }
            if (fallbackNeeded) {
                const year = new Date().getFullYear(); appState.currentYear = year;
                initScenarioData(year, 'Base'); appState.activeScenarioKey = `${year}_Base`;
            }
            const currentScenario = getCurrentScenarioData();
            if (currentScenario) { initializeScenarioDataForRubros(currentScenario); ensureDefaultCoefficientTypes(); }
            else console.error("validateAndSetActiveScenario: No se pudo establecer un escenario activo válido después de los fallbacks.");
        }

        function getCurrentScenarioData() {
             if (appState.activeScenarioKey && appState.scenarios?.[appState.activeScenarioKey]?.year !== undefined) return appState.scenarios[appState.activeScenarioKey];
             return null;
        }

        function initScenarioData(year, scenarioName = 'Base') {
             if (typeof year !== 'number' || year < 2000 || year > 2099) year = new Date().getFullYear();
             const key = `${year}_${scenarioName.replace(/\s+/g, '_').replace(/[^\w-]/g, '')}`;
             if (appState.scenarios[key]) return appState.scenarios[key];
             const defaultTemplate = getDefaultAppState().BaseScenarioStructureTemplate;
             appState.scenarios[key] = JSON.parse(JSON.stringify(defaultTemplate)); // Deep copy
             appState.scenarios[key].year = year; appState.scenarios[key].scenarioName = scenarioName;
             return appState.scenarios[key];
        }

        function initializeScenarioDataForRubros(scenarioData) {
             if (!scenarioData || typeof scenarioData !== 'object' || scenarioData.year === undefined) { console.error("initializeScenarioDataForRubros: datos de escenario inválidos."); return; }

             // Initialize expensas related data
             scenarioData.rubroOrder = scenarioData.rubroOrder ?? { gastos: [], ingresos: [] };
             scenarioData.rubroOrder.gastos = Array.isArray(scenarioData.rubroOrder.gastos) ? scenarioData.rubroOrder.gastos : [];
             scenarioData.rubroOrder.ingresos = Array.isArray(scenarioData.rubroOrder.ingresos) ? scenarioData.rubroOrder.ingresos : [];
             scenarioData.data = scenarioData.data ?? { gastos: {}, ingresos: {} };
             scenarioData.data.gastos = scenarioData.data.gastos ?? {}; scenarioData.data.ingresos = scenarioData.data.ingresos ?? {};

             scenarioData.monthStatus = scenarioData.monthStatus ?? { gastos: {}, ingresos: {} };
             scenarioData.monthStatus.gastos = scenarioData.monthStatus.gastos ?? {};
             scenarioData.monthStatus.ingresos = scenarioData.monthStatus.ingresos ?? {};

             scenarioData.reserveFund = scenarioData.reserveFund ?? { type: 'percent', values: Array(12).fill(5) };
             scenarioData.reserveFund.values = (Array.isArray(scenarioData.reserveFund.values) && scenarioData.reserveFund.values.length === 12) ? scenarioData.reserveFund.values.map(v => parseFloat(v||0)) : Array(12).fill(scenarioData.reserveFund.type === 'fixed' ? 0 : 5);

             scenarioData.calculated = scenarioData.calculated ?? {};
             const defaultCalc = getDefaultAppState().BaseScenarioStructureTemplate?.calculated || {};
             for(const k in defaultCalc) {
                 if(scenarioData.calculated[k] === undefined || scenarioData.calculated[k] === null) {
                    scenarioData.calculated[k] = Array.isArray(defaultCalc[k]) ? [...defaultCalc[k]] : (typeof defaultCalc[k] === 'object' ? {...defaultCalc[k]} : defaultCalc[k]);
                 } else if (Array.isArray(scenarioData.calculated[k]) && scenarioData.calculated[k].length !== 12 && k !== 'annualTotals') {
                    scenarioData.calculated[k] = [...defaultCalc[k]];
                 }
             }
             if (!Array.isArray(scenarioData.calculated.monthOverallStatus) || scenarioData.calculated.monthOverallStatus.length !== 12) {
                scenarioData.calculated.monthOverallStatus = Array(12).fill('Estimado');
             }
             scenarioData.calculated.annualTotals = scenarioData.calculated.annualTotals ?? { gastos: {__TOTAL__:0}, ingresos: {__TOTAL__:0}, fondoReserva: 0, cuotaSobreGastos: 0, cuotaIpc: 0, cuotaRealBase: 0 };
             scenarioData.calculated.annualTotals.gastos = scenarioData.calculated.annualTotals.gastos ?? { __TOTAL__: 0 };
             scenarioData.calculated.annualTotals.ingresos = scenarioData.calculated.annualTotals.ingresos ?? { __TOTAL__: 0 };

             if (!Array.isArray(scenarioData.calculated.ipcManual) || scenarioData.calculated.ipcManual.length !== 12) {
                scenarioData.calculated.ipcManual = [...(appState.settings?.ipcManual || Array(12).fill(0))];
             } else {
                 scenarioData.calculated.ipcManual = scenarioData.calculated.ipcManual.map(v => parseFloat(v||0));
             }

            // Initialize Cash Flow related data
            scenarioData.cashFlow = scenarioData.cashFlow || JSON.parse(JSON.stringify(getDefaultAppState().BaseScenarioStructureTemplate.cashFlow));
            scenarioData.cashFlow.saldoInicialCaja = (Array.isArray(scenarioData.cashFlow.saldoInicialCaja) && scenarioData.cashFlow.saldoInicialCaja.length === 12) ? scenarioData.cashFlow.saldoInicialCaja.map(v => parseFloat(v || 0)) : Array(12).fill(0);
            scenarioData.cashFlow.rubrosIngresosCFData = scenarioData.cashFlow.rubrosIngresosCFData || {};
            scenarioData.cashFlow.rubrosEgresosCFData = scenarioData.cashFlow.rubrosEgresosCFData || {};
            scenarioData.cashFlow.monthStatusCF = scenarioData.cashFlow.monthStatusCF || { saldoInicialCajaEnero: 'Estimado', ingresos: {}, egresos: {} };
            scenarioData.cashFlow.monthStatusCF.saldoInicialCajaEnero = scenarioData.cashFlow.monthStatusCF.saldoInicialCajaEnero || 'Estimado';
            scenarioData.cashFlow.monthStatusCF.ingresos = scenarioData.cashFlow.monthStatusCF.ingresos || {};
            scenarioData.cashFlow.monthStatusCF.egresos = scenarioData.cashFlow.monthStatusCF.egresos || {};

            scenarioData.cashFlow.calculatedCF = scenarioData.cashFlow.calculatedCF || JSON.parse(JSON.stringify(getDefaultAppState().BaseScenarioStructureTemplate.cashFlow.calculatedCF));
            if (!scenarioData.cashFlow.calculatedCF.rubroDetailCollapsedCF) {
                scenarioData.cashFlow.calculatedCF.rubroDetailCollapsedCF = {};
            }


             ['gastos', 'ingresos'].forEach(type => { // For expensas rubros
                 const globalRubros = appState.settings?.rubros?.[type] || [];
                 globalRubros.forEach(rubro => {
                      if (!scenarioData.data[type][rubro]) scenarioData.data[type][rubro] = { detailOrder: [], detailsData: {} };
                      scenarioData.data[type][rubro].detailOrder = Array.isArray(scenarioData.data[type][rubro].detailOrder) ? scenarioData.data[type][rubro].detailOrder : [];
                      scenarioData.data[type][rubro].detailsData = (typeof scenarioData.data[type][rubro].detailsData === 'object' && scenarioData.data[type][rubro].detailsData !== null) ? scenarioData.data[type][rubro].detailsData : {};

                      scenarioData.monthStatus[type][rubro] = (typeof scenarioData.monthStatus[type][rubro] === 'object' && scenarioData.monthStatus[type][rubro] !== null) ? scenarioData.monthStatus[type][rubro] : {};

                      const calcKeyPrefix = type === 'gastos' ? 'gasto' : 'ingreso';
                      const calcKeyTotalRubroMes = `total${type.charAt(0).toUpperCase() + type.slice(1)}RubroMes`;
                      scenarioData.calculated[`${calcKeyPrefix}Ajustado`] = scenarioData.calculated[`${calcKeyPrefix}Ajustado`] ?? {};
                      scenarioData.calculated[`${calcKeyPrefix}Ajustado`][rubro] = scenarioData.calculated[`${calcKeyPrefix}Ajustado`][rubro] ?? {};
                      scenarioData.calculated[calcKeyTotalRubroMes] = scenarioData.calculated[calcKeyTotalRubroMes] ?? {};
                      scenarioData.calculated[calcKeyTotalRubroMes][rubro] = (Array.isArray(scenarioData.calculated[calcKeyTotalRubroMes][rubro]) && scenarioData.calculated[calcKeyTotalRubroMes][rubro].length === 12) ? scenarioData.calculated[calcKeyTotalRubroMes][rubro].map(v=>parseFloat(v||0)) : Array(12).fill(0);
                      scenarioData.calculated.annualTotals[type][rubro] = scenarioData.calculated.annualTotals[type][rubro] ?? 0;

                      Object.keys(scenarioData.data[type][rubro].detailsData).forEach(detail => {
                           if (!scenarioData.data[type][rubro].detailOrder.includes(detail)) scenarioData.data[type][rubro].detailOrder.push(detail);
                           const detailDataArray = scenarioData.data[type][rubro].detailsData[detail];
                           if(!Array.isArray(detailDataArray) || detailDataArray.length !== 12) scenarioData.data[type][rubro].detailsData[detail] = Array(12).fill(0);
                           else scenarioData.data[type][rubro].detailsData[detail] = detailDataArray.map(v => parseFloat(v||0));

                           const statusArray = scenarioData.monthStatus[type]?.[rubro]?.[detail];
                           if (!scenarioData.monthStatus[type][rubro]) scenarioData.monthStatus[type][rubro] = {};
                           if (!Array.isArray(statusArray) || statusArray.length !== 12) {
                               scenarioData.monthStatus[type][rubro][detail] = Array(12).fill('Estimado');
                           } else {
                               scenarioData.monthStatus[type][rubro][detail] = statusArray.map(s => String(s || 'Estimado'));
                           }

                           const calcDetailArray = scenarioData.calculated[`${calcKeyPrefix}Ajustado`][rubro]?.[detail];
                           if(!Array.isArray(calcDetailArray) || calcDetailArray.length !== 12) scenarioData.calculated[`${calcKeyPrefix}Ajustado`][rubro][detail] = Array(12).fill(0);
                           else scenarioData.calculated[`${calcKeyPrefix}Ajustado`][rubro][detail] = calcDetailArray.map(v=>parseFloat(v||0));
                       });
                 });
                 Object.keys(scenarioData.data[type] || {}).forEach(rubro => { if (!globalRubros.includes(rubro)) { delete scenarioData.data[type][rubro]; delete scenarioData.monthStatus[type]?.[rubro]; } });
                 scenarioData.rubroOrder[type] = scenarioData.rubroOrder[type].filter(rubro => globalRubros.includes(rubro));
             });

            // Initialize Cash Flow rubros data and status based on appState.settings.rubrosCF
            ['ingresos', 'egresos'].forEach(cfType => {
                const globalCFRubros = appState.settings.rubrosCF[cfType] || [];
                const cfDataContainer = cfType === 'ingresos' ? scenarioData.cashFlow.rubrosIngresosCFData : scenarioData.cashFlow.rubrosEgresosCFData;
                const cfStatusContainer = scenarioData.cashFlow.monthStatusCF[cfType];

                globalCFRubros.forEach(rubroName => {
                    if (!cfDataContainer[rubroName]) {
                        cfDataContainer[rubroName] = { detailOrder: ["Valor"], detailsData: { "Valor": Array(12).fill(0) } };
                    }
                    if (!cfStatusContainer[rubroName]) {
                        cfStatusContainer[rubroName] = { "Valor": Array(12).fill('Estimado') };
                    }
                    // Ensure "Valor" detail exists and is correctly structured
                    if (!cfDataContainer[rubroName].detailOrder.includes("Valor")) cfDataContainer[rubroName].detailOrder = ["Valor"];
                    if (!cfDataContainer[rubroName].detailsData["Valor"] || cfDataContainer[rubroName].detailsData["Valor"].length !== 12) {
                        cfDataContainer[rubroName].detailsData["Valor"] = Array(12).fill(0);
                    }
                    if (!cfStatusContainer[rubroName]["Valor"] || cfStatusContainer[rubroName]["Valor"].length !== 12) {
                        cfStatusContainer[rubroName]["Valor"] = Array(12).fill('Estimado');
                    }
                });
                // Clean up CF rubros in scenario that are no longer in settings
                Object.keys(cfDataContainer).forEach(rubroName => {
                    if (!globalCFRubros.includes(rubroName)) {
                        delete cfDataContainer[rubroName];
                        delete cfStatusContainer[rubroName];
                    }
                });
            });
         }


        function ensureDefaultCoefficientTypes() {
              const defaultTypes = getDefaultAppState().settings.coefficientTypes;
             appState.settings.coefficientTypes = appState.settings.coefficientTypes || {};
             for (const key in defaultTypes) {
                 if (!appState.settings.coefficientTypes[key]) {
                    appState.settings.coefficientTypes[key] = JSON.parse(JSON.stringify(defaultTypes[key]));
                 } else {
                    appState.settings.coefficientTypes[key].isDefault = defaultTypes[key].isDefault ?? false;
                    if (!Array.isArray(appState.settings.coefficientTypes[key].values) || appState.settings.coefficientTypes[key].values.length !== 12) {
                        appState.settings.coefficientTypes[key].values = Array(12).fill(0);
                    }
                 }
                 if (key === 'IPC') {
                      const manualIPC = appState.settings.ipcManual;
                      if (!Array.isArray(manualIPC) || manualIPC.length !== 12) appState.settings.ipcManual = Array(12).fill(0);
                       appState.settings.coefficientTypes[key].values = [...appState.settings.ipcManual.map(v => parseFloat(v||0))];
                  } else if (key === 'None') {
                       appState.settings.coefficientTypes[key].values = Array(12).fill(0);
                  } else {
                       appState.settings.coefficientTypes[key].values = appState.settings.coefficientTypes[key].values.map(val => (!isNaN(parseFloat(val)) && parseFloat(val) >= -100) ? parseFloat(val) : 0);
                  }
             }
         }

        // --- Lógica de Negocio y Cálculos ---
        function calculateCashFlowMetrics(scenarioData) {
            if (!scenarioData || !scenarioData.cashFlow || !scenarioData.cashFlow.calculatedCF) return;

            const cf = scenarioData.cashFlow;
            const calcCF = cf.calculatedCF;
            const settingsCFRubros = appState.settings.rubrosCF;

            // Reset calculated values
            calcCF.totalOtrosIngresosCFMes = Array(12).fill(0);
            calcCF.totalEgresosCFMes = Array(12).fill(0);
            calcCF.flujoNetoMesCF = Array(12).fill(0);
            calcCF.saldoFinalCajaMes = Array(12).fill(0);
            calcCF.annualTotalsCF = { otrosIngresos: 0, egresos: 0, flujoNeto: 0 };
            calcCF.monthOverallStatusCF = Array(12).fill('Estimado');

            let overallRealCF = true; // For monthOverallStatusCF

            // Calculate Total Otros Ingresos CF
            (settingsCFRubros.ingresos || []).forEach(rubroName => {
                const rubroData = cf.rubrosIngresosCFData[rubroName]?.detailsData?.["Valor"];
                if (rubroData) {
                    rubroData.forEach((val, i) => {
                        calcCF.totalOtrosIngresosCFMes[i] += parseFloat(val || 0);
                    });
                }
            });

            // Calculate Total Egresos CF
            (settingsCFRubros.egresos || []).forEach(rubroName => {
                const rubroData = cf.rubrosEgresosCFData[rubroName]?.detailsData?.["Valor"];
                if (rubroData) {
                    rubroData.forEach((val, i) => {
                        calcCF.totalEgresosCFMes[i] += parseFloat(val || 0);
                    });
                }
            });

            // Calculate Flujo Neto, Saldos y Status
            for (let i = 0; i < 12; i++) {
                // Saldo Inicial
                if (i === 0) {
                    // Saldo inicial de Enero es el de la data (editable)
                    // cf.saldoInicialCaja[0] ya está seteado
                } else {
                    cf.saldoInicialCaja[i] = calcCF.saldoFinalCajaMes[i - 1];
                }

                // Flujo Neto del Mes
                calcCF.flujoNetoMesCF[i] = calcCF.totalOtrosIngresosCFMes[i] - calcCF.totalEgresosCFMes[i];

                // Saldo Final del Mes
                calcCF.saldoFinalCajaMes[i] = cf.saldoInicialCaja[i] + calcCF.flujoNetoMesCF[i];

                // Month Overall Status CF
                let monthIsReal = true;
                if (i === 0 && cf.monthStatusCF.saldoInicialCajaEnero !== 'REAL') monthIsReal = false;

                (settingsCFRubros.ingresos || []).forEach(rubroName => {
                    if (cf.monthStatusCF.ingresos[rubroName]?.["Valor"]?.[i] !== 'REAL') monthIsReal = false;
                });
                (settingsCFRubros.egresos || []).forEach(rubroName => {
                    if (cf.monthStatusCF.egresos[rubroName]?.["Valor"]?.[i] !== 'REAL') monthIsReal = false;
                });
                calcCF.monthOverallStatusCF[i] = monthIsReal ? 'REAL' : 'Estimado';
            }

            // Annual Totals CF
            calcCF.annualTotalsCF.otrosIngresos = calcCF.totalOtrosIngresosCFMes.reduce((sum, val) => sum + val, 0);
            calcCF.annualTotalsCF.egresos = calcCF.totalEgresosCFMes.reduce((sum, val) => sum + val, 0);
            calcCF.annualTotalsCF.flujoNeto = calcCF.flujoNetoMesCF.reduce((sum, val) => sum + val, 0);
            // Saldo final anual es el saldo final de Diciembre.
        }


        function calculateAll(scenarioData) {
             if (!scenarioData) { renderEmptyState(); return; }
             initializeScenarioDataForRubros(scenarioData); // Ensures all structures are present
             ensureDefaultCoefficientTypes();

             const { data, reserveFund, monthStatus } = scenarioData;
             const { settings } = appState; const { rubroConfig, coefficientTypes, cantidadUnidades } = settings;
             const calculated = scenarioData.calculated;

             if (!Array.isArray(calculated.monthOverallStatus) || calculated.monthOverallStatus.length !== 12) {
                calculated.monthOverallStatus = Array(12).fill('Estimado');
             }
             for (let i = 0; i < 12; i++) {
                calculated.monthOverallStatus[i] = getMonthOverallStatus(i, scenarioData);
             }

             calculated.ipcManual = Array.isArray(settings.ipcManual) && settings.ipcManual.length === 12 ? [...settings.ipcManual.map(v=>parseFloat(v||0))] : Array(12).fill(0);
             calculated.gastoAjustado = {}; calculated.totalGastoRubroMes = {}; calculated.totalGastoProyectadoMes = Array(12).fill(0);
             calculated.ingresoAjustado = {}; calculated.totalIngresoRubroMes = {}; calculated.totalIngresoProyectadoMes = Array(12).fill(0);
             Object.assign(calculated, { fondoReservaMes: Array(12).fill(0), cuotaSobreGastosMes: Array(12).fill(0), cuotaIpcMes: Array(12).fill(0), cuotaRealBaseMes: Array(12).fill(0) });
             calculated.annualTotals = { gastos: {__TOTAL__:0}, ingresos: {__TOTAL__:0}, fondoReserva: 0, cuotaSobreGastos: 0, cuotaIpc: 0, cuotaRealBase: 0 };

             const globalGastosRubros = settings?.rubros?.gastos || [];
             const gastoRubros = (scenarioData.rubroOrder?.gastos?.length > 0 ? scenarioData.rubroOrder.gastos : globalGastosRubros).filter(r => globalGastosRubros.includes(r) && data.gastos?.[r]?.detailsData);
             gastoRubros.forEach(rubro => {
                 if (!data.gastos?.[rubro]?.detailsData) return;
                 calculated.gastoAjustado[rubro] = {}; calculated.totalGastoRubroMes[rubro] = Array(12).fill(0); calculated.annualTotals.gastos[rubro] = 0;
                 const detailOrder = (data.gastos[rubro].detailOrder?.length > 0 ? data.gastos[rubro].detailOrder : Object.keys(data.gastos[rubro].detailsData || {})).filter(d => Array.isArray(data.gastos[rubro].detailsData?.[d]) && data.gastos[rubro].detailsData[d].length === 12);
                 if (detailOrder.length === 0) return;

                 detailOrder.forEach(detail => {
                     const srcVals = (data.gastos[rubro].detailsData[detail] || []).map(v => parseFloat(v||0));
                     calculated.gastoAjustado[rubro][detail] = [...srcVals];
                     for (let i=0; i<12; i++) calculated.totalGastoRubroMes[rubro][i] += (srcVals[i]||0);
                 });

                 for (let i=0; i<12; i++) calculated.totalGastoProyectadoMes[i] += (calculated.totalGastoRubroMes[rubro]?.[i]||0);
                 calculated.annualTotals.gastos[rubro] = (calculated.totalGastoRubroMes[rubro]||[]).reduce((a,b)=>a+(b||0),0);
             });
             calculated.annualTotals.gastos.__TOTAL__ = (calculated.totalGastoProyectadoMes||[]).reduce((a,b)=>a+(b||0),0);

             const unidades = parseInt(cantidadUnidades) || 1; const unidadesCuota = unidades > 0 ? unidades : 1;
             const globalIngresosRubros = settings?.rubros?.ingresos || [];
             const ingresoRubros = (scenarioData.rubroOrder?.ingresos?.length > 0 ? scenarioData.rubroOrder.ingresos : globalIngresosRubros).filter(r => globalIngresosRubros.includes(r) && data.ingresos?.[r]?.detailsData);
             ingresoRubros.forEach(rubro => {
                 if (!data.ingresos?.[rubro]?.detailsData) return;
                 calculated.ingresoAjustado[rubro] = {}; calculated.totalIngresoRubroMes[rubro] = Array(12).fill(0); calculated.annualTotals.ingresos[rubro] = 0;
                 const detailOrder = (data.ingresos[rubro].detailOrder?.length > 0 ? data.ingresos[rubro].detailOrder : Object.keys(data.ingresos[rubro].detailsData || {})).filter(d => Array.isArray(data.ingresos[rubro].detailsData?.[d]) && data.ingresos[rubro].detailsData[d].length === 12);
                 if (detailOrder.length === 0) return;
                 detailOrder.forEach(detail => {
                     const baseVals = (data.ingresos[rubro].detailsData[detail]||[]).map(v => parseFloat(v||0));
                     calculated.ingresoAjustado[rubro][detail] = baseVals;
                     for (let i=0; i<12; i++) calculated.totalIngresoRubroMes[rubro][i] += (SPECIAL_INGRESO_RUBROS.includes(rubro) ? baseVals[i]*unidades : baseVals[i]) || 0;
                 });
                 for (let i=0; i<12; i++) calculated.totalIngresoProyectadoMes[i] += (calculated.totalIngresoRubroMes[rubro]?.[i]||0);
                 calculated.annualTotals.ingresos[rubro] = (calculated.totalIngresoRubroMes[rubro]||[]).reduce((a,b)=>a+(b||0),0);
             });
             calculated.annualTotals.ingresos.__TOTAL__ = (calculated.totalIngresoProyectadoMes||[]).reduce((a,b)=>a+(b||0),0);

             if (unidadesCuota <= 0 || !calculated.totalIngresoRubroMes?.[CUOTA_RUBRO_NAME]) calculated.cuotaRealBaseMes = Array(12).fill(0);
             else for (let i=0; i<12; i++) calculated.cuotaRealBaseMes[i] = (calculated.totalIngresoRubroMes[CUOTA_RUBRO_NAME][i]||0) / unidadesCuota;
             calculated.annualTotals.cuotaRealBase = (calculated.cuotaRealBaseMes||[]).reduce((a,b)=>a+(b||0),0);

             const reserveVals = (reserveFund?.values?.length === 12 ? reserveFund.values : Array(12).fill(reserveFund?.type === 'fixed' ? 0:5)).map(v=>parseFloat(v||0));
             for (let i=0; i<12; i++) calculated.fondoReservaMes[i] = reserveFund?.type === 'percent' ? (calculated.totalGastoProyectadoMes[i]||0)*(reserveVals[i]/100) : (reserveVals[i]||0);
             calculated.annualTotals.fondoReserva = (calculated.fondoReservaMes||[]).reduce((a,b)=>a+(b||0),0);

             for (let i=0; i<12; i++) calculated.cuotaSobreGastosMes[i] = unidadesCuota > 0 ? ((calculated.totalGastoProyectadoMes[i]||0) + (calculated.fondoReservaMes[i]||0)) / unidadesCuota : 0;
             calculated.annualTotals.cuotaSobreGastos = (calculated.cuotaSobreGastosMes||[]).reduce((a,b)=>a+(b||0),0);

             const ipcSnap = (calculated.ipcManual?.length === 12 ? calculated.ipcManual : Array(12).fill(0)).map(v=>parseFloat(v||0));
             const baseEneroCuota = calculated.cuotaRealBaseMes?.[0]||0;
             if (baseEneroCuota > 0) {
                 let accMult = 1;
                 for (let i=0; i<12; i++) { accMult *= (!isNaN(ipcSnap[i]) && ipcSnap[i]>=0 ? (1+ipcSnap[i]/100) : 1); calculated.cuotaIpcMes[i] = baseEneroCuota * accMult; }
             } else {
                 calculated.cuotaIpcMes = Array(12).fill(0);
             }
             calculated.annualTotals.cuotaIpc = (calculated.cuotaIpcMes||[]).reduce((a,b)=>a+(b||0),0);

             calculateCashFlowMetrics(scenarioData); // NUEVA LLAMADA
             saveState(); updateUI();
        }

        function recalculateEstimates() { // Solo para gastos de expensas por ahora
            ensureDefaultCoefficientTypes();
            const scenarioData = getCurrentScenarioData(); if (!scenarioData) { showSnackbar("No hay escenario activo.", true, 'error'); return; }
            const { data, monthStatus, rubroOrder } = scenarioData; const { settings } = appState; const { rubroConfig, coefficientTypes } = settings;
            let changesMade = false; let projectedCellCount = 0; let totalDetailsProcessed = 0;
            const globalGastosRubros = settings?.rubros?.gastos || [];
            const gastoRubros = (rubroOrder?.gastos?.length > 0 ? rubroOrder.gastos : globalGastosRubros).filter(r => globalGastosRubros.includes(r) && data.gastos?.[r]?.detailsData);
            if (gastoRubros.length === 0) { showSnackbar("No hay rubros de gasto para proyectar.", false, 'info'); return; }

            gastoRubros.forEach(rubro => {
                if (!data.gastos?.[rubro]?.detailsData) return;
                const detailOrder = (data.gastos[rubro].detailOrder?.length > 0 ? data.gastos[rubro].detailOrder : Object.keys(data.gastos[rubro].detailsData||{})).filter(d => Array.isArray(data.gastos[rubro].detailsData?.[d]) && data.gastos[rubro].detailsData[d].length === 12);
                if (detailOrder.length === 0) return; totalDetailsProcessed += detailOrder.length;

                const coefKey = rubroConfig[rubro]?.coefficientType || 'None';
                const coefType = coefficientTypes[coefKey];

                const monthlyPercentageIncreases = (coefType && Array.isArray(coefType.values) && coefType.values.length === 12)
                    ? coefType.values.map(v => parseFloat(v || 0))
                    : Array(12).fill(0);

                detailOrder.forEach(detail => {
                    const statuses = (monthStatus.gastos?.[rubro]?.[detail]?.length === 12 ? monthStatus.gastos[rubro][detail] : Array(12).fill('Estimado'));
                    const dataVals = (data.gastos[rubro].detailsData[detail]||[]).map(v=>parseFloat(v||0));

                    let lastRealIdx = -1;
                    for (let i = 11; i >= 0; i--) {
                        if(statuses[i]==='REAL'){
                            lastRealIdx=i;
                            break;
                        }
                    }

                    if (lastRealIdx === -1) return;
                    if (lastRealIdx === 11) return;

                    let previousMonthValue = dataVals[lastRealIdx];

                    for (let j = lastRealIdx + 1; j < 12; j++) {
                        if (statuses[j] === 'Estimado') {
                            const percentageIncreaseForMonthJ = monthlyPercentageIncreases[j];
                            const multiplierForMonthJ = 1 + (percentageIncreaseForMonthJ / 100);

                            const projectedValue = previousMonthValue * multiplierForMonthJ;

                            data.gastos[rubro].detailsData[detail][j] = projectedValue;
                            monthStatus.gastos[rubro][detail][j] = 'Estimado';
                            changesMade = true;
                            projectedCellCount++;
                            previousMonthValue = projectedValue;
                        } else if (statuses[j] === 'REAL') {
                            previousMonthValue = dataVals[j];
                        }
                    }
                });
            });
            if (totalDetailsProcessed === 0) { showSnackbar("No se encontraron detalles de gastos válidos para proyectar.", false, 'info'); return; }
            if (changesMade) {
                showSnackbar(`Estimados recalculados (${projectedCellCount} celdas). Actualizando...`, false, 'info');
                calculateAll(scenarioData);
            }
            else showSnackbar("No se necesitaron cambios en los estimados.", false, 'info');
        }

        // --- Funciones Principales de Actualización de UI ---
        function updateSettingsPanel() {
            const ufInput = document.getElementById('cantidad-unidades');
            appState.settings.cantidadUnidades = parseInt(appState.settings.cantidadUnidades)||100; if(appState.settings.cantidadUnidades<0)appState.settings.cantidadUnidades=100;
            if (ufInput) ufInput.value = appState.settings.cantidadUnidades;
            updateRubroList('gastos', 'gasto-rubro-list'); // Expensas
            updateRubroList('ingresos', 'ingreso-rubro-list'); // Expensas
            ensureDefaultCoefficientTypes(); updateCoefficientTypeList();

            const currentEditing = appState.uiState.editingCoefficientType;
            if (currentEditing && appState.settings.coefficientTypes?.[currentEditing]) {
                 renderCoefficientValuesEditor(currentEditing);
            } else {
                document.getElementById('coefficient-values-editor').innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente de la lista de la izquierda para editar/ver sus valores porcentuales (%) mes a mes.</p>';
                document.getElementById('editing-coefficient-name').textContent = 'Ninguno';
                document.getElementById('ipc-editor-note').style.display = 'none';
                appState.uiState.editingCoefficientType = null;
            }
            updateIPCManualInputs();
        }

        function updateReserveFundPanel(scenarioData) {
             const panel = document.getElementById('reserve-fund-panel'); const pRadio=document.getElementById('reserve-type-percent'); const fRadio=document.getElementById('reserve-type-fixed');
             if(!panel||!pRadio||!fRadio) return;
             const defReserve = getDefaultAppState().BaseScenarioStructureTemplate.reserveFund;
             const reserveData = (scenarioData?.reserveFund?.values?.length===12 && typeof scenarioData.reserveFund.type==='string') ? scenarioData.reserveFund : defReserve;
             const typeFromState = reserveData.type==='fixed'?'fixed':'percent'; pRadio.checked=typeFromState==='percent'; fRadio.checked=typeFromState==='fixed';
             const inputs = panel.querySelectorAll('input[type="number"]');
             if (inputs.length === 12) {
                   inputs.forEach((input, i) => { input.value = parseFloat(reserveData.values[i]||0) || (typeFromState==='fixed'?0:5); });
                   updateReserveUI();
             } else renderReserveFundInputsInPanel(panel, reserveData);
        }

        function updateCollapsibleTable(type, scenarioData) { // Para Expensas
             const table = document.getElementById(`${type}-detail-table`); if (!table) return;
             const thead = table.querySelector('thead'); const tbody = table.querySelector('tbody'); const tfoot = table.querySelector('tfoot'); if (!thead || !tbody || !tfoot) return;
             tbody.innerHTML = '';

             const expectedHdrCount = (type==='gastos'?2:1)+MONTHS.length+1;
             if (!scenarioData?.data || !scenarioData.calculated || !scenarioData.monthStatus || !appState.settings) {
                tbody.innerHTML=`<tr><td colspan="${thead.querySelector('tr')?.cells.length||expectedHdrCount}" class="text-muted" style="text-align:center;padding:20px;">Faltan datos.</td></tr>`;
                ensureCollapsibleTableHeaderFooterCells(thead,tfoot,type);
                updateCollapsibleTableFooters(null);
                return;
            }
             const { data, calculated, monthStatus, rubroOrder } = scenarioData;
             const globalRubros = appState.settings.rubros?.[type] || [];
             const rubrosToDisplay = (rubroOrder?.[type]?.length>0 ? rubroOrder[type] : globalRubros).filter(r => globalRubros.includes(r) && data[type]?.[r]?.detailsData);

             ensureCollapsibleTableHeaderFooterCells(thead, tfoot, type);

             if (rubrosToDisplay.length === 0) {
                tbody.innerHTML=`<tr><td colspan="${thead.querySelector('tr')?.cells.length||expectedHdrCount}" class="text-muted" style="text-align:center;padding:20px;">No hay rubros.</td></tr>`;
                updateCollapsibleTableFooters(scenarioData);
                return;
            }

             rubrosToDisplay.forEach(rubro => {
                 if (!data[type]?.[rubro]?.detailsData || !calculated[type==='gastos'?'gastoAjustado':'ingresoAjustado']?.[rubro] || !calculated[type==='gastos'?'totalGastoRubroMes':'totalIngresoRubroMes']?.[rubro] || calculated.annualTotals?.[type]?.[rubro]===undefined) return;
                 const rubroData = data[type][rubro];
                 const detailsToDisplay = (rubroData.detailOrder?.length>0 ? rubroData.detailOrder : Object.keys(rubroData.detailsData||{})).filter(d => Array.isArray(rubroData.detailsData?.[d])&&rubroData.detailsData[d].length===12 && Array.isArray(calculated[type==='gastos'?'gastoAjustado':'ingresoAjustado'][rubro]?.[d]) && calculated[type==='gastos'?'gastoAjustado':'ingresoAjustado'][rubro][d].length===12);

                 if (detailsToDisplay.length === 0 && Object.keys(data[type][rubro].detailsData).length === 0) {
                    return;
                 }
                 const isCollapsed = appState.settings.rubroConfig?.[rubro]?.detailsCollapsed ?? true;
                 const totalRow = tbody.insertRow(); totalRow.className = `rubro-total-row${isCollapsed?' collapsed':''}`; totalRow.dataset.rubro=rubro; totalRow.dataset.type=type;
                 totalRow.insertCell().textContent = rubro; if(type==='gastos') totalRow.insertCell().textContent = '';
                 (calculated[type==='gastos'?'totalGastoRubroMes':'totalIngresoRubroMes'][rubro]||Array(12).fill(0)).forEach(v=>{const c=totalRow.insertCell();c.textContent=formatCurrency(v);c.classList.add('number-cell');});
                 const cellAnnTotal=totalRow.insertCell(); cellAnnTotal.textContent=formatCurrency(calculated.annualTotals[type][rubro]||0); cellAnnTotal.classList.add('number-cell');
                 const coefName = type==='gastos'?(appState.settings.coefficientTypes[appState.settings.rubroConfig[rubro]?.coefficientType||'None']?.name||'N/A'):'';

                 detailsToDisplay.forEach(detail => {
                     const detailVals = calculated[type==='gastos'?'gastoAjustado':'ingresoAjustado'][rubro][detail];
                     let detailStatuses = Array(12).fill('Estimado');
                     if (monthStatus?.[type]?.[rubro]?.[detail]?.length === 12) {
                         detailStatuses = monthStatus[type][rubro][detail].map(s => String(s || 'Estimado'));
                     }

                     const detailRow=tbody.insertRow(); detailRow.className=`detail-row${isCollapsed?' hidden':''}`; detailRow.dataset.rubro=rubro; detailRow.dataset.type=type;
                     const cellDName=detailRow.insertCell(); cellDName.textContent=detail; cellDName.classList.add('text-muted');
                     if(type==='gastos'){const cCoef=detailRow.insertCell();cCoef.textContent=coefName;cCoef.classList.add('text-muted');}
                     let annualDetTotal=0;
                     detailVals.forEach((val,idx)=>{
                         const c=detailRow.insertCell();
                         c.textContent=formatCurrency(val||0);
                         c.classList.add('number-cell');
                         c.classList.add(detailStatuses[idx]==='REAL'?'real-month-cell':'estimated-month-cell');
                         annualDetTotal+=(val||0);
                     });
                     const cellAnnDet=detailRow.insertCell(); cellAnnDet.textContent=formatCurrency(annualDetTotal); cellAnnDet.classList.add('number-cell');
                 });
             });
             updateCollapsibleTableFooters(scenarioData);
             addCollapsibleListenersExpensas();
        }


        // --- NUEVAS FUNCIONES PARA CASH FLOW UI ---
        function renderCashFlowTabUI(scenarioData) {
            const cfTab = document.getElementById('cashflow');
            if (!cfTab) return;

            // Update rubro management lists for CF
            updateRubroCFList('ingresos');
            updateRubroCFList('egresos');

            const table = document.getElementById('cashflow-table');
            if (!table) return;
            const thead = table.querySelector('thead');
            const tbody = table.querySelector('tbody');
            const tfoot = table.querySelector('tfoot');
            if (!thead || !tbody || !tfoot) return;

            tbody.innerHTML = ''; tfoot.innerHTML = '';

            // Ensure header is correct
            let headerRow = thead.querySelector('tr');
            if (!headerRow || headerRow.cells.length !== (1 + MONTHS.length + 1) ) {
                if(headerRow) headerRow.innerHTML = ''; else headerRow = thead.insertRow();
                headerRow.insertCell().textContent = "Concepto";
                MONTHS.forEach(month => { const th = headerRow.insertCell(); th.textContent = month; th.classList.add('number-cell'); });
                const thTotal = headerRow.insertCell(); thTotal.textContent = "Total Anual"; thTotal.classList.add('number-cell');
            }


            if (!scenarioData || !scenarioData.cashFlow || !scenarioData.cashFlow.calculatedCF) {
                tbody.innerHTML = `<tr><td colspan="${1 + MONTHS.length + 1}" class="text-muted" style="text-align:center;padding:20px;">No hay datos de Cash Flow.</td></tr>`;
                return;
            }

            const cf = scenarioData.cashFlow;
            const calcCF = cf.calculatedCF;
            const settingsCFRubros = appState.settings.rubrosCF;

            // 1. Saldo Inicial Caja/Bancos
            const saldoInicialRow = tbody.insertRow();
            saldoInicialRow.insertCell().textContent = "Saldo Inicial Caja/Bancos";
            for (let i = 0; i < 12; i++) {
                const cell = saldoInicialRow.insertCell();
                cell.classList.add('number-cell', 'input-cell');
                if (i === 0) { // Enero es editable
                    const input = document.createElement('input');
                    input.type = 'number';
                    input.value = parseFloat(cf.saldoInicialCaja[0] || 0).toFixed(0); // Sin decimales para simplicidad inicial
                    input.dataset.month = '0';
                    input.dataset.field = 'saldoInicialCajaEnero';
                    input.classList.add(cf.monthStatusCF.saldoInicialCajaEnero === 'REAL' ? 'real-month-cell' : 'estimated-month-cell');
                    input.addEventListener('change', handleCashFlowInputChange);
                    input.addEventListener('blur', handleCashFlowInputChange); // Para guardar al salir
                    cell.appendChild(input);
                } else {
                    cell.textContent = formatCurrency(cf.saldoInicialCaja[i]);
                    cell.classList.add(calcCF.monthOverallStatusCF[i-1] === 'REAL' ? 'real-month-cell' : 'estimated-month-cell'); // Hereda status del mes anterior
                }
            }
            saldoInicialRow.insertCell().textContent = "-"; // Total anual no aplica directamente

            // Helper function to render CF Rubro Rows
            const renderCFRubroSection = (type, title, rubrosList, dataContainer, statusContainer) => {
                const isCollapsedMaster = cf.calculatedCF.rubroDetailCollapsedCF[`master_${type}`] ?? true;
                const totalCatRow = tbody.insertRow();
                totalCatRow.className = `cf-rubro-total-row${isCollapsedMaster ? ' collapsed' : ''}`;
                totalCatRow.dataset.cftype = type; // Usar 'cftype' para diferenciar del 'type' de expensas
                totalCatRow.dataset.cfcategory = `master_${type}`; // Identificador único para la categoría maestra
                totalCatRow.insertCell().textContent = title;

                const monthlyTotals = type === 'ingresos' ? calcCF.totalOtrosIngresosCFMes : calcCF.totalEgresosCFMes;
                monthlyTotals.forEach(val => {
                    const cell = totalCatRow.insertCell();
                    cell.textContent = formatCurrency(val);
                    cell.classList.add('number-cell');
                });
                const annualTotal = type === 'ingresos' ? calcCF.annualTotalsCF.otrosIngresos : calcCF.annualTotalsCF.egresos;
                const cellAnn = totalCatRow.insertCell();
                cellAnn.textContent = formatCurrency(annualTotal);
                cellAnn.classList.add('number-cell');

                (rubrosList || []).forEach(rubroName => {
                    const detailRow = tbody.insertRow();
                    detailRow.className = `cf-detail-row${isCollapsedMaster ? ' hidden' : ''}`; // Ocultar si la categoría maestra está colapsada
                    detailRow.dataset.cftype = type;
                    detailRow.dataset.cfcategory = `master_${type}`;
                    detailRow.insertCell().textContent = `↳ ${rubroName}`; // Sub-item

                    const rubroValues = dataContainer[rubroName]?.detailsData?.["Valor"] || Array(12).fill(0);
                    const rubroStatuses = statusContainer[rubroName]?.["Valor"] || Array(12).fill('Estimado');
                    let annualRubroTotal = 0;

                    for (let i = 0; i < 12; i++) {
                        const cell = detailRow.insertCell();
                        cell.classList.add('number-cell', 'input-cell');
                        const input = document.createElement('input');
                        input.type = 'number';
                        input.value = parseFloat(rubroValues[i] || 0).toFixed(0);
                        input.dataset.month = i;
                        input.dataset.cftype = type; // 'ingresos' o 'egresos'
                        input.dataset.cfrubro = rubroName;
                        input.classList.add(rubroStatuses[i] === 'REAL' ? 'real-month-cell' : 'estimated-month-cell');
                        input.addEventListener('change', handleCashFlowInputChange);
                        input.addEventListener('blur', handleCashFlowInputChange);
                        cell.appendChild(input);
                        annualRubroTotal += parseFloat(rubroValues[i] || 0);
                    }
                    const cellAnnRubro = detailRow.insertCell();
                    cellAnnRubro.textContent = formatCurrency(annualRubroTotal);
                    cellAnnRubro.classList.add('number-cell');
                });
            };

            // 2. (+) Otros Ingresos Efectivos
            renderCFRubroSection('ingresos', '(+) Otros Ingresos Efectivos', settingsCFRubros.ingresos, cf.rubrosIngresosCFData, cf.monthStatusCF.ingresos);

            // 3. (-) Egresos Efectivos
            renderCFRubroSection('egresos', '(-) Egresos Efectivos', settingsCFRubros.egresos, cf.rubrosEgresosCFData, cf.monthStatusCF.egresos);


            // 4. Flujo Neto del Mes
            const flujoNetoRow = tbody.insertRow();
            flujoNetoRow.className = "category-total-row";
            flujoNetoRow.insertCell().textContent = "(=) Flujo Neto del Mes";
            calcCF.flujoNetoMesCF.forEach(val => {
                const cell = flujoNetoRow.insertCell();
                cell.textContent = formatCurrency(val);
                cell.classList.add('number-cell');
            });
            const cellNetoAnual = flujoNetoRow.insertCell();
            cellNetoAnual.textContent = formatCurrency(calcCF.annualTotalsCF.flujoNeto);
            cellNetoAnual.classList.add('number-cell');

            // 5. Saldo Final Caja/Bancos
            const saldoFinalRow = tbody.insertRow();
            saldoFinalRow.className = "category-total-row";
            saldoFinalRow.insertCell().textContent = "(=) Saldo Final Caja/Bancos";
            calcCF.saldoFinalCajaMes.forEach(val => {
                const cell = saldoFinalRow.insertCell();
                cell.textContent = formatCurrency(val);
                cell.classList.add('number-cell');
            });
            const cellFinalAnual = saldoFinalRow.insertCell();
            // El saldo final anual es el saldo final de Diciembre
            cellFinalAnual.textContent = formatCurrency(calcCF.saldoFinalCajaMes[11]);
            cellFinalAnual.classList.add('number-cell');

            addCollapsibleListenersCF();
        }


        function updateCharts(scenarioData) {
             if (!scenarioData?.calculated?.annualTotals) {
                 destroyChart('evolutivoCuotaChart'); displayChartNoData('evolutivoCuotaChart', true);
                 destroyChart('participacionGastosChart'); displayChartNoData('participacionGastosChart', true);
                 destroyChart('participacionIngresosChart'); displayChartNoData('participacionIngresosChart', true);
                 destroyChart('cashFlowChart'); displayChartNoData('cashFlowChart', true); // Nuevo
                 return;
             }
             const { calculated, cashFlow } = scenarioData;
             const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
             const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim();
             const secondaryColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color').trim();
             const infoColor = getComputedStyle(document.documentElement).getPropertyValue('--info-color').trim();
             const cardBg = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim();
             const chartColors = [primaryColor, accentColor, '#ffc107', '#6f42c1', '#fd7e14', '#17a2b8', '#dc3545', secondaryColor, '#20c997', '#0d6efd', '#198754', '#adb5bd'];

             // Dashboard Charts (Expensas)
             destroyChart('evolutivoCuotaChart'); const ctxEvo = document.getElementById('evolutivoCuotaChart')?.getContext('2d');
             const evoHasData = (calculated.cuotaSobreGastosMes?.some(v=>v!==0)??false) || (calculated.cuotaRealBaseMes?.some(v=>v!==0)??false);
             displayChartNoData('evolutivoCuotaChart', !evoHasData);
             if(ctxEvo && evoHasData) window.evolutivoCuotaChart_instance = new Chart(ctxEvo, { type:'line', data:{labels:MONTHS, datasets:[
                 {label:'Cuota s/Gtos ($)',data:calculated.cuotaSobreGastosMes,borderColor:primaryColor,backgroundColor:hexToRgba(primaryColor,0.1),tension:0.2,fill:true,yAxisID:'yCuota'},
                 {label:'Expensa Real Base ($)',data:calculated.cuotaRealBaseMes,borderColor:accentColor,backgroundColor:hexToRgba(accentColor,0.1),tension:0.2,fill:true,yAxisID:'yCuota'},
                 {label:'Cuota IPC ($)',data:calculated.cuotaIpcMes,borderColor:secondaryColor,backgroundColor:hexToRgba(secondaryColor,0.1),tension:0.2,fill:false,borderDash:[5,5],yAxisID:'yCuota'}
             ]}, options:commonChartOptions('yCuota')});

             destroyChart('participacionGastosChart'); const ctxGastos = document.getElementById('participacionGastosChart')?.getContext('2d');
             const activeGastoRubros = (appState.settings.rubros?.gastos||[]).filter(r=>(calculated.annualTotals?.gastos?.[r]||0)>0);
             const gastoData = activeGastoRubros.map(r=>calculated.annualTotals.gastos[r]); displayChartNoData('participacionGastosChart', gastoData.length===0);
             if(ctxGastos && gastoData.length>0) window.participacionGastosChart_instance = new Chart(ctxGastos, {type:'doughnut',data:{labels:activeGastoRubros, datasets:[{data:gastoData,backgroundColor:generateColors(gastoData.length,chartColors,0.8),borderColor:cardBg,borderWidth:2}]},options:pieChartOptions()});

             destroyChart('participacionIngresosChart'); const ctxIngresos = document.getElementById('participacionIngresosChart')?.getContext('2d');
             const activeIngresoRubros = (appState.settings.rubros?.ingresos||[]).filter(r=>(calculated.annualTotals?.ingresos?.[r]||0)>0);
             const ingresoData = activeIngresoRubros.map(r=>calculated.annualTotals.ingresos[r]); displayChartNoData('participacionIngresosChart', ingresoData.length===0);
             if(ctxIngresos && ingresoData.length>0) window.participacionIngresosChart_instance = new Chart(ctxIngresos, {type:'doughnut',data:{labels:activeIngresoRubros, datasets:[{data:ingresoData,backgroundColor:generateColors(ingresoData.length,chartColors.slice().reverse(),0.8),borderColor:cardBg,borderWidth:2}]},options:pieChartOptions()});

             // Cash Flow Chart
             destroyChart('cashFlowChart'); const ctxCF = document.getElementById('cashFlowChart')?.getContext('2d');
             const cfCalc = cashFlow?.calculatedCF;
             const cfHasData = cfCalc && (cfCalc.saldoInicialCajaMes?.some(v => v !== 0) || cfCalc.saldoFinalCajaMes?.some(v => v !== 0));
             displayChartNoData('cashFlowChart', !cfHasData);
             if (ctxCF && cfHasData) {
                 window.cashFlowChart_instance = new Chart(ctxCF, {
                     type: 'line',
                     data: {
                         labels: MONTHS,
                         datasets: [
                             {
                                 label: 'Saldo Inicial Caja ($)',
                                 data: cashFlow.saldoInicialCaja, // Usar el saldo inicial directo
                                 borderColor: infoColor,
                                 backgroundColor: hexToRgba(infoColor, 0.1),
                                 tension: 0.2,
                                 fill: false,
                                 yAxisID: 'ySaldoCF'
                             },
                             {
                                 label: 'Saldo Final Caja ($)',
                                 data: cfCalc.saldoFinalCajaMes,
                                 borderColor: primaryColor,
                                 backgroundColor: hexToRgba(primaryColor, 0.1),
                                 tension: 0.2,
                                 fill: true,
                                 yAxisID: 'ySaldoCF'
                             }
                         ]
                     },
                     options: commonChartOptions('ySaldoCF')
                 });
             }
        }


        function updateDashboardTables(scenarioData) {
            const summaryTable = document.getElementById('dashboard-summary'); if (!summaryTable) return;
            const tbody = summaryTable.querySelector('tbody'); const tfoot = summaryTable.querySelector('tfoot'); if (!tbody || !tfoot) return;
            tbody.innerHTML = ''; tfoot.innerHTML = '';

            if (!scenarioData?.calculated) {
                tbody.innerHTML = `<tr><td colspan="${summaryTable.querySelector('thead tr')?.cells.length||7}" class="text-muted" style="text-align:center;padding:20px;">No hay datos.</td></tr>`;
                tfoot.innerHTML = '';
                updateCollapsibleTable('gastos', scenarioData);
                updateCollapsibleTable('ingresos', scenarioData);
                return;
            }

            const { calculated } = scenarioData;
            const annuals = calculated.annualTotals || {};
            const monthOverallStatuses = calculated.monthOverallStatus || Array(12).fill('Estimado');

            for (let i = 0; i < 12; i++) {
                const r = tbody.insertRow();
                const overallStatusClass = monthOverallStatuses[i] === 'REAL' ? 'real-month-cell' : 'estimated-month-cell';

                r.insertCell().textContent = MONTHS[i];

                let cell = r.insertCell(); cell.textContent = formatCurrency(calculated.totalGastoProyectadoMes?.[i]||0); cell.classList.add(overallStatusClass, 'number-cell');
                cell = r.insertCell(); cell.textContent = formatCurrency(calculated.fondoReservaMes?.[i]||0); cell.classList.add(overallStatusClass, 'number-cell');
                cell = r.insertCell(); cell.textContent = formatCurrency(calculated.cuotaSobreGastosMes?.[i]||0); cell.classList.add(overallStatusClass, 'number-cell');

                r.insertCell().textContent = `${(calculated.ipcManual?.[i]||0).toFixed(1)}%`;

                cell = r.insertCell(); cell.textContent = formatCurrency(calculated.cuotaIpcMes?.[i]||0); cell.classList.add(overallStatusClass, 'number-cell');
                cell = r.insertCell(); cell.textContent = formatCurrency(calculated.cuotaRealBaseMes?.[i]||0); cell.classList.add(overallStatusClass, 'number-cell');
            }

            const fr = tfoot.insertRow();
            fr.insertCell().textContent="TOTAL ANUAL"; fr.cells[0].style.fontWeight="bold";
            fr.insertCell().textContent=formatCurrency(annuals.gastos?.__TOTAL__||0); fr.cells[1].style.fontWeight="bold";fr.cells[1].classList.add('number-cell');
            fr.insertCell().textContent=formatCurrency(annuals.fondoReserva||0); fr.cells[2].style.fontWeight="bold";fr.cells[2].classList.add('number-cell');
            fr.insertCell().textContent=formatCurrency(annuals.cuotaSobreGastos||0); fr.cells[3].style.fontWeight="bold";fr.cells[3].classList.add('number-cell');
            fr.insertCell().textContent="-";
            fr.insertCell().textContent=formatCurrency(annuals.cuotaIpc||0); fr.cells[5].style.fontWeight="bold";fr.cells[5].classList.add('number-cell');
            fr.insertCell().textContent=formatCurrency(annuals.cuotaRealBase||0); fr.cells[6].style.fontWeight="bold";fr.cells[6].classList.add('number-cell');

            updateCollapsibleTable('gastos', scenarioData);
            updateCollapsibleTable('ingresos', scenarioData);
        }

        
// --- Resultado Operativo ---
function updateOperatingResult(scenarioData){
    const card = document.getElementById('operating-result-card');
    const table = document.getElementById('operating-result-table');
    if(!card || !table || !scenarioData || !scenarioData.calculated){
        if(card) card.style.display = 'none';
        return;
    }
    const calc = scenarioData.calculated;
    const gastos = calc.totalGastoProyectadoMes || [];
    const ingresos = calc.totalIngresoProyectadoMes || [];
    if(gastos.length !== 12 || ingresos.length !== 12){
        card.style.display = 'none';
        return;
    }
    const MONTHS = ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'];
    const thead = table.querySelector('thead tr');
    const tbody = table.querySelector('tbody');
    const tfootRow = table.querySelector('tfoot tr');

    // Header
    if(thead.cells.length < 13){
        while(thead.cells.length > 1) thead.deleteCell(1);
        MONTHS.forEach(m => {
            const th = document.createElement('th');
            th.textContent = m;
            th.classList.add('number-cell');
            thead.appendChild(th);
        });
    }
    // Body (single row)
    tbody.innerHTML = '';
    const row = tbody.insertRow();
    row.insertCell().textContent = 'Resultado operativo ($)';
    let totalAnual = 0;
    for(let i=0;i<12;i++){
        const diff = (ingresos[i] || 0) - (gastos[i] || 0);
        totalAnual += diff;
        const cell = row.insertCell();
        cell.textContent = formatCurrency(diff);
        cell.classList.add('number-cell');
        cell.classList.add(diff >= 0 ? 'operating-result-positive' : 'operating-result-negative');
        const status = getMonthOverallStatus ? getMonthOverallStatus(i, scenarioData) : 'ESTIMADO';
        cell.classList.add(status === 'REAL' ? 'real-month-cell' : 'estimated-month-cell');
    }
    // Footer
    tfootRow.innerHTML = '';
    const labelCell = tfootRow.insertCell();
    labelCell.textContent = 'TOTAL ANUAL';
    const totalCell = tfootRow.insertCell();
    totalCell.colSpan = 12;
    totalCell.textContent = formatCurrency(totalAnual);
    totalCell.classList.add('number-cell');
    totalCell.classList.add(totalAnual >= 0 ? 'operating-result-positive' : 'operating-result-negative');

    card.style.display = 'block';
}

        
// --- Resultado Operativo (Ingresos - Gastos) ---
function updateOperatingResult(scenarioData){
    const card = document.getElementById('operating-result-card');
    const table = document.getElementById('operating-result-table');
    if(!card || !table || !scenarioData || !scenarioData.calculated){
        if(card) card.style.display = 'none';
        return;
    }
    const calc = scenarioData.calculated;
    const gastos = calc.totalGastoProyectadoMes || [];
    const ingresos = calc.totalIngresoProyectadoMes || [];
    if(gastos.length !== 12 || ingresos.length !== 12){
        card.style.display = 'none';
        return;
    }
    const MONTHS = ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'];
    const thead = table.querySelector('thead tr');
    const tbody = table.querySelector('tbody');
    const tfootRow = table.querySelector('tfoot tr');

    // Header
    if(thead.cells.length < 13){
        while(thead.cells.length > 1) thead.deleteCell(1);
        MONTHS.forEach(m => {
            const th = document.createElement('th');
            th.textContent = m;
            th.classList.add('number-cell');
            thead.appendChild(th);
        });
    }

    // Clear body
    tbody.innerHTML = '';
    // ----- Row Total Ingresos -----
    const rowIng = tbody.insertRow();
    rowIng.insertCell().textContent = 'Total Ingresos ($)';
    let totalIngAnual = 0;
    for(let i=0;i<12;i++){
        const val = ingresos[i] || 0;
        totalIngAnual += val;
        const cell = rowIng.insertCell();
        cell.textContent = formatCurrency(val);
        cell.classList.add('number-cell');
        const st = getMonthOverallStatus ? getMonthOverallStatus(i, scenarioData) : 'ESTIMADO';
        cell.classList.add(st === 'REAL' ? 'real-month-cell' : 'estimated-month-cell');
    }

    // ----- Row Total Gastos -----
    const rowGas = tbody.insertRow();
    rowGas.insertCell().textContent = 'Total Gastos ($)';
    let totalGasAnual = 0;
    for(let i=0;i<12;i++){
        const val = gastos[i] || 0;
        totalGasAnual += val;
        const cell = rowGas.insertCell();
        cell.textContent = formatCurrency(val);
        cell.classList.add('number-cell');
        const st = getMonthOverallStatus ? getMonthOverallStatus(i, scenarioData) : 'ESTIMADO';
        cell.classList.add(st === 'REAL' ? 'real-month-cell' : 'estimated-month-cell');
    }

    // ----- Row Resultado Operativo -----
    const rowRes = tbody.insertRow();
    rowRes.insertCell().textContent = 'Resultado operativo ($)';
    let totalResAnual = 0;
    for(let i=0;i<12;i++){
        const diff = (ingresos[i] || 0) - (gastos[i] || 0);
        totalResAnual += diff;
        const cell = rowRes.insertCell();
        cell.textContent = formatCurrency(diff);
        cell.classList.add('number-cell');
        cell.classList.add(diff >= 0 ? 'operating-result-positive' : 'operating-result-negative');
        const st = getMonthOverallStatus ? getMonthOverallStatus(i, scenarioData) : 'ESTIMADO';
        cell.classList.add(st === 'REAL' ? 'real-month-cell' : 'estimated-month-cell');
    }

    // Footer
    tfootRow.innerHTML = '';
    tfootRow.insertCell().textContent = 'TOTAL ANUAL';
    const totalIngCell = tfootRow.insertCell();
    totalIngCell.textContent = formatCurrency(totalIngAnual);
    totalIngCell.classList.add('number-cell');
    const totalGasCell = tfootRow.insertCell();
    totalGasCell.textContent = formatCurrency(totalGasAnual);
    totalGasCell.classList.add('number-cell');
    const totalResCell = tfootRow.insertCell();
    totalResCell.textContent = formatCurrency(totalResAnual);
    totalResCell.classList.add('number-cell');
    totalResCell.classList.add(totalResAnual >= 0 ? 'operating-result-positive' : 'operating-result-negative');
    totalResCell.colSpan = 10; // extend across remaining columns

    card.style.display = 'block';
}

        
// --- Resultado Operativo (Ingresos - Gastos) + Acumulado ---
function updateOperatingResult(scenarioData){
    const card = document.getElementById('operating-result-card');
    const table = document.getElementById('operating-result-table');
    if(!card || !table || !scenarioData || !scenarioData.calculated){
        if(card) card.style.display = 'none';
        return;
    }
    const calc = scenarioData.calculated;
    const gastos = calc.totalGastoProyectadoMes || [];
    const ingresos = calc.totalIngresoProyectadoMes || [];
    if(gastos.length !== 12 || ingresos.length !== 12){
        card.style.display = 'none';
        return;
    }
    const MONTHS = ['Ene','Feb','Mar','Abr','May','Jun','Jul','Ago','Sep','Oct','Nov','Dic'];
    const thead = table.querySelector('thead tr');
    const tbody = table.querySelector('tbody');

    // Build header
    if(thead.cells.length < 13){
        while(thead.cells.length > 1) thead.deleteCell(1);
        MONTHS.forEach(m=>{
            const th = document.createElement('th');
            th.textContent = m;
            th.classList.add('number-cell');
            thead.appendChild(th);
        });
    }

    tbody.innerHTML='';
    let totalIngAnual=0,totalGasAnual=0,totalResAnual=0;

    // Row Ingresos
    const rowIng=tbody.insertRow();
    rowIng.insertCell().textContent='Total Ingresos ($)';
    for(let i=0;i<12;i++){
        const val=ingresos[i]||0;
        totalIngAnual+=val;
        const cell=rowIng.insertCell();
        cell.textContent=formatCurrency(val);
        cell.classList.add('number-cell');
        const st=getMonthOverallStatus?getMonthOverallStatus(i,scenarioData):'ESTIMADO';
        cell.classList.add(st==='REAL'?'real-month-cell':'estimated-month-cell');
    }

    // Row Gastos
    const rowGas=tbody.insertRow();
    rowGas.insertCell().textContent='Total Gastos ($)';
    for(let i=0;i<12;i++){
        const val=gastos[i]||0;
        totalGasAnual+=val;
        const cell=rowGas.insertCell();
        cell.textContent=formatCurrency(val);
        cell.classList.add('number-cell');
        const st=getMonthOverallStatus?getMonthOverallStatus(i,scenarioData):'ESTIMADO';
        cell.classList.add(st==='REAL'?'real-month-cell':'estimated-month-cell');
    }

    // Row Resultado Operativo
    const rowRes=tbody.insertRow();
    rowRes.insertCell().textContent='Resultado operativo ($)';
    const diffArray=[];
    for(let i=0;i<12;i++){
        const diff=(ingresos[i]||0)-(gastos[i]||0);
        diffArray.push(diff);
        totalResAnual+=diff;
        const cell=rowRes.insertCell();
        cell.textContent=formatCurrency(diff);
        cell.classList.add('number-cell');
        const st=getMonthOverallStatus?getMonthOverallStatus(i,scenarioData):'ESTIMADO';
        if(diff<0){
            cell.classList.add(st==='REAL'?'operating-result-negative':'operating-result-negative-estimated');
        }else{
            cell.classList.add('operating-result-positive');
        }
        cell.classList.add(st==='REAL'?'real-month-cell':'estimated-month-cell');
    }

    // Row Resultado acumulado
    const rowCum=tbody.insertRow();
    rowCum.insertCell().textContent='Resultado anual acumulado ($)';
    let cumulative=0;
    for(let i=0;i<12;i++){
        cumulative+=diffArray[i];
        const cell=rowCum.insertCell();
        cell.textContent=formatCurrency(cumulative);
        cell.classList.add('number-cell');
        const st=getMonthOverallStatus?getMonthOverallStatus(i,scenarioData):'ESTIMADO';
        if(cumulative<0){
            cell.classList.add(st==='REAL'?'operating-result-negative':'operating-result-negative-estimated');
        }else{
            cell.classList.add('operating-result-positive');
        }
        cell.classList.add(st==='REAL'?'real-month-cell':'estimated-month-cell');
    }

    card.style.display='block';
}

        function updateScenarioSelector() {
            const selector = document.getElementById('scenario-selector'); if (!selector) return;
            const prevVal = selector.value; selector.innerHTML = '';
            const scenariosForYear = Object.keys(appState.scenarios||{}).filter(k=>appState.scenarios[k]?.year===appState.currentYear).sort((a,b)=>(appState.scenarios[a]?.scenarioName||a).localeCompare(appState.scenarios[b]?.scenarioName||b));
            if(scenariosForYear.length===0){const o=document.createElement('option');o.value="";o.textContent="No hay escenarios";o.disabled=true;selector.appendChild(o);selector.value="";}
            else { scenariosForYear.forEach(k=>{if(appState.scenarios[k]){const o=document.createElement('option');o.value=k;o.textContent=`${appState.scenarios[k].scenarioName} (${appState.scenarios[k].year})`;selector.appendChild(o);}});
                if(appState.activeScenarioKey && scenariosForYear.includes(appState.activeScenarioKey)) selector.value = appState.activeScenarioKey;
                else if(scenariosForYear.includes(prevVal)) selector.value = prevVal;
                else selector.value = scenariosForYear.includes(`${appState.currentYear}_Base`) ? `${appState.currentYear}_Base` : scenariosForYear[0];
            }
            if(appState.activeScenarioKey && selector.value!==appState.activeScenarioKey && scenariosForYear.includes(appState.activeScenarioKey)) selector.value = appState.activeScenarioKey;
        }

        function updateCurrentYearAndScenarioInUI() {
            const scenario = getCurrentScenarioData();
            const year = scenario ? scenario.year : (appState.currentYear || new Date().getFullYear());
            const name = scenario ? scenario.scenarioName : "Ninguno";
            document.getElementById('dashboard-year').textContent = year; document.getElementById('dashboard-scenario').textContent = name;
            document.querySelectorAll('.current-year').forEach(s=>s.textContent=year); document.querySelectorAll('.current-scenario').forEach(s=>s.textContent=name);
        }

        function updateReportsPanel() {
             const reportsDiv = document.getElementById('reports'); if (!reportsDiv) return;
             const scenario = getCurrentScenarioData();
             let hasExpensasData = scenario?.calculated && ((scenario.calculated.totalGastoProyectadoMes?.some(v=>(v||0)!==0)??false) || (scenario.calculated.totalIngresoProyectadoMes?.some(v=>(v||0)!==0)??false) || (scenario.calculated.cuotaRealBaseMes?.some(v=>(v||0)!==0)??false));
             let hasCashFlowData = scenario?.cashFlow?.calculatedCF && (scenario.cashFlow.calculatedCF.saldoInicialCajaMes?.some(v => (v || 0) !== 0) || scenario.cashFlow.calculatedCF.totalOtrosIngresosCFMes?.some(v => (v || 0) !== 0) || scenario.cashFlow.calculatedCF.totalEgresosCFMes?.some(v => (v || 0) !== 0));

             const disable = !scenario || (!hasExpensasData && !hasCashFlowData) ;
             reportsDiv.querySelectorAll('button').forEach(btn => {
                if (btn.id === 'exportChartCashFlow') { // Example if we had a specific button for CF chart
                    btn.disabled = !hasCashFlowData;
                    btn.classList.toggle('disabled', !hasCashFlowData);
                } else {
                    btn.disabled = disable;
                    btn.classList.toggle('disabled', disable);
                }
             });
        }


        function renderEmptyState() {
            const sumTable = document.getElementById('dashboard-summary');
            if(sumTable) { sumTable.querySelector('tbody').innerHTML = `<tr><td colspan="${sumTable.querySelector('thead tr')?.cells.length||7}" class="text-muted" style="text-align:center;padding:20px;">No hay datos.</td></tr>`; sumTable.querySelector('tfoot').innerHTML=''; }
            ['gastos','ingresos'].forEach(type=>{ const t=document.getElementById(`${type}-detail-table`); if(t){t.querySelector('tbody').innerHTML=`<tr><td colspan="${t.querySelector('thead tr')?.cells.length||(type==='gastos'?16:15)}" class="text-muted" style="text-align:center;padding:20px;">No hay datos.</td></tr>`; t.querySelector('tfoot').innerHTML='';}});
            destroyChart('evolutivoCuotaChart'); displayChartNoData('evolutivoCuotaChart', true);
            destroyChart('participacionGastosChart'); displayChartNoData('participacionGastosChart', true);
            destroyChart('participacionIngresosChart'); displayChartNoData('participacionIngresosChart', true);
            destroyChart('cashFlowChart'); displayChartNoData('cashFlowChart', true);

            document.getElementById('coefficient-values-editor').innerHTML = '<p class="text-muted">Selecciona un tipo para editar.</p>';
            document.getElementById('editing-coefficient-name').textContent = 'Ninguno';
            document.getElementById('ipc-editor-note').style.display = 'none';
            if(appState.uiState) appState.uiState.editingCoefficientType = null;
            const pRadio=document.getElementById('reserve-type-percent'); const fRadio=document.getElementById('reserve-type-fixed');
            if(pRadio && fRadio) { const defType=(getDefaultAppState().BaseScenarioStructureTemplate.reserveFund || {}).type || 'percent'; pRadio.checked=((getCurrentScenarioData()?.reserveFund?.type) ?? defType)==='percent';fRadio.checked=!pRadio.checked; updateReserveUI(); }

            renderCashFlowTabUI(null); // Render empty state for CF tab
            updateSettingsPanel(); updateReportsPanel();
        }

        // --- UI Orchestration ---
        function updateUI() {
             const scenarioData = getCurrentScenarioData();
             if (!scenarioData) { renderEmptyState(); updateCurrentYearAndScenarioInUI(); updateScenarioSelector(); return; }
             updateCurrentYearAndScenarioInUI(); updateScenarioSelector();
             updateDashboardTables(scenarioData);
            updateOperatingResult(scenarioData);
             renderCashFlowTabUI(scenarioData); // NUEVO para CF
             updateCharts(scenarioData); // updateCharts ahora maneja el gráfico de CF
             updateReserveFundPanel(scenarioData); updateSettingsPanel(); updateReportsPanel();
        }

        function initUI() {
             document.getElementById('exercise-year')?.setAttribute('value', appState.currentYear || new Date().getFullYear());
             const footerYearEl = document.getElementById('footer-year');
             if(footerYearEl) footerYearEl.textContent = new Date().getFullYear();
             updateScenarioSelector(); updateCurrentYearAndScenarioInUI();
             const chatbotIcon = document.getElementById('chatbot-icon');
             if (chatbotIcon) {
                chatbotIcon.style.display = getCurrentScenarioData() ? 'flex' : 'none';
             }
        }

        // --- Tema ---
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia?.('(prefers-color-scheme: dark)')?.matches ?? false;
            appState.darkMode = (savedTheme === 'dark') || (!savedTheme && prefersDark);
            if (window.matchMedia) {
                 window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                    if (!localStorage.getItem('theme')) { appState.darkMode = event.matches; applyTheme(true); saveState(); }
                 });
            }
            applyTheme(false);
        }

        function toggleTheme() {
            appState.darkMode = !appState.darkMode;
            localStorage.setItem('theme', appState.darkMode ? 'dark' : 'light');
            applyTheme(true);
            saveState();
        }

        function applyTheme(updateChartsUI = true){
            document.body.classList.toggle('dark-mode', appState.darkMode);
            const toggleButton = document.getElementById('theme-toggle');
            if (toggleButton) {
                 toggleButton.innerHTML = appState.darkMode ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
                 toggleButton.title = appState.darkMode ? 'Cambiar a tema claro' : 'Cambiar a tema oscuro';
            }
            if (updateChartsUI) {
                 requestAnimationFrame(() => {
                     Chart.defaults.color = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
                     ['evolutivoCuotaChart', 'participacionGastosChart', 'participacionIngresosChart', 'cashFlowChart'].forEach(id => { // Añadido cashFlowChart
                          if (window[`${id}_instance`]) window[`${id}_instance`].update();
                     });
                 });
            }
        }

        // --- Manejo de Eventos y Acciones del Usuario (Main App) ---
        function openTab(evt, tabName) {
             if(!tabName)return; Array.from(document.getElementsByClassName("tab-content")).forEach(tc=>{tc.classList.remove("active");tc.style.display="none";});
             Array.from(document.getElementsByClassName("tab-link")).forEach(tl=>tl.classList.remove("active"));
             const tab=document.getElementById(tabName); if(tab){tab.style.display="block";void tab.offsetWidth;tab.classList.add("active");}
             if(evt?.currentTarget) evt.currentTarget.classList.add("active");
             const chartsToResize = ['evolutivoCuotaChart','participacionGastosChart','participacionIngresosChart', 'cashFlowChart'];
             if(chartsToResize.some(chartId => tabName === document.getElementById(chartId)?.closest('.tab-content')?.id || (tabName === 'dashboard' && (chartId.includes('Cuota') || chartId.includes('Participacion'))) || (tabName === 'cashflow' && chartId === 'cashFlowChart'))) {
                  requestAnimationFrame(()=>{ chartsToResize.forEach(id=>{if(window[`${id}_instance`])window[`${id}_instance`].resize();}); });
             }
         }

        function preventDefaults(e){ e.preventDefault(); e.stopPropagation(); }

        let collapsibleListenersExpensasAdded = false;
        function addCollapsibleListenersExpensas() { // Para tablas de Dashboard (Gastos/Ingresos Expensas)
             const container = document.getElementById('dashboard');
             if(!container || collapsibleListenersExpensasAdded) return;
             container.addEventListener('click', (event) => {
                 const targetRow = event.target.closest('tr.rubro-total-row');
                 if (targetRow && (targetRow.closest('#gastos-detail-table') || targetRow.closest('#ingresos-detail-table'))) {
                     const rubro = targetRow.dataset.rubro; const type = targetRow.dataset.type;
                     if(rubro && type) toggleRubroDetails(type, rubro);
                 }
             });
             collapsibleListenersExpensasAdded = true;
        }

        let collapsibleListenersCFAdded = false;
        function addCollapsibleListenersCF() { // Para tabla de Cash Flow
            const containerCF = document.getElementById('cashflow-table');
            if(!containerCF || collapsibleListenersCFAdded) return;
            containerCF.addEventListener('click', (event) => {
                const targetRow = event.target.closest('tr.cf-rubro-total-row');
                if (targetRow) {
                    const cfType = targetRow.dataset.cftype; // ej: "ingresos" o "egresos"
                    const cfCategory = targetRow.dataset.cfcategory; // ej: "master_ingresos"
                    if (cfType && cfCategory) toggleRubroDetailsCF(cfType, cfCategory);
                }
            });
            collapsibleListenersCFAdded = true;
        }

        function toggleRubroDetails(type, rubro) { // Para Expensas
              appState.settings.rubroConfig = appState.settings.rubroConfig ?? {};
              appState.settings.rubroConfig[rubro] = appState.settings.rubroConfig[rubro] ?? { detailsCollapsed: true };
              if(appState.settings.rubroConfig[rubro].detailsCollapsed===undefined) appState.settings.rubroConfig[rubro].detailsCollapsed=true;
             const newState = !appState.settings.rubroConfig[rubro].detailsCollapsed; appState.settings.rubroConfig[rubro].detailsCollapsed = newState;
             const totalRow = document.querySelector(`#${type}-detail-table tr.rubro-total-row[data-rubro="${rubro}"][data-type="${type}"]`); if(!totalRow){saveState();return;}
             totalRow.classList.toggle('collapsed', newState);
             let nextSib = totalRow.nextElementSibling;
             while(nextSib){ if(nextSib.classList.contains('detail-row') && nextSib.dataset.rubro===rubro && nextSib.dataset.type===type){ nextSib.classList.toggle('hidden',newState); nextSib=nextSib.nextElementSibling; } else break; }
             saveState();
        }

        function toggleRubroDetailsCF(cfTypeOrCategory, isCategoryMaster) { // Para Cash Flow
            const scenario = getCurrentScenarioData();
            if (!scenario || !scenario.cashFlow || !scenario.cashFlow.calculatedCF) return;

            let categoryKey, collapse;
            if (typeof isCategoryMaster === 'boolean') { // Llamada desde botones Expandir/Colapsar Todo CF
                categoryKey = cfTypeOrCategory; // Será "master_ingresos" o "master_egresos"
                collapse = isCategoryMaster; // true para colapsar, false para expandir
                scenario.cashFlow.calculatedCF.rubroDetailCollapsedCF[categoryKey] = collapse;
            } else { // Llamada desde clic en fila
                const type = cfTypeOrCategory; // Será "ingresos" o "egresos"
                categoryKey = `master_${type}`;
                scenario.cashFlow.calculatedCF.rubroDetailCollapsedCF[categoryKey] = !(scenario.cashFlow.calculatedCF.rubroDetailCollapsedCF[categoryKey] ?? true);
                collapse = scenario.cashFlow.calculatedCF.rubroDetailCollapsedCF[categoryKey];
            }

            const totalRow = document.querySelector(`#cashflow-table tr.cf-rubro-total-row[data-cfcategory="${categoryKey}"]`);
            if (!totalRow) { saveState(); return; }

            totalRow.classList.toggle('collapsed', collapse);
            let nextSib = totalRow.nextElementSibling;
            while (nextSib) {
                if (nextSib.classList.contains('cf-detail-row') && nextSib.dataset.cfcategory === categoryKey) {
                    nextSib.classList.toggle('hidden', collapse);
                    nextSib = nextSib.nextElementSibling;
                } else {
                    break;
                }
            }
            saveState();
        }

        function toggleAllRubroDetails(type, collapse) { // Para Expensas
             const table = document.getElementById(`${type}-detail-table`); if(!table?.querySelector('tbody'))return;
             const totalRows = table.querySelectorAll('tbody tr.rubro-total-row'); if(totalRows.length===0){showSnackbar(`No hay rubros de ${type}.`,false,'info');return;}
             let changesMade=false;
             totalRows.forEach(totalRow => {
                  const rubro = totalRow.dataset.rubro; const rowType = totalRow.dataset.type; if(!rubro||rowType!==type)return;
                  appState.settings.rubroConfig = appState.settings.rubroConfig ?? {}; appState.settings.rubroConfig[rubro] = appState.settings.rubroConfig[rubro] ?? { detailsCollapsed: true };
                  if(appState.settings.rubroConfig[rubro].detailsCollapsed !== collapse){ appState.settings.rubroConfig[rubro].detailsCollapsed = collapse; changesMade=true; totalRow.classList.toggle('collapsed',collapse);
                      let nextSib = totalRow.nextElementSibling; while(nextSib){if(nextSib.classList.contains('detail-row')&&nextSib.dataset.rubro===rubro&&nextSib.dataset.type===type){nextSib.classList.toggle('hidden',collapse);nextSib=nextSib.nextElementSibling;}else break;}}
             });
             if(changesMade){saveState();showSnackbar(`Detalles ${collapse?'colapsados':'expandidos'}.`,false,'info');} else showSnackbar(`Detalles ya ${collapse?'colapsados':'expandidos'}.`,false,'info');
         }

        function toggleAllRubroDetailsCF(collapse) { // Para Cash Flow
            const scenario = getCurrentScenarioData();
            if (!scenario || !scenario.cashFlow || !scenario.cashFlow.calculatedCF) {
                showSnackbar("No hay datos de Cash Flow para expandir/colapsar.", false, 'info');
                return;
            }
            let changesMade = false;
            ['ingresos', 'egresos'].forEach(cfType => {
                const categoryKey = `master_${cfType}`;
                if ((scenario.cashFlow.calculatedCF.rubroDetailCollapsedCF[categoryKey] ?? true) !== collapse) {
                    toggleRubroDetailsCF(categoryKey, collapse); // Llama con (categoryKey, collapseState)
                    changesMade = true;
                }
            });

            if (changesMade) {
                showSnackbar(`Rubros de Cash Flow ${collapse ? 'colapsados' : 'expandidos'}.`, false, 'info');
            } else {
                showSnackbar(`Rubros de Cash Flow ya ${collapse ? 'colapsados' : 'expandidos'}.`, false, 'info');
            }
        }


        function handleCoefficientAssignmentChange(event) {
             const select = event.target; const rubro = select.dataset.rubro; const newCoefType = select.value;
             if (rubro && newCoefType !== undefined && appState.settings.rubroConfig) {
                 appState.settings.rubroConfig[rubro] = appState.settings.rubroConfig[rubro] ?? {};
                 appState.settings.rubroConfig[rubro].coefficientType = newCoefType; saveState();
                 showSnackbar(`Coeficiente para "${rubro}" asignado. Guarda configuración para recalcular.`, false, 'info');
             } else showSnackbar("Error al asignar coeficiente.", true, 'error');
         }

        function handleCoefficientValueChange(event) {
             const input=event.target; const monthIdx=parseInt(input.dataset.month); const typeKey=input.dataset.typeKey; const value=parseFloat(input.value);
             const typeData=appState.settings.coefficientTypes?.[typeKey];
             if(!typeKey||!typeData||isNaN(monthIdx)||monthIdx<0||monthIdx>11){ input.value=typeData?.values?.[monthIdx]||0; showSnackbar("Error: Coeficiente/mes inválido.",true,'error'); return;}

             if (typeKey === 'None' || typeKey === 'IPC') {
                 input.value = typeData.values[monthIdx] || 0;
                 showSnackbar(`"${typeData.name}" no se edita aquí.`, false, 'warning');
                 return;
             }

             const isValid = !isNaN(value) && value >= -100;
             if(isValid){
                if(!Array.isArray(typeData.values)||typeData.values.length!==12) typeData.values=Array(12).fill(0);
                typeData.values[monthIdx]=value;
                saveState(); // Guardar el cambio en el valor del coeficiente directamente. "Guardar Configuración" recalculará.
             }
             else { input.value=typeData.values[monthIdx]||0; showSnackbar(`Valor inválido para ${FULL_MONTHS[monthIdx]}. Debe ser >= -100.`,true,'error'); }
         }

        // --- Funciones para Rubros de Expensas ---
        function addRubro(type) {
            const inputId = type === 'gastos' ? 'new-gasto-rubro-name' : 'new-ingreso-rubro-name';
            const inputElement = document.getElementById(inputId); if (!inputElement) return;
            const rubroName = inputElement.value.trim();
            if (!rubroName) { showSnackbar("El nombre del rubro no puede estar vacío.", true, 'error'); return; }
            appState.settings.rubros[type] = appState.settings.rubros[type] || [];
            if (appState.settings.rubros[type].includes(rubroName)) { showSnackbar(`El rubro "${rubroName}" ya existe.`, true, 'warning'); return; }
            appState.settings.rubros[type].push(rubroName);
            appState.settings.rubroConfig[rubroName] = appState.settings.rubroConfig[rubroName] || { coefficientType: 'None', detailsCollapsed: true };
            inputElement.value = '';
            updateRubroList(type, type === 'gastos' ? 'gasto-rubro-list' : 'ingreso-rubro-list');
            showSnackbar(`Rubro "${rubroName}" añadido. Guarda la configuración para aplicar.`, false, 'info');
        }

        function removeRubro(type, rubroName) {
            if (!confirm(`¿Eliminar el rubro de expensas "${rubroName}"? Esto podría afectar datos existentes si no se guarda la configuración.`)) return;
            appState.settings.rubros[type] = (appState.settings.rubros[type] || []).filter(r => r !== rubroName);
            // No se elimina de rubroConfig aquí, se limpiará al guardar/recalcular si es necesario.
            updateRubroList(type, type === 'gastos' ? 'gasto-rubro-list' : 'ingreso-rubro-list');
            showSnackbar(`Rubro "${rubroName}" eliminado de la lista. Guarda la configuración.`, false, 'info');
        }

        // --- Funciones para Rubros de Cash Flow ---
        function addRubroCF(type) { // type es 'ingresos' o 'egresos'
            const inputId = `new-cf-${type === 'ingresos' ? 'ingreso' : 'egreso'}-rubro-name`;
            const inputElement = document.getElementById(inputId);
            if (!inputElement) return;
            const rubroName = inputElement.value.trim();

            if (!rubroName) {
                showSnackbar("El nombre del rubro de Cash Flow no puede estar vacío.", true, 'error');
                return;
            }
            appState.settings.rubrosCF[type] = appState.settings.rubrosCF[type] || [];
            if (appState.settings.rubrosCF[type].includes(rubroName)) {
                showSnackbar(`El rubro de Cash Flow "${rubroName}" ya existe en ${type}.`, true, 'warning');
                return;
            }
            appState.settings.rubrosCF[type].push(rubroName);
            inputElement.value = '';
            updateRubroCFList(type);
            // No se recalcula aquí, se hará al "Guardar Rubros CF"
            showSnackbar(`Rubro de CF "${rubroName}" añadido. Guarda los rubros CF para aplicar los cambios.`, false, 'info');
        }

        function removeRubroCF(type, rubroName) {
            if (!confirm(`¿Eliminar el rubro de Cash Flow "${rubroName}"? Se perderán los datos asociados a este rubro en el escenario actual si guardas.`)) return;
            appState.settings.rubrosCF[type] = (appState.settings.rubrosCF[type] || []).filter(r => r !== rubroName);
            updateRubroCFList(type);
            showSnackbar(`Rubro de CF "${rubroName}" eliminado de la lista. Guarda los rubros CF para aplicar los cambios.`, false, 'info');
        }

        function saveRubrosCF() {
            const scenario = getCurrentScenarioData();
            if (!scenario) {
                showSnackbar("No hay escenario activo para aplicar los cambios de rubros CF.", true, 'error');
                return;
            }
            // La actualización de appState.settings.rubrosCF ya se hizo con add/remove.
            // Ahora, hay que asegurarse de que scenarioData.cashFlow.rubrosIngresosCFData, etc. estén sincronizados.
            initializeScenarioDataForRubros(scenario); // Esto limpiará/creará datos para los rubros CF actuales en settings.
            calculateAll(scenario); // Recalcular todo, incluyendo el cash flow.
            showSnackbar("Rubros de Cash Flow guardados y aplicados al escenario actual.", false, 'success');
        }

        function handleCashFlowInputChange(event) {
            const input = event.target;
            const monthIndex = parseInt(input.dataset.month);
            const fieldType = input.dataset.field; // "saldoInicialCajaEnero"
            const cfType = input.dataset.cftype; // "ingresos" o "egresos"
            const cfRubro = input.dataset.cfrubro; // nombre del rubro CF
            let value = parseFloat(input.value);

            const scenario = getCurrentScenarioData();
            if (!scenario) return;

            const isNumeric = !isNaN(value) && isFinite(value);
            value = isNumeric ? value : 0; // Default to 0 if not valid number

            let statusToSet = isNumeric ? 'REAL' : 'Estimado';
            input.classList.remove('real-month-cell', 'estimated-month-cell');
            input.classList.add(statusToSet === 'REAL' ? 'real-month-cell' : 'estimated-month-cell');


            if (fieldType === 'saldoInicialCajaEnero' && monthIndex === 0) {
                scenario.cashFlow.saldoInicialCaja[0] = value;
                scenario.cashFlow.monthStatusCF.saldoInicialCajaEnero = statusToSet;
            } else if (cfType && cfRubro && monthIndex >= 0 && monthIndex < 12) {
                const dataContainer = cfType === 'ingresos' ? scenario.cashFlow.rubrosIngresosCFData : scenario.cashFlow.rubrosEgresosCFData;
                const statusContainer = cfType === 'ingresos' ? scenario.cashFlow.monthStatusCF.ingresos : scenario.cashFlow.monthStatusCF.egresos;

                if (dataContainer[cfRubro] && dataContainer[cfRubro].detailsData["Valor"]) {
                    dataContainer[cfRubro].detailsData["Valor"][monthIndex] = value;
                }
                if (statusContainer[cfRubro] && statusContainer[cfRubro]["Valor"]) {
                    statusContainer[cfRubro]["Valor"][monthIndex] = statusToSet;
                }
            } else {
                return; // No valid field to update
            }

            // Recalcular solo si el evento es 'change' (no en cada 'blur' si no hubo cambio)
            // O si es 'blur' y el valor realmente cambió (difícil de rastrear sin estado previo aquí)
            // Por simplicidad, recalculamos en 'change' y en 'blur'. Podría optimizarse.
            if (event.type === 'change' || event.type === 'blur') { // Recalcular
                 // Para 'blur', el valor podría no haber cambiado si solo se hizo clic fuera.
                 // Sin embargo, el estado REAL/ESTIMADO podría haber cambiado si se borró un número.
                calculateAll(scenario); // Esto ya incluye saveState() y updateUI()
            }
        }


        function addCoefficientType() {
            const inputElement = document.getElementById('new-coefficient-type-name'); if (!inputElement) return;
            const name = inputElement.value.trim();
            if (!name) { showSnackbar("El nombre del tipo de coeficiente no puede estar vacío.", true, 'error'); return; }
            const key = name.replace(/\s+/g, '_').replace(/[^\w-]/g, '');
            if (!key) { showSnackbar("Nombre de tipo inválido tras sanitizar.", true, 'error'); return; }
            if (appState.settings.coefficientTypes[key]) { showSnackbar(`El tipo de coeficiente "${name}" (o su clave "${key}") ya existe.`, true, 'warning'); return; }
            appState.settings.coefficientTypes[key] = { name: name, values: Array(12).fill(0), isDefault: false };
            inputElement.value = '';
            updateCoefficientTypeList();
            showSnackbar(`Tipo de coeficiente "${name}" añadido. Edita sus valores y guarda.`, false, 'info');
        }

        function removeCoefficientType(typeKey) {
            if (appState.settings.coefficientTypes[typeKey]?.isDefault) { showSnackbar("No se pueden eliminar tipos de coeficiente por defecto.", true, 'warning'); return; }
            if (!confirm(`¿Eliminar el tipo de coeficiente "${appState.settings.coefficientTypes[typeKey]?.name}"?`)) return;
            delete appState.settings.coefficientTypes[typeKey];
            Object.values(appState.settings.rubroConfig).forEach(rc => { if (rc.coefficientType === typeKey) rc.coefficientType = 'None'; });
            if (appState.uiState.editingCoefficientType === typeKey) {
                appState.uiState.editingCoefficientType = null;
                renderCoefficientValuesEditor(null);
            }
            updateCoefficientTypeList();
            updateRubroList('gastos', 'gasto-rubro-list');
            showSnackbar(`Tipo de coeficiente eliminado. Guarda la configuración.`, false, 'info');
        }

        function editCoefficientType(typeKey) {
            appState.uiState.editingCoefficientType = typeKey;
            renderCoefficientValuesEditor(typeKey);
        }

        function createNewExercise() {
            const yearInput = document.getElementById('exercise-year'); if (!yearInput) return; const newYear = parseInt(yearInput.value);
            if (isNaN(newYear)||newYear<2000||newYear>2099) { showSnackbar("Año inválido.",true,'error'); yearInput.value=appState.currentYear; return; }
            if (newYear===appState.currentYear && Object.keys(appState.scenarios||{}).some(k=>appState.scenarios[k]?.year===newYear)){ showSnackbar(`Año ${newYear} ya seleccionado.`,false,'info'); return; }
            appState.currentYear = newYear; validateAndSetActiveScenario(); updateUI(); showSnackbar(`Ejercicio para ${appState.currentYear} seleccionado/creado.`,false,'success'); saveState();
        }

        function createScenario() {
            const name = prompt(`Nombre para nuevo escenario (Año ${appState.currentYear}):`, `Escenario ${Object.keys(appState.scenarios).filter(k=>appState.scenarios[k]?.year===appState.currentYear).length+1}`);
            if (!name?.trim()) { showSnackbar("Creación cancelada.",false,'info'); return; }
            const sanName = name.trim().replace(/\s+/g,'_').replace(/[^\w-]/g,''); if(!sanName){showSnackbar("Nombre inválido.",true,'error');return;}
            const newKey = `${appState.currentYear}_${sanName}`; if(appState.scenarios[newKey]){showSnackbar(`Escenario "${name}" ya existe.`,true,'error');return;}
            initScenarioData(appState.currentYear, name.trim()); appState.activeScenarioKey = newKey;
            initializeScenarioDataForRubros(appState.scenarios[newKey]); calculateAll(appState.scenarios[newKey]);
            showSnackbar(`Escenario "${name.trim()}" creado y activado.`,false,'success');
        }

        function cloneScenario() {
            const current = getCurrentScenarioData(); if(!current){showSnackbar("No hay escenario activo para clonar.",true,'error');return;}
            const newName = prompt(`Nombre para clon (base: "${current.scenarioName}"):`, `${current.scenarioName}_Copia`);
            if(!newName?.trim()){showSnackbar("Clonación cancelada.",false,'info');return;}
            const sanNewName = newName.trim().replace(/\s+/g,'_').replace(/[^\w-]/g,''); if(!sanNewName){showSnackbar("Nombre inválido.",true,'error');return;}
            const newKey = `${current.year}_${sanNewName}`; if(appState.scenarios[newKey]){showSnackbar(`Escenario "${newName}" ya existe.`,true,'error');return;}
            appState.scenarios[newKey] = JSON.parse(JSON.stringify(current)); appState.scenarios[newKey].scenarioName = newName.trim();
            appState.activeScenarioKey = newKey; appState.currentYear = current.year;
            initializeScenarioDataForRubros(appState.scenarios[newKey]); calculateAll(appState.scenarios[newKey]);
            showSnackbar(`Escenario clonado como "${newName.trim()}" y activado.`,false,'success');
        }

        function deleteScenario() {
            const key=appState.activeScenarioKey; const current=getCurrentScenarioData(); if(!current){showSnackbar("No hay escenario para eliminar.",true,'error');return;}
            if(Object.keys(appState.scenarios).filter(k=>appState.scenarios[k]?.year===current.year).length<=1 && current.scenarioName.toLowerCase()==='base'){showSnackbar(`No se puede eliminar el único "Base".`,true,'warning');return;}
            if(!confirm(`¿Eliminar escenario "${current.scenarioName}" (Año ${current.year})? ¡No se puede deshacer!`)){showSnackbar("Eliminación cancelada.",false,'info');return;}
            delete appState.scenarios[key]; appState.activeScenarioKey = null; validateAndSetActiveScenario(); updateUI(); saveState();
            showSnackbar(`Escenario "${current.scenarioName}" eliminado.`,false,'success');
        }

        function saveReserveFund() {
            const scenario = getCurrentScenarioData(); if(!scenario){showSnackbar("No hay escenario activo.",true,'error');return;}
            const type = document.getElementById('reserve-type-percent').checked ? 'percent' : 'fixed';
            scenario.reserveFund.type = type; scenario.reserveFund.values = []; let allValid=true;
            document.querySelectorAll('#reserve-fund-panel input[type="number"]').forEach((input,i)=>{
                const val = parseFloat(input.value);
                if(isNaN(val)||val<0){showSnackbar(`Valor inválido para ${FULL_MONTHS[i]}.`,true,'error');input.value=scenario.reserveFund.values[i]||(type==='percent'?5:0);allValid=false;return;}
                scenario.reserveFund.values[i]=val;
            });
            if(!allValid)return; showSnackbar("Fondo de reserva guardado. Recalculando...",false,'info'); calculateAll(scenario);
        }

        function saveSettings() {
            const ufInput = document.getElementById('cantidad-unidades'); const cantidadUF = parseInt(ufInput.value);
            if(isNaN(cantidadUF)||cantidadUF<1){showSnackbar("UF inválida. Debe ser >= 1.",true,'error');ufInput.value=appState.settings.cantidadUnidades;return;}
            appState.settings.cantidadUnidades=cantidadUF;
            ensureDefaultCoefficientTypes();
            const scenario=getCurrentScenarioData();
            if(!scenario){showSnackbar("No hay escenario activo para aplicar config.",true,'error');saveState();updateSettingsPanel();return;}
            showSnackbar("Configuración guardada. Recalculando...",false,'info'); calculateAll(scenario);
        }

        function handleFileUpload(files) {
            const file = files[0]; const feedbackDiv = document.getElementById('file-upload-feedback'); if(!feedbackDiv)return; feedbackDiv.textContent = '';
            if(!file){feedbackDiv.textContent="No se seleccionó archivo.";feedbackDiv.style.color='var(--danger-color)';return;}
            if(!file.name.match(/\.(xlsx|xls)$/i)){feedbackDiv.textContent=`Archivo no válido: ${file.name}.`;feedbackDiv.style.color='var(--danger-color)';showSnackbar("Tipo de archivo no válido.",true,'error');return;}
            feedbackDiv.textContent=`Cargando ${file.name}...`; feedbackDiv.style.color='var(--info-color)';
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const workbook = XLSX.read(new Uint8Array(e.target.result),{type:'array',cellDates:true}); const scenario = getCurrentScenarioData();
                    if(!scenario){showSnackbar("No hay escenario activo para cargar datos.",true,'error');feedbackDiv.textContent="Error: No hay escenario activo.";feedbackDiv.style.color='var(--danger-color)';return;}
                    let newGR=[],newIR=[],newGD={},newID={},processed=false;
                    [GASTOS_SHEET_NAME,INGRESOS_SHEET_NAME].forEach((sheetName,idx)=>{
                        const type = idx===0?'gastos':'ingresos'; const sheet = workbook.Sheets[sheetName];
                        if(sheet){ const jsonData=XLSX.utils.sheet_to_json(sheet,{header:1,blankrows:false});
                            if(jsonData.length>1){
                                // Limpiar datos de expensas existentes del escenario para este tipo
                                scenario.data[type]={};
                                if(!scenario.monthStatus[type]) scenario.monthStatus[type] = {}; else scenario.monthStatus[type]={};
                                scenario.rubroOrder[type] = [];


                                if(!Array.isArray(appState.settings.rubros[type]))appState.settings.rubros[type]=[];
                                for(let i=1;i<jsonData.length;i++){ const row=jsonData[i],rName=String(row[0]||'').trim(),dName=String(row[1]||'').trim(); if(!rName||!dName)continue;
                                    if(!appState.settings.rubros[type].includes(rName)){appState.settings.rubros[type].push(rName);(type==='gastos'?newGR:newIR).push(rName);appState.settings.rubroConfig[rName]=appState.settings.rubroConfig[rName]||{coefficientType:'None',detailsCollapsed:true};}
                                    if(!scenario.rubroOrder[type].includes(rName))scenario.rubroOrder[type].push(rName);

                                    if(!scenario.data[type][rName]){scenario.data[type][rName]={detailOrder:[],detailsData:{}};}
                                    if(!scenario.monthStatus[type][rName]){scenario.monthStatus[type][rName]={};}

                                    if(!scenario.data[type][rName].detailOrder.includes(dName)){scenario.data[type][rName].detailOrder.push(dName);const newDetailsArray=(type==='gastos'?newGD:newID);if(!newDetailsArray[rName])newDetailsArray[rName]=[];if(!newDetailsArray[rName].includes(dName))newDetailsArray[rName].push(dName);}

                                    scenario.data[type][rName].detailsData[dName]=[];
                                    scenario.monthStatus[type][rName][dName]=[];

                                    for(let m=0;m<12;m++){ const cellVal=row[2+m],numVal=parseFloat(cellVal);
                                        if(typeof cellVal==='number'&&!isNaN(numVal)){
                                            scenario.data[type][rName].detailsData[dName][m]=numVal;
                                            scenario.monthStatus[type][rName][dName][m]='REAL';
                                        }else{
                                            scenario.data[type][rName].detailsData[dName][m]=0;
                                            scenario.monthStatus[type][rName][dName][m]='Estimado';
                                        }
                                    }} processed=true;
                            } else feedbackDiv.textContent+=`\nHoja "${sheetName}" vacía/malformada.`;
                        } else feedbackDiv.textContent+=`\nHoja "${sheetName}" no encontrada.`;
                    });
                    if(processed){ let msg=""; if(newGR.length>0)msg+=`\nNuevos Rubros de Gasto: ${newGR.join(', ')}.`; if(newIR.length>0)msg+=`\nNuevos Rubros de Ingreso: ${newIR.join(', ')}.`;
                        feedbackDiv.textContent=`Archivo "${file.name}" procesado.${msg}\nRecalculando...`;feedbackDiv.style.color='var(--success-color)';
                        initializeScenarioDataForRubros(scenario); // Asegura que la estructura CF también esté
                        calculateAll(scenario); showSnackbar(`Datos de "${file.name}" cargados.${msg}`,false,'success',6000); updateSettingsPanel();
                         const chatbotIcon = document.getElementById('chatbot-icon');
                         if (chatbotIcon) chatbotIcon.style.display = 'flex';
                    } else { if(!feedbackDiv.textContent.includes("Error:"))feedbackDiv.textContent="No se procesaron datos válidos."; showSnackbar("No se procesaron datos.",true,'error');}
                } catch(err){console.error("Error procesando Excel:",err);feedbackDiv.textContent=`Error: ${err.message}`;showSnackbar("Error grave procesando Excel.",true,'error');}
            }; reader.onerror=err=>{console.error("Error leyendo archivo:",err);feedbackDiv.textContent="Error al leer archivo.";showSnackbar("Error al leer archivo.",true,'error');};
            reader.readAsArrayBuffer(file);
        }

        function downloadTemplate() {
            const wb=XLSX.utils.book_new(); const hGastos=["Rubro","Detalle",...MONTHS,"Total Anual (Calculado)"]; const hIngresos=hGastos;
            XLSX.utils.book_append_sheet(wb,XLSX.utils.aoa_to_sheet([hGastos,["Ej: Seguridad","Ej: Vigilador",...Array(12).fill(""),""]]),GASTOS_SHEET_NAME);
            XLSX.utils.book_append_sheet(wb,XLSX.utils.aoa_to_sheet([hIngresos,["Ej: Expensas Ordinarias","Base por UF",...Array(12).fill(""),""]]),INGRESOS_SHEET_NAME);
            XLSX.writeFile(wb,`Plantilla_Expensas_${appState.currentYear}.xlsx`); showSnackbar("Plantilla descargada.",false,'success');
        }

        function loadSampleData() {
            if(!confirm("¿Cargar datos ejemplo? Reemplazará datos del escenario actual, incluyendo Cash Flow.")) {showSnackbar("Carga cancelada.",false,'info');return;}
            const scenario=getCurrentScenarioData(); if(!scenario){showSnackbar("No hay escenario activo.",true,'error');return;}

            // Sample Settings
            appState.settings.rubros={gastos:["Seguridad","Mantenimiento","Administración"],ingresos:[CUOTA_RUBRO_NAME,"Alquiler SUM","Intereses Plazo Fijo"]};
            appState.settings.cantidadUnidades=150; appState.settings.ipcManual=[1,1.2,0.8,1.5,2,1.3,1,0.5,0.7,1.1,1.4,1]; ensureDefaultCoefficientTypes();
            appState.settings.coefficientTypes["SueldosAdmin"]={name:"Sueldos Admin",values:Array(12).fill(2.5),isDefault:false};
            appState.settings.rubroConfig={"Seguridad":{coefficientType:"UTEDYC",detailsCollapsed:false},"Mantenimiento":{coefficientType:"IPC",detailsCollapsed:true},"Administración":{coefficientType:"SueldosAdmin",detailsCollapsed:false},[CUOTA_RUBRO_NAME]:{detailsCollapsed:false},"Alquiler SUM":{detailsCollapsed:true},"Intereses Plazo Fijo":{detailsCollapsed:false}};
            appState.settings.rubrosCF = { // Sample CF Rubros
                ingresos: ["Cobranzas Extraordinarias CF", "Rentas Financieras CF"],
                egresos: ["Pagos Proveedores Grandes CF", "Retiro Inversiones CF"]
            };

            // Sample Expensas Data
            scenario.data.gastos={"Seguridad":{detailOrder:["Vigiladores","Monitoreo"],detailsData:{"Vigiladores":[100000,101000,102000,103000,110000,111000,112000,113000,120000,121000,122000,123000],"Monitoreo":Array(12).fill(25000)}},"Mantenimiento":{detailOrder:["Limpieza","Jardinería"],detailsData:{"Limpieza":Array(12).fill(30000),"Jardinería":[15000,15000,16000,16000,17000,17000,18000,18000,19000,19000,20000,20000]}},"Administración":{detailOrder:["Honorarios Admin","Gastos Bancarios"],detailsData:{"Honorarios Admin":Array(12).fill(50000),"Gastos Bancarios":Array(12).fill(5000)}}};
            scenario.monthStatus.gastos={"Seguridad":{"Vigiladores":Array(12).fill('REAL'),"Monitoreo":Array(12).fill('REAL')},"Mantenimiento":{"Limpieza":Array(12).fill('REAL'),"Jardinería":Array(12).fill('REAL')},"Administración":{"Honorarios Admin":Array(12).fill('REAL'),"Gastos Bancarios":Array(12).fill('REAL')}};
            scenario.rubroOrder.gastos=["Seguridad","Mantenimiento","Administración"];

            scenario.data.ingresos={[CUOTA_RUBRO_NAME]:{detailOrder:["Cuota Base UF"],detailsData:{"Cuota Base UF":Array(12).fill(35.5)}},"Alquiler SUM":{detailOrder:["Eventos FinDeSemana"],detailsData:{"Eventos FinDeSemana":[5000,0,7000,0,10000,0,12000,0,8000,0,6000,0]}},"Intereses Plazo Fijo":{detailOrder:["Fondo Común Inv."],detailsData:{"Fondo Común Inv.":[1000,1100,1050,1200,1150,1300,1250,1400,1350,1500,1450,1600]}}};
            scenario.monthStatus.ingresos = { [CUOTA_RUBRO_NAME]:{"Cuota Base UF":Array(12).fill('REAL')}, "Alquiler SUM":{"Eventos FinDeSemana":Array(12).fill('REAL')}, "Intereses Plazo Fijo":{"Fondo Común Inv.":Array(12).fill('REAL')} };
            scenario.rubroOrder.ingresos=[CUOTA_RUBRO_NAME,"Alquiler SUM","Intereses Plazo Fijo"];
            scenario.reserveFund={type:'percent',values:[5,5,5,6,6,6,7,7,7,8,8,8]};

            // Sample Cash Flow Data
            scenario.cashFlow.saldoInicialCaja[0] = 50000; // Enero Saldo Inicial
            scenario.cashFlow.monthStatusCF.saldoInicialCajaEnero = 'REAL';
            scenario.cashFlow.rubrosIngresosCFData = {
                "Cobranzas Extraordinarias CF": { detailOrder: ["Valor"], detailsData: { "Valor": [10000,0,15000,0,5000,0,20000,0,0,0,12000,0] } },
                "Rentas Financieras CF": { detailOrder: ["Valor"], detailsData: { "Valor": Array(12).fill(1500) } }
            };
            scenario.cashFlow.monthStatusCF.ingresos = {
                "Cobranzas Extraordinarias CF": { "Valor": Array(12).fill('REAL') },
                "Rentas Financieras CF": { "Valor": Array(12).fill('REAL') }
            };
            scenario.cashFlow.rubrosEgresosCFData = {
                "Pagos Proveedores Grandes CF": { detailOrder: ["Valor"], detailsData: { "Valor": [0,25000,0,0,30000,0,0,10000,0,0,40000,0] } },
                "Retiro Inversiones CF": { detailOrder: ["Valor"], detailsData: { "Valor": Array(12).fill(0) } } // Ejemplo, podría ser negativo si es una inversión
            };
            scenario.cashFlow.monthStatusCF.egresos = {
                "Pagos Proveedores Grandes CF": { "Valor": Array(12).fill('REAL') },
                "Retiro Inversiones CF": { "Valor": Array(12).fill('Estimado') } // Ejemplo
            };
             scenario.cashFlow.calculatedCF.rubroDetailCollapsedCF = {
                "master_ingresos": false, // Expandido
                "master_egresos": false   // Expandido
            };


            initializeScenarioDataForRubros(scenario); calculateAll(scenario); updateSettingsPanel();
            showSnackbar("Datos de ejemplo cargados (incluyendo Cash Flow).",false,'success');
            const chatbotIcon = document.getElementById('chatbot-icon');
            if (chatbotIcon) chatbotIcon.style.display = 'flex';
        }

        function xlsxCellStyle(options = {}) {
            const {
                fontName = "Arial", fontSize = 10, bold = false, italic = false, colorRGB = "000000",
                hAlign = "left", vAlign = "center", wrapText = false,
                bgColorRGB = null,
                numFmt = "General",
                border = {}
            } = options;

            const style = { font: {}, alignment: {}, fill: {}, border: {} };
            style.font = { name: fontName, sz: fontSize, bold: bold, italic: italic, color: { rgb: colorRGB } };
            style.alignment = { horizontal: hAlign, vertical: vAlign, wrapText: wrapText };
            if (bgColorRGB) style.fill = { fgColor: { rgb: bgColorRGB } };
            style.numFmt = numFmt;

            const borderStyles = ["thin", "medium", "thick", "dotted", "hair", "dashed", "double"];
            ['top', 'bottom', 'left', 'right'].forEach(side => {
                if (border[side] && border[side].style && border[side].color?.rgb) {
                    if (borderStyles.includes(border[side].style)) {
                        style.border[side] = { style: border[side].style, color: { rgb: border[side].color.rgb } };
                    }
                } else if (border[side] === true) {
                     style.border[side] = { style: "thin", color: { rgb: "000000" } };
                }
            });
            return style;
        }

        function exportToExcel() {
            const scenario = getCurrentScenarioData();
            if (!scenario) { showSnackbar("No hay datos para exportar.", true, 'error'); return; }
            const wb = XLSX.utils.book_new();

            const styles = {
                header: xlsxCellStyle({ bold: true, bgColorRGB: "D9EAD3", hAlign: "center", border: {top:true,bottom:true,left:true,right:true} }),
                totalRow: xlsxCellStyle({ bold: true, bgColorRGB: "E7E6E6", numFmt: '$#,##0.00_);[Red]($#,##0.00)', border: {top:{style:"medium"}}, hAlign:"right"}),
                subTotalRow: xlsxCellStyle({ bold: true, bgColorRGB: "F2F2F2", numFmt: '$#,##0.00_);[Red]($#,##0.00)', hAlign:"right"}),
                realData: xlsxCellStyle({ bgColorRGB: "D1F7D9", numFmt: '$#,##0.00_);[Red]($#,##0.00)', hAlign:"right" }),
                estimatedData: xlsxCellStyle({ bgColorRGB: "FFE8D6", numFmt: '$#,##0.00_);[Red]($#,##0.00)', hAlign:"right" }),
                textLeft: xlsxCellStyle({hAlign:"left"}),
                textCenter: xlsxCellStyle({hAlign:"center"}),
                textRight: xlsxCellStyle({hAlign:"right"}),
                currency: xlsxCellStyle({ numFmt: '$#,##0.00_);[Red]($#,##0.00)', hAlign:"right" }),
                percent: xlsxCellStyle({ numFmt: '0.0%', hAlign:"right" }),
                sectionTitle: xlsxCellStyle({bold:true, fontSize:12, bgColorRGB:"C9DAF8", border:{bottom:{style:"medium"}}}),
                paramName: xlsxCellStyle({bold:true, hAlign:"left"}),
            };


            // --- Hoja: Resumen General ---
            const resumenSheetData = [];
            const resumenHeaders = ["Mes", "Gasto ($)", "Fondo ($)", "Cuota s/Gs ($/UF)", "IPC (%)", "Cuota IPC ($/UF)", "Expensa Real ($/UF)"];
            resumenSheetData.push(resumenHeaders.map(h => ({ v: h, s: styles.header })));

            const monthOverallStatuses = scenario.calculated.monthOverallStatus || Array(12).fill('Estimado');
            for (let i = 0; i < 12; i++) {
                const overallStatus = monthOverallStatuses[i];
                const statusStyleToApply = overallStatus === 'REAL' ? styles.realData : styles.estimatedData;
                resumenSheetData.push([
                    { v: MONTHS[i], s: styles.textCenter },
                    { v: formatNumberForExcel(scenario.calculated.totalGastoProyectadoMes?.[i]), t: 'n', s: statusStyleToApply },
                    { v: formatNumberForExcel(scenario.calculated.fondoReservaMes?.[i]), t: 'n', s: statusStyleToApply },
                    { v: formatNumberForExcel(scenario.calculated.cuotaSobreGastosMes?.[i]), t: 'n', s: statusStyleToApply },
                    { v: (scenario.calculated.ipcManual?.[i] || 0) / 100, t: 'n', s: styles.percent },
                    { v: formatNumberForExcel(scenario.calculated.cuotaIpcMes?.[i]), t: 'n', s: statusStyleToApply },
                    { v: formatNumberForExcel(scenario.calculated.cuotaRealBaseMes?.[i]), t: 'n', s: statusStyleToApply }
                ]);
            }
             resumenSheetData.push([
                { v: "TOTAL ANUAL", s: styles.totalRow },
                { v: formatNumberForExcel(scenario.calculated.annualTotals.gastos?.__TOTAL__), t: 'n', s: styles.totalRow },
                { v: formatNumberForExcel(scenario.calculated.annualTotals.fondoReserva), t: 'n', s: styles.totalRow },
                { v: formatNumberForExcel(scenario.calculated.annualTotals.cuotaSobreGastos), t: 'n', s: styles.totalRow },
                { v: "-", s: {...styles.totalRow, alignment:{horizontal:"center"}} },
                { v: formatNumberForExcel(scenario.calculated.annualTotals.cuotaIpc), t: 'n', s: styles.totalRow },
                { v: formatNumberForExcel(scenario.calculated.annualTotals.cuotaRealBase), t: 'n', s: styles.totalRow }
            ]);
            const resumenWS = XLSX.utils.aoa_to_sheet(resumenSheetData.map(row => row.map(cellObj => cellObj || {v:""})));
            resumenWS['!cols'] = [{wch:12},{wch:18},{wch:18},{wch:20},{wch:10},{wch:20},{wch:20}];
            XLSX.utils.book_append_sheet(wb, resumenWS, "Resumen General");


            // --- Hojas de Detalle (Gastos e Ingresos) ---
            ['gastos', 'ingresos'].forEach(type => {
                const detailSheetData = [];
                const headers = type === 'gastos'
                    ? ["Rubro", "Detalle", "Coef. Aplicado", ...MONTHS, "Total Anual"]
                    : ["Rubro", "Detalle", ...MONTHS, "Total Anual"];
                detailSheetData.push(headers.map(h => ({ v: h, s: styles.header })));

                (appState.settings.rubros?.[type] || []).forEach(rubroName => {
                    if (!scenario.data[type]?.[rubroName]) return;

                    const rubroTotalMonthly = scenario.calculated[type === 'gastos' ? 'totalGastoRubroMes' : 'totalIngresoRubroMes']?.[rubroName] || Array(12).fill(0);
                    const rubroTotalAnnual = scenario.calculated.annualTotals[type]?.[rubroName] || 0;

                    const totalRubroRow = [{ v: rubroName, s: {...styles.subTotalRow, alignment:{horizontal:'left'}} }];
                    totalRubroRow.push({ v: "TOTAL RUBRO", s: {...styles.subTotalRow, alignment:{horizontal:'left'}} });
                    if (type === 'gastos') totalRubroRow.push({ v: "", s: styles.subTotalRow });
                    rubroTotalMonthly.forEach(val => totalRubroRow.push({ v: formatNumberForExcel(val), t:'n', s: styles.subTotalRow }));
                    totalRubroRow.push({ v: formatNumberForExcel(rubroTotalAnnual), t:'n', s: styles.subTotalRow });
                    detailSheetData.push(totalRubroRow);

                    const coefName = type === 'gastos' ? (appState.settings.coefficientTypes[appState.settings.rubroConfig[rubroName]?.coefficientType || 'None']?.name || 'N/A') : '';

                    (scenario.data[type][rubroName]?.detailOrder || []).forEach(detailName => {
                        const detailMonthlyValues = scenario.calculated[type === 'gastos' ? 'gastoAjustado' : 'ingresoAjustado']?.[rubroName]?.[detailName] || Array(12).fill(0);
                        const detailStatuses = scenario.monthStatus?.[type]?.[rubroName]?.[detailName] || Array(12).fill('Estimado');
                        const detailAnnualTotal = detailMonthlyValues.reduce((sum, val) => sum + (val || 0), 0);

                        const detailRow = [{ v: "", s: styles.textLeft }];
                        detailRow.push({ v: `    ${detailName}`, s: styles.textLeft });
                        if (type === 'gastos') detailRow.push({ v: coefName, s: styles.textLeft });

                        detailMonthlyValues.forEach((val, mIdx) => {
                            const cellStatus = detailStatuses[mIdx];
                            detailRow.push({ v: formatNumberForExcel(val), t:'n', s: cellStatus === 'REAL' ? styles.realData : styles.estimatedData });
                        });
                        detailRow.push({ v: formatNumberForExcel(detailAnnualTotal), t:'n', s: styles.currency });
                        detailSheetData.push(detailRow);
                    });
                });

                const totalGeneralMonthly = (type === 'gastos' ? scenario.calculated.totalGastoProyectadoMes : scenario.calculated.totalIngresoProyectadoMes) || Array(12).fill(0);
                const totalGeneralAnnual = (type === 'gastos' ? scenario.calculated.annualTotals.gastos.__TOTAL__ : scenario.calculated.annualTotals.ingresos.__TOTAL__) || 0;
                const totalGeneralRow = [{ v: `TOTAL GENERAL ${type.toUpperCase()}`, s: {...styles.totalRow, alignment:{horizontal:'left'}} }];
                totalGeneralRow.push({v:"", s: styles.totalRow});
                if (type === 'gastos') totalGeneralRow.push({ v: "", s: styles.totalRow });
                totalGeneralMonthly.forEach(val => totalGeneralRow.push({ v: formatNumberForExcel(val), t:'n', s: styles.totalRow }));
                totalGeneralRow.push({ v: formatNumberForExcel(totalGeneralAnnual), t:'n', s: styles.totalRow });
                detailSheetData.push(totalGeneralRow);

                const detailWS = XLSX.utils.aoa_to_sheet(detailSheetData.map(row => row.map(cellObj => cellObj || {v:""})));
                const colWidthsConfig = type === 'gastos'
                    ? [{wch:25},{wch:30},{wch:20}, ...Array(12).fill({wch:15}), {wch:18}]
                    : [{wch:30},{wch:30}, ...Array(12).fill({wch:15}), {wch:18}];
                if (type === 'ingresos') colWidthsConfig.splice(2,0); // Corrected splice for 'ingresos'
                detailWS['!cols'] = colWidthsConfig;
                XLSX.utils.book_append_sheet(wb, detailWS, `Detalle ${type.charAt(0).toUpperCase() + type.slice(1)}`);
            });

            // --- Hoja: Configuración Detallada ---
            const cfgSheetData = [];
            cfgSheetData.push([{v: "Configuración Aplicada al Reporte", s: styles.sectionTitle}, {v:"", s:styles.sectionTitle},{v:"", s:styles.sectionTitle},{v:"", s:styles.sectionTitle}]);
            cfgSheetData.push([]);

            cfgSheetData.push([{v: "Parámetros Generales", s: styles.sectionTitle}, {v:"", s:styles.sectionTitle}]);
            cfgSheetData.push([{v: "Año Ejercicio", s:styles.paramName}, {v: scenario.year, s:styles.textLeft}]);
            cfgSheetData.push([{v: "Nombre Escenario", s:styles.paramName}, {v: scenario.scenarioName, s:styles.textLeft}]);
            cfgSheetData.push([{v: "Cantidad UF", s:styles.paramName}, {v: appState.settings.cantidadUnidades, t:'n', s:styles.textRight}]);
            cfgSheetData.push([]);

            cfgSheetData.push([{v: "Fondo de Reserva", s:styles.sectionTitle}, {v:"", s:styles.sectionTitle}]);
            cfgSheetData.push([{v: "Tipo", s:styles.paramName}, {v: scenario.reserveFund.type, s:styles.textLeft}]);
            scenario.reserveFund.values.forEach((val, i) => {
                cfgSheetData.push([{v: `Fondo Reserva ${MONTHS[i]}`, s:styles.paramName}, {v: scenario.reserveFund.type === 'percent' ? val/100 : val, t:'n', s: (scenario.reserveFund.type === 'percent' ? styles.percent : styles.currency) }]);
            });
            cfgSheetData.push([]);

            cfgSheetData.push([{v: "IPC Manual Referencia (%)", s:styles.sectionTitle}, {v:"", s:styles.sectionTitle}]);
            appState.settings.ipcManual.forEach((val, i) => {
                cfgSheetData.push([{v: MONTHS[i], s:styles.paramName}, {v: val / 100, t:'n', s:styles.percent }]);
            });
            cfgSheetData.push([]);

            cfgSheetData.push([{v: "Tipos de Coeficientes y Valores Mensuales (%)", s: styles.sectionTitle}, {v:"", s:styles.sectionTitle}, {v:"", s:styles.sectionTitle}, {v:"", s:styles.sectionTitle}]);
            Object.entries(appState.settings.coefficientTypes).forEach(([key, coef]) => {
                cfgSheetData.push([{v: coef.name + (coef.isDefault ? " (Por Defecto)" : ""), s:styles.paramName, S:{alignment:{wrapText:true}}}]);

                const monthHeaderCells = MONTHS.map(m => ({v:m, s:xlsxCellStyle({bold:true, hAlign:"center"})}));
                cfgSheetData.push([{v:"Meses:", s: styles.paramName}, ...monthHeaderCells.slice(0,11)]);

                const valuesRow = [{v: "Valores (%):", s:styles.paramName}];
                coef.values.forEach(v => valuesRow.push({v: v / 100, t:'n', s:styles.percent}));
                cfgSheetData.push(valuesRow);
                cfgSheetData.push([]);
            });

            cfgSheetData.push([{v: "Asignación de Coeficientes a Rubros de Gasto", s: styles.sectionTitle}, {v:"", s:styles.sectionTitle}]);
            (appState.settings.rubros?.gastos||[]).forEach(rubroName => {
                const coefKey = appState.settings.rubroConfig[rubroName]?.coefficientType || 'None';
                cfgSheetData.push([{v: rubroName, s:styles.paramName}, {v: appState.settings.coefficientTypes[coefKey]?.name || 'N/A', s:styles.textLeft}]);
            });

            const cfgWS = XLSX.utils.aoa_to_sheet(cfgSheetData);
            cfgWS['!cols'] = [{wch:35},{wch:15},{wch:10},{wch:10},{wch:10},{wch:10},{wch:10},{wch:10},{wch:10},{wch:10},{wch:10},{wch:10},{wch:10}];
            const merges = [];
            let currentRowIdx = 0;
            merges.push({s:{r:currentRowIdx,c:0}, e:{r:currentRowIdx,c:3}}); currentRowIdx +=2;
            merges.push({s:{r:currentRowIdx,c:0}, e:{r:currentRowIdx,c:1}}); currentRowIdx += (3 + 1);
            merges.push({s:{r:currentRowIdx,c:0}, e:{r:currentRowIdx,c:1}}); currentRowIdx += (1 + 12 + 1);
            merges.push({s:{r:currentRowIdx,c:0}, e:{r:currentRowIdx,c:1}}); currentRowIdx += (12 + 1);
            merges.push({s:{r:currentRowIdx,c:0}, e:{r:currentRowIdx,c:13}}); currentRowIdx += 1;
            Object.entries(appState.settings.coefficientTypes).forEach(() => currentRowIdx += 3);
            merges.push({s:{r:currentRowIdx,c:0}, e:{r:currentRowIdx,c:1}});
            cfgWS["!merges"] = merges;

            XLSX.utils.book_append_sheet(wb, cfgWS, "Configuración Detallada");


            XLSX.writeFile(wb, `Reporte_Expensas_${scenario.year}_${scenario.scenarioName.replace(/\s+/g,'_')}_Pro.xlsx`);
            showSnackbar("Reporte Excel con formato profesional generado.", false, 'success');
        }


        function exportChart(chartId, filename) {
            const instance = window[`${chartId}_instance`];
            if(instance){try{const img=instance.toBase64Image();const link=document.createElement('a');link.href=img;link.download=filename;document.body.appendChild(link);link.click();document.body.removeChild(link);URL.revokeObjectURL(link.href);showSnackbar(`Gráfico "${filename}" descargado.`,false,'success');}catch(e){console.error("Error exportando chart:", e); showSnackbar("Error exportando gráfico.",true,'error');}}
            else showSnackbar("Gráfico no disponible.",true,'warning');
        }

        function clearScenarioData() {
             const key=appState.activeScenarioKey; const scenario=appState.scenarios?.[key]; if(!scenario){showSnackbar('No hay escenario activo.',true,'error');return;}
             if(!confirm(`¿Borrar TODOS los datos (gastos, ingresos, status) del escenario "${scenario.scenarioName}" (Año ${scenario.year})?\nConfiguración de Fondo, Coeficientes y rubros se mantendrán.\n¡No se puede deshacer!`)){showSnackbar("Operación cancelada.",false,'info');return;}
             scenario.data={gastos:{},ingresos:{}}; scenario.monthStatus={gastos:{},ingresos:{}}; scenario.rubroOrder={gastos:[],ingresos:[]};
             saveState(); calculateAll(scenario);
              const chatbotIcon = document.getElementById('chatbot-icon');
              if (chatbotIcon) chatbotIcon.style.display = 'none';
        }

        function exportLocalStorage() {
            try {
                const stateToExport = JSON.parse(JSON.stringify(appState));
                const dataStr = JSON.stringify(stateToExport, null, 2);
                const blob = new Blob([dataStr], {type: "application/json"});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `expensas_app_backup_${new Date().toISOString().slice(0,10).replace(/-/g,'')}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showSnackbar("Datos de la aplicación exportados.", false, 'success');
            } catch (e) {
                console.error("Error exportando datos de la aplicación:", e);
                showSnackbar("Error al exportar datos.", true, 'error');
            }
        }

        function importLocalStorage(event) {
            const file = event.target.files[0];
            if (!file) return;
            if (!confirm("Importar datos reemplazará toda la información actual. ¿Continuar?")) {
                event.target.value = null;
                showSnackbar("Importación cancelada.", false, 'info');
                return;
            }
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const importedData = JSON.parse(e.target.result);
                    let newStateCandidate;
                    if (importedData.hasOwnProperty('currentYear') && importedData.hasOwnProperty('scenarios') && importedData.hasOwnProperty('settings')) {
                        newStateCandidate = importedData;
                    } else {
                        throw new Error("El archivo JSON no parece ser un backup válido de la aplicación.");
                    }

                    const defaultAppState = getDefaultAppState();
                    appState = deepMerge(defaultAppState, newStateCandidate);

                    validateAndSetActiveScenario();
                    saveState();
                    updateUI();
                    const chatbotIcon = document.getElementById('chatbot-icon');
                    if (chatbotIcon) {
                         chatbotIcon.style.display = getCurrentScenarioData() ? 'flex' : 'none';
                    }
                    showSnackbar("Datos importados y aplicados.", false, 'success');
                } catch (err) {
                    console.error("Error importando datos:", err);
                    showSnackbar(`Error al importar: ${err.message}`, true, 'error', 6000);
                } finally {
                     event.target.value = null;
                }
            };
            reader.readAsText(file);
        }
        // --- Inicialización de EventListeners ---
        function addEventListeners() {
             document.getElementById('theme-toggle')?.addEventListener('click', toggleTheme);
             document.getElementById('export-storage')?.addEventListener('click', exportLocalStorage);
             document.getElementById('import-storage')?.addEventListener('click', () => document.getElementById('import-storage-input').click());
             document.getElementById('import-storage-input')?.addEventListener('change', importLocalStorage);

             document.getElementById('scenario-selector')?.addEventListener('change', (event) => {
                 const newKey = event.target.value; const newScenario = appState.scenarios?.[newKey];
                 if(newKey&&newScenario){appState.activeScenarioKey=newKey;appState.currentYear=newScenario.year||parseInt(newKey.split('_')[0])||new Date().getFullYear();initializeScenarioDataForRubros(newScenario);calculateAll(newScenario);}
                 else if(newKey===""){appState.activeScenarioKey=null;validateAndSetActiveScenario();updateUI();}
                 else {showSnackbar(`Error: Escenario no válido.`,true,'error');if(appState.activeScenarioKey&&appState.scenarios?.[appState.activeScenarioKey])event.target.value=appState.activeScenarioKey;else event.target.value="";updateUI();}
                 const chatbotIcon = document.getElementById('chatbot-icon');
                 if (chatbotIcon) {
                     chatbotIcon.style.display = getCurrentScenarioData() ? 'flex' : 'none';
                 }
             });
             const uploadArea = document.getElementById('file-upload-area');
             if(uploadArea){ ['dragenter','dragover','dragleave','drop'].forEach(evtName=>document.body.addEventListener(evtName,preventDefaults,false));
                 ['dragenter','dragover'].forEach(evtName=>uploadArea.addEventListener(evtName,()=>uploadArea.style.backgroundColor='var(--clickable-row-hover)',false));
                 ['dragleave','drop'].forEach(evtName=>uploadArea.addEventListener(evtName,()=>uploadArea.style.backgroundColor='var(--bg-color)',false));
                 uploadArea.addEventListener('drop',(event)=>{const files=event.dataTransfer.files;if(files.length>0)handleFileUpload(files);},false);
             }
             addCollapsibleListenersExpensas(); // Para tablas de Dashboard (Expensas)
             addCollapsibleListenersCF(); // Para tabla de Cash Flow

            const chatbotMessagesDiv = document.getElementById('chatbot-messages');
            if (chatbotMessagesDiv) {
                chatbotMessagesDiv.addEventListener('click', function(event) {
                    if (event.target.classList.contains('suggestion-button')) {
                        const suggestionText = event.target.dataset.suggestion;
                        const chatbotInput = document.getElementById('chatbot-input');
                        if (chatbotInput) {
                            chatbotInput.value = suggestionText;
                            handleUserInput();
                        }
                    }
                });
            }
        }

        // --- START CHATBOT LOGIC (MEJORADO) ---
        function initChatbot() {
            const chatbotIcon = document.getElementById('chatbot-icon');
            const chatbotWindow = document.getElementById('chatbot-window');
            const chatbotClose = document.getElementById('chatbot-close');
            const chatbotSend = document.getElementById('chatbot-send');
            const chatbotInput = document.getElementById('chatbot-input');
            const chatbotMessages = document.getElementById('chatbot-messages');

            if (!chatbotIcon || !chatbotWindow || !chatbotClose || !chatbotSend || !chatbotInput || !chatbotMessages) {
                console.warn("Chatbot UI elements not found. Chatbot will not initialize.");
                return;
            }

            chatbotIcon.addEventListener('click', () => {
                chatbotWindow.classList.toggle('hidden');
                if (!chatbotWindow.classList.contains('hidden')) {
                    chatbotInput.focus();
                    if (chatbotMessages.children.length <= 1 || (chatbotMessages.children.length === 1 && chatbotMessages.children[0].textContent === "¡Hola! Soy Centaurito, tu asistente virtual para las expensas. ¿En qué puedo ayudarte?")) {
                        chatbotMessages.innerHTML = '';
                        addMessageToChat("¡Hola! Soy Centaurito. ¿En qué puedo ayudarte hoy con las expensas y el cash flow?", 'bot');
                    }
                    chatbotMessages.scrollTop = chatbotMessages.scrollHeight;
                }
            });
            chatbotClose.addEventListener('click', () => chatbotWindow.classList.add('hidden'));
            chatbotSend.addEventListener('click', handleUserInput);
            chatbotInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); handleUserInput(); }
            });

            if (!getCurrentScenarioData() && chatbotMessages.children.length === 0) {
                 addMessageToChat("¡Hola! Soy Centaurito. Parece que no hay datos cargados. Por favor, carga un archivo Excel o datos de ejemplo para que pueda ayudarte mejor.", 'bot');
            } else if (chatbotMessages.children.length === 0) {
                 addMessageToChat("¡Hola! Soy Centaurito, tu asistente virtual. ¿En qué puedo ayudarte con las expensas o el cash flow?", 'bot');
            }
        }

        function handleUserInput() {
            const chatbotInput = document.getElementById('chatbot-input');
            const userInput = chatbotInput.value.trim();
            if (userInput === "") return;

            addMessageToChat(userInput, 'user');
            chatbotInput.value = "";
            chatbotInput.focus();

            if (waitingForClarification) {
                processClarification(userInput);
            } else {
                processUserQuery(userInput);
            }
        }

        function addMessageToChat(message, sender, options = {}) {
            const chatbotMessages = document.getElementById('chatbot-messages');
            const messageDiv = document.createElement('div');
            messageDiv.classList.add(sender === 'user' ? 'user-message' : 'bot-message');

            const textNode = document.createTextNode(message);
            messageDiv.appendChild(textNode);

            if (sender === 'bot' && options.suggestions && options.suggestions.length > 0) {
                options.suggestions.forEach(sugg => {
                    const button = document.createElement('button');
                    button.classList.add('suggestion-button');
                    button.textContent = sugg.text;
                    button.dataset.suggestion = sugg.payload; // El texto que se autocompletará en el input
                    messageDiv.appendChild(document.createElement('br'));
                    messageDiv.appendChild(button);
                });
            }

            chatbotMessages.appendChild(messageDiv);
            chatbotMessages.scrollTo({ top: chatbotMessages.scrollHeight, behavior: 'smooth' });
            return messageDiv;
        }

        function getKeywordMatch(normalizedQuery, keywordCategory) {
            const synonyms = BOT_SYNONYMS[keywordCategory] || [];
            for (const syn of synonyms) {
                if (normalizedQuery.includes(normalizeBotQuery(syn))) {
                    return true;
                }
            }
            if (keywordCategory === "coeficiente") {
                for (const typeKey in appState.settings.coefficientTypes) {
                    if (normalizedQuery.includes(normalizeBotQuery(appState.settings.coefficientTypes[typeKey].name))) {
                        return true;
                    }
                }
            }
            return false;
        }

        function getYearFromQuery(normalizedQuery, defaultYear) {
            const yearMatch = normalizedQuery.match(/\b(20\d{2})\b/);
            if (yearMatch) {
                return { year: parseInt(yearMatch[1]), explicit: true};
            }
            const today = new Date();
            if (getKeywordMatch(normalizedQuery, "año pasado")) {
                return { year: today.getFullYear() - 1, explicit: true };
            }
            if (getKeywordMatch(normalizedQuery, "proximo año")) {
                 return { year: today.getFullYear() + 1, explicit: true };
            }
            return { year: defaultYear, explicit: false };
        }

        function getMonthInfoFromQuery(normalizedQuery, queryYear) {
            let monthIndex = -1;
            let monthName = null;
            const today = new Date();
            let yearForRelative = queryYear;

            if (getKeywordMatch(normalizedQuery, "este mes")) {
                monthIndex = today.getMonth();
                monthName = FULL_MONTHS[monthIndex];
                if (queryYear !== today.getFullYear() && !normalizedQuery.match(/\b(20\d{2})\b/)) {
                     yearForRelative = today.getFullYear();
                }
            } else if (getKeywordMatch(normalizedQuery, "mes pasado")) {
                if (today.getMonth() === 0) {
                    monthIndex = 11;
                    if (queryYear === today.getFullYear() && !normalizedQuery.match(/\b(20\d{2})\b/)) {
                        yearForRelative = today.getFullYear() - 1;
                    }
                } else {
                    monthIndex = today.getMonth() - 1;
                }
                monthName = FULL_MONTHS[monthIndex];
            } else if (getKeywordMatch(normalizedQuery, "proximo mes")) {
                if (today.getMonth() === 11) {
                    monthIndex = 0;
                     if (queryYear === today.getFullYear() && !normalizedQuery.match(/\b(20\d{2})\b/)) {
                        yearForRelative = today.getFullYear() + 1;
                    }
                } else {
                    monthIndex = today.getMonth() + 1;
                }
                monthName = FULL_MONTHS[monthIndex];
            }

            if (monthIndex === -1) {
                for (let i = 0; i < FULL_MONTHS.length; i++) {
                    if (normalizedQuery.includes(normalizeBotQuery(FULL_MONTHS[i]))) {
                        monthIndex = i; monthName = FULL_MONTHS[i]; yearForRelative = queryYear; break;
                    }
                }
                if (monthIndex === -1) {
                    for (let i = 0; i < MONTHS.length; i++) {
                        if (normalizedQuery.includes(normalizeBotQuery(MONTHS[i]))) {
                            monthIndex = i; monthName = FULL_MONTHS[i]; yearForRelative = queryYear; break;
                        }
                    }
                }
            }
            return { monthIndex, monthName, effectiveYear: yearForRelative };
        }


        function getRubroInfoFromQuery(normalizedQuery, tipoDato = null, context = 'expensas') { // context: 'expensas' o 'cashflow'
            const tipos = tipoDato ? [tipoDato] : ['gastos', 'ingresos']; // 'gastos' o 'ingresos' del contexto
            const allSystemRubros = context === 'expensas' ? appState.settings.rubros : appState.settings.rubrosCF;
            let matches = [];

            for (const tipo of tipos) {
                const rubrosSistema = allSystemRubros[tipo] || [];
                const sortedRubrosSistema = [...rubrosSistema].sort((a, b) => b.length - a.length);

                for (const rubroReal of sortedRubrosSistema) {
                    const normalizedRubroReal = normalizeBotQuery(rubroReal);
                    const synonymKeyForRubro = normalizeBotQuery(rubroReal);
                    const synonymsForThisRubro = (BOT_SYNONYMS[synonymKeyForRubro] || [rubroReal]).map(s => normalizeBotQuery(s));

                    for (const syn of synonymsForThisRubro) {
                        if (normalizedQuery.includes(syn)) {
                            matches.push({ name: rubroReal, type: tipo, strength: syn.length, context: context });
                        }
                    }
                }
            }
            if (matches.length === 0) return null;

            const uniqueMatches = matches.filter((match, index, self) =>
                index === self.findIndex((t) => t.name === match.name && t.type === match.type && t.context === match.context)
            );
            if (uniqueMatches.length === 0) return null;
            if (uniqueMatches.length === 1) return uniqueMatches[0];

            uniqueMatches.sort((a, b) => b.strength - a.strength);
            const topStrength = uniqueMatches[0].strength;
            const topMatches = uniqueMatches.filter(m => m.strength === topStrength);

            return topMatches.length > 1 ? topMatches : topMatches[0];
        }

        function getDetailInfoFromQuery(normalizedQuery, rubroInfo) { // Solo para expensas por ahora
            const currentScenario = getCurrentScenarioData();
            if (!currentScenario || !rubroInfo || rubroInfo.context !== 'expensas') return null; // Detalles solo en expensas

            const rubrosConsiderar = Array.isArray(rubroInfo) ? rubroInfo.filter(r => r.context === 'expensas') : [rubroInfo];
            let bestMatch = null;

            for (const currentRubro of rubrosConsiderar) {
                if (!currentRubro || !currentScenario.data[currentRubro.type]?.[currentRubro.name]?.detailOrder) {
                    continue;
                }
                const details = currentScenario.data[currentRubro.type][currentRubro.name].detailOrder;
                const sortedDetails = [...details].sort((a, b) => b.length - a.length);

                for (const detail of sortedDetails) {
                    const normalizedDetail = normalizeBotQuery(detail);
                    const synonymKeyForDetail = normalizeBotQuery(detail);
                    const synonymsForThisDetail = (BOT_SYNONYMS[synonymKeyForDetail] || [detail]).map(s => normalizeBotQuery(s));

                    for (const syn of synonymsForThisDetail) {
                        if (normalizedQuery.includes(syn)) {
                            const currentMatchStrength = syn.length;
                            if (!bestMatch || currentMatchStrength > bestMatch.strength) {
                                bestMatch = { name: detail, parentRubro: currentRubro.name, type: currentRubro.type, strength: currentMatchStrength };
                            }
                        }
                    }
                }
            }
            return bestMatch;
        }

        function getCoefficientTypeInfoFromQuery(normalizedQuery) {
            let bestMatch = null;
            for (const key in appState.settings.coefficientTypes) {
                const coefTypeData = appState.settings.coefficientTypes[key];
                const normalizedCoefName = normalizeBotQuery(coefTypeData.name);
                const synonymKeyForCoef = normalizeBotQuery(coefTypeData.name);
                const synonymsForThisCoef = (BOT_SYNONYMS[synonymKeyForCoef] || [coefTypeData.name]).map(s => normalizeBotQuery(s));

                for (const syn of synonymsForThisCoef) {
                    if (normalizedQuery.includes(syn)) {
                        const currentMatchStrength = syn.length;
                         if (!bestMatch || currentMatchStrength > bestMatch.strength) {
                            bestMatch = { key: key, name: coefTypeData.name, values: coefTypeData.values, strength: currentMatchStrength };
                        }
                    }
                }
            }
            return bestMatch;
        }

        function parseQuery(rawQueryOriginal) {
            const normalizedQuery = normalizeBotQuery(rawQueryOriginal);
            const uiScenario = getCurrentScenarioData();
            const uiYear = uiScenario ? uiScenario.year : new Date().getFullYear();

            const yearExtraction = getYearFromQuery(normalizedQuery, uiYear);
            const queryYear = yearExtraction.year;
            const yearExplicitlyMentioned = yearExtraction.explicit;

            const monthExtraction = getMonthInfoFromQuery(normalizedQuery, queryYear);

            const entities = {
                raw: rawQueryOriginal,
                normalized: normalizedQuery,
                metric: null, // gasto, ingreso, cuotaReal, ipcMensual, saldoInicial, flujoNeto, etc.
                operation: null, // promedio, diferencia, comparacion, mayor, menor
                subject: {
                    type: null,       // 'gastos', 'ingresos' (puede ser de expensas o CF)
                    rubro: null,      // { name, type, context ('expensas'/'cashflow') }
                    detail: null,     // { name, parentRubro, type } (solo para expensas)
                    general: false,   // Para "total gasto", "total ingreso"
                    coefTypeInfo: null, // Para "valor del coeficiente X"
                    ambiguousRubros: [] // Para desambiguación
                },
                timeframe: {
                    monthIndex: monthExtraction.monthIndex,
                    monthName: monthExtraction.monthName,
                    year: monthExtraction.effectiveYear,
                    annual: getKeywordMatch(normalizedQuery, "anual"),
                    startMonthIndex: -1, endMonthIndex: -1,
                    yearExplicitlyMentioned: yearExplicitlyMentioned
                },
                comparisonItems: [],
                qualifier: null,
                context: 'expensas' // Default context, can be overridden
            };

             // Determine Context: Expensas vs Cash Flow
            if (getKeywordMatch(normalizedQuery, "cash flow") || getKeywordMatch(normalizedQuery, "saldo inicial") ||
                getKeywordMatch(normalizedQuery, "saldo final") || getKeywordMatch(normalizedQuery, "flujo neto") ||
                getKeywordMatch(normalizedQuery, "otros ingresos cf") || getKeywordMatch(normalizedQuery, "egresos cf")) {
                entities.context = 'cashflow';
            }


            // Detección de Operación y Métrica Principal
            if (getKeywordMatch(normalizedQuery, "promedio")) entities.operation = 'promedio';
            else if (getKeywordMatch(normalizedQuery, "diferencia")) entities.operation = 'diferencia';
            else if (getKeywordMatch(normalizedQuery, "comparacion")) entities.operation = 'comparacion';
            else if (getKeywordMatch(normalizedQuery, "mayor")) entities.operation = 'mayor';
            else if (getKeywordMatch(normalizedQuery, "menor")) entities.operation = 'menor';

            // Métricas (priorizar las más específicas)
            // Expensas
            if (entities.context === 'expensas') {
                if (getKeywordMatch(normalizedQuery, "cuota real")) entities.metric = 'cuotaReal';
                else if (getKeywordMatch(normalizedQuery, "cuota ipc")) entities.metric = 'cuotaIPC';
                else if (getKeywordMatch(normalizedQuery, "cuota sobre gastos")) entities.metric = 'cuotaSGastos';
                else if (getKeywordMatch(normalizedQuery, "fondo de reserva")) entities.metric = 'fondoReserva';
                else if (getKeywordMatch(normalizedQuery, "ipc") && (normalizedQuery.includes("acumulado") || (getKeywordMatch(normalizedQuery,"total") && (normalizedQuery.includes("entre") || normalizedQuery.match(/\b(de)\b.*\b(a)\b/i))))) entities.metric = 'ipcAcumulado';
                else if (getKeywordMatch(normalizedQuery, "ipc")) entities.metric = 'ipcMensual';
                else if (getKeywordMatch(normalizedQuery, "coeficiente") && (normalizedQuery.includes("asignado") || normalizedQuery.includes("tiene el rubro") || normalizedQuery.includes("aplica"))) entities.metric = 'coeficienteAsignado';
                else if (getKeywordMatch(normalizedQuery, "coeficiente")) entities.metric = 'coeficienteValor';
                else if (getKeywordMatch(normalizedQuery, "unidades funcionales")) entities.metric = 'ufCantidad';
                else if (getKeywordMatch(normalizedQuery, "gasto")) entities.metric = 'gasto'; // gasto de expensas
                else if (getKeywordMatch(normalizedQuery, "ingreso")) entities.metric = 'ingreso'; // ingreso de expensas
                else if (getKeywordMatch(normalizedQuery, "cuota")) entities.metric = 'cuota'; // Genérico, se intentará resolver
            }
            // Cash Flow
            else if (entities.context === 'cashflow') {
                if (getKeywordMatch(normalizedQuery, "saldo inicial")) entities.metric = 'saldoInicialCF';
                else if (getKeywordMatch(normalizedQuery, "saldo final")) entities.metric = 'saldoFinalCF';
                else if (getKeywordMatch(normalizedQuery, "flujo neto")) entities.metric = 'flujoNetoCF';
                else if (getKeywordMatch(normalizedQuery, "otros ingresos cf") || (getKeywordMatch(normalizedQuery,"ingreso") && getKeywordMatch(normalizedQuery,"caja"))) entities.metric = 'otrosIngresosCF';
                else if (getKeywordMatch(normalizedQuery, "egresos cf") || (getKeywordMatch(normalizedQuery,"gasto") && getKeywordMatch(normalizedQuery,"caja"))) entities.metric = 'egresosCF';
            }

            if (getKeywordMatch(normalizedQuery, "estado")) entities.metric = 'status'; // Aplica a ambos contextos

             // Sujeto
            let potentialSubjectType = null; // 'gastos' o 'ingresos'
            if (entities.metric === 'gasto' || (entities.operation && getKeywordMatch(normalizedQuery,"gasto")) ) potentialSubjectType = 'gastos';
            if (entities.metric === 'ingreso' || (entities.operation && getKeywordMatch(normalizedQuery,"ingreso")) ) potentialSubjectType = 'ingresos';
            if (entities.metric === 'otrosIngresosCF') potentialSubjectType = 'ingresos'; // CF
            if (entities.metric === 'egresosCF') potentialSubjectType = 'gastos'; // CF (internamente se manejan como 'gastos' para CF)

            if (entities.metric === 'coeficienteAsignado' || (entities.metric === 'coeficienteValor' && entities.subject.coefTypeInfo === null) ) potentialSubjectType = 'gastos'; // Coeficientes se aplican a gastos de expensas
            if (entities.metric === 'status' && getKeywordMatch(normalizedQuery,"gasto")) potentialSubjectType = 'gastos';
            if (entities.metric === 'status' && getKeywordMatch(normalizedQuery,"ingreso")) potentialSubjectType = 'ingresos';


            if (getKeywordMatch(normalizedQuery, "total") && (entities.metric === 'gasto' || entities.metric === 'ingreso' || entities.metric === 'otrosIngresosCF' || entities.metric === 'egresosCF' || entities.operation)) {
                 entities.subject.general = true;
                 entities.subject.type = potentialSubjectType || (getKeywordMatch(normalizedQuery, "gasto") ? 'gastos' : (getKeywordMatch(normalizedQuery, "ingreso") ? 'ingresos' : null));
            } else if (entities.metric === 'coeficienteValor' && !potentialSubjectType) {
                entities.subject.coefTypeInfo = getCoefficientTypeInfoFromQuery(normalizedQuery);
            } else if (potentialSubjectType || entities.metric === 'status' || entities.context === 'cashflow') {
                // Para CF, si no es "total", siempre se busca un rubro de CF.
                const rubroContext = entities.context;
                const rubroMatches = getRubroInfoFromQuery(normalizedQuery, potentialSubjectType, rubroContext);

                if (Array.isArray(rubroMatches)) {
                    entities.subject.ambiguousRubros = rubroMatches;
                } else if (rubroMatches) {
                    entities.subject.rubro = rubroMatches; // rubroMatches ya tiene { name, type, context }
                    entities.subject.type = rubroMatches.type;
                    if (rubroContext === 'expensas') { // Detalles solo para expensas
                        entities.subject.detail = getDetailInfoFromQuery(normalizedQuery, entities.subject.rubro);
                    }
                }
            }

            // Periodos para IPC Acumulado o Diferencia
            if (entities.metric === 'ipcAcumulado' || entities.operation === 'diferencia') {
                const monthMatches = [];
                FULL_MONTHS.forEach((fm, idx) => {
                    if (normalizedQuery.includes(normalizeBotQuery(fm))) monthMatches.push({name: fm, index: idx, originalIndex: normalizedQuery.indexOf(normalizeBotQuery(fm))});
                });
                MONTHS.forEach((sm, idx) => {
                    if (normalizedQuery.includes(normalizeBotQuery(sm)) && !monthMatches.some(m => m.index === idx) ) {
                       monthMatches.push({name: FULL_MONTHS[idx], index: idx, originalIndex: normalizedQuery.indexOf(normalizeBotQuery(sm))});
                    }
                });
                if (monthMatches.length >= 2) {
                    monthMatches.sort((a,b) => a.originalIndex - b.originalIndex);
                    entities.timeframe.startMonthIndex = monthMatches[0].index;
                    entities.timeframe.endMonthIndex = monthMatches[monthMatches.length-1].index;
                     if (entities.timeframe.startMonthIndex > entities.timeframe.endMonthIndex) {
                        [entities.timeframe.startMonthIndex, entities.timeframe.endMonthIndex] = [entities.timeframe.endMonthIndex, entities.timeframe.startMonthIndex];
                     }
                }
            }

            // Comparación de Cuotas (solo expensas)
            if (entities.operation === 'comparacion' && entities.context === 'expensas') {
                const cuotaTypes = [
                    { syn: "cuota real", metric: "cuotaReal" }, { syn: "cuota ipc", metric: "cuotaIPC" },
                    { syn: "cuota sobre gastos", metric: "cuotaSGastos" }
                ];
                let tempNormQuery = normalizedQuery;
                for (const ct of cuotaTypes) {
                    if (getKeywordMatch(tempNormQuery, ct.syn)) {
                        entities.comparisonItems.push({ metric: ct.metric });
                        const foundSyn = (BOT_SYNONYMS[ct.syn] || []).find(s => tempNormQuery.includes(normalizeBotQuery(s)));
                        if(foundSyn) tempNormQuery = tempNormQuery.replace(new RegExp(normalizeBotQuery(foundSyn), 'g'), '');
                    }
                }
                if (entities.comparisonItems.length < 2) entities.comparisonItems = [];
            }
            return entities;
        }

        function processClarification(userInput) {
            const normalizedInput = normalizeBotQuery(userInput);
            let choice = null;
            const originalEntities = waitingForClarification.originalQuery;

            if (waitingForClarification.type === 'rubro') {
                waitingForClarification.options.forEach((opt, index) => {
                    if (normalizedInput === normalizeBotQuery(opt.name) || normalizedInput === String(index + 1)) {
                        choice = opt;
                    }
                });

                if (choice) {
                    originalEntities.subject.rubro = choice; // choice ya tiene { name, type, context }
                    originalEntities.subject.ambiguousRubros = [];
                    if (choice.context === 'expensas' && !originalEntities.subject.detail) {
                       originalEntities.subject.detail = getDetailInfoFromQuery(originalEntities.normalized, originalEntities.subject.rubro);
                    }
                    waitingForClarification = null;
                    executeParsedQuery(originalEntities);
                } else {
                    addMessageToChat("No entendí tu elección. Por favor, elige uno de los rubros anteriores (escribe el nombre o el número).", 'bot', {
                        suggestions: waitingForClarification.options.map((opt, i) => ({
                            text: `${i+1}. ${opt.name} (${opt.type}, ${opt.context})`,
                            payload: opt.name
                        }))
                    });
                }
            }
        }

        function executeParsedQuery(entities) {
            const uiScenario = getCurrentScenarioData();
            let dataScenario = uiScenario;

            if (entities.timeframe.yearExplicitlyMentioned && uiScenario && entities.timeframe.year !== uiScenario.year) {
                const targetYear = entities.timeframe.year;
                let foundScenarioForYear = null;
                const currentScenarioNamePart = uiScenario.scenarioName.replace(/\s+/g, '_').replace(/[^\w-]/g, '');
                const potentialKeys = [
                    `${targetYear}_${currentScenarioNamePart}`,
                    `${targetYear}_Base`,
                    ...Object.keys(appState.scenarios).filter(k => appState.scenarios[k].year === targetYear)
                ];
                for (const key of potentialKeys) {
                    if (appState.scenarios[key] && appState.scenarios[key].calculated && appState.scenarios[key].cashFlow?.calculatedCF) {
                        foundScenarioForYear = appState.scenarios[key];
                        break;
                    }
                }

                if (foundScenarioForYear) {
                    addMessageToChat(`Para tu consulta sobre el año ${targetYear}, usaré los datos del escenario "${foundScenarioForYear.scenarioName}".`, 'bot');
                    dataScenario = foundScenarioForYear;
                } else {
                    addMessageToChat(`No encontré datos calculados para el año ${targetYear}. Usaré el escenario actual: "${uiScenario.scenarioName}" (${uiScenario.year}).`, 'bot');
                    entities.timeframe.year = uiScenario.year;
                }
            }

            if (!dataScenario || !dataScenario.calculated || !dataScenario.cashFlow?.calculatedCF) {
                addMessageToChat("No hay datos cargados o calculados para responder. Por favor, carga un archivo Excel y asegúrate de estar en un escenario con datos.", 'bot');
                return;
            }

            if (entities.subject.ambiguousRubros && entities.subject.ambiguousRubros.length > 0) {
                waitingForClarification = {
                    type: 'rubro',
                    options: entities.subject.ambiguousRubros,
                    originalQuery: entities
                };
                let message = "Detecté que tu consulta podría referirse a varios rubros. ¿A cuál te refieres específicamente?\n";
                const suggestions = entities.subject.ambiguousRubros.map((opt, index) => ({
                    text: `${index + 1}. ${opt.name} (${opt.type}, ${opt.context})`,
                    payload: opt.name
                }));
                addMessageToChat(message, 'bot', { suggestions });
                return;
            }
            processSingleQueryWithData(entities, dataScenario, dataScenario.year, dataScenario.scenarioName);
        }

        function processSingleQueryWithData(entities, scenarioFullData, scenarioYear, scenarioName){
            let botResponse = `No entendí bien tu pregunta sobre "${entities.raw}". Intenta ser más específico. Puedes pedir 'ayuda' para ver ejemplos.`;
            const { metric, operation, subject, timeframe, context } = entities;
            const { type: subjectTypeFromParse, rubro, detail, general, coefTypeInfo } = subject; // subjectTypeFromParse es 'gastos' o 'ingresos'
            const { monthIndex, monthName, year, annual, startMonthIndex, endMonthIndex } = timeframe;

            const calculatedData = scenarioFullData.calculated; // Expensas
            const monthStatusData = scenarioFullData.monthStatus; // Expensas
            const rawData = scenarioFullData.data; // Expensas

            const cfData = scenarioFullData.cashFlow; // Cash Flow Data
            const cfCalculated = cfData.calculatedCF; // Cash Flow Calculated
            const cfMonthStatus = cfData.monthStatusCF; // Cash Flow Status
            const cfRawData = { ingresos: cfData.rubrosIngresosCFData, egresos: cfData.rubrosEgresosCFData}; // Cash Flow Raw-like

            try {
                if (context === 'expensas') {
                    // ... (lógica existente para expensas, usando calculatedData, monthStatusData, rawData)
                    if (metric === 'gasto' || metric === 'ingreso') {
                        const tipo = metric; const tipoPlural = tipo === 'gasto' ? 'gastos' : 'ingresos';
                        if (detail && rubro) {
                            const detailValues = rawData[rubro.type]?.[rubro.name]?.detailsData?.[detail.name];
                            if (detailValues) {
                                if (monthIndex !== -1) { const valor = detailValues[monthIndex]; const statusVal = monthStatusData[rubro.type]?.[rubro.name]?.[detail.name]?.[monthIndex]; botResponse = `El ${tipo} para '${detail.name}' (rubro '${rubro.name}') en ${monthName} ${year} fue: ${formatCurrency(valor)} (Estado: ${statusVal}).`; }
                                else if (annual) { const totalAnualDetalle = detailValues.reduce((sum, v) => sum + (parseFloat(v) || 0), 0); botResponse = `El ${tipo} anual para '${detail.name}' (rubro '${rubro.name}') en ${year} fue: ${formatCurrency(totalAnualDetalle)}.`; }
                                else { botResponse = `Para el detalle '${detail.name}' (rubro '${rubro.name}'), ¿quieres el valor mensual o anual para ${year}?`; }
                            } else { botResponse = `No encontré datos para el detalle '${detail.name}' (rubro '${rubro.name}') en el escenario ${scenarioName} (${year}).`; }
                        } else if (rubro) {
                            const rubroCalcData = calculatedData[tipoPlural === 'gastos' ? 'totalGastoRubroMes' : 'totalIngresoRubroMes']?.[rubro.name];
                            if (rubroCalcData) {
                                if (monthIndex !== -1) { botResponse = `El ${tipo} total en '${rubro.name}' para ${monthName} ${year} es: ${formatCurrency(rubroCalcData[monthIndex])}.`; }
                                else if (annual) { botResponse = `El ${tipo} anual total en '${rubro.name}' para ${year} es: ${formatCurrency(calculatedData.annualTotals?.[tipoPlural]?.[rubro.name])}.`; }
                                else { botResponse = `Para el rubro de ${tipoPlural} '${rubro.name}' (${year}), ¿quieres el valor mensual o el total anual?`; }
                            } else { botResponse = `No encontré datos calculados para el rubro '${rubro.name}' en ${scenarioName} (${year}).`; }
                        } else if (general) {
                            if (monthIndex !== -1) { botResponse = `El ${tipo} total proyectado para ${monthName} ${year} es: ${formatCurrency(calculatedData[tipoPlural === 'gastos' ? 'totalGastoProyectadoMes' : 'totalIngresoProyectadoMes']?.[monthIndex])}.`; }
                            else if (annual) { botResponse = `El ${tipo} total anual proyectado para ${year} es: ${formatCurrency(calculatedData.annualTotals?.[tipoPlural]?.__TOTAL__)}.`; }
                            else { botResponse = `Para el ${tipo} total (${year}), ¿quieres el valor de un mes o el anual?`; }
                        } else { botResponse = `No entendí bien tu pregunta sobre ${tipoPlural}. Especifica si es total, un rubro o un detalle, y el período.`; }
                    }
                    else if (metric === 'cuotaReal' || metric === 'cuotaIPC' || metric === 'cuotaSGastos' || metric === 'cuota') {
                        // ... (lógica de cuotas)
                        if (monthIndex !== -1) {
                            let valorCuota, nombreCuota;
                            if (metric === 'cuotaReal' || (metric === 'cuota' && getKeywordMatch(entities.normalized, "real"))) { valorCuota = calculatedData.cuotaRealBaseMes?.[monthIndex]; nombreCuota = "Expensa Real Base por UF"; }
                            else if (metric === 'cuotaIPC' || (metric === 'cuota' && getKeywordMatch(entities.normalized, "ipc"))) { valorCuota = calculatedData.cuotaIpcMes?.[monthIndex]; nombreCuota = "Cuota IPC por UF"; }
                            else if (metric === 'cuotaSGastos' || (metric === 'cuota' && getKeywordMatch(entities.normalized, "sobre gasto"))) { valorCuota = calculatedData.cuotaSobreGastosMes?.[monthIndex]; nombreCuota = "Cuota s/Gastos por UF"; }
                            else if (metric === 'cuota') {botResponse = `¿Qué tipo de cuota te interesa para ${monthName} ${year}? (Ej: real, con IPC, sobre gastos).`; valorCuota=undefined;}

                            if (valorCuota !== undefined) botResponse = `La ${nombreCuota} para ${monthName} ${year} es: ${formatCurrency(valorCuota)}.`;
                            else if (metric !== 'cuota') botResponse = `No encontré datos para esa cuota en ${monthName} ${year}.`;
                        } else { botResponse = `¿Para qué mes quieres saber esa cuota (año ${year})?`; }
                    }
                    else if (metric === 'fondoReserva') { /* ... */ }
                    else if (metric === 'ipcMensual') { /* ... */ }
                    else if (metric === 'ipcAcumulado') { /* ... */ }
                    else if (metric === 'coeficienteAsignado') { /* ... */ }
                    else if (metric === 'coeficienteValor') { /* ... */ }
                    else if (metric === 'ufCantidad') { /* ... */ }
                }
                else if (context === 'cashflow') {
                    if (metric === 'saldoInicialCF') {
                        if (monthIndex !== -1) botResponse = `El Saldo Inicial de Caja para ${monthName} ${year} es: ${formatCurrency(cfData.saldoInicialCaja[monthIndex])}.`;
                        else botResponse = `¿Para qué mes quieres el Saldo Inicial de Caja (${year})?`;
                    }
                    else if (metric === 'saldoFinalCF') {
                        if (monthIndex !== -1) botResponse = `El Saldo Final de Caja proyectado para ${monthName} ${year} es: ${formatCurrency(cfCalculated.saldoFinalCajaMes[monthIndex])}.`;
                        else if (annual) botResponse = `El Saldo Final de Caja proyectado para Diciembre ${year} es: ${formatCurrency(cfCalculated.saldoFinalCajaMes[11])}.`;
                        else botResponse = `¿Quieres el Saldo Final de Caja mensual o el de fin de año para ${year}?`;
                    }
                    else if (metric === 'flujoNetoCF') {
                        if (monthIndex !== -1) botResponse = `El Flujo Neto de Caja para ${monthName} ${year} es: ${formatCurrency(cfCalculated.flujoNetoMesCF[monthIndex])}.`;
                        else if (annual) botResponse = `El Flujo Neto de Caja Anual para ${year} es: ${formatCurrency(cfCalculated.annualTotalsCF.flujoNeto)}.`;
                        else botResponse = `¿Quieres el Flujo Neto de Caja mensual o anual para ${year}?`;
                    }
                    else if (metric === 'otrosIngresosCF' || metric === 'egresosCF') {
                        const tipoCF = metric === 'otrosIngresosCF' ? 'ingresos' : 'egresos';
                        const tituloTipoCF = metric === 'otrosIngresosCF' ? 'Otros Ingresos Efectivos CF' : 'Egresos Efectivos CF';

                        if (rubro && rubro.context === 'cashflow' && rubro.type === tipoCF) { // Consulta por un rubro específico de CF
                            const rubroCFData = cfRawData[tipoCF]?.[rubro.name]?.detailsData?.["Valor"];
                            if (rubroCFData) {
                                if (monthIndex !== -1) {
                                    const valor = rubroCFData[monthIndex];
                                    const statusVal = cfMonthStatus[tipoCF]?.[rubro.name]?.["Valor"]?.[monthIndex];
                                    botResponse = `El valor de '${rubro.name}' (${tituloTipoCF}) en ${monthName} ${year} es: ${formatCurrency(valor)} (Estado: ${statusVal}).`;
                                } else if (annual) {
                                    const totalAnualRubroCF = rubroCFData.reduce((sum, v) => sum + (parseFloat(v) || 0), 0);
                                    botResponse = `El total anual para '${rubro.name}' (${tituloTipoCF}) en ${year} es: ${formatCurrency(totalAnualRubroCF)}.`;
                                } else { botResponse = `Para el rubro CF '${rubro.name}', ¿quieres el valor mensual o anual para ${year}?`; }
                            } else { botResponse = `No encontré datos para el rubro CF '${rubro.name}'.`; }
                        } else if (general) { // Consulta por el total de "Otros Ingresos CF" o "Egresos CF"
                            const totalMesArray = tipoCF === 'ingresos' ? cfCalculated.totalOtrosIngresosCFMes : cfCalculated.totalEgresosCFMes;
                            const totalAnualVal = tipoCF === 'ingresos' ? cfCalculated.annualTotalsCF.otrosIngresos : cfCalculated.annualTotalsCF.egresos;
                            if (monthIndex !== -1) {
                                botResponse = `El total de ${tituloTipoCF} para ${monthName} ${year} es: ${formatCurrency(totalMesArray[monthIndex])}.`;
                            } else if (annual) {
                                botResponse = `El total anual de ${tituloTipoCF} para ${year} es: ${formatCurrency(totalAnualVal)}.`;
                            } else { botResponse = `Para el total de ${tituloTipoCF} (${year}), ¿quieres un valor mensual o el anual?`; }
                        } else { botResponse = `No especificaste un rubro para ${tituloTipoCF}.`; }
                    }
                }

                // Métricas comunes o que pueden aplicar a ambos contextos
                if (metric === 'status') {
                    if (context === 'expensas') {
                        // ... (lógica de status para expensas)
                        if (detail && rubro && monthIndex !== -1) { const status = monthStatusData[subjectTypeFromParse || rubro.type]?.[rubro.name]?.[detail.name]?.[monthIndex]; botResponse = status ? `El estado para '${detail.name}' (${rubro.name}) en ${monthName} ${year} es: ${status}.` : `No encontré info de estado para ese detalle/rubro/mes.`; }
                        else if (rubro && monthIndex !== -1) { let esReal = true, tieneDatos = false; const detallesRubro = Object.keys(monthStatusData[subjectTypeFromParse || rubro.type]?.[rubro.name] || {}); if (detallesRubro.length > 0) tieneDatos = true; for(const d of detallesRubro) if(monthStatusData[subjectTypeFromParse || rubro.type]?.[rubro.name]?.[d]?.[monthIndex] !== 'REAL') esReal = false; botResponse = tieneDatos ? `El estado general del rubro '${rubro.name}' en ${monthName} ${year} es: ${esReal ? 'REAL (todos sus detalles son REALES)' : 'ESTIMADO (alguno/todos sus detalles son ESTIMADOS)'}.` : `No hay detalles con datos para el rubro '${rubro.name}' en ${monthName} ${year}.`; }
                        else if (monthIndex !== -1) { botResponse = `El estado general de los datos (expensas) para ${monthName} ${year} es: ${calculatedData.monthOverallStatus?.[monthIndex]}.`; }
                        else { botResponse = "Para el estado de expensas, dime de qué (rubro, detalle o general) y para qué mes y año."; }

                    } else if (context === 'cashflow') {
                        if (rubro && rubro.context === 'cashflow' && monthIndex !== -1) {
                            const statusVal = cfMonthStatus[rubro.type]?.[rubro.name]?.["Valor"]?.[monthIndex];
                            botResponse = statusVal ? `El estado para el rubro CF '${rubro.name}' en ${monthName} ${year} es: ${statusVal}.` : `No encontré info de estado para ese rubro CF/mes.`;
                        } else if (monthIndex !== -1 && metric === 'saldoInicialCF') { // Estado del saldo inicial de Enero
                             botResponse = `El estado del Saldo Inicial de Caja para Enero ${year} es: ${cfMonthStatus.saldoInicialCajaEnero}. (Los demás meses heredan).`;
                        } else if (monthIndex !== -1) { // Estado general del mes CF
                            botResponse = `El estado general del Cash Flow para ${monthName} ${year} es: ${cfCalculated.monthOverallStatusCF?.[monthIndex]}.`;
                        } else { botResponse = "Para el estado del Cash Flow, dime si es un rubro CF, el saldo inicial de enero, o el estado general del mes, y para qué período.";}
                    }
                }
                // Operaciones como promedio, diferencia, mayor, menor
                else if (operation) {
                    // Aquí se necesitaría lógica más compleja para manejar operaciones sobre datos de expensas o CF
                    // Por ahora, un mensaje genérico si no se implementa específicamente para CF
                    if (context === 'cashflow' && (operation === 'promedio' || operation === 'diferencia' || operation === 'mayor' || operation === 'menor')) {
                        // Ejemplo simple para promedio de Flujo Neto CF
                        if (operation === 'promedio' && metric === 'flujoNetoCF' && annual) {
                            const sum = cfCalculated.flujoNetoMesCF.reduce((a,b) => a + (b||0),0);
                            botResponse = `El promedio mensual del Flujo Neto de Caja para ${year} es: ${formatCurrency(sum/12)}.`;
                        } else {
                           botResponse = `La operación '${operation}' para datos de Cash Flow aún no está completamente implementada. Intenta una consulta más simple.`;
                        }
                    } else if (context === 'expensas') {
                         // ... (lógica existente de operaciones para expensas)
                        if (operation === 'promedio') {
                            let dataArray, itemName;
                            if (rubro) { dataArray = calculatedData[subjectTypeFromParse === 'gastos' ? 'totalGastoRubroMes' : 'totalIngresoRubroMes']?.[rubro.name]; itemName = `'${rubro.name}' (${subjectTypeFromParse})`; }
                            else if (general && subjectTypeFromParse) { dataArray = calculatedData[subjectTypeFromParse === 'gastos' ? 'totalGastoProyectadoMes' : 'totalIngresoProyectadoMes']; itemName = `total de ${subjectTypeFromParse}`; }
                            if (dataArray) { const sum = dataArray.reduce((a, b) => a + (b || 0), 0); botResponse = `El promedio mensual para ${itemName} en ${year} es: ${formatCurrency(sum / 12)}.`; }
                            else { botResponse = `No pude calcular el promedio. Necesito saber de qué rubro o si es el total de gastos/ingresos.`; }
                        }
                        else if (operation === 'diferencia') { /* ... */ }
                        else if (operation === 'comparacion') { /* ... */ }
                        else if (operation === 'mayor' || operation === 'menor') { /* ... */ }
                    }
                }


            } catch (error) {
                console.error("Error en processSingleQueryWithData:", error, "Entidades:", JSON.parse(JSON.stringify(entities)));
                botResponse = "¡Uy! Algo salió mal al procesar tu pregunta. Intenta de nuevo o prueba una pregunta más simple.";
            }
            addMessageToChat(botResponse, 'bot');
        }

        function processUserQuery(rawQueryOriginal) {
            const normalizedOriginalQuery = normalizeBotQuery(rawQueryOriginal);

            if (getKeywordMatch(normalizedOriginalQuery, "hola")) {
                addMessageToChat("¡Hola! Soy Centaurito. ¿En qué puedo ayudarte hoy con las expensas o el cash flow?", 'bot'); return;
            }
            if (getKeywordMatch(normalizedOriginalQuery, "gracias")) {
                addMessageToChat("¡De nada! Si necesitas algo más, solo pregunta.", 'bot'); return;
            }
            if (getKeywordMatch(normalizedOriginalQuery, "adios")) {
                addMessageToChat("¡Hasta luego! Que tengas un buen día.", 'bot'); return;
            }
            if (getKeywordMatch(normalizedOriginalQuery, "ayuda")) {
                 const helpText = "Puedo ayudarte con:\n" +
                                  "**Expensas:**\n" +
                                  "- Gastos/Ingresos: totales, por rubro o detalle (mensual/anual).\n" +
                                  "  Ej: 'gasto de Seguridad en enero', 'total de ingresos anual'.\n" +
                                  "- Cuotas: Real Base, s/Gastos, con IPC (mensual).\n" +
                                  "  Ej: 'cuota con ipc en marzo 2023'.\n" +
                                  "- Fondo de Reserva (mensual/anual).\n" +
                                  "- IPC: mensual o acumulado entre meses.\n" +
                                  "- Estado (Real/Estimado) de los datos.\n" +
                                  "- Coeficientes: asignación a rubros, valor mensual.\n" +
                                  "- Cantidad de UF.\n" +
                                  "**Cash Flow:**\n" +
                                  "- Saldos de Caja: inicial o final (mensual/anual Diciembre).\n" +
                                  "  Ej: 'saldo inicial de caja en febrero', 'saldo final de caja anual'.\n" +
                                  "- Flujo Neto de Caja (mensual/anual).\n" +
                                  "- Otros Ingresos CF / Egresos CF: totales o por rubro CF (mensual/anual).\n" +
                                  "  Ej: 'otros ingresos cf en mayo', 'egresos cf de Pagos Proveedores CF anual'.\n" +
                                  "- Estado (Real/Estimado) de datos CF.\n" +
                                  "**General:**\n" +
                                  "- Operaciones: Promedios, Diferencias, Comparaciones (cuotas), Mayor/Menor.\n" +
                                  "Intenta ser específico con el mes y el año si es relevante.";
                addMessageToChat(helpText, 'bot'); return;
            }

            const entities = parseQuery(rawQueryOriginal);
            console.log("Parsed Entities:", JSON.parse(JSON.stringify(entities)));
            executeParsedQuery(entities);
        }
        // --- END CHATBOT LOGIC (MEJORADO) ---


        // --- Punto de Entrada Principal del Script ---
        document.addEventListener('DOMContentLoaded', () => {
            loadState();
            initTheme();
            validateAndSetActiveScenario();

            const cuotaInfoSpan1 = document.getElementById('cuota-rubro-name-info');
            if (cuotaInfoSpan1) cuotaInfoSpan1.textContent = CUOTA_RUBRO_NAME;
            const cuotaInfoSpan2 = document.getElementById('cuota-rubro-name-info2');
            if (cuotaInfoSpan2) cuotaInfoSpan2.textContent = CUOTA_RUBRO_NAME;

            initUI();
            addEventListeners(); // Esto ahora incluye los listeners para CF
            updateUI(); // Esto ahora incluye la renderización de la pestaña CF y su gráfico
            initChatbot();

            console.log(`App ${STORAGE_KEY} Inicializada Completamente.`);
        });

    </script>

<!-- ======== SCRIPT MANUAL REAL / ESTIMADO v3 (CHATGPT) ======== -->
<script>
(function(){
  document.addEventListener('DOMContentLoaded', ()=>{
    document.addEventListener('dblclick', function(ev){
      const target = ev.target;
      /* Inputs dentro de Cash‑Flow u otros formularios */
      if (target.tagName === 'INPUT' && (target.classList?.contains('real-month-cell') || target.classList?.contains('estimated-month-cell'))) {
          toggleStatusOnInput(target);
          return;
      }

      /* Celdas de tablas */
      const td = target.closest('td');
      if(!td) return;

      const summaryTbl = td.closest('#dashboard-summary');
      const hasStatusClass = td.classList.contains('real-month-cell') || td.classList.contains('estimated-month-cell');

      if (summaryTbl || hasStatusClass) {
          toggleStatusOnCell(td, !!summaryTbl);
      }
    });

    /* ----- Helpers ----- */
    function toggleStatusOnInput(inp){
        const wasReal = inp.classList.contains('real-month-cell');
        const newIsReal = !wasReal;
        inp.classList.toggle('real-month-cell', newIsReal);
        inp.classList.toggle('estimated-month-cell', !newIsReal);
        const newStatus = newIsReal ? 'REAL' : 'Estimado';

        const mIdx = parseInt(inp.dataset.month);
        const cfType = inp.dataset.cftype;
        const cfRubro = inp.dataset.cfrubro;
        if (!isNaN(mIdx) && cfType && cfRubro && window.getCurrentScenarioData){
            const scenario = window.getCurrentScenarioData();
            if(scenario){
                scenario.cashFlow = scenario.cashFlow || {};
                scenario.cashFlow.monthStatusCF = scenario.cashFlow.monthStatusCF || {};
                const branch = scenario.cashFlow.monthStatusCF;
                branch[cfType] = branch[cfType] || {};
                branch[cfType][cfRubro] = branch[cfType][cfRubro] || {};
                const arr = branch[cfType][cfRubro]['Valor'] = branch[cfType][cfRubro]['Valor'] || Array(12).fill('Estimado');
                arr[mIdx] = newStatus;
            }
        }
        if (typeof window.saveState === 'function') window.saveState();
        if (typeof window.calculateAll === 'function') window.calculateAll(window.getCurrentScenarioData());
    }

    function toggleStatusOnCell(cell, isSummary){
        const wasReal = cell.classList.contains('real-month-cell');
        const newIsReal = !wasReal;
        const newStatusCls = newIsReal ? 'real-month-cell' : 'estimated-month-cell';
        cell.classList.remove('real-month-cell', 'estimated-month-cell');
        cell.classList.add(newStatusCls);

        /* Persistir sólo si no es Summary (porque summary se reconstruye) */
        if (isSummary) return;

        const row = cell.closest('tr');
        if(!row) return;

        const type = row.dataset.type; // 'gastos' | 'ingresos'
        const rubro = row.dataset.rubro;
        const detail = row.dataset.detail || row.cells[0]?.textContent?.trim();
        if(!type || !rubro || !detail) return;

        /* Calcular índice de mes ajustando columnas fijas */
        const monthIdx = cell.cellIndex - (type === 'gastos' ? 2 : 1);
        if(monthIdx < 0 || monthIdx > 11) return;

        if(window.getCurrentScenarioData){
            const scenario = window.getCurrentScenarioData();
            if(scenario){
                scenario.monthStatus = scenario.monthStatus || {gastos:{}, ingresos:{}};
                scenario.monthStatus[type] = scenario.monthStatus[type] || {};
                scenario.monthStatus[type][rubro] = scenario.monthStatus[type][rubro] || {};
                scenario.monthStatus[type][rubro][detail] = scenario.monthStatus[type][rubro][detail] || Array(12).fill('Estimado');
                scenario.monthStatus[type][rubro][detail][monthIdx] = newIsReal ? 'REAL' : 'Estimado';
                if (typeof window.saveState === 'function') window.saveState();
                if (typeof window.calculateAll === 'function') window.calculateAll(scenario);
            }
        }
    }
  });
})();
</script>
<!-- ======== FIN SCRIPT MANUAL REAL / ESTIMADO v3 ======== -->

</body>
</html>