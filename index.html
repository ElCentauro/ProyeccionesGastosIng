<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="favicon.png">
    <title>Proyección Expensas - Barrio El Centauro</title>
    <!-- Librería SheetJS (js-xlsx) para leer/escribir Excel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Librería Chart.js para gráficos -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- Plugin doughnut 3D shadow -->
<script>
/* Plugin: doughnutShadow3D
   Añade una sombra suave debajo de cada porción para simular profundidad 3 D.
   Seguro para todos los datasets (evita NaN en createRadialGradient). */
const doughnutShadow3D = {
  id: 'doughnutShadow3D',
  afterDatasetDraw(chart, args, opts) {
    const {ctx} = chart;
    if (args.meta.type !== 'doughnut') return;

    args.meta.data.forEach(segment => {
      const {x, y, startAngle, endAngle, innerRadius, outerRadius} = segment;
      // Ensure numeric validity before attempting to draw
      if (!isFinite(x) || !isFinite(y) || !isFinite(startAngle) || !isFinite(endAngle) || !isFinite(innerRadius) || !isFinite(outerRadius)) {
          console.warn("Skipping shadow for segment due to invalid dimensions:", segment);
          return;
      }

      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.15)';      // shadow color
      ctx.translate(0, 4);                     // vertical offset
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.arc(x, y, outerRadius, startAngle, endAngle);
      ctx.arc(x, y, innerRadius, endAngle, startAngle, true);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    });
  }
};
// Registrar plugin globalmente
if (window.Chart && !Chart.registry.plugins.get('doughnutShadow3D')) {
  Chart.register(doughnutShadow3D);
}
</script>

    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts (Inter) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- Reset Básico y Fuentes --- */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        *{ /* Add a smoother color transition to elements not covered by explicit transitions */
            transition-property: background-color, color, border-color, box-shadow, fill, stroke, transform, opacity; /* Added opacity and transform */
            transition-duration: 0.3s;
            transition-timing-function: ease-in-out;
        }
        html { scroll-behavior: smooth; font-size: 16px; /* Base font size */ }
        body {
            font-family: 'Inter', 'Segoe UI', sans-serif;
            line-height: 1.7; /* Improved readability */
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* --- Variables de Color (Paleta Refinada) --- */
        :root {
            --bg-color: #f8f9fa;              /* Slightly off-white */
            --text-color: #343a40;            /* Darker gray */
            --primary-color: #007bff;          /* Classic blue */
            --primary-color-darker: #0056b3;   /* Darker blue for hover */
            --secondary-color: #6c757d;        /* Standard gray */
            --secondary-color-darker: #5a6268; /* Darker gray for hover */
            --accent-color: #28a745;           /* Vibrant green */
            --accent-color-darker: #218838;    /* Darker green for hover */
            --danger-color: #dc3545;           /* Red */
            --danger-color-darker: #c82333;    /* Darker red */
            --warning-color: #ffc107;           /* Yellow */
            --warning-color-darker: #e0a800;   /* Darker yellow */
            --info-color: #17a2b8;             /* Teal */
            --info-color-darker: #138496;      /* Darker teal */
            --success-color: var(--accent-color); /* Alias for consistency */
            --success-color-darker: var(--accent-color-darker); /* Alias */

            --border-color: #dee2e6;           /* Light gray border */
            --header-bg: #ffffff;              /* White header */
            --card-bg: #ffffff;                /* White cards */
            --shadow-color: rgba(0, 0, 0, 0.08); /* Softer shadow */
            --input-bg: #ffffff;
            --input-border: #ced4da;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(0, 123, 255, 0.25);
            --button-text: #ffffff;
            --button-warning-text: #212529; /* Dark text for yellow button */
            --table-header-bg: #eef2f7;        /* Lighter table header */
            --table-row-hover: #f1f3f5;        /* Subtle hover */
            --expandable-row-bg: #f8f9fa;      /* Same as body bg for subtle diff */
            --clickable-row-hover: #e9ecef;    /* Slightly darker hover for clickable rows */
            --disabled-bg: #e9ecef;
            --disabled-text: #6c757d;
            --disabled-border: #ced4da;

            /* >>> COLORES REAL/ESTIMADO <<< */
            --real-month-bg: #d1f7d9; /* Light, fresh green */
            --estimated-month-bg: #fff3cd; /* Soft Yellow */
        }

        body.dark-mode {
            --bg-color: #1a1a1a;              /* Very dark gray */
            --text-color: #e0e0e0;            /* Light gray text */
            --primary-color: #58a6ff;          /* Brighter blue */
            --primary-color-darker: #79b8ff;   /* Lighter blue for hover */
            --secondary-color: #8b949e;        /* Lighter gray */
            --secondary-color-darker: #a0a8b0; /* Lighter gray hover */
            --accent-color: #56d364;           /* Brighter green */
            --accent-color-darker: #6bde7a;    /* Lighter green hover */
            --danger-color: #f85149;           /* Bright red */
            --danger-color-darker: #fa6a61;    /* Lighter red */
            --warning-color: #f0b41e;          /* Bright yellow */
            --warning-color-darker: #f2c037;   /* Lighter yellow */
            --info-color: #6cb6f1;             /* Bright teal */
            --info-color-darker: #85c3f4;      /* Lighter teal */
            --success-color: var(--accent-color);
            --success-color-darker: var(--accent-color-darker);

            --border-color: #444c56;           /* Darker border */
            --header-bg: #2c2c2c;              /* Dark card background */
            --card-bg: #2c2c2c;                /* Dark card background */
            --shadow-color: rgba(255, 255, 255, 0.05); /* Subtle white shadow */
            --input-bg: #3a3f44;
            --input-border: #5a6268;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(88, 166, 255, 0.25);
            --button-text: #1a1a1a; /* Dark text on bright buttons */
            --button-warning-text: #1a1a1a;
            --table-header-bg: #343a40;        /* Darker header */
            --table-row-hover: #3e444a;        /* Subtle dark hover */
            --expandable-row-bg: #343a40;      /* Darker expandable row bg */
            --clickable-row-hover: #495057;    /* Darker hover for clickable */
            --disabled-bg: #495057;
            --disabled-text: #adb5bd;
            --disabled-border: #5a6268;

            /* >>> COLORES REAL/ESTIMADO OSCURO <<< */
            --real-month-bg: #1c4a2b; /* Darker Green */
            --estimated-month-bg: #5a4a1d; /* Dark Yellow/Brown */
        }

        /* --- Estilos Generales --- */


        h1, h2, h3, h4 { color: var(--primary-color); margin-bottom: 1em; font-weight: 600; }
        h1 { font-size: 2.2rem; text-align: center; }
        h2 { font-size: 1.8rem; border-bottom: 2px solid var(--accent-color); padding-bottom: 0.4em; }
        h3 { font-size: 1.4rem; margin-top: 1.8em; }
        h4 { font-size: 1.15rem; color: var(--secondary-color); margin-top: 1.2em; margin-bottom: 0.6em; }
        a { color: var(--primary-color); text-decoration: none; transition: color 0.2s ease; }
        a:hover { color: var(--primary-color-darker); text-decoration: underline; }

        button {
            padding: 12px 22px;
            border: 1px solid transparent; /* Added border for consistency */
            border-radius: 6px;
            background-color: var(--primary-color);
            color: var(--button-text);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition-property: background-color, border-color, transform, box-shadow, opacity; /* Added transition property explicitly */
            transition-duration: 0.2s;
            transition-timing-function: ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center; /* Center content */
            gap: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            line-height: 1.5; /* Ensure consistent height */
            text-align: center; /* Ensure text aligns center */
        }
        button:hover {
            background-color: var(--primary-color-darker);
            border-color: var(--primary-color-darker);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        button:focus {
            outline: none;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        button:disabled {
            background-color: var(--disabled-bg);
            color: var(--disabled-text);
            border-color: var(--disabled-border);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.7; /* Visually indicate disabled state */
        }
        button i { margin-right: 2px; /* Keep small margin */ }

        /* Button variants */
        .button-primary { background-color: var(--primary-color); border-color: var(--primary-color); color: var(--button-text); }
        .button-primary:hover { background-color: var(--primary-color-darker); border-color: var(--primary-color-darker); }
        .button-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: var(--button-text); }
        .button-secondary:hover { background-color: var(--secondary-color-darker); border-color: var(--secondary-color-darker); }
        .button-success { background-color: var(--success-color); border-color: var(--success-color); color: var(--button-text); }
        .button-success:hover { background-color: var(--success-color-darker); border-color: var(--success-color-darker); }
        .button-danger { background-color: var(--danger-color); border-color: var(--danger-color); color: var(--button-text); }
        .button-danger:hover { background-color: var(--danger-color-darker); border-color: var(--danger-color-darker); }
        .button-warning { background-color: var(--warning-color); border-color: var(--warning-color); color: var(--button-warning-text); }
        .button-warning:hover { background-color: var(--warning-color-darker); border-color: var(--warning-color-darker); }
        .button-info { background-color: var(--info-color); border-color: var(--info-color); color: var(--button-text); }
        .button-info:hover { background-color: var(--info-color-darker); border-color: var(--info-color-darker); }
        .button-sm { padding: 6px 12px; font-size: 0.85rem; gap: 6px;}
        .button-lg { padding: 15px 30px; font-size: 1.1rem; }


        /* --- Header --- */
        header {
            background-color: var(--header-bg);
            padding: 15px 0;
            box-shadow: 0 2px 5px var(--shadow-color);
            position: sticky; top: 0; z-index: 1000;
            border-bottom: 1px solid var(--border-color);
        }
        header .container { display: flex; justify-content: space-between; align-items: center; padding-top: 0; padding-bottom: 0; }
        .app-title { font-size: 1.6rem; font-weight: 700; color: var(--primary-color); }
        /* Removed transition as '*' covers it */
        #theme-toggle { font-size: 1.3rem; background: none; border: none; color: var(--text-color); cursor: pointer; padding: 5px; border-radius: 50%;}
        #theme-toggle:hover { background-color: var(--table-row-hover); }

        /* --- Navegación / Pestañas --- */
        .tabs {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 5px;
        }
        /* Removed transition from tab-link as '*' covers it */
        .tab-link {
            padding: 12px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-bottom: -1px; /* Overlap bottom border */
            background-color: transparent;
            color: var(--secondary-color);
            font-size: 1rem;
            font-weight: 600;
            border-radius: 6px 6px 0 0;
            display: inline-flex; /* Align icon and text */
            align-items: center;
            gap: 8px;
        }
        .tab-link:hover {
             color: var(--primary-color);
             background-color: var(--table-row-hover);
        }
        .tab-link.active {
            background-color: var(--card-bg);
            border-color: var(--border-color);
            border-bottom-color: var(--card-bg); /* Hide bottom border part */
            color: var(--primary-color);
            font-weight: 700;
        }
        .tab-content {
            display: none;
            padding: 30px;
            border: 1px solid var(--border-color);
            border-top: none;
            background-color: var(--card-bg);
            border-radius: 0 0 6px 6px;
            box-shadow: 0 5px 15px var(--shadow-color);
        }
        .tab-content.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Formularios y Entradas --- */
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-color); font-size: 0.95rem;}
        input[type="text"], input[type="number"], input[type="file"], select, textarea {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid var(--input-border);
            border-radius: 6px;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1rem;
             /* Removed transition as '*' covers it */
        }
        input:focus, select:focus, textarea:focus {
            border-color: var(--input-focus-border);
            outline: 0;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        input:disabled, select:disabled, textarea:disabled {
             background-color: var(--disabled-bg);
             color: var(--disabled-text);
             border-color: var(--disabled-border);
             cursor: not-allowed;
        }
        input[type="number"] { text-align: right; -moz-appearance: textfield; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { margin: 0; }
        input[type="file"] { padding: 8px; line-height: 1.5; } /* Adjust file input padding */
        .input-group { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
        .input-group label { margin-bottom: 0; font-weight: normal;}
        .input-group input[type="radio"] { width: auto; margin-right: 5px; }
        .input-small { width: 150px; display: inline-block; margin-left: 10px; }

        /* --- Tablas --- */
        .table-container { overflow-x: auto; margin-top: 25px; border: 1px solid var(--border-color); border-radius: 6px; }
        table { width: 100%; border-collapse: collapse; background-color: var(--card-bg); font-size: 0.9rem; }
        th, td {
            padding: 12px 15px;
            border: none;
            border-bottom: 1px solid var(--border-color);
            text-align: left;
            vertical-align: middle;
            white-space: nowrap;
        }
        th {
            background-color: var(--table-header-bg);
            font-weight: 600;
            position: sticky; top: 0; z-index: 10;
            border-bottom-width: 2px;
        }
        tbody tr:last-child td { border-bottom: none; }
        /* Use a more specific selector for hover not overriding background colors below */
        tbody tr:hover td { background-color: var(--table-row-hover); }


        /* Cell specific styles */
        /* Target only cells within .collapsible-table .detail-row for coloring */
        .collapsible-table tbody tr.detail-row td.real-month-cell { background-color: var(--real-month-bg); }
        .collapsible-table tbody tr.detail-row td.estimated-month-cell { background-color: var(--estimated-month-bg); }

         /* Handle hover for colored cells more explicitly for detail rows */
        .collapsible-table tbody tr.detail-row:hover td.real-month-cell { background-color: color-mix(in srgb, var(--real-month-bg), var(--table-row-hover) 30%); }
        .collapsible-table tbody tr.detail-row:hover td.estimated-month-cell { background-color: color-mix(in srgb, var(--estimated-month-bg), var(--table-row-hover) 30%); }


        td.number-cell { text-align: right; font-variant-numeric: tabular-nums; }
        /*td.input-cell input { width: 100px; padding: 6px; font-size: 0.9rem; text-align: right; }*/ /* Now using monthly-inputs-grid styles */
        /*td.input-cell input:disabled { background-color: transparent; border: none; color: var(--disabled-text);}*/ /* Now using monthly-inputs-grid styles */
        .text-muted { color: var(--secondary-color); font-style: italic; font-size: 0.9em;}

        /* --- Tablas Desplegables --- */
        /* Removed transition as '*' covers it */
        .collapsible-table tbody tr.rubro-total-row { font-weight: bold; cursor: pointer; background-color: var(--expandable-row-bg); }
        .collapsible-table tbody tr.rubro-total-row:hover { background-color: var(--clickable-row-hover); }
        .collapsible-table tbody tr.rubro-total-row td:first-child::before {
            content: '\f078'; /* fa-chevron-down */
            font-family: 'Font Awesome 6 Free'; font-weight: 900; margin-right: 12px; display: inline-block; transition: transform 0.2s ease-in-out; color: var(--primary-color);
        }
        .collapsible-table tbody tr.rubro-total-row.collapsed td:first-child::before { transform: rotate(-90deg); }
        /* Removed transition as '*' covers it */
        .collapsible-table tbody tr.detail-row { display: table-row; background-color: var(--card-bg); }
        .collapsible-table tbody tr.detail-row.hidden { display: none; }
        .collapsible-table tbody tr.detail-row td { font-size: 0.85rem; color: var(--secondary-color); border-color: var(--border-color); }
        .collapsible-table tbody tr.detail-row td:first-child { padding-left: 40px; /* Indent details more */ }
        body.dark-mode .collapsible-table tbody tr.detail-row { background-color: #353535; }
        .collapsible-table tfoot tr { font-weight: bold; background-color: var(--table-header-bg); border-top: 2px solid var(--border-color); }

         /* Styles for Group/Ungroup All buttons */
        .table-actions {
            margin-bottom: 15px;
             display: flex;
             justify-content: flex-end; /* Align buttons to the right */
             gap: 10px;
             flex-wrap: wrap;
        }


        /* --- Componentes UI Específicos --- */
        #dashboard-summary { border-collapse: separate; border-spacing: 0; }
        #dashboard-summary th, #dashboard-summary td { text-align: center; white-space: normal; }
        #dashboard-summary tbody td, #dashboard-summary tfoot td { padding: 10px 8px; }
        #dashboard-summary .month-header { font-weight: bold; }

        .chart-container {
            margin-top: 35px; padding: 30px;
            background-color: var(--card-bg); border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-color);
            position: relative; min-height: 200px; /* Adjusted min height */
        }
        /* Fixed height needed for chart.js responsive container logic */
        .chart-container canvas { max-width: 100%; height: 380px; display: block;}
        /* Added class to manage canvas display when no data */
        .chart-container.no-data canvas { display: none; }


        .chart-no-data {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--secondary-color);
            font-style: italic; font-size: 1.1rem; text-align: center;
             display: none; /* Hidden by default */
        }
         /* Show no-data message when the container has the 'no-data' class */
         .chart-container.no-data .chart-no-data {
             display: block;
         }


        #file-upload-area {
            border: 2px dashed var(--primary-color);
            padding: 45px; text-align: center; background-color: var(--bg-color);
            border-radius: 8px; margin-bottom: 25px; cursor: pointer; /* Removed transition as '*' covers it */
        }
        #file-upload-area:hover { background-color: var(--table-row-hover); border-color: var(--primary-color-darker); }
        #file-upload-area p { margin-bottom: 15px; font-size: 1.1rem; color: var(--secondary-color); }
        #file-upload-area i.fa-file-excel { font-size: 3rem; margin-bottom: 10px; color: var(--accent-color); }
        #file-upload-feedback { margin-top: 15px; font-weight: bold; white-space: pre-wrap; font-size: 0.95rem; min-height: 2em; }

        #reserve-fund-panel { /* This div is now a monthly-inputs-grid */
            margin-top: 20px;
        }


        .config-section {
            border: 1px solid var(--border-color); border-radius: 8px; padding: 25px;
            margin-bottom: 30px; background-color: var(--card-bg);
            box-shadow: 0 3px 7px var(--shadow-color);
        }
        .config-section h4 { border-bottom: 1px solid var(--border-color); padding-bottom: 0.6em; margin-bottom: 1.2em;}
        .management-list { list-style: none; padding: 0; max-height: 350px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 6px; padding: 10px; background-color: var(--bg-color); }
        body.dark-mode .management-list { background-color: #3a3f44; }
        /* Removed transition from li as '*' covers it */
        .management-list li { display: flex; justify-content: space-between; align-items: center; padding: 10px 8px; border-bottom: 1px solid var(--border-color); }
        .management-list li:last-child { border-bottom: none;}
        .management-list li:hover { background-color: var(--table-row-hover); }
        .management-list li span { flex-grow: 1; margin-right: 15px; font-weight: 500; }
        .management-list li select { width: 200px; font-size: 0.88rem; padding: 6px 8px; flex-shrink: 0; }
        .management-list li button { flex-shrink: 0; }
        #coefficient-editor { margin-top: 25px; }
        #coefficient-editor h4 { margin-bottom: 15px;}
        /* #coefficient-editor .table-container { max-height: 450px; overflow-y: auto;} No longer a table-container directly */

        /* Monthly inputs grid style - Applied to #reserve-fund-panel and #coefficient-values-editor */
        .monthly-inputs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); /* Adjusted min-width */
            gap: 15px; /* Slightly reduced gap */
            margin-top: 20px;
            padding: 15px; /* Added padding */
            border: 1px solid var(--border-color); /* Added border */
            border-radius: 6px; /* Added border-radius */
            background-color: var(--bg-color); /* Match management list bg */
             /* Removed transition as '*' covers it */
        }
        body.dark-mode .monthly-inputs-grid { background-color: #3a3f44; }

        .monthly-inputs-grid .form-group {
            margin-bottom: 0; /* Remove default form-group margin */
        }
         .monthly-inputs-grid .form-group label {
             margin-bottom: 5px; /* Smaller margin below label */
             font-weight: normal; /* Normal weight label */
         }
        .monthly-inputs-grid .form-group input {
             width: 100%; /* Make input fill grid cell */
             padding: 8px 10px; /* Adjusted padding */
             font-size: 0.9rem; /* Smaller font size */
             text-align: right; /* Align numbers right */
         }
         .monthly-inputs-grid .input-with-unit {
             display: flex;
             align-items: center;
             gap: 5px; /* Gap between input and unit */
         }
         .monthly-inputs-grid .input-with-unit input {
             flex-grow: 1; /* Input takes available space */
         }
         .monthly-inputs-grid .input-with-unit span {
              flex-shrink: 0; /* Unit doesn't shrink */
              font-weight: normal; /* Unit text normal */
         }


        /* --- Snackbar --- */
        #snackbar {
            visibility: hidden; min-width: 300px; max-width: 90%;
            background-color: var(--success-color); /* Default to success */
            color: var(--button-text); text-align: center;
            border-radius: 6px; padding: 18px 25px; position: fixed; z-index: 1001;
            left: 50%; transform: translateX(-50%); bottom: 30px;
            font-size: 1.05rem; font-weight: 500;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            opacity: 0; transition: visibility 0s 0.5s, opacity 0.5s ease-out, bottom 0.5s ease-out, background-color 0.3s; /* Added bg color transition */
        }
        #snackbar.show {
            visibility: visible; opacity: 1; bottom: 60px;
            transition: opacity 0.5s ease-in, bottom 0.5s ease-in, background-color 0.3s;
        }
        #snackbar.error { background-color: var(--danger-color); color: var(--button-text); }
        #snackbar.warning { background-color: var(--warning-color); color: var(--button-warning-text); }
        #snackbar.info { background-color: var(--info-color); color: var(--button-text); }
        #snackbar.success { background-color: var(--success-color); color: var(--button-text); } /* Ensure success explicit */


        /* --- Footer --- */
        footer {
            margin-top: auto; padding: 20px 0; text-align: center; font-size: 0.95em;
            color: var(--secondary-color); background-color: var(--header-bg);
            border-top: 1px solid var(--border-color);
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 1200px) { .container { width: 98%; } .chart-container canvas { height: 320px; } }
        @media (max-width: 992px) {
             h1 { font-size: 2rem; } h2 { font-size: 1.6rem; } h3 { font-size: 1.3rem; }
             .tabs { justify-content: flex-start; }
             .tab-link { padding: 10px 18px; font-size: 0.95rem;}
             table { font-size: 0.88rem; } th,td {padding: 10px 12px;}
             .management-list li select { width: 150px; } /* Reduce select width */
             /* Allow wrapping text in narrow tables */
            th, td { white-space: normal; }
             /* Adjusting cell padding slightly for smaller screens */
             th:first-child, td:first-child { padding-left: 15px; }
             th:last-child, td:last-child { padding-right: 15px; }
             .monthly-inputs-grid { grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; }
             /*td.input-cell input { width: 90%; /* Make input wider inside td */ }
        }
        @media (max-width: 768px) {
            body { line-height: 1.6; }
            .app-title { font-size: 1.3rem;} #theme-toggle { font-size: 1.1rem;}
            .chart-container { padding: 20px;} .chart-container canvas { height: 280px; }
            .input-group { flex-direction: column; align-items: stretch; gap: 10px;}
            .input-small { margin-left: 0; margin-top: 8px; width: 100%; }
            #reserve-fund-panel .month-config { flex-direction: column; align-items: stretch; }
            #reserve-fund-panel .month-config label { width: 100%; text-align: left; margin-bottom: 5px; }
            #reserve-fund-panel .month-config input { width: 100%; }
            table { font-size: 0.85rem; } /*th, td { padding: 9px 8px; white-space: normal; }*/
            th:first-child, td:first-child { padding-left: 15px; }
            th:last-child, td:last-child { padding-right: 15px; }
            /*td.input-cell input { width: 90%; /* Make input wider inside td */ }
            .management-list li { flex-wrap: wrap; gap: 8px; }
            .management-list li span { flex-basis: 100%; margin-right: 0; } /* Name takes full width */
            .management-list li select { width: calc(100% - 50px); margin-top: 5px; } /* Select almost full width */
            .management-list li button { margin-left: auto; } /* Push button right */
            button { font-size: 0.95rem; padding: 10px 18px;}
            .tabs { gap: 2px; }
            .tab-link { padding: 8px 10px; font-size: 0.85rem;}
             .table-actions { justify-content: center; }
             .monthly-inputs-grid { grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 8px; padding: 10px; }
              .monthly-inputs-grid .form-group label { margin-bottom: 3px; font-size: 0.9em;}
              .monthly-inputs-grid .form-group input { padding: 6px 8px; font-size: 0.85em;}
        }
        @media (max-width: 576px) {
            h1 { font-size: 1.7rem; } .app-title { display: none; } header .container { justify-content: flex-end; }
            .tab-link { padding: 8px 10px; font-size: 0.85rem;}
            th, td { padding: 8px 6px; }
            th:first-child, td:first-child { padding-left: 10px; }
            th:last-child, td:last-child { padding-right: 10px; }
            .chart-container canvas { height: 220px; }
            #snackbar { min-width: 90%; bottom: 20px; font-size: 1rem; padding: 15px 20px; }
            #snackbar.show { bottom: 40px; }
            #file-upload-area { padding: 30px; }
            .management-list li select { width: 100%; } /* Select full width on smallest screens */
             /* Fix columns on small devices to prevent extreme squeezing */
             .monthly-inputs-grid { grid-template-columns: repeat(3, 1fr); /* Fixed 3 columns */ }
             .monthly-inputs-grid .form-group { width: 100%; /* Ensure form group takes full cell width */ }
             .monthly-inputs-grid .input-with-unit { width: 100%; /* Ensure input group takes full form group width */ }

        }
         @media (max-width: 380px) {
              .monthly-inputs-grid { grid-template-columns: repeat(2, 1fr); /* Fixed 2 columns on very small screens */ }
         }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <span class="app-title">Proyección Expensas - El Centauro</span>
            <button id="theme-toggle" title="Cambiar tema"><i class="fas fa-moon"></i></button>
        </div>
    </header>

    <div class="container">
        <div class="tabs">
            <button class="tab-link active" onclick="openTab(event, 'dashboard')"><i class="fas fa-tachometer-alt"></i> Dashboard</button>
            <button class="tab-link" onclick="openTab(event, 'upload')"><i class="fas fa-upload"></i> Cargar Datos</button>
            <button class="tab-link" onclick="openTab(event, 'reserve')"><i class="fas fa-piggy-bank"></i> Fondo Reserva</button>
            <button class="tab-link" onclick="openTab(event, 'settings')"><i class="fas fa-cog"></i> Configuración</button>
            <button class="tab-link" onclick="openTab(event, 'reports')"><i class="fas fa-download"></i> Reportes</button>
        </div>

        <!-- ==================== DASHBOARD ==================== -->
        <div id="dashboard" class="tab-content active">
            <h2><i class="fas fa-tachometer-alt"></i> Dashboard Anual - <span id="dashboard-year"></span> (<span id="dashboard-scenario">Base</span>)</h2>
            <div class="form-group input-group">
                <label for="scenario-selector" style="flex-shrink: 0;">Escenario:</label>
                <select id="scenario-selector" style="flex-grow: 1;"></select>
                <button onclick="createScenario()" class="button-primary button-sm" title="Crear Escenario Nuevo"><i class="fas fa-plus"></i> Crear</button>
                <button onclick="cloneScenario()" class="button-secondary button-sm" title="Clonar Escenario Actual"><i class="fas fa-clone"></i> Clonar</button>
                <button onclick="deleteScenario()" class="button-danger button-sm" title="Eliminar Escenario Actual"><i class="fas fa-trash"></i> Eliminar</button>
                <button id="btnBorrarDatos" class="button-warning button-sm" title="Borrar Datos del Escenario Actual (Gastos, Ingresos, Status)" onclick="clearScenarioData()" ><i class="fas fa-broom"></i> Borrar Datos</button>
                <button onclick="recalculateEstimates()" class="button-info button-sm" title="Proyectar meses estimados de gastos basados en último mes real y coeficientes (acumulativo)"><i class="fas fa-calculator"></i> Calcular Estimados</button>
            </div>

            <h4>Resumen Mensual General</h4>
            <div class="table-container">
                <table id="dashboard-summary">
                    <thead>
                        <tr>
                            <th>Mes</th>
                            <th>Gasto ($)</th>
                            <th>Fondo ($)</th>
                            <th>Cuota s/Gs ($/UF)</th> <!-- Basado en Gasto+Fondo / UF -->
                            <th>IPC Ref (%)</th> <!-- Referencia, now from settings.coefficientTypes.IPC snapshot-->
                            <th>Cuota IPC ($/UF)</th>   <!-- Cuota s/Gs base Enero + IPC acumulado -->
                            <th>Expensa Real ($/UF)</th> <!-- Muestra el valor del rubro Expensas Ordinarias / UF -->
                        </tr>
                    </thead>
                    <tbody><!-- Contenido generado por JS --></tbody>
                    <tfoot><!-- Contenido generado por JS --></tfoot>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Detalle de Gastos Proyectados ($)</h4>
             <p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar los detalles. Las celdas mensuales de detalle se colorean según su origen: <span style="background-color: var(--real-month-bg); padding: 1px 4px; border-radius: 3px; border: 1px solid var(--border-color);">REAL</span> (cargado) o <span style="background-color: var(--estimated-month-bg); padding: 1px 4px; border-radius: 3px; border: 1px solid var(--border-color);">ESTIMADO</span> (proyectado/calculado).</p>

            <!-- Added Group/Ungroup Buttons for Gastos -->
            <div class="table-actions">
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('gastos', false)" title="Expandir todos los detalles de gastos"><i class="fas fa-expand"></i> Expandir Todo</button>
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('gastos', true)" title="Colapsar todos los detalles de gastos"><i class="fas fa-compress"></i> Colapsar Todo</button>
            </div>

            <div class="table-container">
                <table id="gastos-detail-table" class="collapsible-table">
                     <thead>
                        <tr>
                            <th>Rubro / Detalle</th>
                            <th>Coef. Aplicado</th> <!-- Added Coef Aplicado Header -->
                            <!-- Meses y Total Anual generados por JS -->
                         </tr>
                     </thead>
                     <tbody><!-- Contenido generado por JS --></tbody>
                     <tfoot><!-- Contenido generado por JS --></tfoot>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Detalle de Ingresos Proyectados (Valores Base $)</h4>
             <p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar. Los valores aquí son la base de cálculo (valor individual o por UF) como fueron cargados. El Total de Ingresos en el Resumen General incluye la multiplicación por la Cantidad de UF (definida en Configuración) para los rubros específicos.</p>

             <!-- Added Group/Ungroup Buttons for Ingresos -->
             <div class="table-actions">
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('ingresos', false)" title="Expandir todos los detalles de ingresos"><i class="fas fa-expand"></i> Expandir Todo</button>
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('ingresos', true)" title="Colapsar todos los detalles de ingresos"><i class="fas fa-compress"></i> Colapsar Todo</button>
            </div>

            <div class="table-container">
                 <table id="ingresos-detail-table" class="collapsible-table">
                      <thead>
                         <tr>
                            <th>Rubro / Detalle</th>
                             <!-- Meses y Total Anual generados por JS -->
                         </tr>
                       </thead>
                      <tbody><!-- Contenido generado por JS --></tbody>
                      <tfoot><!-- Contenido generado por JS --></tfoot>
                 </table>
            </div>

            <div class="chart-container">
                 <h3>Evolutivo Expensa Mensual ($/UF)</h3>
                 <canvas id="evolutivoCuotaChart"></canvas>
                 <div class="chart-no-data">No hay datos suficientes para graficar.</div>
            </div>

            <div style="display: flex; gap: 25px; flex-wrap: wrap; margin-top: 35px;">
                <div class="chart-container" style="flex: 1; min-width: 320px;">
                    <h3>Participación Gastos (%)</h3>
                    <canvas id="participacionGastosChart"></canvas>
                    <div class="chart-no-data">No hay datos de gastos<br>para mostrar el gráfico.</div>
                </div>
                <div class="chart-container" style="flex: 1; min-width: 320px;">
                    <h3>Participación Ingresos (%)</h3>
                    <canvas id="participacionIngresosChart"></canvas>
                    <div class="chart-no-data">No hay datos de ingresos<br>para mostrar el gráfico.</div>
                </div>
            </div>
        </div>

        <!-- ==================== UPLOAD ==================== -->
        <div id="upload" class="tab-content">
            <h2><i class="fas fa-upload"></i> Cargar Datos Reales / Base</h2>
            <div class="form-group input-group">
                <label for="exercise-year">Año del Ejercicio:</label>
                <input type="number" id="exercise-year" min="2020" max="2099" value="2024" style="width: 120px;">
                <button onclick="createNewExercise()" class="button-success"><i class="fas fa-calendar-plus"></i> Crear/Seleccionar Año</button>
             </div>
            <p>Sube tu archivo Excel con las hojas <strong>"Gastos"</strong> e <strong>"Ingresos"</strong>. Los rubros y detalles nuevos encontrados se añadirán automáticamente a la sección de Configuración.</p>
            <p><strong>Importante:</strong>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>En la hoja "Gastos", las celdas con valores numéricos serán marcadas como 'REAL'. Las celdas vacías o con valores no numéricos se interpretarán como 'Estimado' y podrán ser proyectadas por la función "Calcular Estimados".</li>
                    <li>Los rubros de Ingreso llamados "<strong id="cuota-rubro-name-info">Expensas Ordinarias</strong>" y "<strong>Expensas Extraordinarias</strong>" tendrán sus valores base multiplicados por la cantidad de UF (definida en Configuración) al calcular el *total* de ingresos en el Resumen General. La columna "Expensa Real ($/UF)" en el resumen muestra el valor del rubro "<strong id="cuota-rubro-name-info2">Expensas Ordinarias</strong>" <strong style="color: var(--primary-color)">dividido por la cantidad de UF</strong>.</li>
                </ul>
            </p>
            <div id="file-upload-area" onclick="document.getElementById('excel-file-input').click()">
                 <p><i class="fas fa-file-excel"></i><br>Arrastra tu archivo Excel aquí (.xlsx, .xls) o haz clic para seleccionar</p>
                 <input type="file" id="excel-file-input" accept=".xlsx, .xls" style="display: none;" onchange="handleFileUpload(this.files)">
                 <button type="button" class="button-primary" onclick="event.stopPropagation(); document.getElementById('excel-file-input').click()" style="pointer-events: auto;"><i class="fas fa-folder-open"></i> Seleccionar Archivo</button>
                 <button type="button" onclick="event.stopPropagation(); loadSampleData()" style="margin-left: 10px; pointer-events: auto;" class="button-secondary"><i class="fas fa-database"></i> Cargar Datos Ejemplo</button>
            </div>
            <div id="file-upload-feedback"></div>
            <a href="#" onclick="event.preventDefault(); downloadTemplate();" title="Descargar archivo Excel con estructura de ejemplo"><i class="fas fa-download"></i> Descargar Plantilla Ejemplo</a>
        </div>

        <!-- ==================== RESERVE FUND ==================== -->
        <div id="reserve" class="tab-content">
             <h2><i class="fas fa-piggy-bank"></i> Configurar Fondo de Reserva - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
             <div class="form-group">
                 <label>Método de Cálculo del Fondo:</label>
                 <div class="input-group">
                     <input type="radio" id="reserve-type-percent" name="reserve-type" value="percent" checked onchange="updateReserveUI()">
                     <label for="reserve-type-percent">Porcentaje (%) sobre Gastos Mensuales</label>
                     <input type="radio" id="reserve-type-fixed" name="reserve-type" value="fixed" onchange="updateReserveUI()">
                     <label for="reserve-type-fixed">Valor Fijo Mensual ($)</label>
                 </div>
             </div>
              <h4>Valores Mensuales del Fondo</h4>
              <!-- Used the new monthly-inputs-grid class -->
             <div id="reserve-fund-panel" class="monthly-inputs-grid">
                 <!-- Inputs generados por JS -->
             </div>
             <button onclick="saveReserveFund()" style="margin-top: 25px;" class="button-success" title="Guardar los valores mensuales y el tipo de cálculo del fondo"><i class="fas fa-save"></i> Guardar Configuración del Fondo y Recalcular</button>
        </div>

        <!-- ==================== SETTINGS ==================== -->
        <div id="settings" class="tab-content">
             <h2><i class="fas fa-cog"></i> Configuración General y de Cálculo</h2>

             <div class="config-section">
                 <h4><i class="fas fa-building"></i> Ajustes Generales del Barrio</h4>
                 <div class="form-group">
                     <label for="cantidad-unidades">Cantidad Total de Unidades Funcionales (UF):</label>
                     <input type="number" id="cantidad-unidades" min="1" value="100" style="width: 180px;" title="Número total de UF para calcular cuotas base">
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-list-alt"></i> Gestión de Rubros (Categorías)</h4>
                 <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                     <div style="flex: 1; min-width: 320px;">
                         <h5><i class="fas fa-arrow-down" style="color:var(--danger-color)"></i> Rubros de GASTOS</h5>
                         <p class="text-muted">Asigna un coeficiente a cada rubro para proyectar sus gastos estimados.</p>
                         <div class="form-group input-group">
                             <input type="text" id="new-gasto-rubro-name" placeholder="Nombre nuevo rubro de gasto" style="flex-grow: 1;">
                             <button onclick="addRubro('gastos')" class="button-sm button-success" title="Añadir este nuevo rubro a la lista de gastos"><i class="fas fa-plus"></i> Añadir</button>
                         </div>
                         <ul id="gasto-rubro-list" class="management-list"></ul>
                     </div>
                     <div style="flex: 1; min-width: 320px;">
                          <h5><i class="fas fa-arrow-up" style="color:var(--success-color)"></i> Rubros de INGRESOS</h5>
                          <p class="text-muted">Solo los rubros Expensa Ordinaria y Extraordinaria se multiplican por UF.</p>
                          <div class="form-group input-group">
                              <input type="text" id="new-ingreso-rubro-name" placeholder="Nombre nuevo rubro de ingreso" style="flex-grow: 1;">
                              <button onclick="addRubro('ingresos')" class="button-sm button-success" title="Añadir este nuevo rubro a la lista de ingresos"><i class="fas fa-plus"></i> Añadir</button>
                          </div>
                          <ul id="ingreso-rubro-list" class="management-list"></ul>
                     </div>
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-percentage"></i> Gestión de Coeficientes de Ajuste (%)</h4>
                 <p class="text-muted" style="font-size: 0.9em;">Define tipos de coeficientes (ej. Inflación, Aumento Gremial). Edita sus valores mensuales en porcentaje. <strong style="color: var(--primary-color);">0 %</strong> implica un multiplicador de <strong style="color: var(--primary-color);">1</strong> (sin cambio). <strong style="color: var(--primary-color);">+2.5 %</strong> implica un multiplicador de <strong style="color: var(--primary-color);">1.025</strong>.</p>
                 <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                     <div style="flex: 1; min-width: 280px;">
                         <h5>Tipos de Coeficientes Disponibles</h5>
                         <div class="form-group input-group">
                             <input type="text" id="new-coefficient-type-name" placeholder="Nuevo tipo (ej: Aumento Sindicato)" style="flex-grow: 1;">
                             <button onclick="addCoefficientType()" class="button-sm button-success" title="Añadir este nuevo tipo de coeficiente a la lista"><i class="fas fa-plus"></i> Añadir Tipo</button>
                         </div>
                         <ul id="coefficient-type-list" class="management-list"></ul>
                     </div>
                     <div id="coefficient-editor" style="flex: 2; min-width: 450px;">
                          <h5><i class="fas fa-edit"></i> Editar Valores Mensuales (%) para: <span id="editing-coefficient-name" style="color: var(--primary-color); font-weight: bold;"></span></h5>
                          <!-- Changed to use the monthly-inputs-grid class -->
                          <div id="coefficient-values-editor">
                              <p class="text-muted">Selecciona un tipo de coeficiente de la lista (que no sea "Sin Coeficiente") para editar sus valores (en porcentaje %).</p>
                          </div>
                     </div>
                 </div>
             </div>

             <!-- Combined IPC input into Coefficient Management Section as it is a Coefficient Type now -->
             <!-- <div class="config-section"></div> Removed -->

             <button onclick="saveSettings()" style="margin-top: 20px; width: 100%; padding: 15px;" class="button-success button-lg" title="Guardar todos los cambios realizados en esta pestaña (UF, Rubros, Coeficientes) y recalcular el escenario actual">
                 <i class="fas fa-save"></i> GUARDAR TODA LA CONFIGURACIÓN Y RECALCULAR
             </button>
        </div>

        <!-- ==================== REPORTS ==================== -->
        <div id="reports" class="tab-content">
             <h2><i class="fas fa-download"></i> Descargar Reportes - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
             <p>Genera y descarga los datos del ejercicio y escenario actual en formato Excel, incluyendo detalles y resumen.</p>
             <button onclick="exportToExcel()" class="button-success" title="Descargar un archivo .xlsx con el detalle y resumen del escenario actual"><i class="fas fa-file-excel"></i> Descargar Reporte Completo (.xlsx)</button>

             <h3 style="margin-top: 35px;">Exportar Gráficos Individuales</h3>
             <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                 <button onclick="exportChart('evolutivoCuotaChart', 'evolutivo_expensa_por_uf.png')" class="button-secondary" title="Descargar el gráfico de evolución de expensas como imagen PNG"><i class="fas fa-chart-line"></i> Gráfico Evolutivo ($/UF PNG)</button>
                 <button onclick="exportChart('participacionGastosChart', 'participacion_gastos.png')" class="button-secondary" title="Descargar el gráfico de torta de gastos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Gastos (PNG)</button>
                 <button onclick="exportChart('participacionIngresosChart', 'participacion_ingresos.png')" class="button-secondary" title="Descargar el gráfico de torta de ingresos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Ingresos (PNG)</button>
             </div>
        </div>
    </div> <!-- /container -->

    <footer>
        <div class="container">
            &copy; <span id="footer-year"></span> Proyección Expensas El Centauro. v2.7 (PctCoef_IPCRubro_Style + BugFix)
        </div>
    </footer>
    <div id="snackbar">Mensaje</div>

    <!-- ==================== SCRIPT PRINCIPAL ==================== -->
    <script>
        // --- Constantes y Estado Global ---
        const MONTHS = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
        const FULL_MONTHS = ["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"];
        const GASTOS_SHEET_NAME = "Gastos";
        const INGRESOS_SHEET_NAME = "Ingresos";
        // MODIFICACIÓN STORAGE KEY V2.7 - Introduce coeficientes en porcentaje, IPC como rubro coeficiente y estilos de tablas/graficos
        const STORAGE_KEY = 'expensasAppCentauroState_v2.7_PctCoef_IPCRubro_Style'; // Stay the same
        const CUOTA_RUBRO_NAME = "Expensas Ordinarias"; // Rubro principal para multiplicar x UF y base de Expensa Real
        const EXTRA_CUOTA_RUBRO_NAME = "Expensas Extraordinarias"; // Otro rubro a multiplicar x UF
        const SPECIAL_INGRESO_RUBROS = [CUOTA_RUBRO_NAME, EXTRA_CUOTA_RUBRO_NAME]; // Rubros que se multiplican por UF para el total
        const IPC_COEFFICIENT_KEY = "IPC"; // Key for the default IPC coefficient type

        let appState = getDefaultAppState(); // Iniciar con estado por defecto limpio

        // Chart instances (moved to scope variables)
        let evolutivoCuotaChart_instance = null;
        let participacionGastosChart_instance = null;
        let participacionIngresosChart_instance = null;

        // --- EXPLICITLY expose necessary functions to the global window scope ---
        // This fixes "not defined" errors when functions are called from HTML attributes like onclick="..."
        // These are functions called directly by user interaction elements defined in the static HTML.
        window.openTab = openTab;
        window.toggleTheme = toggleTheme;
        window.createNewExercise = createNewExercise;
        window.loadSampleData = loadSampleData;
        window.downloadTemplate = downloadTemplate;
        window.createScenario = createScenario;
        window.cloneScenario = cloneScenario;
        window.deleteScenario = deleteScenario;
        window.clearScenarioData = clearScenarioData;
        window.recalculateEstimates = recalculateEstimates;
        window.handleFileUpload = handleFileUpload; // Called by input onchange
        window.saveReserveFund = saveReserveFund;
        window.updateReserveUI = updateReserveUI; // Called by radio button onchange
        window.saveSettings = saveSettings;
        window.addRubro = addRubro; // Called by buttons in Settings
        window.addCoefficientType = addCoefficientType; // Called by button in Settings
        window.exportToExcel = exportToExcel;
        window.exportChart = exportChart; // Called by buttons in Reports
        window.toggleAllRubroDetails = toggleAllRubroDetails; // Called by buttons in Dashboard

        // Other functions like deleteRubro, deleteCoefficientType, handleCoefficientValueChange,
        // handleCoefficientAssignmentChange, selectCoefficientTypeForEditing are attached dynamically
        // to elements or called from within other JavaScript functions, so they don't need to be
        // explicitly attached to `window` here for the initial page load.

        // --- Inicialización ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log(`DOM Cargado. Inicializando App ${STORAGE_KEY}...`);
            loadState(); // Cargar estado guardado si existe
            initTheme(); // Aplicar tema (antes de cualquier render que dependa de él)

            // Asegurar que exista al menos un escenario activo y válido
            validateAndSetActiveScenario(); // This sets the year and active key

            // --- Update UI instructions with the correct name ---
            const cuotaInfoSpan = document.getElementById('cuota-rubro-name-info');
            if (cuotaInfoSpan) cuotaInfoSpan.textContent = CUOTA_RUBRO_NAME; // Usa la constante actualizada
            const cuotaInfoSpan2 = document.getElementById('cuota-rubro-name-info2');
            if (cuotaInfoSpan2) cuotaInfoSpan2.textContent = CUOTA_RUBRO_NAME;

            // Initialize core UI elements
            initUI();
            // Add main event listeners (delegated where possible)
            addEventListeners();

            // Perform the initial render/update based on the loaded state
            updateUI();

            console.log(`App ${STORAGE_KEY} Inicializada.`);
        });


        // --- Migración (if needed from previous versions) ---
         // Modifies the loadedState object in place. Returns true if state was significantly changed/corrected.
         function migrateState(loadedState) {
            let changed = false; // Flag to indicate if state was modified

             // Migration from v2.6 (IPC manual was a top-level array) to v2.7 (IPC is a Coefficient Type)
             // Check if the old ipcManual array exists in the loaded state's settings
            if (Array.isArray(loadedState?.settings?.ipcManual)) {
                console.log("Migración: Detectada estructura IPC Manual anterior.");

                // Ensure settings and coefficientTypes objects exist, creating default if necessary
                loadedState.settings = loadedState.settings || getDefaultAppState().settings;
                loadedState.settings.coefficientTypes = loadedState.settings.coefficientTypes || getDefaultAppState().settings.coefficientTypes;

                const currentIpcCoefType = loadedState.settings.coefficientTypes?.[IPC_COEFFICIENT_KEY];
                 const defaultIpcCoefType = getDefaultAppState().settings.coefficientTypes?.[IPC_COEFFICIENT_KEY]; // Get default definition for reference


                // Option 1: IPC coefficient type already exists in loaded state
                 if (currentIpcCoefType) {
                     console.log(`Migración: Coefficient type "${IPC_COEFFICIENT_KEY}" exists. Overwriting its values with old ipcManual data.`);
                      // Overwrite the 'values' array of the existing IPC type with the migrated data
                      const migratedValues = loadedState.settings.ipcManual.slice(0, 12).map(v => typeof v === 'number' ? v : 0); // Ensure array of 12 numbers >= 0? IPC % can be negative, let's keep numbers as is for now if loaded. Let's enforce >= 0 for *saved* values later.
                      // For migration, use loaded numbers directly. Validation during saveSettings/renderCoef will ensure >= 0.
                      loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].values = loadedState.settings.ipcManual.slice(0, 12).map(v => typeof v === 'number' ? v : 0);
                      // Also ensure name and isDefault are correct based on the default template if the type already existed
                       if (defaultIpcCoefType) {
                            loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].name = defaultIpcCoefType.name;
                            loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].isDefault = defaultIpcCoefType.isDefault;
                       } else {
                            // If somehow IPC default is missing, fallback
                             loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].name = loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].name || IPC_COEFFICIENT_KEY;
                             loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].isDefault = loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].isDefault ?? true;
                       }

                 } else {
                     // Option 2: IPC coefficient type does NOT exist in loaded state, create it using migrated data
                     console.log(`Migración: Coefficient type "${IPC_COEFFICIENT_KEY}" missing. Creating from old ipcManual data.`);
                      const defaultTemplate = defaultIpcCoefType || { name: IPC_COEFFICIENT_KEY, values: Array(12).fill(0), isDefault: true };
                      loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY] = {
                          name: defaultTemplate.name,
                          values: loadedState.settings.ipcManual.slice(0, 12).map(v => typeof v === 'number' ? v : 0),
                          isDefault: defaultTemplate.isDefault
                     };
                 }
                 delete loadedState.settings.ipcManual; // Remove the old property
                 changed = true; // State was changed by this migration step
                 console.log("Migración de IPC manual completada.");
             }


             // Add any new default coefficient types defined in getDefaultAppState but missing in the loaded state.
              // Also validate/correct structure of existing default and custom types.
              const defaultCoefficientTypes = getDefaultAppState().settings.coefficientTypes;
              loadedState.settings = loadedState.settings || {};
              loadedState.settings.coefficientTypes = loadedState.settings.coefficientTypes || {};

              // Iterate through the DEFAULT types to ensure they exist in loaded state and have correct default properties
              Object.keys(defaultCoefficientTypes).forEach(defaultKey => {
                  const defaultDef = defaultCoefficientTypes[defaultKey];
                  const loadedType = loadedState.settings.coefficientTypes[defaultKey];

                  if (!loadedType) {
                      // If a default type is completely missing in loaded state, add it (deep copy)
                      console.log(`Migración: Adding missing default coefficient type "${defaultKey}".`);
                      loadedState.settings.coefficientTypes[defaultKey] = JSON.parse(JSON.stringify(defaultDef));
                      changed = true;
                  } else {
                       // If a default type exists, ensure its default properties (name, isDefault) are correct
                       if (loadedType.name !== defaultDef.name || loadedType.isDefault !== defaultDef.isDefault) {
                            console.warn(`Migración: Correcting default properties for coefficient type "${defaultKey}".`);
                           loadedType.name = defaultDef.name;
                           loadedType.isDefault = defaultDef.isDefault;
                           changed = true;
                       }

                      // Ensure 'values' array for THIS type exists and has 12 numeric elements
                       const isValidLoadedValues = Array.isArray(loadedType.values) && loadedType.values.length === 12 && loadedType.values.every(v => typeof v === 'number');

                      if (!isValidLoadedValues) {
                           console.warn(`Migración: Coefficient values array for "${defaultKey}" corrupted. Resetting to default values.`);
                          // Use default definition values if valid, else default fill (0% or 1 for None)
                           loadedType.values = Array.isArray(defaultDef.values) ? JSON.parse(JSON.stringify(defaultDef.values)) : Array(12).fill(defaultKey === 'None' ? 1 : 0);
                           changed = true;
                      } else {
                           // For default 'None' type, ensure all values are exactly 1
                          if (defaultKey === 'None' && !loadedType.values.every(v => v === 1)) {
                             console.warn(`Migración: "None" coefficient type values should all be 1. Correcting.`);
                             loadedType.values = Array(12).fill(1);
                             changed = true;
                           }
                           // For default *percentage* types (like IPC, UTEDYC default examples), ensure non-negative values
                           else if (defaultKey !== 'None') { // Assumes non-'None' defaults are percentages
                              const correctedValues = loadedType.values.map(v => v >= 0 ? v : 0); // Ensure non-negative
                              if (JSON.stringify(correctedValues) !== JSON.stringify(loadedType.values)) {
                                  console.warn(`Migración: Found negative values in percentage coefficient type "${defaultKey}". Correcting.`);
                                   loadedType.values = correctedValues;
                                   changed = true;
                              }
                           }
                      }
                  }
              });

             // Iterate through LOADED custom coefficient types to ensure their structure and values are okay
             Object.keys(loadedState.settings.coefficientTypes).forEach(loadedKey => {
                  const defaultDef = defaultCoefficientTypes[loadedKey];
                   // If this key is NOT one of the default keys defined in getDefaultAppState, it's a custom one.
                  if (!defaultDef) {
                      const loadedType = loadedState.settings.coefficientTypes[loadedKey];
                       console.log(`Migración: Validating custom coefficient type "${loadedKey}".`);

                      // Ensure a custom type has a name (use key if missing), and isDefault is false
                       if (!loadedType.name) { loadedType.name = loadedKey; changed = true; console.warn(`Migración: Custom coefficient type "${loadedKey}" missing name. Using key.`);}
                       if (loadedType.isDefault !== false) { loadedType.isDefault = false; changed = true; console.warn(`Migración: Custom coefficient type "${loadedKey}" marked as default. Correcting.`);}

                      // Ensure 'values' array for THIS type exists, has 12 numbers, and are non-negative (as they're treated as percentages)
                       const isValidLoadedValues = Array.isArray(loadedType.values) && loadedType.values.length === 12 && loadedType.values.every(v => typeof v === 'number');
                       if (!isValidLoadedValues) {
                           console.warn(`Migración: Coefficient values array for custom type "${loadedKey}" corrupted. Resetting to 0%.`);
                          loadedType.values = Array(12).fill(0); // Reset custom corrupted values to 0%
                           changed = true;
                       } else {
                           const correctedValues = loadedType.values.map(v => v >= 0 ? v : 0); // Ensure non-negative percentages
                           if (JSON.stringify(correctedValues) !== JSON.stringify(loadedType.values)) {
                                console.warn(`Migración: Found negative values in custom percentage coefficient type "${loadedKey}". Correcting.`);
                                loadedType.values = correctedValues;
                                changed = true;
                           }
                       }
                  }
                   // Note: Rubros assigned to a deleted/corrupted coef type will default to 'None' during initializeScenarioDataForRubros or rubro config cleanup.

             });


            // Ensure appState.settings.rubroConfig structure is okay and default collapsed is true for missing configs or rubros not in the global list.
             loadedState.settings.rubroConfig = loadedState.settings.rubroConfig || {}; // Ensure exists

            // Iterate through rubros defined in GLOBAL settings (loadedState.settings) to ensure their config entries exist and are valid.
             ['gastos', 'ingresos'].forEach(type => {
                  (loadedState.settings.rubros?.[type] || []).forEach(rubroKey => {
                     if (!loadedState.settings.rubroConfig[rubroKey]) {
                          console.log(`Migración: Creating default rubroConfig for "${rubroKey}" (${type}).`);
                          // Default collapsed true, default coef type None
                          loadedState.settings.rubroConfig[rubroKey] = { coefficientType: 'None', detailsCollapsed: true };
                           changed = true;
                     } else {
                         const config = loadedState.settings.rubroConfig[rubroKey];

                         // Ensure boolean state for detailsCollapsed, default to true if undefined/null/invalid type
                         if (typeof config.detailsCollapsed !== 'boolean') { // Includes undefined, null
                              console.warn(`Migración: detailsCollapsed for "${rubroKey}" invalid type. Setting to true.`);
                                config.detailsCollapsed = true; // Default to true
                                changed = true;
                         }

                         // Ensure coefficientType key exists and points to a valid type key in settings.coefficientTypes, default to 'None'
                         const currentCoefTypeKey = config.coefficientType;
                          const validCoefTypeKeys = Object.keys(loadedState.settings.coefficientTypes || {}); // Get keys from potentially corrected types list
                         if (currentCoefTypeKey === undefined || !validCoefTypeKeys.includes(currentCoefTypeKey)) {
                              if (currentCoefTypeKey !== undefined) console.warn(`Migración: CoefficientType "${currentCoefTypeKey}" for "${rubroKey}" is invalid or missing. Setting to 'None'.`);
                                config.coefficientType = 'None'; // Default to None
                                changed = true;
                         }
                     }
                  });
             });

            // Clean up rubroConfig entries for rubros that are no longer in the settings.rubros lists (gastos or ingresos)
             Object.keys(loadedState.settings.rubroConfig).forEach(rubroKey => {
                 const isInGastos = (loadedState.settings.rubros?.gastos || []).includes(rubroKey);
                 const isInIngresos = (loadedState.settings.rubros?.ingresos || []).includes(rubroKey);
                 if (!isInGastos && !isInIngresos) {
                      console.log(`Migración: Rubro "${rubroKey}" not found in global settings lists. Removing its rubroConfig.`);
                      delete loadedState.settings.rubroConfig[rubroKey];
                     changed = true;
                 }
             });


             // Ensure each scenario's data structures (data, monthStatus, calculated sub-objects/arrays) are complete
             // based on the potentially updated global settings lists (rubros, coefficientTypes, rubroConfig).
             // This needs to happen AFTER the global settings in loadedState are fully migrated/corrected.
              if (loadedState.scenarios) {
                 Object.values(loadedState.scenarios).forEach(scenario => {
                      if(scenario) {
                           // Call initialization logic for *each* scenario object found
                          initializeScenarioDataForRubros(scenario, loadedState.settings); // Pass corrected settings
                           // The ipcManual snapshot *within each scenario's calculated object*
                           // is initialized/updated during initializeScenarioDataForRubros now.
                      } else {
                         console.warn("Migración: Skipping structure init for a null/undefined scenario entry.");
                     }
                 });
                  changed = true; // Structure init/validation might add/correct things within scenarios
             } else {
                  // If scenarios object was missing entirely, set it to default empty
                  loadedState.scenarios = getDefaultAppState().scenarios;
                   changed = true;
                  console.log("Migración: Scenarios object was missing. Initializing empty scenarios structure.");
             }

              // Ensure quantityUnits is a number >= 1
             const currentQty = loadedState.settings?.quantityUnits;
             if (typeof currentQty !== 'number' || currentQty < 1 || isNaN(currentQty)) {
                 console.warn(`Migración: quantityUnits "${currentQty}" invalid. Setting to default ${getDefaultAppState().settings.quantityUnits}.`);
                  loadedState.settings.quantityUnits = getDefaultAppState().settings.quantityUnits;
                 changed = true;
             }


             // Ensure rubro lists are arrays (redundant check after push logic, but defensive)
              loadedState.settings.rubros = loadedState.settings.rubros || {};
              loadedState.settings.rubros.gastos = Array.isArray(loadedState.settings.rubros.gastos) ? loadedState.settings.rubros.gastos.map(r => String(r).trim()) : []; // Ensure array of strings
              loadedState.settings.rubros.ingresos = Array.isArray(loadedState.settings.rubros.ingresos) ? loadedState.settings.rubros.ingresos.map(r => String(r).trim()) : []; // Ensure array of strings


            // Add logic for other migration steps for future versions here...


             return changed; // Return whether any significant structural/data changes were made during the migration process
         }


        // --- Validation and setting Active Scenario ---
         // Ensures there is always a valid active scenario key pointing to an existing scenario object in appState.
         // Also syncs appState.currentYear to the year of the active scenario.
        function validateAndSetActiveScenario() {
             // Use Object.keys on a potentially missing object defensively
             const scenarioKeys = Object.keys(appState.scenarios || {});
             let activeKeyIsValid = false;

             // Check if the stored active key points to a valid scenario entry
             if (appState.activeScenarioKey && appState.scenarios && appState.scenarios[appState.activeScenarioKey]) {
                 const activeScenarioData = appState.scenarios[appState.activeScenarioKey];
                 // Also ensure the scenario object itself is valid (basic check for existence of core properties)
                  if (activeScenarioData?.year !== undefined && activeScenarioData?.scenarioName !== undefined) { // Simple check for essential props
                      // Sync appState.currentYear to the year stored *in* the active scenario object
                       const yearFromScenario = activeScenarioData.year;
                       if (typeof yearFromScenario === 'number' && !isNaN(yearFromScenario)) {
                           if (appState.currentYear !== yearFromScenario) {
                                console.warn(`Current year mismatch detected: State has ${appState.currentYear}, Active Scenario "${activeScenarioData.scenarioName}" has ${yearFromScenario}. Syncing appState.currentYear.`);
                                 appState.currentYear = yearFromScenario;
                           }
                           // The active key points to an existing, seemingly valid scenario.
                           activeKeyIsValid = true;
                       } else {
                           console.warn(`Active scenario "${appState.activeScenarioKey}" has an invalid year property: "${yearFromScenario}". Treating active key as invalid.`);
                            // activeKeyIsValid remains false
                       }
                  } else {
                       console.warn(`Active scenario "${appState.activeScenarioKey}" seems incomplete or corrupted. Treating active key as invalid.`, activeScenarioData);
                       // activeKeyIsValid remains false
                  }

             } else {
                 console.warn(`Active scenario key "${appState.activeScenarioKey}" is invalid or missing from state. Searching for alternative.`);
                 appState.activeScenarioKey = null; // Explicitly clear invalid key
             }

             // --- Fallback Logic if the current active key is invalid or missing ---
             let fallbackKey = null;
             if (!activeKeyIsValid) {
                 console.log("No valid active scenario found. Searching for a fallback.");

                 // Priority 1: Try finding 'Base' scenario for the current `appState.currentYear`
                 const currentYearBaseKey = `${appState.currentYear}_Base`;
                 if (appState.scenarios && appState.scenarios[currentYearBaseKey]) {
                     fallbackKey = currentYearBaseKey;
                     console.log(`Fallback: Found Base scenario for current year: ${fallbackKey}`);
                 } else {
                     // Priority 2: Try finding ANY scenario for the current `appState.currentYear`, sorted alphabetically
                      const firstKeyForCurrentYear = scenarioKeys.filter(k => k.startsWith(`${appState.currentYear}_`)).sort((a,b) => (appState.scenarios?.[a]?.scenarioName || '').localeCompare(appState.scenarios?.[b]?.scenarioName || ''))[0];
                     if (firstKeyForCurrentYear) {
                         fallbackKey = firstKeyForCurrentYear;
                          console.log(`Fallback: Found first scenario for current year: ${fallbackKey}`);
                     } else {
                         // Priority 3: No scenarios for the current year. Try finding the first scenario chronologically (oldest year first, then name) globally.
                          if (scenarioKeys.length > 0) {
                               const firstGlobalKey = scenarioKeys.sort((a, b) => {
                                   // Sort by year (ascending), then by scenario name (alphabetical)
                                   const yearA = parseInt(a.split('_')[0]);
                                   const yearB = parseInt(b.split('_')[0]);
                                    // Handle invalid year parsing - treat as equivalent if cannot parse, rely on name sort?
                                    // Let's make invalid years sort after valid years
                                    const isNaN_A = isNaN(yearA);
                                    const isNaN_B = isNaN(yearB);
                                    if (!isNaN_A && isNaN_B) return -1; // A valid year before B invalid year
                                    if (isNaN_A && !isNaN_B) return 1;  // A invalid year after B valid year
                                    if (!isNaN_A && !isNaN_B && yearA !== yearB) return yearA - yearB; // Sort by year ascending
                                   // If years are the same or invalid, sort by name
                                   const nameA = appState.scenarios?.[a]?.scenarioName || '';
                                   const nameB = appState.scenarios?.[b]?.scenarioName || '';
                                   return nameA.localeCompare(nameB); // Alphabetical sort by name
                               })[0]; // Get the first key based on this sorting
                             if (firstGlobalKey) {
                                   fallbackKey = firstGlobalKey;
                                    // Sync currentYear to the year of the selected global scenario
                                    const yearFromGlobalFallback = parseInt(fallbackKey.split('_')[0]);
                                   if (!isNaN(yearFromGlobalFallback)) appState.currentYear = yearFromGlobalFallback;
                                   else console.warn(`Fallback: Invalid year in key ${fallbackKey} from global search. Keeping appState.currentYear ${appState.currentYear}.`);
                                   console.log(`Fallback: No scenarios for year ${new Date().getFullYear()}. Set to global scenario: ${fallbackKey}. Synced currentYear to ${appState.currentYear}.`);
                             }
                          }
                     }
                 }
             }


             // --- Apply Fallback Key or Create Initial Scenario if Still None ---
             if (fallbackKey) {
                 appState.activeScenarioKey = fallbackKey; // Set the determined fallback key as active
                 // appState.currentYear was synced during fallback determination if it changed.
                 activeKeyIsValid = true; // The state is now considered valid with the fallback key
                 console.log(`Validated/Set active scenario to fallback key: ${appState.activeScenarioKey}. Current Year: ${appState.currentYear}.`);
             } else if (!appState.activeScenarioKey) { // If STILL no active key exists after all fallbacks (implies no scenarios existed initially)
                 console.log("Validation: No valid scenario found after all fallbacks. Creating initial default scenario (Base for current year).");
                 // Reset appState to a minimal default state and then initialize the first scenario
                 appState = getDefaultAppState(); // Resets state including scenarios{} and activeScenarioKey=null, settings{defaults}
                 appState.currentYear = new Date().getFullYear(); // Ensure currentYear is indeed the actual current year
                 initScenarioData(appState.currentYear); // Creates the 'Base' scenario structure and initializes it based on appState.settings
                 appState.activeScenarioKey = `${appState.currentYear}_Base`; // Set the newly created Base scenario as active
                 activeKeyIsValid = true; // The state is now valid with the new initial scenario
                 console.log(`Created initial scenario: ${appState.activeScenarioKey}. Current Year: ${appState.currentYear}.`);
             }

             // --- Final Structure Consistency Check ---
             // At this point, appState.activeScenarioKey is guaranteed to point to an existing scenario in appState.scenarios,
             // and appState.currentYear is synced to the year of that scenario.
             // Ensure ALL scenario data structures (details, monthStatus, calculated) are consistent with the *current* global settings (rubros, coefs).
             // This is important if global settings changed independently (e.g., manually in localStorage) or if new rubros were added since a scenario was created.
             console.log("Validation: Ensuring consistency and completeness for all scenario structures based on current global settings...");
             Object.values(appState.scenarios || {}).forEach(scenario => {
                  if(scenario) {
                      // Pass the potentially updated global settings from appState
                      initializeScenarioDataForRubros(scenario, appState.settings);
                      // The ipcManual snapshot within *each* scenario's calculated object is updated here based on appState.settings.coefficientTypes.IPC.values.
                  } else {
                     console.warn("Validation: Skipping structure init for a null/undefined scenario object found in state.");
                 }
             });

            // State is now validated, migrated (if applicable), corrected, and made consistent. Save the updated state.
             saveState();
        }


        // --- Gestión de Datos del Escenario ---

        // Safely gets the data object for the current active scenario from appState.
        // Returns the scenario object or null if state is invalid.
        function getCurrentScenarioData() {
            // Check if scenarios object exists AND activeKey is not null AND the scenario for that key exists.
            if (appState.scenarios && appState.activeScenarioKey !== null && appState.scenarios[appState.activeScenarioKey]) {
                const scenario = appState.scenarios[appState.activeScenarioKey];
                 // Basic check for scenario structure validity - must be an object and have a year
                if (typeof scenario === 'object' && scenario !== null && !Array.isArray(scenario) && scenario.year !== undefined) {
                     return scenario; // Return the valid scenario object
                } else {
                     console.error(`Error getCurrentScenarioData: Active scenario data for key "${appState.activeScenarioKey}" is not a valid object.`, scenario);
                      return null; // Return null for corrupted scenario data
                }
            } else {
                 // This check should theoretically pass after validateAndSetActiveScenario runs on load.
                 // If it fails runtime, it means state became invalid between checks.
                console.error(`Error getCurrentScenarioData: No active scenario data found for key "${appState.activeScenarioKey}".`, {
                    scenariosExists: !!appState.scenarios,
                    activeKeyNotNull: appState.activeScenarioKey !== null,
                    keyExistsInScenarios: appState.scenarios ? appState.scenarios[appState.activeScenarioKey] !== undefined : 'N/A'
                });
                return null; // Return null if active scenario is not found/invalid in state
            }
        }


        // Initializes/validates a single scenarioData object structure based on a given settings object.
        // This ensures consistent structure (presence of nested objects/arrays for all rubros/details)
        // within a scenario's data, monthStatus, and calculated properties.
        // Modifies the scenarioData object in place.
         // Optionally accepts the global settings object, uses appState.settings if not provided.
        function initializeScenarioDataForRubros(scenarioData, currentSettings = appState.settings) {
             if (!scenarioData || typeof scenarioData !== 'object') {
                console.warn("initializeScenarioDataForRubros called without valid scenario data object.");
                return; // Cannot proceed without scenario data object
             }
              if (!currentSettings || typeof currentSettings !== 'object') {
                   console.error("initializeScenarioDataForRubros called without valid settings object.");
                   currentSettings = getDefaultAppState().settings; // Fallback to default settings structure if input settings are bad
                   // Even with fallback, logic might fail if appState.settings itself is needed and bad.
                   // This function relies heavily on the provided settings object to define expected rubros.
              }

              // Use the structure pattern from getDefaultAppState as a template for completeness
             const defaultScenarioTemplatePart = getDefaultAppState().scenarios.BaseExample;

             // Ensure essential top-level structures exist using nullish coalescing assignment `??=`
             // Preserve existing objects/arrays if they exist, otherwise use an empty base or default
             scenarioData.rubroOrder ??= { gastos: [], ingresos: [] }; // Keep existing if any, else new empty objects
             scenarioData.data ??= { gastos: {}, ingresos: {} };
             scenarioData.monthStatus ??= { gastos: {}, ingresos: {} };
              // Ensure default type and values for reserveFund if missing entirely
              scenarioData.reserveFund = scenarioData.reserveFund ?? { type: 'percent', values: Array(12).fill(5) };


             // Ensure core calculated structure exists. Nested objects/arrays will be detailed below.
              scenarioData.calculated ??= {};
             const defaultCalcStructureTemplate = defaultScenarioTemplatePart.calculated;

             // Initialize top-level calculated arrays if missing or wrong size/type
              ['totalGastoProyectadoMes', 'totalIngresoProyectadoMes', 'fondoReservaMes',
               'cuotaSobreGastosMes', 'cuotaIpcMes', 'cuotaRealBaseMes'].forEach(arrKey => {
                  const defaultValue = defaultCalcStructureTemplate[arrKey]; // Expected shape from template (array of 12)
                  if (!Array.isArray(scenarioData.calculated[arrKey]) || scenarioData.calculated[arrKey].length !== defaultValue.length || !scenarioData.calculated[arrKey].every(v => typeof v === 'number')) {
                       console.warn(`Structure init: calculated array "${arrKey}" invalid in scenario data. Resetting to 0s.`);
                      scenarioData.calculated[arrKey] = Array(defaultValue.length).fill(0); // Re-initialize with zeros
                  } else {
                      // Ensure all values are numbers even if the array size was okay
                      scenarioData.calculated[arrKey] = scenarioData.calculated[arrKey].map(v => typeof v === 'number' ? v : 0);
                  }
             });


             // Initialize annualTotals structure and ensure objects/default values
              scenarioData.calculated.annualTotals ??= { gastos: {}, ingresos: {}, fondoReserva: 0, cuotaSobreGastos: 0, cuotaIpc: 0, cuotaRealBase: 0 };
              scenarioData.calculated.annualTotals.gastos ??= { __TOTAL__: 0 };
              scenarioData.calculated.annualTotals.ingresos ??= { __TOTAL__: 0 };

             // Ensure ipcManual snapshot array exists and has 12 numbers.
             // Initialize it based on the CURRENT IPC Coefficient type values in settings, not scenario data.
              const ipcCoefficientValuesInSettings = currentSettings.coefficientTypes?.[IPC_COEFFICIENT_KEY]?.values || Array(12).fill(0);
             scenarioData.calculated.ipcManual = Array.isArray(ipcCoefficientValuesInSettings) && ipcCoefficientValuesInSettings.length === 12 && ipcCoefficientValuesInSettings.every(v => typeof v === 'number')
                                                    ? ipcCoefficientValuesInSettings.map(v => v) // Copy valid numbers from settings
                                                    : Array(12).fill(0); // Default to 0s if settings IPC is bad

             // Iterate through GLOBAL rubro lists from settings to ensure their corresponding structures
             // exist and are consistent within the scenario's data, monthStatus, and calculated properties.
             ['gastos', 'ingresos'].forEach(type => {
                 const globalRubrosForType = currentSettings.rubros?.[type] || []; // Get rubros list for this type from settings
                 const scenarioDataForType = scenarioData.data?.[type]; // Get the data object for this type in the scenario (might be undefined)

                  // If the main data object for this type is missing in scenario, initialize it.
                  if (!scenarioDataForType || typeof scenarioDataForType !== 'object' || Array.isArray(scenarioDataForType)) {
                       console.warn(`Structure init: data object for type "${type}" missing or invalid. Resetting.`);
                       scenarioData.data[type] = {};
                  }
                 // Ensure rubroOrder array for this type exists
                  scenarioData.rubroOrder[type] ??= [];

                  // If the monthStatus object for this type is missing, initialize it.
                 if (!scenarioData.monthStatus?.[type] || typeof scenarioData.monthStatus[type] !== 'object' || Array.isArray(scenarioData.monthStatus[type])) {
                      console.warn(`Structure init: monthStatus object for type "${type}" missing or invalid. Resetting.`);
                      scenarioData.monthStatus[type] = {};
                  }


                 // Ensure required calculated objects exist at the type level if needed
                 if (type === 'gastos') {
                      scenarioData.calculated.gastoAjustado ??= {};
                      scenarioData.calculated.totalGastoRubroMes ??= {};
                      scenarioData.calculated.annualTotals.gastos ??= { __TOTAL__: 0 }; // Defensive, checked earlier too
                 } else { // type === 'ingresos'
                      scenarioData.calculated.ingresoAjustado ??= {};
                      scenarioData.calculated.totalIngresoRubroMes ??= {};
                      scenarioData.calculated.annualTotals.ingresos ??= { __TOTAL__: 0 }; // Defensive
                 }


                  // Process each rubro defined in the global settings for this type
                  globalRubrosForType.forEach(rubroKey => {
                      // Ensure the data structure for this rubro exists within the scenario
                       scenarioData.data[type][rubroKey] ??= { detailOrder: [], detailsData: {} };

                      // Ensure the monthStatus structure for this rubro exists within the scenario (object mapping details to arrays)
                       scenarioData.monthStatus[type][rubroKey] ??= {};

                      // Ensure calculated structures for this specific rubro key exist at the rubro level
                      if (type === 'gastos') {
                           scenarioData.calculated.gastoAjustado[rubroKey] ??= {}; // Object to hold detail values
                           scenarioData.calculated.totalGastoRubroMes[rubroKey] ??= Array(12).fill(0); // Array of 12 zeros for monthly sums
                           scenarioData.calculated.annualTotals.gastos[rubroKey] ??= 0; // Default annual total to 0
                      } else { // type === 'ingresos'
                           scenarioData.calculated.ingresoAjustado[rubroKey] ??= {}; // Object to hold detail values
                           scenarioData.calculated.totalIngresoRubroMes[rubroKey] ??= Array(12).fill(0); // Array of 12 zeros for monthly sums (before UF mult handled by calcAll)
                           scenarioData.calculated.annualTotals.ingresos[rubroKey] ??= 0; // Default annual total to 0
                      }


                      // --- Ensure detail data structures within this rubro are consistent ---
                       const rubroDetailsData = scenarioData.data[type][rubroKey].detailsData;
                      rubroDetailsData ??= {}; // Ensure detailsData object exists within rubro data
                       scenarioData.data[type][rubroKey].detailsData = rubroDetailsData; // Assign back if defaulted


                       // Iterate over detail keys *found in the scenario data* for this rubro (which might be from loaded Excel data)
                      Object.keys(rubroDetailsData).forEach(detailKey => {
                          // Ensure the data array for this detail exists, has 12 elements, and contains only numbers
                           const currentDetailDataArray = rubroDetailsData[detailKey];
                           if (!Array.isArray(currentDetailDataArray) || currentDetailDataArray.length !== 12 || !currentDetailDataArray.every(v => typeof v === 'number')) {
                                console.warn(`Structure init: data array for detail "${rubroKey}/${detailKey}" corrupted. Resetting to 0s.`);
                               rubroDetailsData[detailKey] = Array(12).fill(0); // Reset corrupted detail data
                            } else {
                                // Ensure numerical integrity even if structure is correct
                                 rubroDetailsData[detailKey] = currentDetailDataArray.map(v => typeof v === 'number' ? v : 0);
                            }

                           // Ensure monthStatus array for this detail exists, has 12 strings (only for 'gastos')
                            if (type === 'gastos') {
                                 const detailStatusArray = scenarioData.monthStatus[type][rubroKey]?.[detailKey];
                                 if (!Array.isArray(detailStatusArray) || detailStatusArray.length !== 12 || !detailStatusArray.every(s => typeof s === 'string')) {
                                      console.warn(`Structure init: monthStatus array for detail "${rubroKey}/${detailKey}" corrupted. Resetting to 'Estimado'.`);
                                     scenarioData.monthStatus[type][rubroKey][detailKey] = Array(12).fill('Estimado'); // Reset corrupted status
                                 }
                             } else {
                                 // For Ingresos details, the structure initialize might create an entry in monthStatus[type][rubro] if not there,
                                 // but details within it (monthStatus[type][rubro][detail]) aren't strictly used by current logic for state coloring/projection.
                                 // No explicit detail status validation needed here for incomes yet.
                             }


                           // Ensure detail is included in the scenario's `detailOrder` array for this rubro, adding it if missing.
                           // This array defines the display order in the table and comes from the Excel data loading process.
                            const rubroDetailOrder = scenarioData.data[type][rubroKey].detailOrder ?? []; // Get/default detailOrder array
                           if (!rubroDetailOrder.includes(detailKey)) {
                               // console.log(`Structure init: Detail "${detailKey}" not found in rubro detailOrder. Adding.`);
                                rubroDetailOrder.push(detailKey); // Add if missing
                               // Keep rubroDetailOrder assigned back to the scenario data structure
                                scenarioData.data[type][rubroKey].detailOrder = rubroDetailOrder;
                            }

                      }); // End iteration over detail keys


                      // If a detail was in `detailOrder` but no longer exists in `detailsData`, remove it from `detailOrder`
                      // This handles cleanup of detail lines manually deleted from state or loaded Excel.
                      const rubroDetailOrder = scenarioData.data[type][rubroKey].detailOrder ?? [];
                      scenarioData.data[type][rubroKey].detailOrder = rubroDetailOrder.filter(detailKey => rubroDetailsData[detailKey] !== undefined); // Filter to keep only keys present in detailsData

                      // Sort the final detailOrder array alphabetically (optional, but keeps table consistent)
                       scenarioData.data[type][rubroKey].detailOrder.sort((a, b) => a.localeCompare(b));


                  }); // End iteration over global rubros for this type


                 // Ensure scenario's top-level rubroOrder list for this type matches the global settings rubros list
                 // This enforces the display order in the UI to follow the order defined/added in global settings.
                  scenarioData.rubroOrder[type] = globalRubrosForType.slice(); // Use a copy

             }); // End iteration over types ('gastos', 'ingresos')

             // Additional checks for structures not directly tied to rubros or in DefaultCalcStructure
             // E.g., Validate/ensure existence of base structure objects even if they had no children arrays initially
             scenarioData.data ??= { gastos: {}, ingresos: {} };
             scenarioData.monthStatus ??= { gastos: {}, ingresos: {} };
              scenarioData.rubroOrder ??= { gastos: [], ingresos: [] };
              scenarioData.reserveFund ??= { type: 'percent', values: Array(12).fill(5) }; // Redundant with earlier nullish coalescing but defensive
              scenarioData.calculated ??= defaultScenarioTemplatePart.calculated; // Redundant if done earlier


             // console.log("Initialization for scenario data complete.");
             // Return scenarioData (modified in place)

         }


        // --- Lógica de Negocio y Cálculos ---
         // Performs all calculations for the given scenario, updates calculated properties, saves state, and updates UI.
        function calculateAll(scenarioData) {
             console.log(`Recalculando TODO para: ${scenarioData?.year} - ${scenarioData?.scenarioName}`);
             if (!scenarioData || typeof scenarioData !== 'object' || !scenarioData.settings || typeof scenarioData.settings !== 'object') {
                 console.error("CalculateAll: Invalid scenario data or settings provided. Cannot calculate.");
                  renderEmptyState(); // Clear UI
                  // Show a critical error message? Handled by updateUI on invalid state.
                 return;
             }

             // Ensure scenario structures are complete *before* calculating anything
             // This handles cases where rubros/details/calculated sub-objects might exist in state but are inconsistent.
             // This is idempotent and safe to call even on already clean state.
             initializeScenarioDataForRubros(scenarioData, appState.settings); // Ensure scenarioData structure is valid


             const { data, monthStatus, reserveFund } = scenarioData; // Get references to source data & configs within scenario
             const { settings } = appState; // Get references to global settings (rubros, coefs, UF)


             const calculated = scenarioData.calculated; // Get reference to the calculated data structure *within this scenario*

             // --- Reset ALL calculated numeric properties ---
             // Use explicit Array(12).fill(0) to ensure clean slate for monthly values
             calculated.totalGastoProyectadoMes = Array(12).fill(0);
             calculated.totalIngresoProyectadoMes = Array(12).fill(0);
             calculated.fondoReservaMes = Array(12).fill(0);
             calculated.cuotaSobreGastosMes = Array(12).fill(0);
             calculated.cuotaIpcMes = Array(12).fill(0);
             calculated.cuotaRealBaseMes = Array(12).fill(0);

              // Reset calculated objects that accumulate totals per rubro/detail
              // Ensure objects exist before clearing contents
              calculated.gastoAjustado = calculated.gastoAjustado ?? {};
              calculated.totalGastoRubroMes = calculated.totalGastoRubroMes ?? {};
              calculated.ingresoAjustado = calculated.ingresoAjustado ?? {};
              calculated.totalIngresoRubroMes = calculated.totalIngresoRubroMes ?? {};

              // Clear nested contents of calculated objects (details, monthly rubro sums) based on currently known rubros
              // Use the global settings rubro lists for iterating over *defined* rubros,
              // but also consider rubros present in the scenario data but NOT settings (old data).
              // Best to iterate rubros present in scenario.data for the type OR settings, then filter later if not in settings.
              // However, calculateAll and updateCollapsibleTable logic is designed to FILTER by GLOBAL settings lists.
              // So, only reset keys corresponding to GLOBAL settings rubros? Or all keys in scenario.calculated.xyz?
              // Let's reset keys corresponding to GLOBAL settings rubros *plus* those in the scenario's data (handle legacy).
               const allKnownRubros = {
                   gastos: [...(appState.settings.rubros?.gastos || []), ...Object.keys(data?.gastos || {})].filter((v,i,a)=>a.indexOf(v)===i),
                   ingresos: [...(appState.settings.rubros?.ingresos || []), ...Object.keys(data?.ingresos || {})].filter((v,i,a)=>a.indexOf(v)===i)
               };

              ['gastos', 'ingresos'].forEach(type => {
                  // Ensure calculated objects exist before attempting to access keys
                  const calculatedForType = calculated[type === 'gastos' ? 'gastoAjustado' : 'ingresoAjustado'];
                  const calculatedTotalsForType = calculated[type === 'gastos' ? 'totalGastoRubroMes' : 'totalIngresoRubroMes'];

                  // Iterate over all known rubro keys (global + in data) to clear old calculated values
                  allKnownRubros[type].forEach(rubroKey => {
                       if (calculatedForType?.[rubroKey]) calculatedForType[rubroKey] = {}; // Clear detail calculations for this rubro
                       if (calculatedTotalsForType?.[rubroKey]) calculatedTotalsForType[rubroKey] = Array(12).fill(0); // Reset rubro monthly totals

                       // Reset annual totals per rubro
                        calculated.annualTotals[type] = calculated.annualTotals[type] ?? { __TOTAL__: 0 };
                        if (calculated.annualTotals[type]?.[rubroKey] !== undefined) calculated.annualTotals[type][rubroKey] = 0;
                   });
                   calculated.annualTotals[type].__TOTAL__ = 0; // Reset type overall annual total

              });


             // --- Synchronize ipcManual snapshot with current settings BEFORE calculation ---
             // This array of percentages is used for the 'Cuota IPC Calculada' line and summary IPC Ref column.
             // Get the values array from the GLOBAL IPC Coefficient type definition.
             const ipcCoefficientType = appState.settings.coefficientTypes?.[IPC_COEFFICIENT_KEY];
             // Copy percentage values (ensuring it's an array of 12 numbers, default to 0s if source is bad)
             calculated.ipcManual = Array.isArray(ipcCoefficientType?.values) && ipcCoefficientType.values.length === 12 && ipcCoefficientType.values.every(v => typeof v === 'number')
                                    ? ipcCoefficientType.values.map(v => v) // Copy numbers as is (percentages)
                                    : Array(12).fill(0); // Default to 0% if missing/corrupted settings data

             // Ensure ipcManual values are non-negative (they represent positive percentage changes)
              calculated.ipcManual = calculated.ipcManual.map(v => v >= 0 ? v : 0); // Ensures >= 0 %


             // 1. Gastos Ajustados and Totals
             // Iterate through rubros defined in GLOBAL settings lists *that are also present in THIS scenario's data*.
             const gastoRubrosInSettingsAndData = (appState.settings.rubros?.gastos || [])
                                          .filter(rubro => data.gastos?.[rubro]?.detailsData && Object.keys(data.gastos[rubro].detailsData).length > 0);


             gastoRubrosInSettingsAndData.forEach(rubro => {
                 const rubroData = data.gastos[rubro]; // Get rubro data from THIS scenario
                 const rubroConfigForCoef = appState.settings.rubroConfig?.[rubro]; // Get rubro config from GLOBAL settings

                 // Ensure calculated structures for this rubro are initialized and cleared (redundant after main reset, but safe)
                 calculated.gastoAjustado[rubro] ??= {}; // Object to hold detail values
                 calculated.totalGastoRubroMes[rubro] ??= Array(12).fill(0); // Array for monthly sums
                 calculated.annualTotals.gastos[rubro] ??= 0; // Annual total for this specific rubro


                 // Use the detail order defined *in THIS scenario data*
                 const detailOrder = rubroData.detailOrder || [];

                 detailOrder.forEach(detail => {
                      const detailDataArray = rubroData.detailsData?.[detail]; // Raw values loaded from file or last projection
                       // Ensure values array exists, is correct size, and contains only numbers
                      if (!Array.isArray(detailDataArray) || detailDataArray.length !== 12 || !detailDataArray.every(v => typeof v === 'number')) {
                           console.warn(`Calc (Gastos): Detail data array "${rubro}/${detail}" corrupted/missing. Skipping detail aggregation.`);
                           return; // Skip processing this detail line
                      }

                     // Initialize calculated.gastoAjustado entry for this detail if missing
                     calculated.gastoAjustado[rubro][detail] ??= Array(12).fill(0); // Will hold the FINAL calculated values

                     // In this version (v2.7), recalculateEstimates already calculated the 'adjusted' value
                     // based on real data and coefficient accumulation and STORED it directly in data.gastos[rubro].detailsData.
                     // So, calculateAll simply needs to use those stored values to sum totals.
                      // The monthStatus array from scenarioData.monthStatus is only used by updateCollapsibleTable for COLORING cells.
                     // The status DOES NOT determine the multiplier applied in calculateAll itself in this version.

                      detailDataArray.forEach((value, i) => {
                          const val = parseFloat(value || 0); // Ensure it's a number, use 0 if null/undefined

                          // Store the final calculated value (which came from load or projection) in calculated.gastoAjustado
                           calculated.gastoAjustado[rubro][detail][i] = val;

                         // Add this value to the monthly total for the rubro (this accumulates detail values)
                         calculated.totalGastoRubroMes[rubro][i] += val;
                     });
                 }); // End detailOrder loop

                 // Sum monthly totals for the rubro to the overall monthly total and this rubro's annual total
                 for (let i = 0; i < 12; i++) {
                     const monthTotalRubro = calculated.totalGastoRubroMes[rubro]?.[i] || 0;
                     calculated.totalGastoProyectadoMes[i] += monthTotalRubro; // Sum into overall monthly gasto
                     calculated.annualTotals.gastos[rubro] += monthTotalRubro; // Sum into this rubro's annual total
                 }
             }); // End gastoRubrosInSettingsAndData loop
             // Calculate the overall annual total for gastos (sum of all monthly overall totals)
             calculated.annualTotals.gastos.__TOTAL__ = calculated.totalGastoProyectadoMes.reduce((a, b) => a + (b||0), 0);


             // 2. Ingresos Adjusted (Base) & Totals (Final incl. UF mult) & Expensa Real Base Extraction
             const unidades = parseInt(settings.quantityUnits) || 1; // Get UF count from GLOBAL settings
             // Process only income rubros defined in GLOBAL settings lists *that are also present in THIS scenario's data*.
             const ingresoRubrosInSettingsAndData = (appState.settings.rubros?.ingresos || [])
                                          .filter(rubro => data.ingresos?.[rubro]?.detailsData && Object.keys(data.ingresos[rubro].detailsData).length > 0);


             ingresoRubrosInSettingsAndData.forEach(rubro => {
                  const rubroData = data.ingresos[rubro]; // Get rubro data from THIS scenario

                  // Ensure calculated structures for this rubro exist and are cleared
                  calculated.ingresoAjustado[rubro] ??= {}; // Stores BASE values (from Excel input) for detail display
                  calculated.totalIngresoRubroMes[rubro] ??= Array(12).fill(0); // Stores FINAL calculated value (incl. UF mult)
                  calculated.annualTotals.ingresos[rubro] ??= 0;


                 // Use the detail order defined *in THIS scenario data*
                 const detailOrder = rubroData.detailOrder || [];

                 detailOrder.forEach(detail => {
                      const baseValuesArray = rubroData.detailsData?.[detail]; // Raw values loaded from Excel file (base amounts)
                      // Ensure values array exists, is correct size, and contains only numbers
                       if (!Array.isArray(baseValuesArray) || baseValuesArray.length !== 12 || !baseValuesArray.every(v => typeof v === 'number')) {
                            console.warn(`Calc (Ingresos): Detail data array "${rubro}/${detail}" corrupted/missing. Skipping detail aggregation.`);
                            return; // Skip processing this detail line
                       }


                     // Store BASE values in 'ingresoAjustado' for the detail table display.
                     // Map to ensure they are numbers or 0, use value directly (no multiplication here).
                     calculated.ingresoAjustado[rubro][detail] = baseValuesArray.map(v => parseFloat(v || 0));


                     // Sum monthly BASE values for the rubro. This is an intermediate sum before UF multiplication.
                     for (let i = 0; i < 12; i++) {
                         calculated.totalIngresoRubroMes[rubro][i] += (baseValuesArray[i] || 0);
                     }
                 }); // End detailOrder loop

                 // After summing all details BASE values for the rubro, apply multiplication if it's a special rubro
                 // This updates totalIngresoRubroMes to hold the FINAL calculated value for this rubro (incl. UF mult if applicable)
                 // Multiplier is QuantityUnits if >= 1 and rubro is special type. Otherwise, multiplier is 1.
                 const rubroMultiplier = SPECIAL_INGRESO_RUBROS.includes(rubro) && unidades > 0 ? unidades : 1;

                 if (rubroMultiplier !== 1) {
                     for (let i = 0; i < 12; i++) {
                         calculated.totalIngresoRubroMes[rubro][i] *= rubroMultiplier;
                     }
                 } else if (SPECIAL_INGRESO_RUBROS.includes(rubro) && unidades <= 0) {
                      console.warn(`Cantidad de UF (${unidades}) es <= 0. Rubro "${rubro}" (tipo ingreso especial) no se multiplicará por UF.`);
                 }


                 // Sum the FINAL calculated monthly totals for this rubro into the overall monthly total and this rubro's annual total
                 for (let i = 0; i < 12; i++) {
                     const monthTotalRubroFinal = calculated.totalIngresoRubroMes[rubro]?.[i] || 0;
                     calculated.totalIngresoProyectadoMes[i] += monthTotalRubroFinal; // Sum into overall monthly income
                     calculated.annualTotals.ingresos[rubro] += monthTotalRubroFinal; // Sum into this rubro's annual total
                 }
             }); // End ingresoRubrosInSettingsAndData loop
             // Calculate the overall annual total for ingresos (sum of all monthly overall totals)
             calculated.annualTotals.ingresos.__TOTAL__ = calculated.totalIngresoProyectadoMes.reduce((a, b) => a + (b||0), 0);


             // --- Calculate Expensa Real ($/UF) ---
             // This uses the FINAL total calculated for the main CUOTA_RUBRO_NAME (Ord Expensa) and divides by UF count
             const unidadesParaExpensaReal = parseInt(settings.quantityUnits) || 1;

             if (unidadesParaExpensaReal <= 0) {
                  console.warn("Calc (Expensa Real): Cantidad de Unidades Funcionales es cero o inválida. Cuota Real Base por UF se establece a 0.");
                 calculated.cuotaRealBaseMes = Array(12).fill(0); // Array of 12 zeros
             } else {
                  // Get the FINAL monthly totals for the main CUOTA_RUBRO_NAME rubro (these *already* include UF mult)
                  const cuotaRubroFinalMonthlyTotals = Array.isArray(calculated.totalIngresoRubroMes?.[CUOTA_RUBRO_NAME]) && calculated.totalIngresoRubroMes[CUOTA_RUBRO_NAME].length === 12 && calculated.totalIngresoRubroMes[CUOTA_RUBRO_NAME].every(v => typeof v === 'number')
                                                         ? calculated.totalIngresoRubroMes[CUOTA_RUBRO_NAME].map(v => v)
                                                          : Array(12).fill(0); // Default to 0s if missing/corrupted

                 calculated.cuotaRealBaseMes = Array(12); // Initialize the output array
                 for (let i = 0; i < 12; i++) {
                     const totalRubroMesFinal = cuotaRubroFinalMonthlyTotals[i] || 0;
                     // Divide the final rubro total (which was Base Value * UF) by UF to get value PER UF
                     calculated.cuotaRealBaseMes[i] = totalRubroMesFinal / unidadesParaExpensaReal; // Value PER UF
                 }
             }
             // Calculate annual total for Expensa Real per UF (sum of monthly values per UF)
             calculated.annualTotals.cuotaRealBase = calculated.cuotaRealBaseMes.reduce((a,b)=>a+(b||0),0);


             // 3. Fondo Reserva
              // Ensure reserveFund exists in scenario data and get its config (type and values array)
              const reserveFundConfig = scenarioData.reserveFund ?? { type: 'percent', values: Array(12).fill(5) };
              const reserveFundValues = Array.isArray(reserveFundConfig.values) && reserveFundConfig.values.length === 12 && reserveFundConfig.values.every(v => typeof v === 'number')
                                    ? reserveFundConfig.values.map(v => v >= 0 ? v : 0) // Ensure non-negative for percentage/fixed amount inputs
                                     : Array(12).fill(reserveFundConfig.type === 'fixed' ? 0 : 5); // Default 0 or 5% if corrupted/missing


             for (let i = 0; i < 12; i++) {
                 const reserveValueInput = reserveFundValues[i] || 0;

                 calculated.fondoReservaMes[i] = reserveFundConfig.type === 'percent'
                     ? (calculated.totalGastoProyectadoMes[i] || 0) * (reserveValueInput / 100) // Apply percentage (e.g. 5 becomes 0.05 multiplier) on total monthly gasto
                     : reserveValueInput; // Use fixed value directly
             }
             calculated.annualTotals.fondoReserva = calculated.fondoReservaMes.reduce((a, b) => a + (b||0), 0);


             // 4. Cuota Sobre Gastos (Total Gasto + Fondo) / UF
             const unidadesParaCuotaSobreGastos = parseInt(settings.quantityUnits) || 1;
             for (let i = 0; i < 12; i++) {
                 const totalGastoYFondo = (calculated.totalGastoProyectadoMes[i] || 0) + (calculated.fondoReservaMes[i] || 0);
                 calculated.cuotaSobreGastosMes[i] = unidadesParaCuotaSobreGastos > 0 ? totalGastoYFondo / unidadesParaCuotaSobreGastos : 0;
             }
             // Calculate annual total for Cuota Sobre Gastos (sum of monthly $/UF values)
             calculated.annualTotals.cuotaSobreGastos = calculated.cuotaSobreGastosMes.reduce((a, b) => a + (b||0), 0);


             // 5. Cuota IPC Calculada
             // This calculates a reference "Cuota IPC" value PER UF, starting with the Enero Expensa Real ($/UF) base
             // and cumulatively applying the monthly percentages from the IPC Ref (snapshot in calculated.ipcManual).
             {
                 const ipcRefPercentages = calculated.ipcManual || Array(12).fill(0); // Get the IPC snapshot percentages (already non-negative by initialization)

                 // Use the calculated Expensa Real ($/UF) value from January as the base value PER UF
                 const baseEneroPerUF = calculated.cuotaRealBaseMes?.[0] || 0; // January Expensa Real ($/UF)


                 // January calculation: Start with base Enero Expensa Real and apply Enero IPC % increase
                 const ipcEneroPercentage = parseFloat(ipcRefPercentages?.[0] || 0); // Get percentage for Enero
                  // Calculate multiplier (1 + percentage/100). Already >= 0 by initialization.
                 const ipcEneroMultiplier = 1 + (ipcEneroPercentage / 100);

                 calculated.cuotaIpcMes[0] = baseEneroPerUF * ipcEneroMultiplier; // Calculated value for January PER UF


                 // Subsequent months (accumulative)
                 for (let i = 1; i < 12; i++) {
                     const ipcMonthPercentage = parseFloat(ipcRefPercentages?.[i] || 0); // Get percentage for current month `i`
                     // Calculate multiplier (1 + percentage/100) for current month `i`. Already >= 0.
                     const ipcMonthMultiplier = 1 + (ipcMonthPercentage / 100);

                     // Calculated value for current month `i` = previous month's (i-1) calculated Cuota IPC value * current month's (i) IPC multiplier
                     calculated.cuotaIpcMes[i] = (calculated.cuotaIpcMes[i - 1] || 0) * ipcMonthMultiplier; // Calculated value for month `i` PER UF
                 }
             }
             // Calculate annual total for Cuota IPC Calculada (sum of monthly $/UF values)
             calculated.annualTotals.cuotaIpc = calculated.cuotaIpcMes.reduce((a, b) => a + (b||0), 0);


             console.log("Recálculo Finalizado.", calculated);

             // Save the state *after* calculation completes and calculated data is populated/updated
             saveState();

             // Update the UI to display the new calculated data
             updateUI();

             // Show success message
             showSnackbar("Cálculos actualizados correctamente.", false, 'success');
        }


        // --- Recalculate Estimates (ACCUMULATIVE) - Applies Percentage Coefs ---
        // This function projects GASTO values for months currently marked as 'Estimado',
        // starting from the last found 'REAL' value for each individual detail line.
        // The projection applies the coefficient assigned to the rubro cumulatively month-by-month.
        // It only modifies data.gastos and monthStatus.gastos for 'Estimado' cells AFTER the last REAL.
        function recalculateEstimates() {
            const scenarioData = getCurrentScenarioData(); // Get current scenario data
            // Ensure we have valid scenario data before proceeding
            if (!scenarioData || typeof scenarioData !== 'object' || !scenarioData.settings || typeof scenarioData.settings !== 'object') {
                 showSnackbar("No hay escenario activo para calcular estimados o datos de configuración.", true, 'error');
                 return;
            }
             // Ensure structures are complete, including monthStatus for Gastos details
             initializeScenarioDataForRubros(scenarioData, appState.settings);


            const { data, monthStatus } = scenarioData; // Need data to read/write values, monthStatus to check status
            const { settings } = appState; // Need settings for rubroConfig (coefficient assignments) and coefficientTypes (coefficient values)
            const { rubroConfig, coefficientTypes } = settings;

            let changesMade = false; // Flag to track if any data values or statuses were modified


             // Iterate only through rubros that are marked as GASTOS in global settings
             // AND exist as keys in this scenario's `data.gastos` with actual detail data
             const gastoRubrosToProcess = (settings.rubros?.gastos || [])
                                         .filter(rubroKey => data.gastos?.[rubroKey]?.detailsData && Object.keys(data.gastos[rubroKey].detailsData).length > 0); // Rubro exists & has detail data


            if (gastoRubrosToProcess.length === 0) {
                 console.log("RecalcEstimates: No expense rubros with data found in settings/scenario.");
                 showSnackbar("No hay rubros de gastos con datos cargados para calcular estimados.", false, 'info');
                 return; // Exit if no applicable rubros found
            }


            gastoRubrosToProcess.forEach(rubroKey => {
                const rubroData = data.gastos[rubroKey]; // Data object for this rubro in the scenario (holds detail data and detail order)
                 // Get monthStatus object for this rubro in the scenario (maps detail keys to status arrays)
                 // Initialize if somehow missing (defensive, initializeScenarioData handles this)
                const rubroStatus = monthStatus.gastos?.[rubroKey] ?? {};

                // Get the key of the assigned coefficient type for this rubro from GLOBAL settings config. Default to 'None'.
                const rubroConfigForCoef = rubroConfig[rubroKey] || {};
                const coefTypeKey = rubroConfigForCoef.coefficientType || 'None';

                 // Get the array of monthly percentage values for the assigned coefficient type from GLOBAL settings.
                 // Default to an array of 0s (0% change) if the type or values are missing/corrupted.
                const coefPercentageValues = (coefficientTypes[coefTypeKey]?.values || Array(12).fill(0))
                                               .slice(0, 12) // Ensure it has exactly 12 elements
                                               .map(v => typeof v === 'number' ? (v >= 0 ? v : 0) : 0); // Ensure numbers and non-negative


                // Iterate through detail lines *defined in the scenario's detailOrder* for this rubro.
                // Filter to only include details that also have data AND status arrays.
                const detailsToProcess = (rubroData.detailOrder || [])
                                         .filter(detailKey => rubroData.detailsData?.[detailKey] !== undefined && rubroStatus?.[detailKey] !== undefined); // Detail exists & has data & status

                detailsToProcess.forEach(detailKey => {
                     const detailDataArray = rubroData.detailsData[detailKey]; // The actual array of 12 monthly values
                     const detailStatusArray = rubroStatus[detailKey]; // The actual array of 12 status strings


                     // --- Find the Last REAL Month ---
                     let lastRealMonthIndex = -1;
                     // Iterate backwards from December (index 11) to January (index 0)
                     for (let i = detailStatusArray.length - 1; i >= 0; i--) {
                         if (detailStatusArray[i] === 'REAL') {
                             lastRealMonthIndex = i;
                             break; // Stop when the latest REAL month is found
                         }
                     }

                     if (lastRealMonthIndex === -1) {
                         // If no REAL month is found for this detail line throughout the year, there's no base to project from.
                         // console.log(`   - Detail "${rubroKey}/${detailKey}": No REAL month found. Skipping projection.`);
                         return; // Skip projection for this detail line
                    }

                    // --- Perform Cumulative Projection from the month AFTER the last REAL month ---
                    // The starting value for the accumulation is the value from the last month marked as 'REAL'.
                    let previousMonthValueForProjection = parseFloat(detailDataArray[lastRealMonthIndex] || 0);

                    // Loop through months from the one AFTER the last REAL month (index `lastRealMonthIndex + 1`) up to December (index 11).
                    for (let j = lastRealMonthIndex + 1; j < 12; j++) {

                         // IMPORTANT: If we encounter a month index `j` that is CURRENTLY marked as 'REAL' (e.g., data was loaded sporadically),
                         // we should STOP projecting this specific estimated segment. The REAL data acts as a new base.
                         // Update the `previousMonthValueForProjection` to this new REAL value and continue the loop.
                         // Projection logic effectively runs on segments between REAL data points.
                         if (detailStatusArray[j] === 'REAL') {
                             console.log(`   - Detail "${rubroKey}/${detailKey}": Month ${FULL_MONTHS[j]} is REAL. Resuming projection from this value for later months.`);
                              // The previousMonthValueForProjection should now take the value of THIS Real month.
                             previousMonthValueForProjection = parseFloat(detailDataArray[j] || 0);
                             continue; // Skip the projection calculation for this specific month `j` because it's REAL
                         }

                        // If the current month `j` is marked as 'Estimado', apply the coefficient for this month.
                         const percentage = coefPercentageValues[j]; // Get the percentage value for month `j` (guaranteed number >= 0 by checks above)
                        // Calculate the multiplier from the percentage: (1 + percentage / 100).
                        // Example: 5% becomes 1.05, 0% becomes 1.00.
                         const multiplier = 1 + (percentage / 100);

                         // Calculate the projected value for month `j`: It's the value of the *previous* month's projection result
                         // (or the last REAL value if this is the first month after the last REAL) multiplied by the current month's multiplier.
                         const projectedValue = previousMonthValueForProjection * multiplier;

                         // Check if updating this month's value and status is necessary.
                         // Only make changes if the current stored value is significantly different from the new projected value
                         // OR if the status for this month is not already 'Estimado' (e.g., if it was mistakenly left as REAL during a partial update).
                         const currentMonthStoredValue = detailDataArray[j]; // The value currently in data.gastos
                         const epsilon = 0.001; // Tolerance for floating-point comparison

                         if (Math.abs(currentMonthStoredValue - projectedValue) > epsilon || detailStatusArray[j] !== 'Estimado') {
                            // Make the changes: update the value in the data array and ensure status is 'Estimado'.
                            detailDataArray[j] = projectedValue; // Update the monthly value in the scenario data
                            detailStatusArray[j] = 'Estimado'; // Ensure status is marked as 'Estimado'

                            changesMade = true; // Mark that changes were made
                             // console.log(`     * Projected ${rubroKey}/${detailKey} - ${FULL_MONTHS[j]}: ${projectedValue.toFixed(2)} (Base: ${previousMonthValueForProjection.toFixed(2)} * Multiplier: ${multiplier.toFixed(3)} from ${percentage}%)`);
                         }

                         // --- Update for Next Iteration ---
                         // Set `previousMonthValueForProjection` to the `projectedValue` for month `j`.
                         // This value will be used as the base for the calculation of month `j+1`, achieving cumulative projection.
                         previousMonthValueForProjection = projectedValue;

                    } // End month loop (j)
                     console.log(`   - Detail "${rubroKey}/${detailKey}": Projection complete starting from ${FULL_MONTHS[lastRealMonthIndex]}.`);

                }); // End detailsToProcess loop
             }); // End gastoRubrosToProcess loop

            // --- Finalize RecalculateEstimates ---
            if (changesMade) {
                console.log("Se realizaron cambios en los estimados de gastos. Saving state and recalculating all summaries...");
                // Save state immediately after modifying data/status arrays.
                // A subsequent calculateAll call is needed to re-sum totals based on these new values.
                calculateAll(scenarioData); // calculateAll saves state and updates UI again.
                // A snackbar message for successful calculation will be shown by calculateAll.
                // Show a preceding snackbar indicating *what* happened (estimates projected)
                showSnackbar("Meses estimados de gastos recalculados (acumulativo).", false, 'info', 3000);

            } else {
                // If no changes were necessary (all future months were already Real or already matched the projection), just inform the user.
                console.log("No se necesitaron cambios en los estimados de gastos.");
                showSnackbar("No se encontraron meses estimados de gastos que requieran recalcular.", false, 'info');
            }
        }


        // --- Actualización de la Interfaz (UI) ---

        // Initial UI setup upon DOM ready.
        function initUI() {
             // Set current year in upload tab input field
             const yearInput = document.getElementById('exercise-year');
             if (yearInput) yearInput.setAttribute('value', appState.currentYear);
              else console.warn("Upload tab year input not found.");

             // Set the current year in the footer
             const footerYearSpan = document.getElementById('footer-year');
             if (footerYearSpan) footerYearSpan.textContent = new Date().getFullYear();
             else console.warn("Footer year span not found.");


             // Populate the scenario selector dropdown based on available scenarios in the state
             updateScenarioSelector();
             // Update titles in tabs to reflect the currently active year and scenario name
             updateCurrentYearAndScenarioInUI();

             // Add the default placeholder message to the coefficient editor area.
             // It will be replaced by the monthly inputs grid when a coefficient type is selected.
            const coefEditorDiv = document.getElementById('coefficient-values-editor');
             if (coefEditorDiv) {
                 coefEditorDiv.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente de la lista (que no sea "Sin Coeficiente") para editar sus valores (en porcentaje %).</p>';
                  // Ensure the grid layout class is not applied initially
                 coefEditorDiv.classList.remove('monthly-inputs-grid');
             } else {
                 console.warn("Coefficient editor div not found.");
             }

             // No explicit IPC inputs rendering here anymore, as it's handled by the generic coef editor.

             // Initial call to update settings panel just in case other parts are updated by default state
             // updateSettingsPanel(); // Not needed here, updateUI calls it after scenario data is fully processed.
        }

        // Central function to update all dynamic parts of the user interface.
        // Should be called after state changes or calculations.
        function updateUI() {
             console.log("Updating complete UI display...");
             // Get the current scenario data object from the state
             const scenarioData = getCurrentScenarioData();


             // Check if a valid scenario data object was retrieved.
             // If not, render an empty state and stop updating dependent elements.
             if (!scenarioData) {
                 console.error("updateUI: No valid scenario data found. Cannot render Dashboard, Reserve, or Reports content.");
                 renderEmptyState(); // Clear/Reset UI dependent on scenario data
                 // Update elements that might exist regardless of specific scenario data existence
                 updateCurrentYearAndScenarioInUI(); // Update year/scenario name display (might show "Ninguno")
                 updateScenarioSelector(); // Refresh scenario dropdown (might be empty or show other years)
                 updateReportsPanel(); // Disable reports buttons
                 updateSettingsPanel(); // Refresh settings lists/editors (depends on global settings, not specific scenario data)

                  // Potentially show a general error snackbar if state is invalid.
                  // Already handled by loadState/validateAndSetActiveScenario, avoid redundancy here.
                 return; // Stop execution
             }

             // Ensure the retrieved scenario data object has its internal structures (like data, calculated)
             // initialized and consistent with the global settings *before* rendering UI elements that read them.
             // This is defensive; initializeScenarioDataForRubros is called on load and validate/create, but this ensures latest consistency.
             initializeScenarioDataForRubros(scenarioData, appState.settings);


             // Update the dashboard summary and detail tables based on scenario data
             updateDashboardTables(scenarioData);

             // Update the charts based on scenario data
             updateCharts(scenarioData);

             // Update the Reserve Fund configuration panel UI based on scenario data
             updateReserveFundPanel(scenarioData);

             // Update the Settings panel lists and editors based on global settings
             updateSettingsPanel();

             // Update the Reports panel buttons enable/disable state based on calculation status
             updateReportsPanel();

             // Update the year/scenario name display in all tabs based on the active scenario
             updateCurrentYearAndScenarioInUI();

             console.log("Complete UI display updated.");
        }

        // Clears dashboard tables and hides charts, displaying placeholder messages.
        function renderEmptyState() {
            console.log("Rendering empty state...");
            // Find table elements
            const summaryTable = document.getElementById('dashboard-summary');
            const gastosTable = document.getElementById('gastos-detail-table');
            const ingresosTable = document.getElementById('ingresos-detail-table');

             // Determine colspan based on table headers found or a reasonable default if tables missing
             const summaryHeaderCols = summaryTable?.querySelector('thead tr')?.cells?.length || 8; // Header has 8 columns in summary
             const gastosHeaderCols = gastosTable?.querySelector('thead tr')?.cells?.length || 15; // Header has Rubro, Coef, 12M, Total = 15
             const ingresosHeaderCols = ingresosTable?.querySelector('thead tr')?.cells?.length || 14; // Header has Rubro, 12M, Total = 14


            // Function to clear table body and footer with a placeholder message
            const clearTableWithEmptyMessage = (tableId, colspan) => {
                 const table = document.getElementById(tableId);
                 if (table) {
                      const tbody = table.querySelector('tbody');
                      const tfoot = table.querySelector('tfoot');
                       if (tbody) {
                            // Add placeholder row spanning all columns
                            const tableName = tableId === 'dashboard-summary' ? 'dashboard' : (tableId === 'gastos-detail-table' ? 'gastos' : 'ingresos'); // Get descriptive name
                             tbody.innerHTML = `<tr><td colspan="${colspan}" class="text-muted" style="text-align: center; padding: 20px;">${tableName === 'dashboard' ? 'No hay datos calculados para este escenario.' : `No hay datos ${tableName === 'gastos' ? 'de gastos' : 'de ingresos'} para mostrar.`} Carga datos o usa los de ejemplo y luego ejecuta Calcular Estimados.</td></tr>`;
                       } else { console.warn(`Table tbody not found for ${tableId}`); }
                      if (tfoot) tfoot.innerHTML = ''; // Ensure footer is clear
                       else { console.warn(`Table tfoot not found for ${tableId}`); }
                 } else { console.warn(`Table element not found for ${tableId}`); }
            };


            // Clear specific tables by ID and appropriate colspan
             clearTableWithEmptyMessage('dashboard-summary', summaryHeaderCols);
             clearTableWithEmptyMessage('gastos-detail-table', gastosHeaderCols);
             clearTableWithEmptyMessage('ingresos-detail-table', ingresosHeaderCols);


            // Destroy any existing Chart.js instances
            destroyChart('evolutivoCuotaChart');
            destroyChart('participacionGastosChart');
            destroyChart('participacionIngresosChart');

             // Explicitly show "No Data" messages for all charts after destroying instances
             // This also hides the canvas elements.
             displayChartNoData('evolutivoCuotaChart', true);
             displayChartNoData('participacionGastosChart', true);
             displayChartNoData('participacionIngresosChart', true);


            // Clear coefficient editor content and reset editing state
            const coefEditorDiv = document.getElementById('coefficient-values-editor');
            const coefNameSpan = document.getElementById('editing-coefficient-name');
             if(coefEditorDiv) {
                  coefEditorDiv.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente de la lista (que no sea "Sin Coeficiente") para editar sus valores (en porcentaje %).</p>';
                  coefEditorDiv.classList.remove('monthly-inputs-grid'); // Ensure grid class is removed when empty
             } else { console.warn("Coefficient editor div not found.");}

            if(coefNameSpan) coefNameSpan.textContent = 'Ninguno';
             else { console.warn("Editing coefficient name span not found."); }

             // Update UI state flag
            if(appState.uiState) appState.uiState.editingCoefficientType = null;


             // Refresh the coefficient type list UI to update the highlighting (no selection should be highlighted)
            updateCoefficientTypeList();
        }

         // Destroys a Chart.js instance and manages associated canvas display and container classes.
        function destroyChart(canvasId) {
             // Get the Chart.js instance by its window property reference
             const chart = window[`${canvasId}_instance`];
             const canvasElement = document.getElementById(canvasId); // Get the canvas element

             // Get the chart container element (parent of the canvas)
             const container = canvasElement?.parentElement;


             // If a chart instance exists, destroy it using Chart.js method
             if (chart && typeof chart.destroy === 'function') {
                chart.destroy();
                window[`${canvasId}_instance`] = null; // Nullify the global reference
                // console.log(`Chart ${canvasId} destroyed.`);
             }

              // Ensure canvas is generally visible (display: block) after potential destroy, unless displayChartNoData overrides
             if (canvasElement) canvasElement.style.display = 'block';

              // Remove 'no-data' class from container. displayChartNoData will re-add it if needed.
              // This is important if you are recreating a chart that *might* have data this time.
             if (container) container.classList.remove('no-data');

         }

         // Toggles the visibility of the "No Data" message for a chart and the canvas element itself.
         // Applies a 'no-data' class to the chart's container for easier CSS management.
        function displayChartNoData(canvasId, show) {
            const canvasElement = document.getElementById(canvasId);
            // Return if the canvas element isn't found
            if (!canvasElement) {
                console.warn(`Canvas element not found for ${canvasId}. Cannot manage no-data display.`);
                return;
            }

            // Get the parent container element for styling
            const container = canvasElement.parentElement;

            // If the container element exists, toggle the 'no-data' class on it
            if (container) {
                 // Toggling the class directly affects the display of both the canvas (via CSS in style block)
                 // and the 'chart-no-data' message (also via CSS in style block).
                container.classList.toggle('no-data', show);
            } else {
                 // Fallback logic if the container isn't found (less robust)
                 console.warn(`Chart container not found for ${canvasId}. Fallback to managing canvas/message display directly.`);
                 canvasElement.style.display = show ? 'none' : 'block'; // Hide/show canvas
                 const noDataElement = canvasElement.nextElementSibling; // Assume message is the next sibling
                 if(noDataElement && noDataElement.classList.contains('chart-no-data')) {
                    noDataElement.style.display = show ? 'block' : 'none'; // Hide/show message
                 }
            }
         }


        // Update Reserve Fund panel monthly inputs UI based on the selected type
        function updateReserveUI() {
             // This function is called when the 'reserve-type-percent' or 'reserve-type-fixed' radio button's value changes.
             // It updates the UI elements (labels, step) to match the currently selected calculation type.
             // It reads the currently selected type directly from the DOM radio buttons.
             const percentRadio = document.getElementById('reserve-type-percent');
             const fixedRadio = document.getElementById('reserve-type-fixed');
             const selectedType = percentRadio?.checked ? 'percent' : 'fixed'; // Determine selected type


             const panel = document.getElementById('reserve-fund-panel');
             if (!panel) {
                console.warn("Reserve fund panel element not found for UI update.");
                return; // Exit if panel element not found
            }

            // Update radio button check state in UI based on the scenario data *if available*.
            // This part ensures that when updateUI calls updateReserveUI, the radio buttons reflect the saved state.
             const scenarioData = getCurrentScenarioData();
             if (scenarioData?.reserveFund) {
                 if (percentRadio) percentRadio.checked = scenarioData.reserveFund.type === 'percent';
                 if (fixedRadio) fixedRadio.checked = scenarioData.reserveFund.type === 'fixed';
                  // After updating based on state, NOW read the *UI's* selected state again to ensure UI elements match what the user sees/interacts with
                   const uiSelectedType = percentRadio?.checked ? 'percent' : 'fixed';
                   const unitLabel = uiSelectedType === 'percent' ? '%' : '$';
                   const currentStep = uiSelectedType === 'percent' ? '0.1' : '100';
                   const inputPlaceholder = uiSelectedType === 'percent' ? 'Ej: 5' : 'Ej: 10000';
                   const inputTitlePrefix = uiSelectedType === 'percent' ? 'Porcentaje (%) para ' : 'Valor fijo ($) para ';


                  panel.querySelectorAll('.form-group').forEach(formGroup => {
                       const inputGroup = formGroup.querySelector('.input-with-unit');
                       const input = inputGroup?.querySelector('input[type="number"]');
                       const unitSpan = inputGroup?.querySelector('span');
                       const monthIndex = parseInt(input?.dataset.month);


                      // Update step, placeholder, and title for inputs
                       if (input) {
                            input.step = currentStep;
                            input.placeholder = inputPlaceholder;
                             if (!isNaN(monthIndex)) { // Ensure monthIndex is valid
                                  input.title = `${inputTitlePrefix}${FULL_MONTHS[monthIndex]}`;
                             } else {
                                 input.title = inputTitlePrefix; // Generic title if month index is bad
                            }

                            // Update the displayed value in the input field based on the saved state *for that month*.
                             // This happens correctly in updateReserveFundPanel itself during rendering of the month inputs grid.
                            // No need to manually change input.value here inside the UI update handler,
                            // as it will be overwritten when the grid is built. This function primarily updates labels/hints.

                       } else { console.warn("Reserve UI update: input element not found within form group."); }

                       // Update unit text
                       if (unitSpan) { unitSpan.textContent = unitLabel; } else { console.warn("Reserve UI update: unit span not found within input group.");}

                       // Label text doesn't change, it's just the month name.
                  });
             } else {
                console.warn("Reserve UI update: No scenario data or reserveFund config found to update UI.");
                 // If no scenario/config, just show default labels/units (likely fixed)
                 const unitLabel = 'percent' === 'percent' ? '%' : '$'; // Default to percent display
                  const currentStep = '0.1';
                   panel.querySelectorAll('.form-group').forEach(formGroup => {
                       const inputGroup = formGroup.querySelector('.input-with-unit');
                        const input = inputGroup?.querySelector('input[type="number"]');
                       const unitSpan = inputGroup?.querySelector('span');
                       if (input) { input.step = currentStep; input.placeholder = 'Ej: 5'; }
                        if (unitSpan) unitSpan.textContent = unitLabel;
                        // Titles not set without monthIndex from dataset.
                   });

             }

        }


        // Update settings UI elements: quantity units input, rubro lists, coefficient list and editor.
        function updateSettingsPanel() {
            // Get UI elements
            const ufInput = document.getElementById('cantidad-unidades');
             const gastoRubroListEl = document.getElementById('gasto-rubro-list');
             const ingresoRubroListEl = document.getElementById('ingreso-rubro-list');
             const coefTypeListEl = document.getElementById('coefficient-type-list');
            const coefEditorDiv = document.getElementById('coefficient-values-editor');


             // Update Quantity Units input
            if (ufInput && appState.settings) {
                 // Use quantityUnits consistently. Ensure it's a number >= 1 before assigning to value.
                 ufInput.value = (typeof appState.settings.quantityUnits === 'number' && appState.settings.quantityUnits >= 1)
                                 ? appState.settings.quantityUnits : (getDefaultAppState().settings?.quantityUnits || 1); // Use valid number or default to 1

            } else { console.warn("Quantity units input not found or appState.settings missing."); }

            // Update rubro lists for Gastos and Ingresos
             if (gastoRubroListEl) updateRubroList('gastos', 'gasto-rubro-list'); else console.warn("Gasto rubro list element not found.");
             if (ingresoRubroListEl) updateRubroList('ingresos', 'ingreso-rubro-list'); else console.warn("Ingreso rubro list element not found.");


            // Update the list of coefficient types available
             if (coefTypeListEl) updateCoefficientTypeList(); else console.warn("Coefficient type list element not found.");


             // Check which coefficient type is currently selected for editing in the UI state
            const currentEditingTypeKey = appState.uiState?.editingCoefficientType;

             // Render the monthly value inputs area for the selected type, or show default message if none/invalid selected
            if (coefEditorDiv) {
                renderCoefficientValuesEditor(currentEditingTypeKey); // Handles displaying inputs or default message
            } else {
                console.warn("Coefficient editor div not found.");
            }
        }

        // Updates the lists of rubros in the settings tab based on global appState.settings.rubros.
         // Populates the list items and assigns coefficient selectors for 'gastos' rubros.
        function updateRubroList(type, listId) {
             const listElement = document.getElementById(listId);
             if (!listElement) {
                 console.warn(`Rubro list element "${listId}" not found.`);
                return;
            }

             listElement.innerHTML = ''; // Clear existing list items

             // Get the list of rubros for the specified type from global settings
             // Ensure it's an array, fallback to empty array if missing or not array
             const rubrosInSettings = Array.isArray(appState.settings?.rubros?.[type])
                                        ? appState.settings.rubros[type]
                                         : [];

             // Sort rubros alphabetically for consistent list display
             const sortedRubros = rubrosInSettings.slice().sort((a, b) => a.localeCompare(b));


             // Display a message if there are no rubros defined for this type
             if (sortedRubros.length === 0) {
                 listElement.innerHTML = '<li class="text-muted" style="padding: 10px 8px;">No hay rubros definidos. Añade uno manualmente o carga un Excel.</li>';
                 return; // Exit function early if no rubros to list
             }

             // Get necessary references from global settings
              const rubroConfig = appState.settings?.rubroConfig || {}; // Config for individual rubros
              const coefTypes = appState.settings?.coefficientTypes || {}; // Definitions of coefficient types


             // Iterate over the sorted list of rubros to build list items
             sortedRubros.forEach(rubro => {
                 const li = document.createElement('li'); // Create list item element
                 li.title = rubro; // Add title for hover (useful for long names)

                 const span = document.createElement('span'); // Span for the rubro name
                 span.textContent = rubro;
                 li.appendChild(span);


                 // If the rubro type is 'gastos', add a coefficient assignment dropdown
                 if (type === 'gastos') {
                     const select = document.createElement('select'); // Create select element
                     select.title = `Asignar coeficiente de ajuste para ${rubro}`;
                     select.dataset.rubro = rubro; // Store the rubro name in a data attribute
                     select.onchange = handleCoefficientAssignmentChange; // Assign the change handler


                      // Populate the dropdown with coefficient type options
                      // Filter out potentially null/undefined keys from coefficientTypes
                       const availableCoefKeys = Object.keys(coefTypes || {}).filter(key => coefTypes[key]);


                      // Sort coefficient type keys alphabetically by name, but put 'None' and 'IPC' first if they exist
                     const sortedCoefKeys = availableCoefKeys.sort((a, b) => {
                          const nameA = coefTypes[a]?.name || a; // Use name from data or key if missing
                          const nameB = coefTypes[b]?.name || b;

                          if (a === 'None' || a === IPC_COEFFICIENT_KEY) return -1; // None and IPC first
                          if (b === 'None' || b === IPC_COEFFICIENT_KEY) return 1;

                          return nameA.localeCompare(nameB); // Alphabetical sort by name for others
                     });

                     // Add options to the select dropdown
                     sortedCoefKeys.forEach(coefKey => {
                           const coefTypeData = coefTypes[coefKey]; // Get coefficient type definition

                           // Create option element
                           const option = document.createElement('option');
                           option.value = coefKey; // Value is the coefficient type key (string)
                           option.textContent = coefTypeData?.name || coefKey; // Display name (use key if name missing)


                           // Set the selected option based on the rubroConfig in global settings
                           // Use rubroConfig[rubro]?.coefficientType with nullish coalescing to default to 'None' if config missing or property missing
                            const assignedCoefTypeKey = rubroConfig[rubro]?.coefficientType ?? 'None'; // Get saved assignment key, defaulting to 'None'
                            if (assignedCoefTypeKey === coefKey) {
                               option.selected = true;
                            }


                           select.appendChild(option); // Add the option to the select dropdown
                     });

                      // Ensure the select's *displayed value* matches the state, especially if the assigned type was somehow deleted after being assigned
                       // Get the assigned coefficient type key from the state, default to 'None' if missing config or property
                       const assignedCoefTypeKey = rubroConfig[rubro]?.coefficientType ?? 'None';
                      // Check if the saved assignment key actually exists in the available options list or if it's 'None'.
                      // If not ('None' is handled explicitly), set the select's value to 'None' as a fallback.
                       const isAssignedKeyValid = coefTypes[assignedCoefTypeKey] !== undefined || assignedCoefTypeKey === 'None';
                       if (!isAssignedKeyValid) {
                            console.warn(`Rubro "${rubro}" assigned deleted/invalid coef type "${assignedCoefTypeKey}". Defaulting select value to "None".`);
                           select.value = 'None'; // Force UI select to 'None'
                            // Optionally, update the state as well if needed? No, let saveSettings handle state cleanup.
                       } else {
                            select.value = assignedCoefTypeKey; // Set the select value based on the state (the correct one)
                       }


                     li.appendChild(select); // Add the select element to the list item
                 }


                 // Add the delete button for the rubro
                 const deleteBtn = document.createElement('button'); // Create delete button element
                 deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>'; // Set button icon (Font Awesome)
                 deleteBtn.classList.add('button-danger', 'button-sm'); // Add styling classes
                 deleteBtn.title = `Eliminar rubro "${rubro}" (¡no se puede deshacer!)`; // Add hover title
                 deleteBtn.onclick = () => deleteRubro(type, rubro); // Assign click handler


                 // Determine if the delete button should be disabled
                 const isDefaultRubro = false; // Currently, there are no predefined rubros in the list arrays in getDefaultAppState. If you add names like ["Seguridad", "Administración"] directly there, you would need logic here to mark them as non-deletable defaults.
                 // For now, all rubros added manually or from Excel can be deleted.
                  if (isDefaultRubro) deleteBtn.disabled = true;


                 li.appendChild(deleteBtn); // Add the delete button to the list item


                 listElement.appendChild(li); // Add the completed list item to the UI list
             }); // End forEach sortedRubros loop
        }

         // Updates the list of coefficient types in the settings tab based on global appState.settings.coefficientTypes.
         // Controls selection highlight and delete button state.
        function updateCoefficientTypeList() {
             const listElement = document.getElementById('coefficient-type-list');
             if (!listElement) {
                 console.warn("Coefficient type list element not found.");
                return; // Exit if list element not found
             }

             listElement.innerHTML = ''; // Clear existing list items

             // Get the coefficient types definitions from global settings.
             // Ensure the object exists, fallback to empty object if missing.
             const coefTypes = appState.settings?.coefficientTypes || {};
             // Get the key of the coefficient type currently selected for editing in the UI state.
             const currentEditingTypeKey = appState.uiState?.editingCoefficientType;


             // Filter out potential null/undefined type entries
              const availableCoefKeys = Object.keys(coefTypes || {}).filter(key => coefTypes[key]);

              // Sort coefficient type keys for consistent list display.
              // Put 'None' and 'IPC' (if default) first, then sort others alphabetically by name.
             const sortedKeys = availableCoefKeys.sort((a, b) => {
                  const typeA = coefTypes[a]; const typeB = coefTypes[b];
                   const nameA = typeA?.name || a; // Use name from data or key if missing
                   const nameB = typeB?.name || b;

                  // Primary sort: Put 'None' and default 'IPC' first
                  if (a === 'None') return -1; // None comes before anything else
                  if (b === 'None') return 1;
                  if (a === IPC_COEFFICIENT_KEY && typeA?.isDefault) return -1; // IPC default comes after None but before others
                  if (b === IPC_COEFFICIENT_KEY && typeB?.isDefault) return 1;

                  // Secondary sort: Alphabetical by name for all other types
                  return nameA.localeCompare(nameB);
             });


            // Display a message if there are no coefficient types defined (shouldn't happen if 'None' and 'IPC' defaults are guaranteed).
             if (sortedKeys.length === 0) {
                  // This fallback might only show if getDefaultAppState itself is broken or state is severely corrupted.
                 listElement.innerHTML = '<li class="text-muted" style="padding: 10px 8px;">No hay tipos de coeficientes definidos.</li>';
                 return; // Exit function
             }


             // Iterate through the sorted list of coefficient type keys to build list items
             sortedKeys.forEach(typeKey => {
                 const typeData = coefTypes[typeKey]; // Get the definition for this type key
                 if (!typeData) return; // Should not happen with filtered keys, but defensive.


                 const li = document.createElement('li'); // Create list item element
                 li.title = typeData.name; // Add hover title (uses the displayed name)

                 // Add special styling and make clickable for selection
                  li.style.cursor = (typeKey === 'None' || typeData.isDefault) ? 'default' : 'pointer'; // No pointer for default types

                 // Highlight if this type is currently selected for editing in the UI state
                 if (typeKey === currentEditingTypeKey) {
                     li.style.backgroundColor = 'var(--clickable-row-hover)';
                     li.style.fontWeight = 'bold';
                 }
                  // Add click handler *only if* the type is NOT a non-editable default ('None' or isDefault=true)
                 if (typeKey !== 'None' && !typeData.isDefault) { // Editable types are clickable to select for editing
                       li.onclick = () => selectCoefficientTypeForEditing(typeKey); // Assign the click handler
                 } else if (typeData.isDefault && typeKey !== 'None') {
                     // Default types (like IPC) are clickable to view values but not edit
                      // This doesn't currently require a specific handler, renderCoefficientValuesEditor will display read-only inputs
                      // For simplicity, clicking any default type will just set it as the "editing" type to view its values.
                      li.style.cursor = 'pointer'; // Make default clickable to view
                      li.onclick = () => selectCoefficientTypeForEditing(typeKey); // Use same selector for defaults now

                 } // 'None' is neither clickable to edit values nor has delete button


                 const span = document.createElement('span'); // Span for the type name
                 span.textContent = typeData.name; // Display the name from the definition
                 li.appendChild(span);


                 // Container for action icons/buttons (like lock or delete)
                 const actionsDiv = document.createElement('div');
                 actionsDiv.style.marginLeft = 'auto'; // Push actions to the right
                 actionsDiv.style.display = 'flex';
                 actionsDiv.style.alignItems = 'center';
                 actionsDiv.style.gap = '5px'; // Small gap between elements


                 // Add lock icon for default types (isDefault=true)
                 if (typeData.isDefault) {
                     const lockIcon = document.createElement('i'); // Create icon element
                     lockIcon.className = 'fas fa-lock fa-fw'; // Set Font Awesome lock icon class
                     lockIcon.title = `Tipo por defecto "${typeData.name}" (no eliminable).`; // Add hover title
                     lockIcon.style.color = 'var(--secondary-color)'; // Style icon color
                     actionsDiv.appendChild(lockIcon); // Add icon to actions container
                 } else {
                     // Add delete button for custom, non-default types
                     const deleteBtn = document.createElement('button'); // Create delete button element
                     deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>'; // Set icon
                     deleteBtn.classList.add('button-danger', 'button-sm'); // Add styling classes
                     deleteBtn.title = `Eliminar tipo "${typeData.name}". Los rubros asignados pasarán a "Sin Coeficiente".`; // Add hover title
                      // Assign click handler for deletion. Stop event propagation to prevent the click from also triggering the list item's selectCoefficientTypeForEditing handler.
                     deleteBtn.onclick = (e) => { e.stopPropagation(); deleteCoefficientType(typeKey); };

                     actionsDiv.appendChild(deleteBtn); // Add button to actions container
                 }


                 li.appendChild(actionsDiv); // Add the actions container to the list item
                 listElement.appendChild(li); // Add the completed list item to the UI list
             }); // End forEach sortedKeys loop
        }

         // Handles a click on a coefficient type in the list. Updates the UI state to indicate which type is being edited
         // and triggers the rendering of the monthly value input form for that type.
         // Skips 'None' type for editing, but now allows viewing defaults.
        function selectCoefficientTypeForEditing(typeKey) {
             // Get the coefficient type data from global settings.
             const typeData = appState.settings.coefficientTypes?.[typeKey];

             // If type data is missing or key is null/undefined, log error and do nothing.
             if (!typeKey || !typeData) {
                console.error(`Attempting to select non-existent or invalid type key for editing: ${typeKey}`);
                // Reset editing state and editor display if the current key is invalid
                appState.uiState.editingCoefficientType = null;
                renderCoefficientValuesEditor(null); // Clear editor UI
                updateCoefficientTypeList(); // Update list highlighting (removes old highlight)
                return; // Exit function
             }

             // If clicking on the *currently selected editable* type, deselect it.
              const isCurrentlyEditing = appState.uiState?.editingCoefficientType === typeKey;
              // Check if the clicked type is NOT a default editable type (only custom types toggle on/off when clicked again)
              if (isCurrentlyEditing && !typeData.isDefault) {
                  console.log(`Deselecting coefficient type: "${typeData.name}".`);
                  appState.uiState.editingCoefficientType = null; // Reset the UI state flag
                  renderCoefficientValuesEditor(null); // Clear the editor UI
                  updateCoefficientTypeList(); // Update the list highlight (removes highlight)

              } else {
                  // If clicking on a different type, OR if clicking on a default type (which cannot be edited anyway, only viewed),
                  // set this type as the currently selected type for editing/viewing.
                   console.log(`Selecting coefficient type for editing/viewing: "${typeData.name}".`);
                  appState.uiState.editingCoefficientType = typeKey; // Update the UI state flag
                   // Render the monthly inputs for this type. renderCoefficientValuesEditor handles whether inputs are enabled based on isDefault.
                  renderCoefficientValuesEditor(typeKey);
                  updateCoefficientTypeList(); // Update the list highlight (adds highlight)
              }
        }


        // --- Functions for CRUD on Rubros and Coefficient Types (within Settings) ---

        // Adds a new rubro (Gasto or Ingreso) to the global settings.
        function addRubro(type) {
            // Get input field for the new rubro name based on the type ('gastos' or 'ingresos')
            const inputId = `new-${type}-rubro-name`;
            const input = document.getElementById(inputId);
            if (!input) {
                console.error(`Input element not found for new rubro of type "${type}". ID: ${inputId}`);
                showSnackbar("Error interno: Elemento de input no encontrado.", true, 'error');
                return; // Exit if input element is missing
            }
            const newRubroName = input.value.trim(); // Get the entered name, trimming whitespace

            // Validate input: name cannot be empty
            if (!newRubroName) {
                showSnackbar(`Nombre de rubro (${type}) vacío.`, true, 'warning');
                input.focus(); // Set focus back to the input field
                return; // Exit if name is empty
            }

            // Validate input: Check if a rubro with this name (case-insensitive) already exists in global settings for this type
             appState.settings = appState.settings || {}; // Ensure settings object exists
             appState.settings.rubros ??= { gastos: [], ingresos: [] }; // Ensure rubros object and type arrays exist
             const rubrosInSettingsForType = appState.settings.rubros[type] || []; // Get list for this type

             if (rubrosInSettingsForType.some(r => String(r).trim().toLowerCase() === newRubroName.toLowerCase())) {
                 showSnackbar(`Ya existe un rubro "${newRubroName}" en la lista de ${type}.`, true, 'warning');
                 input.select(); // Select the text in the input field
                 return; // Exit if rubro already exists
            }


            // --- Add the New Rubro to Global Settings ---
             console.log(`Adding new rubro "${newRubroName}" to global settings for type "${type}".`);
             // Add the new rubro name (using its trimmed value with original casing from input) to the global list for this type
             // Ensure rubros arrays exist before pushing
            appState.settings.rubros[type].push(newRubroName);


            // Initialize default configuration for the new rubro if it's an expense type
             appState.settings.rubroConfig = appState.settings.rubroConfig || {}; // Ensure rubroConfig object exists
             if (type === 'gastos') {
                 // Set default coefficientType to 'None' and default detailsCollapsed state to true
                 appState.settings.rubroConfig[newRubroName] = { coefficientType: 'None', detailsCollapsed: true };
                 console.log(`Initialized default rubroConfig for new expense rubro "${newRubroName}".`);
             }
             // For 'ingresos' rubros, add an empty config object if it doesn't exist (might not be needed for income, but safe)
             else if (type === 'ingresos') {
                 appState.settings.rubroConfig[newRubroName] ??= { }; // Maybe just an empty object, or structure like {detailsCollapsed: true}? Defaulting collapsed is reasonable for any rubro type. Let's keep it consistent.
                 appState.settings.rubroConfig[newRubroName] = { detailsCollapsed: true }; // Initialize default collapsed state for incomes too
                 console.log(`Initialized default rubroConfig for new income rubro "${newRubroName}".`);
             }


            // --- Initialize Data Structures for This New Rubro in ALL Existing Scenarios ---
            // This ensures that any existing scenario objects get the necessary empty containers
            // (empty data objects/arrays, empty monthStatus arrays, and include the rubro in their rubroOrder)
            // so that if data is later loaded via Excel, it can be placed into the correct structure without errors.
             console.log(`Ensuring new rubro "${newRubroName}" is integrated into all existing scenarios' structures.`);
            Object.values(appState.scenarios || {}).forEach(scenario => {
                 if (scenario) { // Process only if scenario object exists
                      initializeScenarioDataForRubros(scenario, appState.settings); // Updates the scenario structure based on the NOW updated appState.settings
                 } else {
                     console.warn("Skipping scenario structure update for a null/undefined scenario entry.");
                 }
            });


            input.value = ''; // Clear the input field after successful addition

            // --- Save the Entire Application State ---
            saveState();


            // --- Update UI ---
            // Refresh the rubro list display in the Settings tab
            updateRubroList(type, `${type}-rubro-list`);

            // If adding a Gasto rubro, need to refresh the Gasto rubro list selectors
            // as they now have a new option available implicitly (via the default coef type assigned) or config might be updated.
             if (type === 'gastos') {
                 // This actually just refreshes the *display* of the list itself including selectors for gastos.
                 // It doesn't update income list.
             }

             // Recalculation of scenario totals is NOT triggered here.
             // It happens only on "Guardar Configuración" button click or data load.

            // Show a success message
            showSnackbar(`Rubro "${newRubroName}" (${type}) añadido.`, false, 'success');
        }


        // Deletes a rubro (Gasto or Ingreso) from the global settings and from all scenarios.
        // This action is irreversible and includes associated data and configurations.
        function deleteRubro(type, rubroToDelete) {
             // Get the current global rubros list for the specified type
            const rubrosInSettingsForType = Array.isArray(appState.settings?.rubros?.[type])
                                             ? appState.settings.rubros[type]
                                              : [];

             // Find the actual rubro name with original casing in the global list for display in confirmation message
            const rubroDisplayName = rubrosInSettingsForType.find(r => r === rubroToDelete) || rubroToDelete;

            // Basic check if the rubro exists in the list before confirming deletion
              if (!rubrosInSettingsForType.includes(rubroToDelete)) {
                  console.warn(`Attempted to delete rubro "${rubroToDelete}" (${type})" which does not exist in global settings.`);
                  showSnackbar(`Error: El rubro "${rubroDisplayName}" ya fue eliminado o no existe.`, true, 'error');
                   updateRubroList(type, `${type}-rubro-list`); // Refresh the list just in case it was out of sync
                  return; // Exit if rubro not found
              }

             // Future improvement: Check if this is a default/system rubro that shouldn't be deletable. (Currently not implemented default rubros).

            // Ask for confirmation before proceeding with deletion
             if (!confirm(`¿Estás seguro que deseas eliminar el rubro "${rubroDisplayName}" (${type})?\n\n¡Se borrarán TODOS sus datos y configuraciones (coeficientes, estado expandido/colapsado) en TODOS los escenarios!\n¡Esta acción NO SE PUEDE DESHACER!`)) {
                 showSnackbar("Eliminación de rubro cancelada.", false, 'info');
                 return; // Exit if user cancels
             }


            // --- Delete the Rubro from Global Settings ---
             console.log(`Deleting rubro "${rubroToDelete}" from global settings and all scenarios.`);

             // Remove from the global list of rubro names for this type
             appState.settings.rubros[type] = rubrosInSettingsForType.filter(r => r !== rubroToDelete);

             // Remove its configuration entry from rubroConfig object (if it exists)
             if (appState.settings.rubroConfig) { // Ensure rubroConfig object exists
                  if (appState.settings.rubroConfig[rubroToDelete] !== undefined) {
                       delete appState.settings.rubroConfig[rubroToDelete];
                       console.log(`Deleted rubroConfig entry for "${rubroToDelete}".`);
                   }
             }


            // --- Delete the Rubro's Data Structures from ALL Scenarios ---
             Object.values(appState.scenarios || {}).forEach(scenario => {
                 if (scenario) { // Process only if scenario object exists
                      // Delete the rubro key and its nested data from the scenario's data structure
                      if (scenario.data?.[type] && scenario.data[type][rubroToDelete] !== undefined) {
                           delete scenario.data[type][rubroToDelete];
                           console.log(`Deleted data for rubro "${rubroToDelete}" (${type}) in scenario "${scenario.scenarioName}".`);
                       }
                      // Delete the rubro key and its nested month status data from the scenario's monthStatus structure
                       if (scenario.monthStatus?.[type] && scenario.monthStatus[type][rubroToDelete] !== undefined) {
                          delete scenario.monthStatus[type][rubroToDelete];
                           console.log(`Deleted monthStatus for rubro "${rubroToDelete}" (${type}) in scenario "${scenario.scenarioName}".`);
                       }
                      // Delete calculated structures related to this rubro within the scenario's calculated object
                       if (scenario.calculated) { // Ensure calculated object exists
                           // Delete specific calculated detail/monthly sum objects keyed by rubroKey
                           if (type === 'gastos') {
                               if (scenario.calculated.gastoAjustado?.[rubroToDelete] !== undefined) delete scenario.calculated.gastoAjustado[rubroToDelete];
                               if (scenario.calculated.totalGastoRubroMes?.[rubroToDelete] !== undefined) delete scenario.calculated.totalGastoRubroMes[rubroToDelete];
                           } else { // type === 'ingresos'
                                if (scenario.calculated.ingresoAjustado?.[rubroToDelete] !== undefined) delete scenario.calculated.ingresoAjustado[rubroToDelete];
                               if (scenario.calculated.totalIngresoRubroMes?.[rubroToDelete] !== undefined) delete scenario.calculated.totalIngresoRubroMes[rubroToDelete];
                           }
                            // Remove the rubro's entry from the annual totals object for this type
                            if (scenario.calculated.annualTotals?.[type]?.[rubroToDelete] !== undefined) {
                                delete scenario.calculated.annualTotals[type][rubroToDelete];
                                console.log(`Deleted calculated data/annual total for rubro "${rubroToDelete}" (${type}) in scenario "${scenario.scenarioName}".`);
                           }
                       }
                      // Remove the rubro key from the scenario's rubroOrder array for this type
                       if (scenario.rubroOrder?.[type] && Array.isArray(scenario.rubroOrder[type])) {
                            scenario.rubroOrder[type] = scenario.rubroOrder[type].filter(r => r !== rubroToDelete);
                           console.log(`Removed rubro "${rubroToDelete}" from rubroOrder in scenario "${scenario.scenarioName}".`);
                       } else {
                            console.warn(`Rubro order for type "${type}" missing or invalid in scenario "${scenario.scenarioName}". Skipping order cleanup.`);
                       }
                 } else {
                      console.warn("Skipping data deletion for a null/undefined scenario entry during rubro deletion.");
                 }
             });


             // If the deleted rubro's type was 'gastos' AND it had an assigned coefficient type
             // it doesn't need explicit reassignment now because the rubroConfig entry for it was deleted.

             // If the deleted rubro's type was 'gastos' AND it was using a CUSTOM coefficient type that is *no longer used* by ANY other rubro, should that custom coef type be deleted?
             // Current logic only deletes coefficient types explicitly from the list in Settings. This seems safer - deletion is user-initiated from the coef type list itself.


             // --- Save the State After Deletion ---
             saveState();


             // --- Update UI ---
             // Refresh the list of rubros in the Settings tab to reflect the deletion
             updateRubroList(type, `${type}-rubro-list`);

             // Recalculate the currently active scenario to update dashboard totals and charts
             // (These now won't include values from the deleted rubro).
              // Re-initialize structures for all scenarios (especially the active one) after potential deletions before calculation.
              Object.values(appState.scenarios || {}).forEach(scenario => initializeScenarioDataForRubros(scenario, appState.settings));


              const activeScenarioAfterDeletion = getCurrentScenarioData();
             if (activeScenarioAfterDeletion) {
                 // Recalculate totals, which also saves state and updates all dashboard/chart UI.
                 calculateAll(activeScenarioAfterDeletion);
             } else {
                  // If somehow there's no active scenario left (unlikely after validateAndSetActiveScenario),
                  // just update the UI state that depends on it (e.g., render empty tables).
                 updateUI(); // This call should handle the case of no active scenario by rendering empty state.
                  showSnackbar(`Rubro "${rubroDisplayName}" (${type}) eliminado.`, false, 'success', 5000); // Show standalone success message if no recalc happened
             }
        }


        // Adds a new coefficient type definition to the global settings.
        function addCoefficientType() {
             // Get input element for the new coefficient type name
            const input = document.getElementById('new-coefficient-type-name');
             if (!input) {
                 console.error("Input element not found for new coefficient type.");
                showSnackbar("Error interno: Elemento de input no encontrado.", true, 'error');
                return; // Exit if input missing
            }
            const name = input.value.trim(); // Get the entered name, trimming whitespace

            // Validate input: name cannot be empty
            if (!name) {
                 showSnackbar("Nombre para el tipo de coeficiente vacío.", true, 'warning');
                input.focus(); // Set focus back to input
                return; // Exit if name is empty
            }

            // Generate a safe key from the name for internal use (e.g., replace spaces with underscores, upper case)
             const key = name.replace(/\s+/g, '_').replace(/[^a-zA-Z0-9_]/g, '').toUpperCase();

             // Validate key: generated key cannot be empty
            if (!key) {
                 showSnackbar("El nombre proporcionado no genera una clave interna válida.", true, 'error');
                 input.focus();
                 return;
            }

            // Check if the generated key OR the name (case-insensitive) already exists among existing coefficient types in global settings.
             appState.settings = appState.settings || {}; // Ensure settings exist
             appState.settings.coefficientTypes ??= {}; // Ensure coefficientTypes object exists

             const existingTypes = appState.settings.coefficientTypes; // Reference to the existing types object
             const keyExists = existingTypes[key] !== undefined; // Check if key already exists

            // Check if the provided name (case-insensitive) already exists among the names of existing types
            const nameExists = Object.values(existingTypes).some(t => t.name && String(t.name).trim().toLowerCase() === name.toLowerCase());

             if (keyExists || nameExists) {
                 showSnackbar(`El tipo de coeficiente "${name}" o una clave similar ya existe.`, true, 'warning');
                 input.select(); // Select the text in the input field
                 return; // Exit if type already exists
             }


            // --- Add the New Coefficient Type to Global Settings ---
             console.log(`Adding new coefficient type: "${name}" (key: ${key})`);
            // Add the new type definition to the global settings object
            // New types default to monthly values of 0 (representing 0% change) and are NOT default types.
            existingTypes[key] = { name: name, values: Array(12).fill(0), isDefault: false };


            input.value = ''; // Clear the input field

            // --- Save the Entire Application State ---
            saveState();


            // --- Update UI ---
            // Refresh the list of coefficient types displayed in the Settings tab.
            updateCoefficientTypeList();

            // Refresh the coefficient assignment dropdowns in the Gasto rubro list items
            // as the new coefficient type is now available as an option.
            updateRubroList('gastos', 'gasto-rubro-list'); // Only need to update gastos list

            // Show a success message
            showSnackbar(`Tipo de coeficiente "${name}" añadido.`, false, 'success');
        }


        // Deletes a custom (non-default) coefficient type definition from the global settings.
        // If the type is currently assigned to any expense rubro, prevents deletion.
        function deleteCoefficientType(typeKey) {
             // Get the definition for the coefficient type key to delete from global settings.
            const types = appState.settings?.coefficientTypes;
             // Check if types object exists and the key points to a definition.
             const typeData = types?.[typeKey];

             // If the type definition is missing or not found, log error and exit.
             if (!typeKey || !typeData) {
                 console.error(`Attempted to delete non-existent or invalid coefficient type key: ${typeKey}`);
                showSnackbar("Error interno: El tipo de coeficiente no encontrado o inválido.", true, 'error');
                // Update list display in case it was out of sync
                 updateCoefficientTypeList();
                // Clear editor if this key was selected
                if (appState.uiState?.editingCoefficientType === typeKey) {
                     appState.uiState.editingCoefficientType = null;
                    renderCoefficientValuesEditor(null);
                }
                return; // Exit function
             }


             // Check if the type is marked as a default type that cannot be deleted.
             if (typeData.isDefault) {
                 showSnackbar(`El tipo por defecto "${typeData.name}" no se puede eliminar.`, true, 'warning');
                 return; // Exit if it's a default type
             }


             // Check if this coefficient type is currently assigned to any expense rubro in the global settings.
             appState.settings.rubros ??= { gastos: [], ingresos: [] }; // Ensure structure
             appState.settings.rubroConfig ??= {}; // Ensure structure

             const rubrosAssignedToThisType = (appState.settings.rubros.gastos || []) // Get the list of gasto rubro names
                                            .filter(rubroKey => { // Filter rubro keys where the coefficientType config matches the typeKey to delete
                                                 // Get rubro config, use default 'None' if missing or property missing
                                                 const rubroConfigEntry = appState.settings.rubroConfig[rubroKey];
                                                  const assignedCoefType = rubroConfigEntry?.coefficientType ?? 'None';
                                                 return assignedCoefType === typeKey; // Return true if this rubro is assigned the type to delete
                                             }) || []; // Fallback to empty array

            // If there are any rubros assigned to this type, prevent deletion and inform the user.
             if (rubrosAssignedToThisType.length > 0) {
                 const rubroList = rubrosAssignedToThisType.join(', '); // Create a comma-separated list of affected rubro names
                 showSnackbar(`El tipo de coeficiente "${typeData.name}" está en uso por los siguientes rubros de gasto: ${rubroList}. Reasigna estos rubros a otro tipo (ej. "Sin Coeficiente") antes de eliminar este tipo.`, true, 'warning', 10000); // Extended duration
                 return; // Exit function
             }


            // Ask for confirmation before proceeding with deletion
             if (!confirm(`¿Estás seguro que deseas eliminar el tipo de coeficiente "${typeData.name}"?\n\nTodos los rubros que pudieran estar asignados a este tipo (si la verificación anterior falló por algún bug) se establecerán automáticamente en "Sin Coeficiente".\n¡Esta acción NO SE PUEDE DESHACER COMPLETAMENTE!`)) {
                 showSnackbar("Eliminación de tipo de coeficiente cancelada.", false, 'info');
                 return; // Exit if user cancels
             }


             // --- Delete the Coefficient Type from Global Settings ---
             console.log(`Deleting coefficient type: "${typeData.name}" (key: ${typeKey})`);

             // Assign any rubros that might still be assigned to this type to 'None' as a safety fallback (the check above *should* prevent this).
             (appState.settings.rubros.gastos || []).forEach(rubroKey => {
                  const rubroConfigEntry = appState.settings.rubroConfig[rubroKey];
                   if (rubroConfigEntry && rubroConfigEntry.coefficientType === typeKey) {
                       rubroConfigEntry.coefficientType = 'None';
                       console.log(`Fallback: Rubro "${rubroKey}" was still assigned to "${typeKey}". Re-assigned to "None".`);
                       // Note: If this re-assignment happens, the settings state has changed *beyond* just deletion.
                       // The subsequent saveState covers this.
                   }
             });

             // Delete the type definition key from the global settings coefficientTypes object.
              if (types) delete types[typeKey]; // Use optional chaining
              appState.settings.coefficientTypes = types; // Re-assign the modified object


             // --- Update UI State and Display ---
             // If the deleted type was the one currently selected for editing in the UI state, clear the editing state.
             if (appState.uiState?.editingCoefficientType === typeKey) {
                 appState.uiState.editingCoefficientType = null; // Clear the UI state flag
                  // Clear the coefficient editor display and show the default message.
                 renderCoefficientValuesEditor(null);
             }


             // --- Save the Entire Application State ---
             // Save the state with the deleted coefficient type and updated rubro assignments (set to 'None').
             saveState();


             // --- Update UI Lists ---
             // Refresh the list of coefficient types to reflect the deletion.
             updateCoefficientTypeList();

             // Refresh the coefficient assignment dropdowns in the Gasto rubro list items.
             // The deleted type will no longer be an option. This is handled by updateRubroList re-populating options.
             updateRubroList('gastos', 'gasto-rubro-list');


             // --- Recalculate affected scenarios ---
             // Deleting a coefficient type doesn't *directly* change numerical data in `scenarioData.data`.
             // However, rubros previously using this type are now implicitly assigned 'None'.
             // The NEXT time calculateEstimates runs on such a rubro/detail, it will use a multiplier of 1.
             // RecalculateAll needs to run to update dashboard sums and charts based on the *currently stored values*.
             // But the stored estimated values for those rubros still contain the effect of the OLD coefficient until CalculateEstimates is run again (or data is cleared/reloaded).
             // For simplicity, just trigger a full UI update and recalculation based on current stored data and new config.
              // Re-initialize structures for all scenarios after potentially removing config affecting them
             Object.values(appState.scenarios || {}).forEach(scenario => initializeScenarioDataForRubros(scenario, appState.settings));

             const activeScenarioAfterCoefDeletion = getCurrentScenarioData();
             if (activeScenarioAfterCoefDeletion) {
                 // Recalculate totals, which also saves state and updates all dashboard/chart UI.
                  // NOTE: calculateEstimates is NOT automatically triggered here. Stored estimated values remain until user clicks "Calcular Estimados".
                 calculateAll(activeScenarioAfterCoefDeletion);
             } else {
                 updateUI(); // Just update settings panel and tables if no active scenario remains
                  showSnackbar(`Tipo de coeficiente "${rubroDisplayName}" eliminado. Los rubros asignados pasarán a "Sin Coeficiente".`, false, 'success', 5000); // Show standalone success message
             }
        }
    </script>

<!-- Keeping old commented blocks just in case for reference during development, but these are likely obsolete -->
<!-- Toggle Rubros -->
<script>
// Old Toggle Rubros script - The main script now uses event delegation for this
// This block is likely vestigial.
/*
// Note: This section seems to be remnants of an older toggle implementation.
// The current toggle logic uses event delegation on the table rows themselves
// via addCollapsibleListeners and toggleRubroDetails. Keeping it here
// for now just in case, but it might not be actively used by the main script.
// Consider removing if testing confirms it's unused.
function initRubrosToggle(){
  document.querySelectorAll('.rubro-header').forEach(h=>{
    h.addEventListener('click', ()=> toggleDetail(h));
  });
}
function toggleDetail(header){
  const detail = header.nextElementSibling;
  if(detail){
    detail.classList.toggle('collapsed');
    const icon = header.querySelector('.arrow');
    if(icon) icon.textContent = detail.classList.contains('collapsed') ? '▼' : '▲';
  }
}
// Botones globales
function toggleSection(sectionId, collapse){
  document.querySelectorAll('#'+sectionId+' .rubro-detail').forEach(d=>{
     if(collapse===undefined){
        d.classList.toggle('collapsed');
     }else{
        d.classList.toggle('collapsed', collapse);
     }
  });
  // actualizar iconos
  document.querySelectorAll('#'+sectionId+' .rubro-header .arrow').forEach(i=>{
     const header=i.closest('.rubro-header');
     const det=header.nextElementSibling;
     i.textContent = det.classList.contains('collapsed') ? '▼':'▲';
  });
}
// document.addEventListener('DOMContentLoaded', initRubrosToggle); // This line is likely commented out or should be if not used.
*/
</script>
<!-- End Toggle Rubros -->


<!-- Expensa Real Auto‑Fill v4 -->
<script>
// Old Auto-Fill script for Expensa Real - This functionality is now fully
// integrated into the calculateAll function which computes the value directly
// from the main Ord Expensa rubro and UF count. This block is vestigial and
// could potentially cause issues if uncommented. Keeping it commented out.
/*
// Note: This script seems to be an old attempt to auto-fill the "Expensa Real"
// column based on an old data structure (appState.ingresos).
// The main script now calculates calculated.cuotaRealBaseMes directly from
// scenarioData.data.ingresos[CUOTA_RUBRO_NAME].detailsData, which is more robust.
// This script is likely obsolete and could be removed. It might interfere or
// be redundant. Let's keep it commented out or remove it entirely to avoid confusion.
// The patching part commented out in the previous version reinforces its obsolescence.
// Leave this block commented entirely.
(function(){
  const FULL = ['enero','febrero','marzo','abril','mayo','junio','julio','agosto','septiembre','octubre','noviembre','diciembre'];
  const ABBR = ['ene','feb','mar','abr','may','jun','jul','ago','sep','oct','nov','dic'];

  function findMonthIndex(key){
     key = key.toLowerCase().trim();
     if(key.match(/^m\d+$/)) return parseInt(key.slice(1))-1;
     let idx = FULL.indexOf(key);
     if(idx>-1) return idx;
     idx = ABBR.indexOf(key.slice(0,3));
     return idx;
  }

  function getExpensasRow(){
     // This structure appState.ingresos no longer exists in the current state structure
     // It was likely from a previous version
     if(!window.appState || !appState.ingresos) return null;
     return appState.ingresos.find(r=>{
       const rub=(r.rubro||'').toString().toLowerCase().trim();
       const det=(r.detalle||'').toString().toLowerCase().trim();
       return rub==='expensas' && det==='expensas ordinarias';
     });
  }

  function getMonthlyArray(row){
     const arr = new Array(12).fill(0);
     if(!row) return arr;
     Object.entries(row).forEach(([k,v])=>{
        const idx = findMonthIndex(k);
        if(idx>=0 && idx<12) arr[idx]=Number(v)||0;
     });
     return arr;
  }

  function writeToTable(){
     const table=document.querySelector('#dashboard-summary');
     if(!table) return false;
     // Search for the column index
     let colIdx = -1;
     const headers = table.querySelectorAll('thead th');
     for(let i=0; i < headers.length; i++){
        if (headers[i].textContent.toLowerCase().includes('expensa real ($/uf)')) {
           colIdx = i;
           break;
        }
        if (headers[i].textContent.toLowerCase().includes('expensa real ($)')) { // Fallback to older name
            colIdx = i;
            break;
        }
     }

     if(colIdx === -1) {
         // console.warn("Expensa Real column not found in summary table header.");
         return false; // Column not found
     }


     const rows=table.querySelectorAll('tbody tr');
     if(rows.length < 12) {
         // console.warn("Summary table tbody doesn't have 12 rows yet.");
         return false; // Table not fully populated yet
     }

     // This part relies on the old data structure and function, which is no longer used.
     // The main calculateAll already populates the cuotaRealBaseMes and updates the summary table correctly.
     // So, the data obtained here would likely be from the old, defunct structure.
     // Calling this part would try to write potentially incorrect/stale data.
     // const data=getMonthlyArray(getExpensasRow());
     // if(data.every(v => v === 0)){
         // console.log("Old Expensa Real data is all zeros, likely not populated in old structure.");
         // return true; // Found column, but no data in old structure, assume modern code will handle
     // }

     // const fmt=new Intl.NumberFormat('es-AR',{style:'currency',currency:'ARS',minimumFractionDigits:2});
     // data.forEach((val,i)=>{
         // If the cell *already* has content (meaning the main script populated it), don't overwrite.
     //    if(i < rows.length && rows[i].children[colIdx].textContent.trim() === formatCurrency(0).trim()){ // Only overwrite if cell is effectively $0.00
     //       rows[i].children[colIdx].textContent=fmt.format(val);
     //    }
     // });

     return true; // Indicate that the column was found
  }

  // function waitAndWrite(attempt=0){
  //    if(writeToTable()) return; // Stop waiting once column is found
  //    if(attempt<20) setTimeout(()=>waitAndWrite(attempt+1),300); // Retry for a few seconds
  // }

  // The patching functions (patching handleFileUpload, cargarEscenario) are also obsolete
  // as they rely on the old flow. Remove or leave commented. Keeping commented for history.

  // Instead of patching or trying to run writeToTable manually, this entire block
  // related to auto-filling the old Expensa Real from an old structure should be removed.
  // The functionality is replaced by calculateAll populating calculated.cuotaRealBaseMes
  // which is then displayed correctly by updateDashboardTables.
  // If the column is still not colored correctly after this v2.7 update, the CSS or
  // updateDashboardTables logic for colors might need refinement, NOT adding back old auto-fill.
})();
*/
</script>

</body>
</html>