<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Favicon -->
<link rel="icon" type="image/png" href="favicon.png">
    <title>Proyección Expensas - Barrio El Centauro</title>
    <!-- Librería SheetJS (js-xlsx) para leer/escribir Excel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Librería Chart.js para gráficos -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- Plugin doughnut 3D shadow -->
<script>
/* Plugin: doughnutShadow3D
   Añade una sombra suave debajo de cada porción para simular profundidad 3 D.
   Seguro para todos los datasets (evita NaN en createRadialGradient). */
const doughnutShadow3D = {
  id: 'doughnutShadow3D',
  afterDatasetDraw(chart, args, opts) {
    const {ctx} = chart;
    if (args.meta.type !== 'doughnut') return;

    args.meta.data.forEach(segment => {
      const {x, y, startAngle, endAngle, innerRadius, outerRadius} = segment;
      if (!isFinite(x) || !isFinite(y) || !isFinite(innerRadius) || !isFinite(outerRadius)) return;

      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.15)';      // shadow color
      ctx.translate(0, 4);                     // vertical offset
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.arc(x, y, outerRadius, startAngle, endAngle);
      ctx.arc(x, y, innerRadius, endAngle, startAngle, true);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    });
  }
};
// Registrar plugin globalmente
if (window.Chart && !Chart.registry.plugins.get('doughnutShadow3D')) {
  Chart.register(doughnutShadow3D);
}
</script>

    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts (Inter) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- Reset Básico y Fuentes --- */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; /* Base font size */ }
        body {
            font-family: 'Inter', 'Segoe UI', sans-serif;
            line-height: 1.7; /* Improved readability */
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* --- Variables de Color (Paleta Refinada) --- */
        :root {
            --bg-color: #f8f9fa;              /* Slightly off-white */
            --text-color: #343a40;            /* Darker gray */
            --primary-color: #007bff;          /* Classic blue */
            --primary-color-darker: #0056b3;   /* Darker blue for hover */
            --secondary-color: #6c757d;        /* Standard gray */
            --secondary-color-darker: #5a6268; /* Darker gray for hover */
            --accent-color: #28a745;           /* Vibrant green */
            --accent-color-darker: #218838;    /* Darker green for hover */
            --danger-color: #dc3545;           /* Red */
            --danger-color-darker: #c82333;    /* Darker red */
            --warning-color: #ffc107;           /* Yellow */
            --warning-color-darker: #e0a800;   /* Darker yellow */
            --info-color: #17a2b8;             /* Teal */
            --info-color-darker: #138496;      /* Darker teal */
            --success-color: var(--accent-color); /* Alias for consistency */
            --success-color-darker: var(--accent-color-darker); /* Alias */

            --border-color: #dee2e6;           /* Light gray border */
            --header-bg: #ffffff;              /* White header */
            --card-bg: #ffffff;                /* White cards */
            --shadow-color: rgba(0, 0, 0, 0.08); /* Softer shadow */
            --input-bg: #ffffff;
            --input-border: #ced4da;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(0, 123, 255, 0.25);
            --button-text: #ffffff;
            --button-warning-text: #212529; /* Dark text for yellow button */
            --table-header-bg: #eef2f7;        /* Lighter table header */
            --table-row-hover: #f1f3f5;        /* Subtle hover */
            --expandable-row-bg: #f8f9fa;      /* Same as body bg for subtle diff */
            --clickable-row-hover: #e9ecef;    /* Slightly darker hover for clickable rows */
            --disabled-bg: #e9ecef;
            --disabled-text: #6c757d;
            --disabled-border: #ced4da;

            /* >>> COLORES REAL/ESTIMADO <<< */
            --real-month-bg: #d1f7d9; /* Light, fresh green */
            --estimated-month-bg: #fff3cd; /* Soft Yellow */
        }

        body.dark-mode {
            --bg-color: #1a1a1a;              /* Very dark gray */
            --text-color: #e0e0e0;            /* Light gray text */
            --primary-color: #58a6ff;          /* Brighter blue */
            --primary-color-darker: #79b8ff;   /* Lighter blue for hover */
            --secondary-color: #8b949e;        /* Lighter gray */
            --secondary-color-darker: #a0a8b0; /* Lighter gray hover */
            --accent-color: #56d364;           /* Brighter green */
            --accent-color-darker: #6bde7a;    /* Lighter green hover */
            --danger-color: #f85149;           /* Bright red */
            --danger-color-darker: #fa6a61;    /* Lighter red */
            --warning-color: #f0b41e;          /* Bright yellow */
            --warning-color-darker: #f2c037;   /* Lighter yellow */
            --info-color: #6cb6f1;             /* Bright teal */
            --info-color-darker: #85c3f4;      /* Lighter teal */
            --success-color: var(--accent-color);
            --success-color-darker: var(--accent-color-darker);

            --border-color: #444c56;           /* Darker border */
            --header-bg: #2c2c2c;              /* Dark card background */
            --card-bg: #2c2c2c;                /* Dark card background */
            --shadow-color: rgba(255, 255, 255, 0.05); /* Subtle white shadow */
            --input-bg: #3a3f44;
            --input-border: #5a6268;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(88, 166, 255, 0.25);
            --button-text: #1a1a1a; /* Dark text on bright buttons */
            --button-warning-text: #1a1a1a;
            --table-header-bg: #343a40;        /* Darker header */
            --table-row-hover: #3e444a;        /* Subtle dark hover */
            --expandable-row-bg: #343a40;      /* Darker expandable row bg */
            --clickable-row-hover: #495057;    /* Darker hover for clickable */
            --disabled-bg: #495057;
            --disabled-text: #adb5bd;
            --disabled-border: #5a6268;

            /* >>> COLORES REAL/ESTIMADO OSCURO <<< */
            --real-month-bg: #1c4a2b; /* Darker Green */
            --estimated-month-bg: #5a4a1d; /* Dark Yellow/Brown */
        }

        /* --- Estilos Generales --- */
        .container { width: 95%; max-width: 1700px; margin: 0 auto; padding: 25px 20px; }
        h1, h2, h3, h4 { color: var(--primary-color); margin-bottom: 1em; font-weight: 600; }
        h1 { font-size: 2.2rem; text-align: center; }
        h2 { font-size: 1.8rem; border-bottom: 2px solid var(--accent-color); padding-bottom: 0.4em; }
        h3 { font-size: 1.4rem; margin-top: 1.8em; }
        h4 { font-size: 1.15rem; color: var(--secondary-color); margin-top: 1.2em; margin-bottom: 0.6em; }
        a { color: var(--primary-color); text-decoration: none; transition: color 0.2s ease; }
        a:hover { color: var(--primary-color-darker); text-decoration: underline; }

        button {
            padding: 12px 22px;
            border: 1px solid transparent; /* Added border for consistency */
            border-radius: 6px;
            background-color: var(--primary-color);
            color: var(--button-text);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out, transform 0.1s ease, box-shadow 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center; /* Center content */
            gap: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            line-height: 1.5; /* Ensure consistent height */
            text-align: center; /* Ensure text aligns center */
        }
        button:hover {
            background-color: var(--primary-color-darker);
            border-color: var(--primary-color-darker);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        button:focus {
            outline: none;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        button:disabled {
            background-color: var(--disabled-bg);
            color: var(--disabled-text);
            border-color: var(--disabled-border);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        button i { margin-right: 2px; /* Keep small margin */ }

        /* Button variants */
        .button-primary { background-color: var(--primary-color); border-color: var(--primary-color); color: var(--button-text); }
        .button-primary:hover { background-color: var(--primary-color-darker); border-color: var(--primary-color-darker); }
        .button-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: var(--button-text); }
        .button-secondary:hover { background-color: var(--secondary-color-darker); border-color: var(--secondary-color-darker); }
        .button-success { background-color: var(--success-color); border-color: var(--success-color); color: var(--button-text); }
        .button-success:hover { background-color: var(--success-color-darker); border-color: var(--success-color-darker); }
        .button-danger { background-color: var(--danger-color); border-color: var(--danger-color); color: var(--button-text); }
        .button-danger:hover { background-color: var(--danger-color-darker); border-color: var(--danger-color-darker); }
        .button-warning { background-color: var(--warning-color); border-color: var(--warning-color); color: var(--button-warning-text); }
        .button-warning:hover { background-color: var(--warning-color-darker); border-color: var(--warning-color-darker); }
        .button-info { background-color: var(--info-color); border-color: var(--info-color); color: var(--button-text); }
        .button-info:hover { background-color: var(--info-color-darker); border-color: var(--info-color-darker); }
        .button-sm { padding: 6px 12px; font-size: 0.85rem; gap: 6px;}

        /* --- Header --- */
        header {
            background-color: var(--header-bg);
            padding: 15px 0;
            box-shadow: 0 2px 5px var(--shadow-color);
            position: sticky; top: 0; z-index: 1000;
            border-bottom: 1px solid var(--border-color);
        }
        header .container { display: flex; justify-content: space-between; align-items: center; padding-top: 0; padding-bottom: 0; }
        .app-title { font-size: 1.6rem; font-weight: 700; color: var(--primary-color); }
        #theme-toggle { font-size: 1.3rem; background: none; border: none; color: var(--text-color); cursor: pointer; padding: 5px; border-radius: 50%; transition: background-color 0.2s;}
        #theme-toggle:hover { background-color: var(--table-row-hover); }

        /* --- Navegación / Pestañas --- */
        .tabs {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 5px;
        }
        .tab-link {
            padding: 12px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-bottom: -1px; /* Overlap bottom border */
            background-color: transparent;
            color: var(--secondary-color);
            font-size: 1rem;
            font-weight: 600;
            border-radius: 6px 6px 0 0;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            display: inline-flex; /* Align icon and text */
            align-items: center;
            gap: 8px;
        }
        .tab-link:hover {
             color: var(--primary-color);
             background-color: var(--table-row-hover);
        }
        .tab-link.active {
            background-color: var(--card-bg);
            border-color: var(--border-color);
            border-bottom-color: var(--card-bg); /* Hide bottom border part */
            color: var(--primary-color);
            font-weight: 700;
        }
        .tab-content {
            display: none;
            padding: 30px;
            border: 1px solid var(--border-color);
            border-top: none;
            background-color: var(--card-bg);
            border-radius: 0 0 6px 6px;
            box-shadow: 0 5px 15px var(--shadow-color);
        }
        .tab-content.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Formularios y Entradas --- */
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-color); font-size: 0.95rem;}
        input[type="text"], input[type="number"], input[type="file"], select, textarea {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid var(--input-border);
            border-radius: 6px;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        input:focus, select:focus, textarea:focus {
            border-color: var(--input-focus-border);
            outline: 0;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        input:disabled, select:disabled, textarea:disabled {
             background-color: var(--disabled-bg);
             color: var(--disabled-text);
             border-color: var(--disabled-border);
             cursor: not-allowed;
        }
        input[type="number"] { text-align: right; -moz-appearance: textfield; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { margin: 0; }
        input[type="file"] { padding: 8px; line-height: 1.5; } /* Adjust file input padding */
        .input-group { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
        .input-group label { margin-bottom: 0; font-weight: normal;}
        .input-group input[type="radio"] { width: auto; margin-right: 5px; }
        .input-small { width: 150px; display: inline-block; margin-left: 10px; }

        /* --- Tablas --- */
        .table-container { overflow-x: auto; margin-top: 25px; border: 1px solid var(--border-color); border-radius: 6px; }
        table { width: 100%; border-collapse: collapse; background-color: var(--card-bg); font-size: 0.9rem; }
        th, td {
            padding: 12px 15px;
            border: none;
            border-bottom: 1px solid var(--border-color);
            text-align: left;
            vertical-align: middle;
            white-space: nowrap;
        }
        th {
            background-color: var(--table-header-bg);
            font-weight: 600;
            position: sticky; top: 0; z-index: 10;
            border-bottom-width: 2px;
        }
        tbody tr:last-child td { border-bottom: none; }
        tbody tr:hover { background-color: var(--table-row-hover); }
        th:first-child, td:first-child { border-left: none; padding-left: 20px; /* More padding for first col */ }
        th:last-child, td:last-child { border-right: none; padding-right: 20px; /* More padding for last col */}

        /* Cell specific styles */
        td.real-month-cell { background-color: var(--real-month-bg) !important; /* Use important to override hover */ }
        td.estimated-month-cell { background-color: var(--estimated-month-bg) !important; }
        td.number-cell { text-align: right; font-variant-numeric: tabular-nums; }
        td.input-cell input { width: 100px; padding: 6px; font-size: 0.9rem; text-align: right; }
        td.input-cell input:disabled { background-color: transparent; border: none; color: var(--disabled-text);}
        .text-muted { color: var(--secondary-color); font-style: italic; font-size: 0.9em;}

        /* --- Tablas Desplegables --- */
        .collapsible-table tbody tr.rubro-total-row { font-weight: bold; cursor: pointer; background-color: var(--expandable-row-bg); transition: background-color 0.2s; }
        .collapsible-table tbody tr.rubro-total-row:hover { background-color: var(--clickable-row-hover); }
        .collapsible-table tbody tr.rubro-total-row td:first-child::before {
            content: '\f078'; /* fa-chevron-down */
            font-family: 'Font Awesome 6 Free'; font-weight: 900; margin-right: 12px; display: inline-block; transition: transform 0.2s ease-in-out; color: var(--primary-color);
        }
        .collapsible-table tbody tr.rubro-total-row.collapsed td:first-child::before { transform: rotate(-90deg); }
        .collapsible-table tbody tr.detail-row { display: table-row; background-color: var(--card-bg); transition: background-color 0.3s; }
        .collapsible-table tbody tr.detail-row.hidden { display: none; }
        .collapsible-table tbody tr.detail-row td { font-size: 0.85rem; color: var(--secondary-color); border-color: var(--border-color); }
        .collapsible-table tbody tr.detail-row td:first-child { padding-left: 40px; /* Indent details more */ }
        body.dark-mode .collapsible-table tbody tr.detail-row { background-color: #353535; }
        .collapsible-table tfoot tr { font-weight: bold; background-color: var(--table-header-bg); border-top: 2px solid var(--border-color); }

         /* Styles for Group/Ungroup All buttons */
        .table-actions {
            margin-bottom: 15px;
             display: flex;
             justify-content: flex-end; /* Align buttons to the right */
             gap: 10px;
             flex-wrap: wrap;
        }


        /* --- Componentes UI Específicos --- */
        #dashboard-summary { border-collapse: separate; border-spacing: 0; }
        #dashboard-summary th, #dashboard-summary td { text-align: center; white-space: normal; }
        #dashboard-summary tbody td, #dashboard-summary tfoot td { padding: 10px 8px; }
        #dashboard-summary .month-header { font-weight: bold; }

        .chart-container {
            margin-top: 35px; padding: 30px;
            background-color: var(--card-bg); border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-color);
            position: relative; min-height: 200px; /* Adjusted min height */
        }
        .chart-container canvas { max-width: 100%; height: 380px !important; }
        .chart-no-data { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--secondary-color); font-style: italic; font-size: 1.1rem; text-align: center; }

        #file-upload-area {
            border: 2px dashed var(--primary-color);
            padding: 45px; text-align: center; background-color: var(--bg-color);
            border-radius: 8px; margin-bottom: 25px; transition: background-color 0.2s ease, border-color 0.2s ease; cursor: pointer;
        }
        #file-upload-area:hover { background-color: var(--table-row-hover); border-color: var(--primary-color-darker); }
        #file-upload-area p { margin-bottom: 15px; font-size: 1.1rem; color: var(--secondary-color); }
        #file-upload-area i.fa-file-excel { font-size: 3rem; margin-bottom: 10px; color: var(--accent-color); }
        #file-upload-feedback { margin-top: 15px; font-weight: bold; white-space: pre-wrap; font-size: 0.95rem; min-height: 2em; }

        #reserve-fund-panel { margin-top: 20px; }
        #reserve-fund-panel .month-config { display: flex; align-items: center; gap: 15px; margin-bottom: 12px; flex-wrap: wrap; padding: 10px; border-radius: 4px; background-color: var(--bg-color); transition: background-color 0.3s; }
        body.dark-mode #reserve-fund-panel .month-config { background-color: #3a3f44; }
        #reserve-fund-panel .month-config label { width: 110px; margin-bottom: 0; flex-shrink: 0; font-weight: 600;}
        #reserve-fund-panel .month-config input { width: 140px; flex-grow: 1; }

        .config-section {
            border: 1px solid var(--border-color); border-radius: 8px; padding: 25px;
            margin-bottom: 30px; background-color: var(--card-bg);
            box-shadow: 0 3px 7px var(--shadow-color);
        }
        .config-section h4 { border-bottom: 1px solid var(--border-color); padding-bottom: 0.6em; margin-bottom: 1.2em;}
        .management-list { list-style: none; padding: 0; max-height: 350px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 6px; padding: 10px; background-color: var(--bg-color); }
        body.dark-mode .management-list { background-color: #3a3f44; }
        .management-list li { display: flex; justify-content: space-between; align-items: center; padding: 10px 8px; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s; }
        .management-list li:last-child { border-bottom: none;}
        .management-list li:hover { background-color: var(--table-row-hover); }
        .management-list li span { flex-grow: 1; margin-right: 15px; font-weight: 500; }
        .management-list li select { width: 200px; font-size: 0.88rem; padding: 6px 8px; flex-shrink: 0; }
        .management-list li button { flex-shrink: 0; }
        #coefficient-editor { margin-top: 25px; } #coefficient-editor h4 { margin-bottom: 15px;}
        #coefficient-editor .table-container { max-height: 450px; overflow-y: auto;}

        /* --- Snackbar --- */
        #snackbar {
            visibility: hidden; min-width: 300px; max-width: 90%;
            background-color: var(--success-color); /* Default to success */
            color: var(--button-text); text-align: center;
            border-radius: 6px; padding: 18px 25px; position: fixed; z-index: 1001;
            left: 50%; transform: translateX(-50%); bottom: 30px;
            font-size: 1.05rem; font-weight: 500;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            opacity: 0; transition: visibility 0s 0.5s, opacity 0.5s ease-out, bottom 0.5s ease-out;
        }
        #snackbar.show {
            visibility: visible; opacity: 1; bottom: 60px;
            transition: opacity 0.5s ease-in, bottom 0.5s ease-in;
        }
        #snackbar.error { background-color: var(--danger-color); color: var(--button-text); }
        #snackbar.warning { background-color: var(--warning-color); color: var(--button-warning-text); }
        #snackbar.info { background-color: var(--info-color); color: var(--button-text); }


        /* --- Footer --- */
        footer {
            margin-top: auto; padding: 20px 0; text-align: center; font-size: 0.95em;
            color: var(--secondary-color); background-color: var(--header-bg);
            border-top: 1px solid var(--border-color);
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 1200px) { .container { width: 98%; } .chart-container canvas { height: 320px !important; } }
        @media (max-width: 992px) {
             h1 { font-size: 2rem; } h2 { font-size: 1.6rem; } h3 { font-size: 1.3rem; }
             .tabs { justify-content: flex-start; }
             .tab-link { padding: 10px 18px; font-size: 0.95rem;}
             table { font-size: 0.88rem; } th,td {padding: 10px 12px;}
             .management-list li select { width: 150px; } /* Reduce select width */
        }
        @media (max-width: 768px) {
            body { line-height: 1.6; }
            .app-title { font-size: 1.3rem;} #theme-toggle { font-size: 1.1rem;}
            .chart-container { padding: 20px;} .chart-container canvas { height: 280px !important; }
            .input-group { flex-direction: column; align-items: stretch; gap: 10px;}
            .input-small { margin-left: 0; margin-top: 8px; width: 100%; }
            #reserve-fund-panel .month-config { flex-direction: column; align-items: stretch; }
            #reserve-fund-panel .month-config label { width: 100%; text-align: left; margin-bottom: 5px; }
            #reserve-fund-panel .month-config input { width: 100%; }
            table { font-size: 0.85rem; } th, td { padding: 9px 8px; white-space: normal; } /* Allow wrap */
            th:first-child, td:first-child { padding-left: 15px; }
            th:last-child, td:last-child { padding-right: 15px; }
            td.input-cell input { width: 80px; padding: 5px; }
            .management-list li { flex-wrap: wrap; gap: 8px; }
            .management-list li span { flex-basis: 100%; margin-right: 0; } /* Name takes full width */
            .management-list li select { width: calc(100% - 50px); margin-top: 5px; } /* Select almost full width */
            .management-list li button { margin-left: auto; } /* Push button right */
            button { font-size: 0.95rem; padding: 10px 18px;}
            .tabs { gap: 2px; }
            .tab-link { padding: 8px 10px; font-size: 0.85rem;}
             .table-actions { justify-content: center; }
        }
        @media (max-width: 576px) {
            h1 { font-size: 1.7rem; } .app-title { display: none; } header .container { justify-content: flex-end; }
            .tab-link { padding: 8px 10px; font-size: 0.85rem;}
            th, td { padding: 8px 6px; }
            th:first-child, td:first-child { padding-left: 10px; }
            th:last-child, td:last-child { padding-right: 10px; }
            .chart-container canvas { height: 220px !important; }
            #snackbar { min-width: 90%; bottom: 20px; font-size: 1rem; padding: 15px 20px; }
            #snackbar.show { bottom: 40px; }
            #file-upload-area { padding: 30px; }
            .management-list li select { width: 100%; } /* Select full width on smallest screens */
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <span class="app-title">Proyección Expensas - El Centauro</span>
            <button id="theme-toggle" title="Cambiar tema"><i class="fas fa-moon"></i></button>
        </div>
    </header>

    <div class="container">
        <div class="tabs">
            <button class="tab-link active" onclick="openTab(event, 'dashboard')"><i class="fas fa-tachometer-alt"></i> Dashboard</button>
            <button class="tab-link" onclick="openTab(event, 'upload')"><i class="fas fa-upload"></i> Cargar Datos</button>
            <button class="tab-link" onclick="openTab(event, 'reserve')"><i class="fas fa-piggy-bank"></i> Fondo Reserva</button>
            <button class="tab-link" onclick="openTab(event, 'settings')"><i class="fas fa-cog"></i> Configuración</button>
            <button class="tab-link" onclick="openTab(event, 'reports')"><i class="fas fa-download"></i> Reportes</button>
        </div>

        <!-- ==================== DASHBOARD ==================== -->
        <div id="dashboard" class="tab-content active">
            <h2><i class="fas fa-tachometer-alt"></i> Dashboard Anual - <span id="dashboard-year"></span> (<span id="dashboard-scenario">Base</span>)</h2>
            <div class="form-group input-group">
                <label for="scenario-selector" style="flex-shrink: 0;">Escenario:</label>
                <select id="scenario-selector" style="flex-grow: 1;"></select>
                <button onclick="createScenario()" class="button-primary button-sm" title="Crear Escenario Nuevo"><i class="fas fa-plus"></i> Crear</button>
                <button onclick="cloneScenario()" class="button-secondary button-sm" title="Clonar Escenario Actual"><i class="fas fa-clone"></i> Clonar</button>
                <button onclick="deleteScenario()" class="button-danger button-sm" title="Eliminar Escenario Actual"><i class="fas fa-trash"></i> Eliminar</button>
                <button id="btnBorrarDatos" class="button-warning button-sm" title="Borrar Datos del Escenario Actual (Gastos, Ingresos, Status)" onclick="clearScenarioData()" ><i class="fas fa-broom"></i> Borrar Datos</button>
                <button onclick="recalculateEstimates()" class="button-info button-sm" title="Proyectar meses estimados basados en último mes real y coeficientes (acumulativo)"><i class="fas fa-calculator"></i> Calcular Estimados</button>
            </div>

            <h4>Resumen Mensual General</h4>
            <div class="table-container">
                <table id="dashboard-summary">
                    <thead>
                        <tr>
                            <th>Mes</th>
                            <th>Gasto ($)</th>
                            <th>Fondo ($)</th>
                            <th>Cuota s/Gs ($)</th> <!-- Basado en Gasto+Fondo / UF -->
                            <th>IPC (%)</th>
                            <th>Cuota IPC ($)</th>   <!-- NUEVO: Cuota s/Gs * (1 + IPC%) -->
                            <th>Expensa Real ($)</th> <!-- MODIFICADO: Valor Base Ingresos -->
                        </tr>
                    </thead>
                    <tbody><!-- Contenido generado por JS --></tbody>
                    <tfoot><!-- Contenido generado por JS --></tfoot>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Detalle de Gastos Proyectados ($)</h4>
             <p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar los detalles. Las celdas mensuales de detalle se colorean según su origen: <span style="background-color: var(--real-month-bg); padding: 1px 4px; border-radius: 3px;">REAL</span> (cargado) o <span style="background-color: var(--estimated-month-bg); padding: 1px 4px; border-radius: 3px;">ESTIMADO</span> (proyectado/calculado).</p>

            <!-- Added Group/Ungroup Buttons for Gastos -->
            <div class="table-actions">
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('gastos', false)" title="Expandir todos los detalles de gastos"><i class="fas fa-expand"></i> Expandir Todo</button>
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('gastos', true)" title="Colapsar todos los detalles de gastos"><i class="fas fa-compress"></i> Colapsar Todo</button>
            </div>

            <div class="table-container">
                <table id="gastos-detail-table" class="collapsible-table">
                     <thead>
                        <tr>
                            <th>Rubro / Detalle</th>
                            <!-- Meses y Total Anual generados por JS -->
                         </tr>
                     </thead>
                     <tbody><!-- Contenido generado por JS --></tbody>
                     <tfoot><!-- Contenido generado por JS --></tfoot>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Detalle de Ingresos Proyectados ($)</h4>
             <p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar. Los valores aquí son la base de cálculo (valor individual o por UF). El Total de Ingresos en el Resumen General puede incluir la multiplicación por UF.</p>

             <!-- Added Group/Ungroup Buttons for Ingresos -->
             <div class="table-actions">
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('ingresos', false)" title="Expandir todos los detalles de ingresos"><i class="fas fa-expand"></i> Expandir Todo</button>
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('ingresos', true)" title="Colapsar todos los detalles de ingresos"><i class="fas fa-compress"></i> Colapsar Todo</button>
            </div>

            <div class="table-container">
                 <table id="ingresos-detail-table" class="collapsible-table">
                      <thead>
                         <tr>
                            <th>Rubro / Detalle</th>
                             <!-- Meses y Total Anual generados por JS -->
                         </tr>
                       </thead>
                      <tbody><!-- Contenido generado por JS --></tbody>
                      <tfoot><!-- Contenido generado por JS --></tfoot>
                 </table>
            </div>

            <div class="chart-container">
                 <h3>Evolutivo Expensa Mensual ($)</h3> <!-- MODIFICADO -->
                 <canvas id="evolutivoCuotaChart"></canvas>
                 <div class="chart-no-data" style="display: none;">No hay datos suficientes para graficar.</div>
            </div>

            <div style="display: flex; gap: 25px; flex-wrap: wrap; margin-top: 35px;">
                <div class="chart-container" style="flex: 1; min-width: 320px;">
                    <h3>Participación Gastos (%)</h3>
                    <canvas id="participacionGastosChart"></canvas>
                    <div class="chart-no-data" style="display: none;">No hay datos de gastos<br>para mostrar el gráfico.</div>
                </div>
                <div class="chart-container" style="flex: 1; min-width: 320px;">
                    <h3>Participación Ingresos (%)</h3>
                    <canvas id="participacionIngresosChart"></canvas>
                    <div class="chart-no-data" style="display: none;">No hay datos de ingresos<br>para mostrar el gráfico.</div>
                </div>
            </div>
        </div>

        <!-- ==================== UPLOAD ==================== -->
        <div id="upload" class="tab-content">
            <h2><i class="fas fa-upload"></i> Cargar Datos Reales / Base</h2>
            <div class="form-group input-group">
                <label for="exercise-year">Año del Ejercicio:</label>
                <input type="number" id="exercise-year" min="2020" max="2099" value="2024" style="width: 120px;">
                <button onclick="createNewExercise()" class="button-success"><i class="fas fa-calendar-plus"></i> Crear/Seleccionar Año</button>
             </div>
            <p>Sube tu archivo Excel con las hojas <strong>"Gastos"</strong> e <strong>"Ingresos"</strong>. Los rubros nuevos se añadirán automáticamente a la sección de Configuración.</p>
            <p><strong>Importante:</strong>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>Las celdas con números en la hoja "Gastos" marcarán ese mes/detalle como 'REAL' (fondo verde claro en detalle).</li>
                    <!-- MODIFICADO -->
                    <li>Los rubros de Ingreso llamados "<strong id="cuota-rubro-name-info">Expensas Ordinarias</strong>" y "<strong>Expensas Extraordinarias</strong>" tendrán sus valores base multiplicados por la cantidad de UF (definida en Configuración) al calcular el *total* de ingresos en el Resumen General.</li>
                </ul>
            </p>
            <div id="file-upload-area" onclick="document.getElementById('excel-file-input').click()">
                 <p><i class="fas fa-file-excel"></i><br>Arrastra tu archivo Excel aquí (.xlsx, .xls) o haz clic para seleccionar</p>
                 <input type="file" id="excel-file-input" accept=".xlsx, .xls" style="display: none;" onchange="handleFileUpload(this.files)">
                 <button type="button" class="button-primary" onclick="event.stopPropagation(); document.getElementById('excel-file-input').click()" style="pointer-events: auto;"><i class="fas fa-folder-open"></i> Seleccionar Archivo</button>
                 <button type="button" onclick="event.stopPropagation(); loadSampleData()" style="margin-left: 10px; pointer-events: auto;" class="button-secondary"><i class="fas fa-database"></i> Cargar Datos Ejemplo</button>
            </div>
            <div id="file-upload-feedback"></div>
            <a href="#" onclick="event.preventDefault(); downloadTemplate();" title="Descargar archivo Excel con estructura de ejemplo"><i class="fas fa-download"></i> Descargar Plantilla Ejemplo</a>
        </div>

        <!-- ==================== RESERVE FUND ==================== -->
        <div id="reserve" class="tab-content">
             <h2><i class="fas fa-piggy-bank"></i> Configurar Fondo de Reserva - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
             <div class="form-group">
                 <label>Método de Cálculo del Fondo:</label>
                 <div class="input-group">
                     <input type="radio" id="reserve-type-percent" name="reserve-type" value="percent" checked onchange="updateReserveUI()">
                     <label for="reserve-type-percent">Porcentaje (%) sobre Gastos Mensuales</label>
                     <input type="radio" id="reserve-type-fixed" name="reserve-type" value="fixed" onchange="updateReserveUI()">
                     <label for="reserve-type-fixed">Valor Fijo Mensual ($)</label>
                 </div>
             </div>
             <div id="reserve-fund-panel">
                 <!-- Inputs generados por JS -->
             </div>
             <button onclick="saveReserveFund()" style="margin-top: 25px;" class="button-success" title="Guardar los valores mensuales y el tipo de cálculo del fondo"><i class="fas fa-save"></i> Guardar Configuración del Fondo y Recalcular</button>
        </div>

        <!-- ==================== SETTINGS ==================== -->
        <div id="settings" class="tab-content">
             <h2><i class="fas fa-cog"></i> Configuración General y de Cálculo</h2>

             <div class="config-section">
                 <h4><i class="fas fa-building"></i> Ajustes Generales del Barrio</h4>
                 <div class="form-group">
                     <label for="cantidad-unidades">Cantidad Total de Unidades Funcionales (UF):</label>
                     <input type="number" id="cantidad-unidades" min="1" value="100" style="width: 180px;" title="Número total de UF para calcular cuotas base">
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-list-alt"></i> Gestión de Rubros (Categorías)</h4>
                 <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                     <div style="flex: 1; min-width: 320px;">
                         <h5><i class="fas fa-arrow-down" style="color:var(--danger-color)"></i> Rubros de GASTOS</h5>
                         <div class="form-group input-group">
                             <input type="text" id="new-gasto-rubro-name" placeholder="Nombre nuevo rubro de gasto" style="flex-grow: 1;">
                             <button onclick="addRubro('gastos')" class="button-sm button-success" title="Añadir este nuevo rubro a la lista de gastos"><i class="fas fa-plus"></i> Añadir</button>
                         </div>
                         <ul id="gasto-rubro-list" class="management-list"></ul>
                     </div>
                     <div style="flex: 1; min-width: 320px;">
                          <h5><i class="fas fa-arrow-up" style="color:var(--success-color)"></i> Rubros de INGRESOS</h5>
                          <div class="form-group input-group">
                              <input type="text" id="new-ingreso-rubro-name" placeholder="Nombre nuevo rubro de ingreso" style="flex-grow: 1;">
                              <button onclick="addRubro('ingresos')" class="button-sm button-success" title="Añadir este nuevo rubro a la lista de ingresos"><i class="fas fa-plus"></i> Añadir</button>
                          </div>
                          <ul id="ingreso-rubro-list" class="management-list"></ul>
                     </div>
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-percentage"></i> Gestión de Coeficientes de Ajuste (para Gastos Estimados)</h4>
                 <p class="text-muted" style="font-size: 0.9em;">Define tipos de coeficientes (ej. Inflación, Aumento Gremial) y asigna uno a cada rubro de Gasto. Al usar "Calcular Estimados" en el Dashboard, el sistema proyectará los meses sin datos 'REAL' multiplicando el último valor 'REAL' por el coeficiente correspondiente a cada mes futuro.</p>
                 <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                     <div style="flex: 1; min-width: 280px;">
                         <h5>Tipos de Coeficientes Disponibles</h5>
                         <div class="form-group input-group">
                             <input type="text" id="new-coefficient-type-name" placeholder="Nuevo tipo (ej: Aumento Sindicato)" style="flex-grow: 1;">
                             <button onclick="addCoefficientType()" class="button-sm button-success" title="Añadir este nuevo tipo de coeficiente a la lista"><i class="fas fa-plus"></i> Añadir Tipo</button>
                         </div>
                         <ul id="coefficient-type-list" class="management-list"></ul>
                     </div>
                     <div id="coefficient-editor" style="flex: 2; min-width: 450px;">
                          <h5><i class="fas fa-edit"></i> Editar Valores Mensuales para: <span id="editing-coefficient-name" style="color: var(--primary-color); font-weight: bold;"></span></h5>
                          <div id="coefficient-values-editor" class="table-container">
                              <p class="text-muted">Selecciona un tipo de coeficiente de la lista de la izquierda para editar sus valores (1 = sin cambio, 1.1 = +10%, 0.9 = -10%).</p>
                          </div>
                     </div>
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-chart-line"></i> Índices IPC Mensuales (Referencia)</h4>
                 <p class="text-muted">Introduce el porcentaje (%) de IPC estimado o real para cada mes. Se usa únicamente para calcular la columna "Cuota IPC ($)" como referencia en el Dashboard.</p>
                 <div id="ipc-inputs" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 20px;">
                     <!-- Inputs generados por JS -->
                 </div>
             </div>

             <button onclick="saveSettings()" style="margin-top: 20px; width: 100%; padding: 15px;" class="button-success button-lg" title="Guardar todos los cambios realizados en esta pestaña (UF, Rubros, Coeficientes, IPC) y recalcular el escenario actual">
                 <i class="fas fa-save"></i> GUARDAR TODA LA CONFIGURACIÓN Y RECALCULAR
             </button>
        </div>

        <!-- ==================== REPORTS ==================== -->
        <div id="reports" class="tab-content">
             <h2><i class="fas fa-download"></i> Descargar Reportes - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
             <p>Genera y descarga los datos del ejercicio y escenario actual en formato Excel, incluyendo detalles y resumen.</p>
             <button onclick="exportToExcel()" class="button-success" title="Descargar un archivo .xlsx con el detalle y resumen del escenario actual"><i class="fas fa-file-excel"></i> Descargar Reporte Completo (.xlsx)</button>

             <h3 style="margin-top: 35px;">Exportar Gráficos Individuales</h3>
             <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                 <button onclick="exportChart('evolutivoCuotaChart', 'evolutivo_expensa.png')" class="button-secondary" title="Descargar el gráfico de evolución de expensas como imagen PNG"><i class="fas fa-chart-line"></i> Gráfico Evolutivo (PNG)</button> <!-- MODIFICADO -->
                 <button onclick="exportChart('participacionGastosChart', 'participacion_gastos.png')" class="button-secondary" title="Descargar el gráfico de torta de gastos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Gastos (PNG)</button>
                 <button onclick="exportChart('participacionIngresosChart', 'participacion_ingresos.png')" class="button-secondary" title="Descargar el gráfico de torta de ingresos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Ingresos (PNG)</button>
             </div>
        </div>
    </div> <!-- /container -->

    <footer>
        <div class="container">
            &copy; <span id="footer-year"></span> Proyección Expensas El Centauro. v2.5 (Fixes: Detalle Carga, Nombre Expensa)
        </div>
    </footer>
    <div id="snackbar">Mensaje</div>

    <!-- ==================== SCRIPT PRINCIPAL ==================== -->
    <script>
        // --- Constantes y Estado Global ---
        const MONTHS = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
        const FULL_MONTHS = ["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"];
        const GASTOS_SHEET_NAME = "Gastos";
        const INGRESOS_SHEET_NAME = "Ingresos";
        const STORAGE_KEY = 'expensasAppCentauroState_v2.5_Fixes'; // Version bump for fixes
        // --- MODIFICADO: Nombre Rubro Principal ---
        const CUOTA_RUBRO_NAME = "Expensas Ordinarias"; // Rubro principal para multiplicar x UF y base de Expensa Real
        const EXTRA_CUOTA_RUBRO_NAME = "Expensas Extraordinarias"; // Otro rubro a multiplicar x UF
        const SPECIAL_INGRESO_RUBROS = [CUOTA_RUBRO_NAME, EXTRA_CUOTA_RUBRO_NAME]; // Actualizado automáticamente

        let appState = getDefaultAppState(); // Iniciar con estado por defecto limpio

        // Chart instances (moved to scope variables)
        let evolutivoCuotaChart_instance = null;
        let participacionGastosChart_instance = null;
        let participacionIngresosChart_instance = null;


        // --- Inicialización ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log(`DOM Cargado. Inicializando App ${STORAGE_KEY}...`);
            loadState(); // Cargar estado guardado si existe
            initTheme(); // Aplicar tema (antes de cualquier render que dependa de él)

            // Asegurar que exista al menos un escenario activo y válido
            validateAndSetActiveScenario();

            // --- MODIFICADO: Update UI instructions with the correct name ---
            const cuotaInfoSpan = document.getElementById('cuota-rubro-name-info');
            if (cuotaInfoSpan) cuotaInfoSpan.textContent = CUOTA_RUBRO_NAME; // Usa la constante actualizada

            initUI(); // Inicializar elementos de la UI que dependen del estado inicial
            addEventListeners(); // Añadir listeners globales
            updateUI(); // Renderizar todo con el estado actual/cargado
            console.log(`App ${STORAGE_KEY} Inicializada.`);
        });

        // --- Validación y Selección de Escenario Activo ---
        function validateAndSetActiveScenario() {
            let activeKeyIsValid = false;
            if (appState.activeScenarioKey && appState.scenarios[appState.activeScenarioKey]) {
                const activeYear = parseInt(appState.activeScenarioKey.split('_')[0]);
                if (appState.currentYear === activeYear) {
                    activeKeyIsValid = true;
                } else {
                    console.warn(`Mismatch: currentYear (${appState.currentYear}) vs activeScenarioKey year (${activeYear}). Adjusting currentYear.`);
                    appState.currentYear = activeYear;
                    activeKeyIsValid = true; // Key itself is valid, just needed year sync
                }
            }

            if (!activeKeyIsValid) {
                console.warn(`Clave activa inválida o ausente: ${appState.activeScenarioKey}. Buscando alternativa...`);
                // Try finding Base for current year
                const currentYearBaseKey = `${appState.currentYear}_Base`;
                // Try finding any scenario for current year
                const firstKeyForCurrentYear = Object.keys(appState.scenarios).find(k => k.startsWith(`${appState.currentYear}_`));
                // Try finding the very first scenario available
                const firstKeyOverall = Object.keys(appState.scenarios)[0];

                let fallbackKey = null;
                if (appState.scenarios[currentYearBaseKey]) {
                    fallbackKey = currentYearBaseKey;
                } else if (firstKeyForCurrentYear) {
                    fallbackKey = firstKeyForCurrentYear;
                } else if (firstKeyOverall) {
                    fallbackKey = firstKeyOverall;
                }

                if (fallbackKey) {
                    console.log(`Cambiando a escenario de fallback: ${fallbackKey}`);
                    appState.activeScenarioKey = fallbackKey;
                    appState.currentYear = parseInt(fallbackKey.split('_')[0]); // Update year based on the found key
                } else {
                    // No scenarios exist at all, create the default Base
                    console.log("No existen escenarios. Creando Base para el año actual.");
                    appState.currentYear = new Date().getFullYear();
                    initScenarioData(appState.currentYear); // Creates Base by default
                    appState.activeScenarioKey = `${appState.currentYear}_Base`;
                }
                saveState(); // Save potentially corrected state
            }

             // Ensure the selected scenario data structure is complete
             const currentScenario = getCurrentScenarioData();
             if (currentScenario) {
                initializeScenarioDataForRubros(currentScenario);
             }
        }


        // --- Gestión de Datos del Escenario ---
        function getCurrentScenarioData() {
             if (!appState.activeScenarioKey || !appState.scenarios[appState.activeScenarioKey]) {
                console.error(`Error Crítico: No se pudo obtener un escenario activo válido (actual: ${appState.activeScenarioKey}). Intentando recuperación.`);
                 // Attempt recovery one last time - this shouldn't be reached if validateAndSetActiveScenario works
                 validateAndSetActiveScenario();
                 if (!appState.activeScenarioKey || !appState.scenarios[appState.activeScenarioKey]){
                     // Still no valid scenario - critical state
                     showSnackbar("Error crítico: No se puede operar sin un escenario válido.", true, 'error', 10000);
                     // Maybe disable parts of the UI?
                     return null; // Indicate failure
                 }
             }
            return appState.scenarios[appState.activeScenarioKey];
        }

        function initScenarioData(year, scenarioName = 'Base') {
            const key = `${year}_${scenarioName.replace(/\s+/g, '_')}`;
            if (!appState.scenarios[key]) {
                console.log(`Inicializando nuevo escenario: ${key}`);
                // Start with a deep copy of the default structure's scenario part
                 const defaultScenarioStructure = JSON.parse(JSON.stringify(getDefaultAppState().scenarios.BaseExample || {
                     year: year,
                     scenarioName: scenarioName,
                     rubroOrder: { gastos: [], ingresos: [] },
                     data: { gastos: {}, ingresos: {} },
                     monthStatus: { gastos: {}, ingresos: {} },
                     reserveFund: { type: 'percent', values: Array(12).fill(5) },
                     calculated: {
                         gastoAjustado: {}, totalGastoRubroMes: {}, totalGastoProyectadoMes: Array(12).fill(0),
                         ingresoAjustado: {}, totalIngresoRubroMes: {}, totalIngresoProyectadoMes: Array(12).fill(0),
                         fondoReservaMes: Array(12).fill(0),
                         cuotaSobreGastosMes: Array(12).fill(0),
                         ipcManual: Array(12).fill(0),
                         cuotaIpcMes: Array(12).fill(0),
                         cuotaRealBaseMes: Array(12).fill(0), // Now Expensa Real Base
                         annualTotals: {
                             gastos: {__TOTAL__:0}, ingresos: {__TOTAL__:0}, fondoReserva: 0,
                             cuotaSobreGastos: 0, cuotaIpc: 0, cuotaRealBase: 0 // Now Expensa Real Base
                         }
                     }
                 }));
                 // Override year and name
                 defaultScenarioStructure.year = year;
                 defaultScenarioStructure.scenarioName = scenarioName;
                 // Copy global IPC settings into the new scenario's initial IPC snapshot
                 defaultScenarioStructure.calculated.ipcManual = [...appState.settings.ipcManual];

                 appState.scenarios[key] = defaultScenarioStructure;

                 // Ensure structures for existing global rubros are created within this new scenario
                initializeScenarioDataForRubros(appState.scenarios[key]);
            }
            return appState.scenarios[key];
        }


        function initializeScenarioDataForRubros(scenarioData) {
             if (!scenarioData) {
                console.warn("initializeScenarioDataForRubros llamado sin datos de escenario.");
                return;
             }

             // Ensure top-level structures exist using nullish coalescing
             scenarioData.rubroOrder = scenarioData.rubroOrder ?? { gastos: [], ingresos: [] };
             scenarioData.data = scenarioData.data ?? { gastos: {}, ingresos: {} };
             scenarioData.monthStatus = scenarioData.monthStatus ?? { gastos: {}, ingresos: {} };
             scenarioData.reserveFund = scenarioData.reserveFund ?? { type: 'percent', values: Array(12).fill(5) };
             scenarioData.calculated = scenarioData.calculated ?? {}; // Ensure calculated object exists
             scenarioData.calculated.annualTotals = scenarioData.calculated.annualTotals ?? {}; // Ensure annualTotals object exists

             // Ensure default calculated arrays/objects exist if missing
             const defaultCalculated = getDefaultAppState().scenarios.BaseExample?.calculated || {
                 gastoAjustado: {}, totalGastoRubroMes: {}, totalGastoProyectadoMes: Array(12).fill(0),
                 ingresoAjustado: {}, totalIngresoRubroMes: {}, totalIngresoProyectadoMes: Array(12).fill(0),
                 fondoReservaMes: Array(12).fill(0), cuotaSobreGastosMes: Array(12).fill(0), ipcManual: Array(12).fill(0), cuotaIpcMes: Array(12).fill(0), cuotaRealBaseMes: Array(12).fill(0),
                 annualTotals: { gastos: {__TOTAL__:0}, ingresos: {__TOTAL__:0}, fondoReserva: 0, cuotaSobreGastos: 0, cuotaIpc: 0, cuotaRealBase: 0 }
             };

             for(const key in defaultCalculated) {
                if(scenarioData.calculated[key] === undefined || scenarioData.calculated[key] === null) {
                     // Deep copy arrays/objects from default to avoid reference issues
                     scenarioData.calculated[key] = JSON.parse(JSON.stringify(defaultCalculated[key]));
                }
                 // Ensure nested annualTotals are objects
                if(key === 'annualTotals') {
                     scenarioData.calculated.annualTotals.gastos = scenarioData.calculated.annualTotals.gastos ?? { __TOTAL__: 0 };
                     scenarioData.calculated.annualTotals.ingresos = scenarioData.calculated.annualTotals.ingresos ?? { __TOTAL__: 0 };
                }
             }
             // Ensure ipcManual array exists and has 12 elements
             if (!Array.isArray(scenarioData.calculated.ipcManual) || scenarioData.calculated.ipcManual.length !== 12) {
                scenarioData.calculated.ipcManual = [...appState.settings.ipcManual]; // Copy from global settings
             }


             // Iterate through GLOBAL rubro lists from settings
             ['gastos', 'ingresos'].forEach(type => {
                 // Ensure type-specific structures exist in scenario
                 scenarioData.rubroOrder[type] = scenarioData.rubroOrder[type] ?? [];
                 scenarioData.data[type] = scenarioData.data[type] ?? {};
                 scenarioData.monthStatus[type] = scenarioData.monthStatus[type] ?? {};
                 scenarioData.calculated.annualTotals[type] = scenarioData.calculated.annualTotals[type] ?? { __TOTAL__: 0 };

                 // Process each rubro defined in global settings
                 appState.settings.rubros[type].forEach(rubro => {
                     // Ensure data/status structures for the rubro exist in the scenario
                     if (!scenarioData.data[type][rubro]) {
                         scenarioData.data[type][rubro] = { detailOrder: [], detailsData: {} };
                     }
                     if (!scenarioData.monthStatus[type][rubro]) {
                         scenarioData.monthStatus[type][rubro] = {}; // Initialize as object
                     }
                     // Initialize detailOrder/detailsData inside data[type][rubro] if they are missing
                     scenarioData.data[type][rubro].detailOrder = scenarioData.data[type][rubro].detailOrder ?? [];
                     scenarioData.data[type][rubro].detailsData = scenarioData.data[type][rubro].detailsData ?? {};


                     // Initialize calculated substructures if missing
                     if (type === 'gastos') {
                        scenarioData.calculated.gastoAjustado = scenarioData.calculated.gastoAjustado ?? {};
                        scenarioData.calculated.totalGastoRubroMes = scenarioData.calculated.totalGastoRubroMes ?? {};
                        if (!scenarioData.calculated.gastoAjustado[rubro]) scenarioData.calculated.gastoAjustado[rubro] = {};
                        if (!scenarioData.calculated.totalGastoRubroMes[rubro]) scenarioData.calculated.totalGastoRubroMes[rubro] = Array(12).fill(0);
                     } else { // ingresos
                        scenarioData.calculated.ingresoAjustado = scenarioData.calculated.ingresoAjustado ?? {};
                        scenarioData.calculated.totalIngresoRubroMes = scenarioData.calculated.totalIngresoRubroMes ?? {};
                         if (!scenarioData.calculated.ingresoAjustado[rubro]) scenarioData.calculated.ingresoAjustado[rubro] = {};
                         if (!scenarioData.calculated.totalIngresoRubroMes[rubro]) scenarioData.calculated.totalIngresoRubroMes[rubro] = Array(12).fill(0);
                     }

                     // Initialize annual totals for the rubro if missing
                     if (scenarioData.calculated.annualTotals[type][rubro] === undefined) {
                         scenarioData.calculated.annualTotals[type][rubro] = 0;
                     }
                 });
             });
        }


        // --- Lógica de Negocio y Cálculos ---
        function calculateAll(scenarioData) {
             console.log(`Recalculando TODO para: ${scenarioData?.year} - ${scenarioData?.scenarioName}`);
             if (!scenarioData) { console.error("CalculateAll: No scenario data provided."); renderEmptyState(); return; }

             // Ensure structures are complete before calculating
             initializeScenarioDataForRubros(scenarioData);

             const { data, monthStatus, reserveFund, rubroOrder } = scenarioData;
             const { settings } = appState;
             const { rubros, rubroConfig, coefficientTypes, cantidadUnidades, ipcManual } = settings; // Use GLOBAL settings IPC
             const calculated = scenarioData.calculated; // Direct reference

             // --- Reset Calculated Values ---
             calculated.gastoAjustado = {}; calculated.totalGastoRubroMes = {}; calculated.totalGastoProyectadoMes = Array(12).fill(0);
             calculated.ingresoAjustado = {}; calculated.totalIngresoRubroMes = {}; calculated.totalIngresoProyectadoMes = Array(12).fill(0);
             calculated.fondoReservaMes = Array(12).fill(0);
             calculated.cuotaSobreGastosMes = Array(12).fill(0);
             calculated.cuotaIpcMes = Array(12).fill(0); // Reset Cuota IPC
             calculated.cuotaRealBaseMes = Array(12).fill(0); // Reset Expensa Real Base
             calculated.ipcManual = [...ipcManual]; // Store snapshot of IPC used for this calculation

             calculated.annualTotals = {
                gastos: { __TOTAL__: 0 },
                ingresos: { __TOTAL__: 0 },
                fondoReserva: 0,
                cuotaSobreGastos: 0,
                cuotaIpc: 0,        // Reset Annual Cuota IPC
                cuotaRealBase: 0   // Reset Annual Expensa Real Base
             };
             // Ensure annual total objects exist (redundant with initialize, but safe)
             calculated.annualTotals.gastos = { __TOTAL__: 0 };
             calculated.annualTotals.ingresos = { __TOTAL__: 0 };
             // --- End Reset ---


             // 1. Gastos Ajustados y Totales
             // Use scenario-specific rubro order if available, otherwise process all in data
             const gastoRubrosToProcess = Array.isArray(rubroOrder?.gastos) && rubroOrder.gastos.length > 0
                                          ? rubroOrder.gastos
                                          : Object.keys(data?.gastos || {});

             gastoRubrosToProcess.forEach(rubro => {
                 if (!settings.rubros.gastos.includes(rubro)) {
                     console.warn(`Skipping calc for gasto rubro "${rubro}" not in settings or data.`);
                     return;
                 }
                 // Ensure data structure exists for this rubro
                 if (!data.gastos || !data.gastos[rubro]) {
                    console.warn(`Data missing for gasto rubro "${rubro}" during calculation.`);
                    return;
                 }

                 // Initialize calculated structures for this rubro
                 calculated.gastoAjustado[rubro] = {};
                 calculated.totalGastoRubroMes[rubro] = Array(12).fill(0);
                 calculated.annualTotals.gastos[rubro] = 0;

                 const config = rubroConfig[rubro] || {};
                 const coefTypeKey = config.coefficientType || 'None';
                 // Use .values directly, handle potential undefined type
                 const coefValues = coefficientTypes[coefTypeKey]?.values || Array(12).fill(1);

                 // Use scenario-specific detail order if available, otherwise process all in data
                 const detailOrder = Array.isArray(data.gastos[rubro].detailOrder) && data.gastos[rubro].detailOrder.length > 0
                                     ? data.gastos[rubro].detailOrder
                                     : Object.keys(data.gastos[rubro].detailsData || {});

                 detailOrder.forEach(detail => {
                      // Ensure data structure exists for this detail
                      if (!data.gastos[rubro].detailsData || data.gastos[rubro].detailsData[detail] === undefined) {
                           console.warn(`Data missing for gasto detail "${rubro}/${detail}" during calculation.`);
                           return;
                      }
                     calculated.gastoAjustado[rubro][detail] = Array(12).fill(0);
                     const baseValues = data.gastos[rubro].detailsData[detail] || Array(12).fill(0);
                     // Ensure status array exists
                     const statusArray = (monthStatus.gastos && monthStatus.gastos[rubro] && monthStatus.gastos[rubro][detail])
                                         ? monthStatus.gastos[rubro][detail]
                                         : Array(12).fill('Estimado');


                     for (let i = 0; i < 12; i++) {
                         const base = parseFloat(baseValues[i] || 0);
                         let adjusted = base;
                         // Apply coefficient only if the month is marked as 'Estimado'
                         if (statusArray[i] === 'Estimado') {
                             adjusted = base * parseFloat(coefValues[i] || 1);
                         }
                         // Store the final value (adjusted or base)
                         calculated.gastoAjustado[rubro][detail][i] = adjusted;
                         // Add to monthly total for the rubro using the final value
                         calculated.totalGastoRubroMes[rubro][i] += adjusted;
                     }
                 });

                 // Sum monthly totals for the rubro to overall monthly/annual totals
                 for (let i = 0; i < 12; i++) {
                     const monthTotalRubro = calculated.totalGastoRubroMes[rubro]?.[i] || 0;
                     calculated.totalGastoProyectadoMes[i] += monthTotalRubro;
                     calculated.annualTotals.gastos[rubro] += monthTotalRubro;
                 }
             });
             calculated.annualTotals.gastos.__TOTAL__ = calculated.totalGastoProyectadoMes.reduce((a, b) => a + b, 0);


             // 2. Ingresos Ajustados & Totales & Expensa Real Base Extraction
             const unidades = parseInt(cantidadUnidades) || 1;
             const ingresoRubrosToProcess = Array.isArray(rubroOrder?.ingresos) && rubroOrder.ingresos.length > 0
                                            ? rubroOrder.ingresos
                                            : Object.keys(data?.ingresos || {});

             ingresoRubrosToProcess.forEach(rubro => {
                 if (!settings.rubros.ingresos.includes(rubro)) {
                     console.warn(`Skipping calc for ingreso rubro "${rubro}" not in settings or data.`);
                     return;
                 }
                  // Ensure data structure exists for this rubro
                  if (!data.ingresos || !data.ingresos[rubro]) {
                     console.warn(`Data missing for ingreso rubro "${rubro}" during calculation.`);
                     return;
                  }

                 calculated.ingresoAjustado[rubro] = {}; // Stores BASE values for detail display
                 calculated.totalIngresoRubroMes[rubro] = Array(12).fill(0); // Stores FINAL calculated value (incl. UF mult)
                 calculated.annualTotals.ingresos[rubro] = 0;

                 const detailOrder = Array.isArray(data.ingresos[rubro].detailOrder) && data.ingresos[rubro].detailOrder.length > 0
                                     ? data.ingresos[rubro].detailOrder
                                     : Object.keys(data.ingresos[rubro].detailsData || {});

                 detailOrder.forEach(detail => {
                      // Ensure data structure exists for this detail
                      if (!data.ingresos[rubro].detailsData || data.ingresos[rubro].detailsData[detail] === undefined) {
                           console.warn(`Data missing for ingreso detail "${rubro}/${detail}" during calculation.`);
                           return;
                      }
                     const baseValues = data.ingresos[rubro].detailsData[detail] || Array(12).fill(0);
                     // Store BASE values in 'ingresoAjustado' for the detail table display
                     calculated.ingresoAjustado[rubro][detail] = baseValues.map(v => parseFloat(v || 0));

                     // --- Store Base for Expensa Real --- MODIFICADO
                     // If this is the primary cuota rubro AND the first detail, store its base values
                     if (rubro === CUOTA_RUBRO_NAME && detail === detailOrder[0]) {
                         for (let i = 0; i < 12; i++){
                            calculated.cuotaRealBaseMes[i] = parseFloat(baseValues[i] || 0);
                         }
                     }
                     // --- End Store Base ---

                     // Calculate the contribution of this detail's BASE value to the monthly rubro total (before UF mult)
                     for (let i = 0; i < 12; i++) {
                         calculated.totalIngresoRubroMes[rubro][i] += parseFloat(baseValues[i] || 0);
                     }
                 });

                 // After summing all details for the rubro, apply multiplication if it's a special rubro
                 if (SPECIAL_INGRESO_RUBROS.includes(rubro)) {
                     for (let i = 0; i < 12; i++) {
                         calculated.totalIngresoRubroMes[rubro][i] *= unidades;
                     }
                 }

                 // Sum the final calculated monthly totals for the rubro to the overall ingreso totals and annuals
                 for (let i = 0; i < 12; i++) {
                     const monthTotalRubroFinal = calculated.totalIngresoRubroMes[rubro]?.[i] || 0;
                     calculated.totalIngresoProyectadoMes[i] += monthTotalRubroFinal;
                     calculated.annualTotals.ingresos[rubro] += monthTotalRubroFinal;
                 }
             });
             calculated.annualTotals.ingresos.__TOTAL__ = calculated.totalIngresoProyectadoMes.reduce((a, b) => a + b, 0);


             // 3. Fondo Reserva
             for (let i = 0; i < 12; i++) {
                 const reserveValueInput = parseFloat(reserveFund?.values?.[i] || 0);
                 calculated.fondoReservaMes[i] = reserveFund?.type === 'percent'
                     ? calculated.totalGastoProyectadoMes[i] * (reserveValueInput / 100)
                     : reserveValueInput;
             }
             calculated.annualTotals.fondoReserva = calculated.fondoReservaMes.reduce((a, b) => a + b, 0);


             // 4. Cuota Sobre Gastos (Gasto + Fondo / UF)
             for (let i = 0; i < 12; i++) {
                 const totalGastoYFondo = (calculated.totalGastoProyectadoMes[i] || 0) + (calculated.fondoReservaMes[i] || 0);
                 calculated.cuotaSobreGastosMes[i] = unidades > 0 ? totalGastoYFondo / unidades : 0;
             }


             // 5. Cuota IPC (Cuota s/Gs * (1 + IPC%)) - Use IPC snapshot stored in calculated.ipcManual
             for (let i = 0; i < 12; i++) {
                 const cuotaBase = calculated.cuotaSobreGastosMes[i] || 0;
                 const ipc = parseFloat(calculated.ipcManual?.[i] || 0); // Use stored IPC
                 calculated.cuotaIpcMes[i] = cuotaBase * (1 + ipc / 100);
             }

             // 6. Calculate Annual Totals for new/modified columns
             calculated.annualTotals.cuotaSobreGastos = calculated.cuotaSobreGastosMes.reduce((a, b) => a + b, 0);
             calculated.annualTotals.cuotaIpc = calculated.cuotaIpcMes.reduce((a, b) => a + b, 0); // Sum calculated IPC cuotas
             calculated.annualTotals.cuotaRealBase = calculated.cuotaRealBaseMes.reduce((a, b) => a + b, 0); // Sum base real expensas


             console.log("Recálculo Finalizado.", calculated);
             saveState(); // Save state after successful calculation
             updateUI(); // Update the display
             showSnackbar("Cálculos actualizados correctamente.", false, 'success');
        }

        // --- Recalcular Estimados (ACUMULATIVO) ---
        function recalculateEstimates() {
            const scenarioData = getCurrentScenarioData();
            if (!scenarioData) { showSnackbar("No hay escenario activo para calcular estimados.", true, 'error'); return; }
            console.log(`Calculando estimados (Acumulativo) para: ${scenarioData.scenarioName}`);

            const { data, monthStatus, rubroOrder } = scenarioData;
            const { settings } = appState;
            const { rubros, rubroConfig, coefficientTypes } = settings;
            let changesMade = false;

            // Ensure rubroOrder.gastos exists and is an array
             const gastoRubrosToProcess = Array.isArray(rubroOrder?.gastos) ? rubroOrder.gastos : [];

            gastoRubrosToProcess.forEach(rubro => {
                if (!settings.rubros.gastos.includes(rubro)) return; // Skip rubros not in settings
                if (!data.gastos || !data.gastos[rubro]) return; // Skip if rubro data missing

                // Ensure detailOrder exists and is an array
                const detailOrder = Array.isArray(data.gastos[rubro].detailOrder) ? data.gastos[rubro].detailOrder : [];

                const rubroCoefConfig = rubroConfig[rubro] || {};
                const coefTypeKey = rubroCoefConfig.coefficientType || 'None';
                // Use .values directly, handle potential undefined type
                const coefValues = coefficientTypes[coefTypeKey]?.values || Array(12).fill(1);

                detailOrder.forEach(detail => {
                     if (!data.gastos[rubro].detailsData || data.gastos[rubro].detailsData[detail] === undefined) return; // Skip if detail data missing

                    // Ensure data and status arrays exist before accessing them
                    const currentStatuses = (monthStatus.gastos && monthStatus.gastos[rubro] && monthStatus.gastos[rubro][detail])
                                            ? monthStatus.gastos[rubro][detail]
                                            : Array(12).fill('Estimado');
                    const currentData = data.gastos[rubro].detailsData[detail] || Array(12).fill(0);

                    let lastRealMonthIndex = -1;
                    for (let i = currentStatuses.length - 1; i >= 0; i--) { // Iterate backwards
                        if (currentStatuses[i] === 'REAL') {
                            lastRealMonthIndex = i;
                            break;
                        }
                    }

                    if (lastRealMonthIndex === -1) {
                         // console.log(`   - ${rubro}/${detail}: Sin mes REAL encontrado, no se proyectará.`);
                         return; // Skip projection if no REAL month found
                    }

                    let previousMonthValue = parseFloat(currentData[lastRealMonthIndex] || 0); // Base value from the last REAL month

                    for (let j = lastRealMonthIndex + 1; j < 12; j++) {
                        const coefficient = parseFloat(coefValues[j] || 1);
                        // Accumulative calculation: multiply the PREVIOUS month's value by the CURRENT month's coefficient
                        const projectedValue = previousMonthValue * coefficient;

                        // Get current value, default to 0 if undefined
                        const currentMonthValue = data.gastos[rubro].detailsData[detail][j] ?? 0;

                        // Update only if the projected value is different OR if the status needs changing from REAL
                        if (currentMonthValue !== projectedValue || currentStatuses[j] !== 'Estimado') {
                            // Ensure nested structures exist before assigning (redundant with earlier checks, but safe)
                            if (!data.gastos[rubro]) data.gastos[rubro] = { detailOrder: [], detailsData: {} };
                            if (!data.gastos[rubro].detailsData[detail]) data.gastos[rubro].detailsData[detail] = Array(12).fill(0);
                            if (!monthStatus.gastos[rubro]) monthStatus.gastos[rubro] = {};
                            if (!monthStatus.gastos[rubro][detail]) monthStatus.gastos[rubro][detail] = Array(12).fill('Estimado');

                            data.gastos[rubro].detailsData[detail][j] = projectedValue;
                            monthStatus.gastos[rubro][detail][j] = 'Estimado'; // Ensure status is Estimado
                            changesMade = true;
                            // console.log(`     * ${MONTHS[j]} (${rubro}/${detail}): ${projectedValue.toFixed(2)} (Prev: ${previousMonthValue.toFixed(2)} * Coef: ${coefficient})`);
                        }
                        // Update previousMonthValue for the next iteration *using the newly calculated projected value*
                        previousMonthValue = projectedValue;
                    }
                });
            });

            if (changesMade) {
                console.log("Se realizaron cambios en los estimados, recalculando todo...");
                showSnackbar("Meses estimados recalculados (acum.). Actualizando dashboard...", false, 'info', 4000);
                calculateAll(scenarioData); // Recalculate everything after projections
            } else {
                console.log("No se necesitaron cambios en los estimados.");
                showSnackbar("No se encontraron meses estimados que requieran recalcular.", false, 'info');
            }
        }


        // --- Actualización de la Interfaz (UI) ---
        function initUI() {
             document.getElementById('exercise-year')?.setAttribute('value', appState.currentYear);
             document.getElementById('footer-year').textContent = new Date().getFullYear();
             updateScenarioSelector(); // Populate selector based on loaded state
             updateCurrentYearAndScenarioInUI(); // Set initial text based on active scenario/year
        }

        function updateUI() {
             console.log("Actualizando UI completa...");
             const scenarioData = getCurrentScenarioData(); // Get current data
             if (!scenarioData) {
                 console.error("updateUI: No hay escenario activo o datos disponibles. Renderizando estado vacío.");
                 renderEmptyState(); // Show empty state if no data
                 updateCurrentYearAndScenarioInUI(); // Still update year/scenario display (might show 'Ninguno')
                 updateScenarioSelector(); // Update selector too (might show empty)
                 updateReportsPanel(); // Disable report buttons
                 updateSettingsPanel(); // Update settings lists and inputs
                 return; // Stop further UI updates
             }

             // If we have data, ensure it's properly initialized
             initializeScenarioDataForRubros(scenarioData);

             // Update all relevant UI sections
             updateCurrentYearAndScenarioInUI();
             updateScenarioSelector(); // Ensure selector reflects current state
             updateDashboardTables(scenarioData); // Update summary and detail tables
             updateCharts(scenarioData); // Update all charts
             updateReserveFundPanel(scenarioData); // Update reserve fund inputs
             updateSettingsPanel(); // Update settings lists and inputs
             updateReportsPanel(); // Enable/disable report buttons
             console.log("UI Actualizada.");
        }

        function renderEmptyState() {
            console.log("Renderizando estado vacío...");
            // Clear tables
            const summaryTable = document.getElementById('dashboard-summary');
            const summaryTbody = summaryTable?.querySelector('tbody');
            const summaryTfoot = summaryTable?.querySelector('tfoot');
             const summaryHeaderCells = summaryTable?.querySelector('thead tr')?.cells?.length || 7;
            if(summaryTbody) summaryTbody.innerHTML = `<tr><td colspan="${summaryHeaderCells}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos calculados para este escenario. Carga datos o usa los de ejemplo.</td></tr>`;
            if(summaryTfoot) summaryTfoot.innerHTML = '';

            const gastosTable = document.getElementById('gastos-detail-table');
            const gastosTheadCells = gastosTable?.querySelector('thead tr')?.cells?.length || 14;
            const gastosTbody = gastosTable?.querySelector('tbody');
            const gastosTfoot = gastosTable?.querySelector('tfoot');
            if(gastosTbody) gastosTbody.innerHTML = `<tr><td colspan="${gastosTheadCells}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos de gastos.</td></tr>`;
            if(gastosTfoot) gastosTfoot.innerHTML = '';

            const ingresosTable = document.getElementById('ingresos-detail-table');
            const ingresosTheadCells = ingresosTable?.querySelector('thead tr')?.cells?.length || 14;
            const ingresosTbody = ingresosTable?.querySelector('tbody');
            const ingresosTfoot = ingresosTable?.querySelector('tfoot');
            if(ingresosTbody) ingresosTbody.innerHTML = `<tr><td colspan="${ingresosTheadCells}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos de ingresos.</td></tr>`;
            if(ingresosTfoot) ingresosTfoot.innerHTML = '';


            // Clear charts
            destroyChart('evolutivoCuotaChart'); displayChartNoData('evolutivoCuotaChart', true);
            destroyChart('participacionGastosChart'); displayChartNoData('participacionGastosChart', true);
            destroyChart('participacionIngresosChart'); displayChartNoData('participacionIngresosChart', true);

            // Clear coefficient editor
            const coefEditor = document.getElementById('coefficient-values-editor');
            const coefNameSpan = document.getElementById('editing-coefficient-name');
            if(coefEditor) coefEditor.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente de la lista.</p>';
            if(coefNameSpan) coefNameSpan.textContent = 'Ninguno';
            if(appState.uiState) appState.uiState.editingCoefficientType = null;
        }

        function destroyChart(canvasId) {
             const instance = window[`${canvasId}_instance`];
             if (instance) {
                instance.destroy();
                window[`${canvasId}_instance`] = null;
                // console.log(`Chart ${canvasId} destroyed.`);
             }
         }

        function displayChartNoData(canvasId, show) {
            const container = document.getElementById(canvasId)?.parentElement;
            const noDataElement = container?.querySelector('.chart-no-data');
            if (noDataElement) {
                noDataElement.style.display = show ? 'block' : 'none';
            }
            const canvasElement = document.getElementById(canvasId);
             if (canvasElement) {
                 canvasElement.style.display = show ? 'none' : 'block'; // Hide canvas if no data
             }
        }

        function updateCurrentYearAndScenarioInUI() {
            const scenarioData = getCurrentScenarioData();
            const year = scenarioData ? scenarioData.year : appState.currentYear;
            const scenarioName = scenarioData ? scenarioData.scenarioName : '(Ninguno)';
            // Update dashboard titles
            document.getElementById('dashboard-year').textContent = year;
            document.getElementById('dashboard-scenario').textContent = scenarioName;
            // Update titles in other tabs
            document.querySelectorAll('.current-year').forEach(el => el.textContent = year);
            document.querySelectorAll('.current-scenario').forEach(el => el.textContent = scenarioName);
            // Update year input in Upload tab if it differs
            const yearInput = document.getElementById('exercise-year');
            if (yearInput && yearInput.value !== String(year)) {
                 yearInput.value = year;
            }
        }

        function updateDashboardTables(scenarioData) {
             if (!scenarioData || !scenarioData.calculated) {
                 console.error("Faltan datos calculados en updateDashboardTables. Renderizando vacío.");
                 renderEmptyState();
                 return;
             }

             const { calculated } = scenarioData;
             // Use the IPC snapshot stored in 'calculated' for consistency
             const ipcSnapshot = calculated.ipcManual || appState.settings.ipcManual || Array(12).fill(0);
             const summaryTable = document.getElementById('dashboard-summary');
             const summaryTbody = summaryTable?.querySelector('tbody');
             const summaryTfoot = summaryTable?.querySelector('tfoot');

             if (!summaryTable || !summaryTbody || !summaryTfoot) {
                console.error("Elementos de la tabla de resumen no encontrados.");
                return;
             }
             const summaryHeaderCells = summaryTable.querySelector('thead tr')?.cells?.length || 7;


             summaryTbody.innerHTML = '';
             summaryTfoot.innerHTML = '';

             const hasData = calculated.totalGastoProyectadoMes?.some(v => v !== 0) || calculated.cuotaSobreGastosMes?.some(v => v !== 0);
             if (!hasData) {
                summaryTbody.innerHTML = `<tr><td colspan="${summaryHeaderCells}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos calculados para mostrar en el resumen.</td></tr>`;
                // Clear detail tables as well if summary is empty
                 updateCollapsibleTable('gastos', scenarioData);
                 updateCollapsibleTable('ingresos', scenarioData);
                return;
            }

             // Populate tbody
             for (let i = 0; i < 12; i++) {
                 const row = summaryTbody.insertRow();
                 row.insertCell().textContent = MONTHS[i]; // Mes

                 // Gasto ($)
                 const gastoCell = row.insertCell();
                 gastoCell.textContent = formatCurrency(calculated.totalGastoProyectadoMes?.[i] || 0);
                 gastoCell.classList.add('number-cell');

                 // Fondo ($)
                 const fondoCell = row.insertCell();
                 fondoCell.textContent = formatCurrency(calculated.fondoReservaMes?.[i] || 0);
                 fondoCell.classList.add('number-cell');

                 // Cuota s/Gs ($)
                 const cuotaGsCell = row.insertCell();
                 cuotaGsCell.textContent = formatCurrency(calculated.cuotaSobreGastosMes?.[i] || 0);
                 cuotaGsCell.classList.add('number-cell');

                 // IPC (%)
                 const ipcVal = ipcSnapshot?.[i] || 0;
                 const ipcCell = row.insertCell();
                 ipcCell.textContent = `${ipcVal}%`;
                 ipcCell.classList.add('number-cell'); // Center align percentage

                 // Cuota IPC ($) - Use pre-calculated value
                 const cuotaIpcCell = row.insertCell();
                 cuotaIpcCell.textContent = formatCurrency(calculated.cuotaIpcMes?.[i] || 0);
                 cuotaIpcCell.classList.add('number-cell', 'estimated-month-cell'); // Mark as calculated/estimated

                 // Expensa Real ($) - Use pre-calculated base value (MODIFICADO)
                 const cuotaRealCell = row.insertCell();
                 cuotaRealCell.textContent = formatCurrency(calculated.cuotaRealBaseMes?.[i] || 0);
                 cuotaRealCell.classList.add('number-cell', 'real-month-cell'); // Mark as 'real' input visually
             }

             // Populate tfoot with annual totals
             const tfootRow = summaryTfoot.insertRow();
             tfootRow.insertCell().textContent = "TOTAL ANUAL";

             // Gasto Total
             const gastoFootCell = tfootRow.insertCell();
             gastoFootCell.textContent = formatCurrency(calculated.annualTotals?.gastos?.__TOTAL__ || 0);
             gastoFootCell.classList.add('number-cell');

             // Fondo Total
             const fondoFootCell = tfootRow.insertCell();
             fondoFootCell.textContent = formatCurrency(calculated.annualTotals?.fondoReserva || 0);
             fondoFootCell.classList.add('number-cell');

             // Cuota s/Gs Total
             const cuotaGsFootCell = tfootRow.insertCell();
             cuotaGsFootCell.textContent = formatCurrency(calculated.annualTotals?.cuotaSobreGastos || 0);
             cuotaGsFootCell.classList.add('number-cell');

             // IPC Total (Not applicable)
             tfootRow.insertCell().textContent = "-";

             // Cuota IPC Total
             const cuotaIpcFootCell = tfootRow.insertCell();
             cuotaIpcFootCell.textContent = formatCurrency(calculated.annualTotals?.cuotaIpc || 0);
             cuotaIpcFootCell.classList.add('number-cell', 'estimated-month-cell');

             // Expensa Real Total (MODIFICADO)
             const cuotaRealFootCell = tfootRow.insertCell();
             cuotaRealFootCell.textContent = formatCurrency(calculated.annualTotals?.cuotaRealBase || 0);
             cuotaRealFootCell.classList.add('number-cell', 'real-month-cell');

             // --- Update detail tables AFTER summary ---
             updateCollapsibleTable('gastos', scenarioData);
             updateCollapsibleTable('ingresos', scenarioData);
         }

        function updateCollapsibleTable(type, scenarioData) {
             const tableId = `${type}-detail-table`;
             const table = document.getElementById(tableId);
             if (!table) { console.warn(`Tabla ${tableId} no encontrada.`); return; }

             const thead = table.querySelector('thead');
             const tbody = table.querySelector('tbody');
             const tfoot = table.querySelector('tfoot');

             if (!thead || !tbody || !tfoot) { console.error(`Elementos internos de ${tableId} no encontrados.`); return;}

             tbody.innerHTML = '';
             tfoot.innerHTML = '';

             if (!scenarioData || !scenarioData.data || !scenarioData.calculated || !scenarioData.rubroOrder || !appState.settings || !appState.settings.rubros) {
                 const cols = thead.querySelector('tr')?.cells?.length || 14;
                 tbody.innerHTML = `<tr><td colspan="${cols}" class="text-muted" style="text-align: center; padding: 20px;">Faltan datos o configuración para mostrar el detalle.</td></tr>`;
                 return;
             }

             const { data, calculated, monthStatus, rubroOrder } = scenarioData;
             const config = appState.settings.rubroConfig || {};
             // Use 'gastoAjustado' for gastos (includes coefficient effect)
             // Use 'ingresoAjustado' for ingresos (stores BASE values for display consistency)
             const calculatedSet = calculated[type === 'gastos' ? 'gastoAjustado' : 'ingresoAjustado'] || {};
             // Use 'totalGastoRubroMes' or 'totalIngresoRubroMes' for rubro totals (includes UF mult for ingresos)
             const totalRubroSet = calculated[type === 'gastos' ? 'totalGastoRubroMes' : 'totalIngresoRubroMes'] || {};
             const annualRubroTotals = calculated.annualTotals?.[type] || { __TOTAL__: 0 };
             // --- FIX: Use scenario-specific rubro order ---
             const orderedRubros = Array.isArray(rubroOrder[type]) ? rubroOrder[type] : [];

             // --- Dynamically add Month Headers if not present ---
             let theadRow = thead.querySelector('tr');
             if (!theadRow) {
                 theadRow = thead.insertRow();
                 theadRow.insertCell().textContent = "Rubro / Detalle";
             }
             const expectedHeaderCount = 2 + MONTHS.length; // Rubro/Detalle + 12 Months + Total Anual
             if (theadRow.cells.length < expectedHeaderCount) {
                 // Clear existing cells beyond the first one
                 while (theadRow.cells.length > 1) theadRow.deleteCell(-1);
                 // Add month and total headers
                 MONTHS.forEach(month => {
                     const th = document.createElement('th');
                     th.textContent = month;
                     th.classList.add('number-cell');
                     theadRow.appendChild(th);
                 });
                 const thTotal = document.createElement('th');
                 thTotal.textContent = "Total Anual";
                 thTotal.classList.add('number-cell');
                 theadRow.appendChild(thTotal);
             }
             // --- End Dynamic Header ---


             if (orderedRubros.length === 0) {
                 tbody.innerHTML = `<tr><td colspan="${expectedHeaderCount}" class="text-muted" style="text-align: center; padding: 20px;">No hay rubros definidos o cargados para ${type} en este escenario.</td></tr>`;
                 return;
             }

             // Build table body rows
             let hasVisibleDetails = false; // Track if any details are actually processed
             orderedRubros.forEach(rubro => {
                if (!appState.settings.rubros[type].includes(rubro)) return;
                 if (!data[type]?.[rubro]) return; // Skip if no data for this rubro in scenario

                 const rubroData = data[type][rubro];
                 // --- FIX: Use scenario-specific detail order ---
                 const orderedDetails = Array.isArray(rubroData.detailOrder) ? rubroData.detailOrder : [];
                 // Use global config for collapsed state, ensure it exists
                 const rubroUiConfig = config[rubro] || { detailsCollapsed: true };

                 // --- Rubro Total Row ---
                 const totalRow = tbody.insertRow();
                 totalRow.classList.add('rubro-total-row');
                 if (rubroUiConfig.detailsCollapsed) totalRow.classList.add('collapsed');
                 totalRow.dataset.rubro = rubro;
                 totalRow.dataset.type = type;

                 totalRow.insertCell().textContent = rubro;

                 const monthlyTotals = totalRubroSet[rubro] || Array(12).fill(0);
                 monthlyTotals.forEach(val => {
                     const cell = totalRow.insertCell();
                     cell.textContent = formatCurrency(val);
                     cell.classList.add('number-cell');
                 });

                 const cellAnnualTotal = totalRow.insertCell();
                 cellAnnualTotal.textContent = formatCurrency(annualRubroTotals[rubro] || 0);
                 cellAnnualTotal.classList.add('number-cell');
                 // --- End Rubro Total Row ---


                 // --- Detail Rows (if any) ---
                 orderedDetails.forEach(detail => {
                      // --- FIX: Ensure detail data exists in calculatedSet before rendering row ---
                      if (!calculatedSet[rubro] || calculatedSet[rubro][detail] === undefined) {
                         console.warn(`Detalle calculado no encontrado para ${type}/${rubro}/${detail}. Omitiendo fila.`);
                         return;
                      }
                      hasVisibleDetails = true; // Mark that we are adding at least one detail row

                     const detailRow = tbody.insertRow();
                     detailRow.classList.add('detail-row');
                     detailRow.dataset.rubro = rubro;
                     detailRow.dataset.type = type;
                     if (rubroUiConfig.detailsCollapsed) detailRow.classList.add('hidden');

                     const cellDetailName = detailRow.insertCell();
                     cellDetailName.textContent = detail;
                     cellDetailName.classList.add('text-muted');

                     // Monthly value cells for the detail
                     const detailValues = calculatedSet[rubro][detail]; // Use pre-validated calculated values
                     const detailStatuses = monthStatus[type]?.[rubro]?.[detail] || Array(12).fill('Estimado'); // Get status for coloring
                     let annualDetailTotal = 0;

                     detailValues.forEach((val, index) => {
                         const cell = detailRow.insertCell();
                         cell.textContent = formatCurrency(val);
                         cell.classList.add('number-cell');
                         // Apply specific background based on status ONLY for GASTOS details
                         if (type === 'gastos') {
                             cell.classList.add(detailStatuses[index] === 'REAL' ? 'real-month-cell' : 'estimated-month-cell');
                         }
                         annualDetailTotal += val;
                     });

                     // Annual total cell for the detail
                     const cellAnnualDetail = detailRow.insertCell();
                     cellAnnualDetail.textContent = formatCurrency(annualDetailTotal);
                     cellAnnualDetail.classList.add('number-cell');
                 });
                 // --- End Detail Rows ---
             });

             // --- FIX: Check if tbody is empty *after* loops ---
             if (tbody.rows.length === 0) {
                 tbody.innerHTML = `<tr><td colspan="${expectedHeaderCount}" class="text-muted" style="text-align: center; padding: 20px;">No hay rubros con datos para mostrar en el detalle de ${type}.</td></tr>`;
             } else {
                 // Build table footer row (Overall Total) only if there was content
                 const tfootRow = tfoot.insertRow();
                 tfootRow.insertCell().textContent = `TOTAL GENERAL ${type.toUpperCase()}`;

                 // Use totalGastoProyectadoMes or totalIngresoProyectadoMes for footer totals
                 const totalGeneralMensual = calculated[type === 'gastos' ? 'totalGastoProyectadoMes' : 'totalIngresoProyectadoMes'] || Array(12).fill(0);
                 totalGeneralMensual.forEach(val => {
                     const cell = tfootRow.insertCell();
                     cell.textContent = formatCurrency(val);
                     cell.classList.add('number-cell');
                 });

                 const cellTotalAnualGeneral = tfootRow.insertCell();
                 cellTotalAnualGeneral.textContent = formatCurrency(annualRubroTotals.__TOTAL__ || 0);
                 cellTotalAnualGeneral.classList.add('number-cell');
             }

             // Ensure listeners are present (safe to call multiple times if logic prevents duplicates)
             addCollapsibleListeners();
         }


        function updateCharts(scenarioData) {
             if (!scenarioData || !scenarioData.calculated || !scenarioData.calculated.annualTotals) {
                 console.warn("Datos insuficientes para actualizar gráficos.");
                 destroyChart('evolutivoCuotaChart'); displayChartNoData('evolutivoCuotaChart', true);
                 destroyChart('participacionGastosChart'); displayChartNoData('participacionGastosChart', true);
                 destroyChart('participacionIngresosChart'); displayChartNoData('participacionIngresosChart', true);
                 return;
             }

             const { calculated } = scenarioData;
             const labels = MONTHS;

             // Get current theme colors dynamically
             const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
             const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim();
             const secondaryColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color').trim();
             const cardBg = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim();
             const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();


             const chartColors = [ // Define a consistent palette
                primaryColor, accentColor, '#ffc107', '#6f42c1', '#fd7e14', '#17a2b8',
                '#dc3545', secondaryColor, '#20c997', '#0d6efd', '#198754', '#adb5bd' // More colors
             ];

             // --- Evolutivo Expensa Chart (Line) ---
             destroyChart('evolutivoCuotaChart');
             const ctxEvolutivo = document.getElementById('evolutivoCuotaChart')?.getContext('2d');
             const evolutivoHasData = (calculated.cuotaSobreGastosMes?.some(v => v !== 0) ?? false) || (calculated.cuotaRealBaseMes?.some(v => v !== 0) ?? false);
             displayChartNoData('evolutivoCuotaChart', !evolutivoHasData);

             if (ctxEvolutivo && evolutivoHasData) {
                window.evolutivoCuotaChart_instance = new Chart(ctxEvolutivo, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            { // Cuota s/Gtos (Calculated from expenses + reserve)
                                label: 'Cuota s/Gtos ($)',
                                data: calculated.cuotaSobreGastosMes,
                                borderColor: primaryColor,
                                backgroundColor: hexToRgba(primaryColor, 0.1),
                                tension: 0.2,
                                fill: true,
                                yAxisID: 'yCuota'
                            },
                            { // Expensa Real Base (From Ingresos base data) - MODIFICADO
                                label: 'Expensa Real Base ($)',
                                data: calculated.cuotaRealBaseMes,
                                borderColor: accentColor,
                                backgroundColor: hexToRgba(accentColor, 0.1),
                                tension: 0.2,
                                fill: true,
                                yAxisID: 'yCuota' // Same axis for direct comparison
                            },
                             { // Cuota IPC (Calculated based on Cuota s/Gtos and IPC ref)
                                label: 'Cuota IPC ($)',
                                data: calculated.cuotaIpcMes,
                                borderColor: secondaryColor, // Use secondary color
                                backgroundColor: hexToRgba(secondaryColor, 0.1),
                                tension: 0.2,
                                fill: false, // Don't fill this one to avoid clutter
                                borderDash: [5, 5], // Dashed line for reference value
                                yAxisID: 'yCuota' // Same axis
                            }
                        ]
                    },
                    options: commonChartOptions('yCuota')
                 });
             }


             // --- Participación Gastos Chart (Doughnut) ---
             destroyChart('participacionGastosChart');
             const ctxGastos = document.getElementById('participacionGastosChart')?.getContext('2d');
             // Filter labels based on *global* settings first, then check for > 0 value
             // Filter out zero values before mapping to labels/data
             const activeGastoRubros = (appState.settings.rubros?.gastos || []).filter(rubro =>
                  (calculated.annualTotals?.gastos?.[rubro] || 0) > 0
             );
             const gastoLabels = activeGastoRubros;
             const gastoData = activeGastoRubros.map(rubro => calculated.annualTotals.gastos[rubro]);

             displayChartNoData('participacionGastosChart', gastoData.length === 0);

             if (ctxGastos && gastoData.length > 0) {
                 window.participacionGastosChart_instance = new Chart(ctxGastos, {
                     type: 'doughnut', // Changed to doughnut
                     data: {
                         labels: gastoLabels,
                         datasets: [{
                             data: gastoData,
                             backgroundColor: generateColors(gastoData.length, chartColors, 0.8), // Use helper
                             borderColor: cardBg,
                             borderWidth: 2
                         }]
                     },
                     options: pieChartOptions('Gasto Anual') // Use pie chart options (works for doughnut)
                 });
             }


             // --- Participación Ingresos Chart (Doughnut) ---
             destroyChart('participacionIngresosChart');
             const ctxIngresos = document.getElementById('participacionIngresosChart')?.getContext('2d');
             // Filter labels based on *global* settings first, then check for > 0 value
              // Filter out zero values before mapping to labels/data
             const activeIngresoRubros = (appState.settings.rubros?.ingresos || []).filter(rubro =>
                  (calculated.annualTotals?.ingresos?.[rubro] || 0) > 0
              );
             const ingresoLabels = activeIngresoRubros;
             const ingresoData = activeIngresoRubros.map(rubro => calculated.annualTotals.ingresos[rubro]);

             displayChartNoData('participacionIngresosChart', ingresoData.length === 0);

             if (ctxIngresos && ingresoData.length > 0) {
                 window.participacionIngresosChart_instance = new Chart(ctxIngresos, {
                     type: 'doughnut', // Changed to doughnut
                     data: {
                         labels: ingresoLabels,
                         datasets: [{
                             data: ingresoData,
                             // Use different colors or reverse order from gastos chart
                             backgroundColor: generateColors(ingresoData.length, chartColors.slice().reverse(), 0.8), // Use helper
                             borderColor: cardBg,
                             borderWidth: 2
                         }]
                     },
                     options: pieChartOptions('Ingreso Anual') // Use pie chart options
                 });
             }
         }

         // Helper to generate enough colors for pie charts, repeating palette if necessary
         function generateColors(count, palette, alpha = 1) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                colors.push(hexToRgba(palette[i % palette.length], alpha));
            }
            return colors;
         }

        function commonChartOptions(mainYAxisID = 'y', additionalScales = {}) {
            const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
            const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
            return {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    [mainYAxisID]: {
                        beginAtZero: true,
                        ticks: { color: textColor, padding: 10, callback: value => formatCurrency(value).replace(",00", "") },
                        grid: { color: borderColor, drawTicks: false }, // Hide grid ticks
                        border: { color: borderColor } // Axis line color
                    },
                    x: {
                        ticks: { color: textColor, padding: 10 },
                        grid: { display: false }, // Hide vertical grid lines for cleaner look
                        border: { color: borderColor }
                    },
                    ...additionalScales // Include any additional axes passed in
                },
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: {
                            color: textColor,
                            boxWidth: 15,
                            padding: 20
                        }
                    },
                    tooltip: {
                        backgroundColor: hexToRgba(getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim(), 0.9),
                        titleColor: textColor,
                        bodyColor: textColor,
                        borderColor: getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim(),
                        borderWidth: 1,
                        padding: 10,
                        callbacks: {
                             title: tooltipItems => tooltipItems[0]?.label ? FULL_MONTHS[MONTHS.indexOf(tooltipItems[0].label)] : '',
                             label: context => {
                                 let label = context.dataset.label || '';
                                 if (label) label += ': ';
                                 if (context.parsed.y !== null) label += formatCurrency(context.parsed.y);
                                 return label;
                            }
                        }
                    }
                },
                interaction: { mode: 'index', intersect: false },
            };
         }

        function pieChartOptions(labelPrefix = '') {
             const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
             const cardBg = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim();
             const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
             const baseFontSize = parseFloat(getComputedStyle(document.body).fontSize); // Get actual computed font size
             const legendFontSize = Math.round(baseFontSize * 1.2); // Increase by 20%


             return {
                 responsive: true,
                 maintainAspectRatio: false,
                 plugins: {
                     legend: {
                         position: 'right',
                         labels: {
                            color: textColor,
                            boxWidth: 15,
                            padding: 15,
                            font: { // Apply font settings here
                                 size: legendFontSize, // Apply increased size
                            },
                             generateLabels: chart => {
                                const data = chart.data;
                                if (!data.labels.length || !data.datasets.length) return [];
                                const { labels } = data; const dataset = data.datasets[0];
                                const total = dataset.data.reduce((a, b) => a + b, 0);
                                return labels.map((label, i) => {
                                    const value = dataset.data[i];
                                     // --- MODIFICADO: Generate label text without dashed description ---
                                     const percentage = total > 0 ? ((value / total) * 100).toFixed(1) + '%' : '0.0%';
                                     const textLabel = `${label} (${percentage})`; // Format: "Label (Percentage)"

                                    return {
                                        text: textLabel, // Use the custom text label
                                        fillStyle: dataset.backgroundColor[i],
                                        strokeStyle: dataset.borderColor || dataset.backgroundColor[i],
                                        lineWidth: dataset.borderWidth || 0,
                                        // Note: Chart.js automatically handles hiding legend entries for hidden data
                                        hidden: chart.getDataVisibility(i) || value === 0, // Hide if data is zero as well
                                        index: i
                                    };
                                });
                             }
                         }
                     },
                     tooltip: {
                         backgroundColor: hexToRgba(cardBg, 0.9),
                         titleColor: textColor, bodyColor: textColor,
                         borderColor: borderColor, borderWidth: 1, padding: 10,
                         callbacks: {
                            label: context => {
                                 let label = context.label || ''; // context.label is the original label text
                                 if (context.parsed !== null) {
                                     const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                     const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) + '%' : '0.0%';
                                     // Show original label + formatted value and percentage in tooltip
                                     label = `${label}: ${formatCurrency(context.parsed)} (${percentage})`;
                                 }
                                 return label;
                            }
                         }
                     }
                 },
                 cutout: '30%' // Define cutout for Doughnut chart
             };
         }

        function updateReserveFundPanel(scenarioData) {
             if (!scenarioData || !scenarioData.reserveFund) {
                 console.warn("No reserve fund data to update panel.");
                 const panel = document.getElementById('reserve-fund-panel');
                 if (panel) panel.innerHTML = '<p class="text-muted">Datos del fondo de reserva no disponibles.</p>';
                 return;
            }
             const { reserveFund } = scenarioData;
             const panel = document.getElementById('reserve-fund-panel');
             if (!panel) return;
             panel.innerHTML = ''; // Clear previous inputs

             const typePercentRadio = document.getElementById('reserve-type-percent');
             const typeFixedRadio = document.getElementById('reserve-type-fixed');
             if (typePercentRadio) typePercentRadio.checked = reserveFund.type === 'percent';
             if (typeFixedRadio) typeFixedRadio.checked = reserveFund.type === 'fixed';

             const unitLabel = reserveFund.type === 'percent' ? '%' : '$';
             const currentStep = reserveFund.type === 'percent' ? '0.1' : '100';

             // Ensure values array has 12 elements
              const reserveValues = Array.isArray(reserveFund.values) && reserveFund.values.length === 12
                                     ? reserveFund.values
                                     : Array(12).fill(reserveFund.type === 'percent' ? 5 : 0);

             for (let i = 0; i < 12; i++) {
                 const monthDiv = document.createElement('div');
                 monthDiv.classList.add('month-config');

                 const label = document.createElement('label');
                 label.textContent = FULL_MONTHS[i];
                 label.htmlFor = `reserve-month-${i}`;

                 const input = document.createElement('input');
                 input.type = 'number';
                 input.id = `reserve-month-${i}`;
                 input.dataset.month = i;
                 input.value = reserveValues[i]; // Use validated array
                 input.step = currentStep;
                 input.min = '0';
                 input.style.textAlign = 'right';

                 const unitSpan = document.createElement('span');
                 unitSpan.textContent = unitLabel;
                 unitSpan.style.marginLeft = "5px";

                 monthDiv.appendChild(label);
                 monthDiv.appendChild(input);
                 monthDiv.appendChild(unitSpan);
                 panel.appendChild(monthDiv);
             }
        }

        function updateSettingsPanel() {
            const ufInput = document.getElementById('cantidad-unidades');
            if (ufInput) ufInput.value = appState.settings.cantidadUnidades;

            updateRubroList('gastos', 'gasto-rubro-list');
            updateRubroList('ingresos', 'ingreso-rubro-list');

            updateCoefficientTypeList();
            const currentEditing = appState.uiState.editingCoefficientType;
            if (currentEditing && appState.settings.coefficientTypes[currentEditing]) {
                renderCoefficientValuesEditor(currentEditing);
            } else {
                const editorDiv = document.getElementById('coefficient-values-editor');
                const nameSpan = document.getElementById('editing-coefficient-name');
                if (editorDiv) editorDiv.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente de la lista.</p>';
                if (nameSpan) nameSpan.textContent = 'Ninguno';
                if(appState.uiState.editingCoefficientType !== null && !appState.settings.coefficientTypes[appState.uiState.editingCoefficientType]) {
                   appState.uiState.editingCoefficientType = null; // Reset if type became invalid
                }
            }
            updateIPCManualInputs();
        }

        function updateRubroList(type, listId) {
             const list = document.getElementById(listId);
             if (!list) return;
             list.innerHTML = '';

             const rubros = appState.settings.rubros[type]?.slice().sort((a, b) => a.localeCompare(b)) || [];
             const config = appState.settings.rubroConfig || {};
             const coefTypes = appState.settings.coefficientTypes || {};

             if (rubros.length === 0) {
                 list.innerHTML = '<li class="text-muted" style="padding: 10px 8px;">No hay rubros definidos. Añade uno o carga un Excel.</li>';
                 return;
             }

             rubros.forEach(rubro => {
                 const li = document.createElement('li');
                 const span = document.createElement('span');
                 span.textContent = rubro;
                 li.appendChild(span);

                 if (type === 'gastos') {
                     const select = document.createElement('select');
                     select.title = `Asignar coeficiente de ajuste para ${rubro}`;
                     select.dataset.rubro = rubro;
                     select.onchange = handleCoefficientAssignmentChange;

                     // Sort coefficient types alphabetically by name for the dropdown
                     Object.keys(coefTypes)
                         .sort((a, b) => coefTypes[a].name.localeCompare(coefTypes[b].name))
                         .forEach(coefKey => {
                             const option = document.createElement('option');
                             option.value = coefKey;
                             option.textContent = coefTypes[coefKey].name;
                             // Ensure config[rubro] exists before accessing coefficientType
                             if (config[rubro]?.coefficientType === coefKey) {
                                 option.selected = true;
                             }
                             select.appendChild(option);
                         });
                     li.appendChild(select);
                 }

                 const deleteBtn = document.createElement('button');
                 deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                 deleteBtn.classList.add('button-danger', 'button-sm');
                 deleteBtn.title = `Eliminar rubro "${rubro}" (¡no se puede deshacer!)`;
                 deleteBtn.onclick = () => deleteRubro(type, rubro);
                 li.appendChild(deleteBtn);

                 list.appendChild(li);
             });
        }

        function updateCoefficientTypeList() {
             const list = document.getElementById('coefficient-type-list');
             if (!list) return;
             list.innerHTML = '';

             const types = appState.settings.coefficientTypes || {};
             const currentEditing = appState.uiState.editingCoefficientType;

             const sortedKeys = Object.keys(types)
                 .filter(key => key !== 'None') // Exclude the default 'None' type from the deletable list
                 .sort((a, b) => types[a].name.localeCompare(types[b].name));

             // Always add the 'None' type first, non-interactively
              const noneType = types['None'];
              if (noneType) {
                    const liNone = document.createElement('li');
                    const spanNone = document.createElement('span');
                    spanNone.textContent = noneType.name;
                    liNone.appendChild(spanNone);
                    const lockIcon = document.createElement('i');
                    lockIcon.className = 'fas fa-lock fa-fw';
                    lockIcon.title = 'Tipo por defecto (no eliminable ni editable).';
                    lockIcon.style.color = 'var(--secondary-color)';
                    lockIcon.style.marginLeft = 'auto';
                    liNone.appendChild(lockIcon);
                    liNone.style.opacity = '0.7'; // Visually distinct
                    list.appendChild(liNone);
              }


             if (sortedKeys.length === 0) {
                 list.innerHTML += '<li class="text-muted" style="padding: 10px 8px;">No hay tipos de coeficientes definidos (además de los por defecto).</li>';
                 return;
             }

             sortedKeys.forEach(key => {
                 const typeData = types[key];
                 const li = document.createElement('li');
                 li.style.cursor = 'pointer';
                 li.onclick = () => selectCoefficientTypeForEditing(key);

                 if (key === currentEditing) {
                     li.style.backgroundColor = 'var(--clickable-row-hover)';
                     li.style.fontWeight = 'bold';
                 }

                 const span = document.createElement('span');
                 span.textContent = typeData.name;
                 li.appendChild(span);

                 const actionsDiv = document.createElement('div');
                 actionsDiv.style.marginLeft = 'auto'; // Push actions right
                 actionsDiv.style.display = 'flex';
                 actionsDiv.style.alignItems = 'center';
                 actionsDiv.style.gap = '5px';

                 if (typeData.isDefault) { // Should only be true for built-ins if we add more
                     const lockIcon = document.createElement('i');
                     lockIcon.className = 'fas fa-lock fa-fw';
                     lockIcon.title = 'Tipo por defecto (no eliminable).';
                     lockIcon.style.color = 'var(--secondary-color)';
                     actionsDiv.appendChild(lockIcon);
                 } else {
                     const deleteBtn = document.createElement('button');
                     deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                     deleteBtn.classList.add('button-danger', 'button-sm');
                     deleteBtn.title = `Eliminar tipo "${typeData.name}"`;
                     deleteBtn.onclick = (e) => { e.stopPropagation(); deleteCoefficientType(key); };
                     actionsDiv.appendChild(deleteBtn);
                 }
                li.appendChild(actionsDiv);
                 list.appendChild(li);
             });
        }

        function selectCoefficientTypeForEditing(typeKey) {
             if (typeKey === 'None') {
                showSnackbar("El tipo 'Sin Coeficiente' no es editable.", false, 'info');
                return;
             }
             if (appState.settings.coefficientTypes[typeKey]) {
                 appState.uiState.editingCoefficientType = typeKey;
                 updateCoefficientTypeList(); // Re-render list to show selection highlight
                 renderCoefficientValuesEditor(typeKey);
             } else {
                 console.error(`Intentando editar tipo de coeficiente inexistente: ${typeKey}`);
             }
        }

        function renderCoefficientValuesEditor(typeKey) {
             const editorDiv = document.getElementById('coefficient-values-editor');
             const nameSpan = document.getElementById('editing-coefficient-name');
             if (!editorDiv || !nameSpan) return;
             editorDiv.innerHTML = '';

             if (!typeKey || !appState.settings.coefficientTypes[typeKey] || typeKey === 'None') {
                 editorDiv.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente de la lista (que no sea "Sin Coeficiente") para editar sus valores.</p>';
                 nameSpan.textContent = 'Ninguno';
                 appState.uiState.editingCoefficientType = null;
                 return;
             }

             const typeData = appState.settings.coefficientTypes[typeKey];
             nameSpan.textContent = typeData.name;

             const table = document.createElement('table');
             table.style.width = '100%';
             const thead = table.createTHead().insertRow();
             const tbody = table.createTBody().insertRow();

             // thead.insertCell().textContent = "Mes"; // Removed, using col headers
             tbody.insertCell().textContent = "Valor Coef.";
             tbody.cells[0].style.fontWeight = "600"; // Bold the row header

             // Ensure values array exists and has 12 elements
             const values = Array.isArray(typeData.values) && typeData.values.length === 12
                             ? typeData.values
                             : Array(12).fill(1);


             MONTHS.forEach((month, index) => {
                 const th = thead.insertCell();
                 th.textContent = month;
                 th.classList.add('number-cell');
                 th.style.textAlign = 'center';

                 const td = tbody.insertCell();
                 td.classList.add('input-cell');
                 td.style.textAlign = 'center';

                 const input = document.createElement('input');
                 input.type = 'number';
                 input.step = '0.01';
                 input.min = '0';
                 input.value = values[index]; // Use validated array
                 input.dataset.month = index;
                 input.dataset.typeKey = typeKey;
                 input.onchange = handleCoefficientValueChange;
                 input.style.maxWidth = '80px';
                 input.title = `Coeficiente para ${FULL_MONTHS[index]}`;

                 td.appendChild(input);
             });

             editorDiv.appendChild(table);
        }

        function updateIPCManualInputs() {
             const ipcDiv = document.getElementById('ipc-inputs');
             if (!ipcDiv) return;
             ipcDiv.innerHTML = '';

             // Ensure IPC array exists and has 12 elements
             const ipcValues = Array.isArray(appState.settings.ipcManual) && appState.settings.ipcManual.length === 12
                                ? appState.settings.ipcManual
                                : Array(12).fill(0);

             for (let i = 0; i < 12; i++) {
                 const monthDiv = document.createElement('div');
                 monthDiv.classList.add('form-group');

                 const label = document.createElement('label');
                 label.textContent = FULL_MONTHS[i];
                 label.htmlFor = `ipc-month-${i}`;

                 const input = document.createElement('input');
                 input.type = 'number';
                 input.id = `ipc-month-${i}`;
                 input.dataset.month = i;
                 input.value = ipcValues[i]; // Use validated array
                 input.step = '0.1';
                 input.min = '0'; // Allow zero IPC
                 input.placeholder = '%';
                 input.style.textAlign = 'right';
                 input.style.maxWidth = '120px';
                 input.title = `IPC de referencia para ${FULL_MONTHS[i]} (%)`;

                 input.onchange = (event) => {
                     const monthIndex = parseInt(event.target.dataset.month);
                     const value = parseFloat(event.target.value);
                      if (!isNaN(monthIndex) && monthIndex >= 0 && monthIndex < 12) { // Added NaN check
                          // Allow 0 and positive numbers
                          // Ensure the global array exists before writing
                          if (!Array.isArray(appState.settings.ipcManual) || appState.settings.ipcManual.length !== 12) {
                            appState.settings.ipcManual = Array(12).fill(0);
                          }
                          appState.settings.ipcManual[monthIndex] = (!isNaN(value) && value >= 0) ? value : 0;
                          // No saveState/recalc here; happens on main Save button
                      } else {
                          console.error("Invalid month index for IPC input.");
                      }
                 };

                 monthDiv.appendChild(label);
                 monthDiv.appendChild(input);
                 ipcDiv.appendChild(monthDiv);
             }
        }


        // --- Manejo de Eventos ---
        function addEventListeners() {
             document.getElementById('theme-toggle')?.addEventListener('click', toggleTheme);

             document.getElementById('scenario-selector')?.addEventListener('change', (event) => {
                 const newKey = event.target.value;
                 if (newKey && appState.scenarios[newKey]) {
                     appState.activeScenarioKey = newKey;
                     appState.currentYear = parseInt(newKey.split('_')[0]);
                     console.log(`Escenario cambiado a: ${newKey}`);
                     saveState();
                     updateUI(); // Refresh UI for the new scenario
                 } else if (newKey === "") {
                     console.warn("Selector de escenario cambió a valor vacío (puede ocurrir si no hay escenarios).");
                 } else {
                      console.error(`Intento de cambiar a escenario inválido o no encontrado: ${newKey}`);
                      event.target.value = appState.activeScenarioKey; // Revert selection
                 }
             });

             // Drag & Drop Upload Area
             const uploadArea = document.getElementById('file-upload-area');
             if (uploadArea) {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, preventDefaults, false);
                    document.body.addEventListener(eventName, preventDefaults, false); // Prevent browser opening file
                });
                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => uploadArea.style.backgroundColor = 'var(--clickable-row-hover)', false);
                });
                ['dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => uploadArea.style.backgroundColor = 'var(--bg-color)', false);
                });
                 uploadArea.addEventListener('drop', (event) => {
                    const files = event.dataTransfer.files;
                    if (files.length > 0) handleFileUpload(files);
                 }, false);
             }

             // Add collapsible listeners only once using delegation
             addCollapsibleListeners();
        }

        function preventDefaults (e) {
            e.preventDefault();
            e.stopPropagation();
        }

        let collapsibleListenersAdded = false; // Flag to prevent adding multiple times
        function addCollapsibleListeners() {
             // Use event delegation on a parent element that exists reliably (e.g., the main container)
             const container = document.querySelector('.container');
             // Only add the listener once
             if (!container || collapsibleListenersAdded) return;

             container.addEventListener('click', (event) => {
                 // Find the closest ancestor that is a collapsible total row
                 const targetRow = event.target.closest('tr.rubro-total-row');
                 // Check if the click happened inside one of the detail tables
                 if (targetRow && (targetRow.closest('#gastos-detail-table') || targetRow.closest('#ingresos-detail-table'))) {
                     const rubro = targetRow.dataset.rubro;
                     const type = targetRow.dataset.type;
                     if (rubro && type) {
                         toggleRubroDetails(type, rubro);
                     }
                 }
             });

             collapsibleListenersAdded = true; // Set flag
             console.log("Listeners delegados para filas colapsables añadidos al contenedor.");
        }


        function toggleRubroDetails(type, rubro) {
             // Toggle state in GLOBAL settings.rubroConfig
             // Ensure the config object exists for the rubro
             if (!appState.settings.rubroConfig[rubro]) {
                 appState.settings.rubroConfig[rubro] = { coefficientType: 'None', detailsCollapsed: false }; // Default expanded on first click if config didn't exist
             } else {
                 // Toggle the existing value, default to false (expanded) if property doesn't exist
                 appState.settings.rubroConfig[rubro].detailsCollapsed = !(appState.settings.rubroConfig[rubro].detailsCollapsed ?? false);
             }
             const isNowCollapsed = appState.settings.rubroConfig[rubro].detailsCollapsed;
             console.log(`Toggling ${type}/${rubro}. Now collapsed: ${isNowCollapsed}`);

             // Update UI for the current table
             const tableId = `${type}-detail-table`;
             const totalRow = document.querySelector(`#${tableId} tr.rubro-total-row[data-rubro="${rubro}"]`);
             const detailRows = document.querySelectorAll(`#${tableId} tr.detail-row[data-rubro="${rubro}"]`);

             if (totalRow) {
                totalRow.classList.toggle('collapsed', isNowCollapsed);
             } else {
                 console.warn(`Total row not found for ${type}/${rubro} during toggle.`);
             }

             detailRows.forEach(row => {
                 row.classList.toggle('hidden', isNowCollapsed);
             });

             saveState(); // Save the changed collapsed preference
        }

         // New function to toggle all rubro details for a given type
         function toggleAllRubroDetails(type, collapse) {
             console.log(`${collapse ? 'Colapsando' : 'Expandiendo'} todos los rubros de ${type}...`);
             const scenarioData = getCurrentScenarioData();
             if (!scenarioData) { showSnackbar("No hay escenario activo.", true, 'error'); return; }

             const rubrosToToggle = appState.settings.rubros[type] || [];
             let changesMade = false;

             rubrosToToggle.forEach(rubro => {
                 // Ensure config object exists before modifying
                 if (!appState.settings.rubroConfig[rubro]) {
                     appState.settings.rubroConfig[rubro] = { coefficientType: 'None', detailsCollapsed: true }; // Default collapsed
                 }
                 if ((appState.settings.rubroConfig[rubro].detailsCollapsed ?? true) !== collapse) { // Only change if different
                      appState.settings.rubroConfig[rubro].detailsCollapsed = collapse;
                      changesMade = true;
                 }
             });

             if (changesMade) {
                 saveState(); // Save the changed collapsed preferences
                 // Update UI for the affected table directly
                 const tableId = `${type}-detail-table`;
                 const totalRows = document.querySelectorAll(`#${tableId} tr.rubro-total-row`);
                 const detailRows = document.querySelectorAll(`#${tableId} tr.detail-row`);

                 totalRows.forEach(row => {
                     const rubro = row.dataset.rubro;
                      const isCollapsed = appState.settings.rubroConfig[rubro]?.detailsCollapsed ?? true;
                      row.classList.toggle('collapsed', isCollapsed);
                 });

                 detailRows.forEach(row => {
                     const rubro = row.dataset.rubro;
                      const isCollapsed = appState.settings.rubroConfig[rubro]?.detailsCollapsed ?? true;
                      row.classList.toggle('hidden', isCollapsed);
                 });

                 showSnackbar(`${collapse ? 'Todos los detalles colapsados.' : 'Todos los detalles expandidos.'}`, false, 'info', 3000);
             } else {
                  showSnackbar(`Los detalles ya están ${collapse ? 'colapsados' : 'expandidos'}.`, false, 'info', 3000);
             }
         }


         function handleCoefficientAssignmentChange(event) {
             const select = event.target;
             const rubro = select.dataset.rubro;
             const newCoefType = select.value;

             if (rubro && newCoefType !== undefined) {
                 // Ensure config object exists before assigning
                 if (!appState.settings.rubroConfig[rubro]) {
                     appState.settings.rubroConfig[rubro] = { detailsCollapsed: true }; // Keep default collapsed state
                 }
                 appState.settings.rubroConfig[rubro].coefficientType = newCoefType;
                 console.log(`Coeficiente para "${rubro}" asignado a "${newCoefType}".`);
                 saveState(); // Save assignment immediately
                  showSnackbar(`Coeficiente para "${rubro}" asignado. Guardar Configuración recalculará los estimados.`, false, 'info', 3000);
             } else {
                  console.error("Error al asignar coeficiente: falta rubro o valor.", {rubro, newCoefType});
             }
         }

         function handleCoefficientValueChange(event) {
             const input = event.target;
             const monthIndex = parseInt(input.dataset.month);
             const typeKey = input.dataset.typeKey;
             const newValue = parseFloat(input.value);

             if (typeKey && appState.settings.coefficientTypes[typeKey] && !isNaN(monthIndex) && monthIndex >= 0 && monthIndex < 12) {
                 // Ensure values array exists before modifying
                 if (!Array.isArray(appState.settings.coefficientTypes[typeKey].values) || appState.settings.coefficientTypes[typeKey].values.length !== 12) {
                    appState.settings.coefficientTypes[typeKey].values = Array(12).fill(1);
                 }

                 if (!isNaN(newValue) && newValue >= 0) {
                     appState.settings.coefficientTypes[typeKey].values[monthIndex] = newValue;
                     console.log(`Valor mes ${MONTHS[monthIndex]} para "${typeKey}" actualizado a ${newValue}.`);
                     saveState(); // Save immediately
                     showSnackbar(`Valor para ${FULL_MONTHS[monthIndex]} de "${appState.settings.coefficientTypes[typeKey].name}" actualizado. Guardar Configuración recalculará.`, false, 'info', 3000);
                 } else {
                     input.value = appState.settings.coefficientTypes[typeKey].values[monthIndex]; // Revert invalid input
                     showSnackbar(`Valor inválido para ${FULL_MONTHS[monthIndex]}. Debe ser >= 0.`, true, 'error', 4000);
                 }
             } else {
                 console.error("Error al manejar cambio de valor de coeficiente.", { typeKey, monthIndex, newValue });
             }
         }


        // --- Funciones de Acción (Botones, etc.) ---
        function createNewExercise(year = null) {
             const inputYearElement = document.getElementById('exercise-year');
             const inputYear = year || parseInt(inputYearElement?.value);

             if (!inputYear || isNaN(inputYear) || inputYear < 2000 || inputYear > 2099) {
                 showSnackbar("Año inválido. Introduce un año entre 2000 y 2099.", true, 'error');
                 if(inputYearElement) inputYearElement.focus();
                 return;
             }

             console.log(`Creando o seleccionando Ejercicio ${inputYear}`);
             // Initialize the 'Base' scenario if it doesn't exist
             initScenarioData(inputYear, 'Base');

             // Set the application's current year and active scenario
             appState.currentYear = inputYear;
             appState.activeScenarioKey = `${inputYear}_Base`;

             saveState();

             // Update UI elements
             updateScenarioSelector();
             const selector = document.getElementById('scenario-selector');
             if (selector) selector.value = appState.activeScenarioKey;

             updateUI();
             showSnackbar(`Ejercicio ${inputYear} (Escenario Base) seleccionado/creado.`, false, 'success');
        }

        function createScenario(){
             const year = appState.currentYear;
             const existingScenariosCount = Object.keys(appState.scenarios).filter(k => k.startsWith(year + '_')).length;
             const defaultName = `Escenario ${existingScenariosCount + 1}`;

             let nombre = prompt(`Nombre para el nuevo escenario del año ${year}:`, defaultName);
             if (nombre === null) { showSnackbar("Creación cancelada.", false, 'info'); return; } // Handle Cancel
             nombre = nombre.trim();
             if (!nombre) { showSnackbar("El nombre no puede estar vacío.", true, 'error'); return; }

             const key = `${year}_${nombre.replace(/\s+/g,'_')}`;
             if (appState.scenarios[key]) {
                 showSnackbar(`El escenario "${nombre}" ya existe para ${year}. Elige otro nombre.`, true, 'warning');
                 return;
             }

             // Create a fresh, empty scenario
             console.log("Creando un escenario nuevo vacío.");
             initScenarioData(year, nombre); // Initialize with the new name

             appState.activeScenarioKey = key;
             saveState();

             updateScenarioSelector();
             const selector = document.getElementById('scenario-selector');
             if(selector) selector.value = key;
             updateUI();
             showSnackbar(`Escenario "${nombre}" creado y seleccionado.`, false, 'success');
        }

        function cloneScenario() {
             const currentScenario = getCurrentScenarioData();
             if (!currentScenario) {
                 showSnackbar("No hay un escenario activo para clonar.", true, 'error');
                 return;
             }

             const currentName = currentScenario.scenarioName;
             const defaultNewName = `${currentName} - Copia`;
             const newScenarioName = prompt(`Nombre para la copia del escenario "${currentName}":`, defaultNewName);

             if (newScenarioName === null) { showSnackbar("Clonación cancelada.", false, 'info'); return; }
             const trimmedNewName = newScenarioName.trim();
             if (!trimmedNewName) { showSnackbar("El nombre no puede estar vacío.", true, 'error'); return; }

             const newKey = `${currentScenario.year}_${trimmedNewName.replace(/\s+/g, '_')}`;
             if (appState.scenarios[newKey]) {
                 showSnackbar(`Ya existe un escenario "${trimmedNewName}" para ${currentScenario.year}.`, true, 'warning');
                 return;
             }

             // Deep clone using JSON methods for safety
             appState.scenarios[newKey] = JSON.parse(JSON.stringify(currentScenario));
             // Update specific properties for the new scenario
             appState.scenarios[newKey].scenarioName = trimmedNewName;
             appState.scenarios[newKey].year = currentScenario.year; // Ensure year is correct

             appState.activeScenarioKey = newKey;
             console.log(`Escenario clonado: ${appState.activeScenarioKey} -> ${newKey}`);
             saveState();

             updateScenarioSelector();
             const selector = document.getElementById('scenario-selector');
             if(selector) selector.value = newKey;
             updateUI();
             showSnackbar(`Escenario "${trimmedNewName}" clonado y seleccionado.`, false, 'success');
        }

        function deleteScenario() {
             const keyToDelete = appState.activeScenarioKey;
             const scenarioToDelete = appState.scenarios[keyToDelete];

             if (!scenarioToDelete) {
                 showSnackbar("No hay escenario activo para eliminar.", true, 'error');
                 return;
             }

             const scenariosForYear = Object.keys(appState.scenarios).filter(k => k.startsWith(`${scenarioToDelete.year}_`));
             if (scenariosForYear.length <= 1) {
                 showSnackbar(`No se puede eliminar el último escenario ("${scenarioToDelete.scenarioName}") para ${scenarioToDelete.year}.`, true, 'warning');
                 return;
             }

             if (confirm(`¿Seguro que quieres eliminar el escenario "${scenarioToDelete.scenarioName}"?\n\n¡Esta acción no se puede deshacer!`)) {
                 const year = scenarioToDelete.year;
                 const deletedName = scenarioToDelete.scenarioName;

                 delete appState.scenarios[keyToDelete];
                 console.log(`Escenario eliminado: ${keyToDelete}`);

                 // Determine next active scenario
                 const baseKey = `${year}_Base`;
                 const remainingKeysForYear = Object.keys(appState.scenarios).filter(k => k.startsWith(`${year}_`));
                 const firstGlobalKey = Object.keys(appState.scenarios)[0];

                 let nextActiveKey = null;
                 if (appState.scenarios[baseKey]) { nextActiveKey = baseKey; }
                 else if (remainingKeysForYear.length > 0) { nextActiveKey = remainingKeysForYear.sort((a,b) => appState.scenarios[a].scenarioName.localeCompare(appState.scenarios[b].scenarioName))[0]; }
                 else if (firstGlobalKey) { nextActiveKey = firstGlobalKey; }

                 appState.activeScenarioKey = nextActiveKey;

                 if (!appState.activeScenarioKey) {
                     console.log("No quedan escenarios, creando uno base para el año actual.");
                     appState.currentYear = new Date().getFullYear();
                     initScenarioData(appState.currentYear);
                     appState.activeScenarioKey = `${appState.currentYear}_Base`;
                 } else {
                     appState.currentYear = parseInt(appState.activeScenarioKey.split('_')[0]);
                 }

                 saveState();

                 updateScenarioSelector();
                 const selector = document.getElementById('scenario-selector');
                 if (selector && appState.activeScenarioKey) selector.value = appState.activeScenarioKey;
                 updateUI();
                 showSnackbar(`Escenario "${deletedName}" eliminado.`, false, 'success');
             } else {
                 showSnackbar("Eliminación cancelada.", false, 'info');
             }
        }


        function updateScenarioSelector() {
            const selector = document.getElementById('scenario-selector');
            if (!selector) return;
            const currentActiveKey = appState.activeScenarioKey; // Store current key before clearing
            selector.innerHTML = '';

            const currentYearScenariosKeys = Object.keys(appState.scenarios)
                .filter(key => key.startsWith(`${appState.currentYear}_`))
                .sort((a, b) => appState.scenarios[a].scenarioName.localeCompare(appState.scenarios[b].scenarioName));

            if (currentYearScenariosKeys.length === 0) {
                const opt = document.createElement('option');
                opt.value = "";
                opt.textContent = `(No hay escenarios para ${appState.currentYear})`;
                opt.disabled = true;
                selector.appendChild(opt);
                selector.disabled = true;
                // If the active key was from this year, it's now invalid. validateAndSetActiveScenario should handle this on next load/update.
                return;
            }

            selector.disabled = false;
            let activeKeyFoundInList = false;
            currentYearScenariosKeys.forEach(key => {
                const scenario = appState.scenarios[key];
                if (scenario) {
                    const opt = document.createElement('option');
                    opt.value = key;
                    opt.textContent = scenario.scenarioName;
                    if (key === currentActiveKey) {
                        opt.selected = true;
                        activeKeyFoundInList = true;
                    }
                    selector.appendChild(opt);
                }
            });

            // If the previously active key wasn't found in the current year's list,
            // default to the first one in the list, update state, and save.
            if (!activeKeyFoundInList && currentYearScenariosKeys.length > 0) {
                 const newActiveKey = currentYearScenariosKeys[0];
                 console.warn(`Active scenario key "${currentActiveKey}" not valid for year ${appState.currentYear}. Defaulting to "${newActiveKey}".`);
                 appState.activeScenarioKey = newActiveKey;
                 selector.value = newActiveKey; // Update selector display
                 saveState(); // Save the corrected active key
            } else if (activeKeyFoundInList) {
                 selector.value = currentActiveKey; // Ensure visual selection matches state
            }
         }

        // --- Carga de Archivo Excel ---
        function handleFileUpload(files) {
             if (!files || files.length === 0) { showSnackbar("No se seleccionó archivo.", true, 'warning'); return; }
             const file = files[0];
             const validTypes = ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/vnd.ms-excel'];
             if (!validTypes.includes(file.type)) { showSnackbar("Archivo inválido. Sube .xlsx o .xls.", true, 'error'); return; }

             const reader = new FileReader();
             const feedbackDiv = document.getElementById('file-upload-feedback');
             feedbackDiv.textContent = `Procesando: ${file.name}...`;
             feedbackDiv.style.color = 'var(--info-color)';

             reader.onload = (e) => {
                 try {
                     const data = new Uint8Array(e.target.result);
                     const workbook = XLSX.read(data, { type: 'array', cellDates: false, cellNF: false });

                     const gastosSheet = workbook.Sheets[GASTOS_SHEET_NAME];
                     const ingresosSheet = workbook.Sheets[INGRESOS_SHEET_NAME];

                     if (!gastosSheet) throw new Error(`Hoja "${GASTOS_SHEET_NAME}" no encontrada.`);
                     if (!ingresosSheet) throw new Error(`Hoja "${INGRESOS_SHEET_NAME}" no encontrada.`);

                     const scenarioData = getCurrentScenarioData();
                     if (!scenarioData) throw new Error("No hay escenario activo para cargar datos.");

                     // --- Reset specific data parts for the current scenario before processing ---
                     scenarioData.data = { gastos: {}, ingresos: {} };
                     scenarioData.monthStatus = { gastos: {}, ingresos: {} };
                     scenarioData.rubroOrder = { gastos: [], ingresos: [] }; // Will be rebuilt from Excel
                     // Calculated data is reset inside calculateAll which is called later

                     let newRubrosFound = { gastos: [], ingresos: [] };

                     // Process sheets - This populates scenarioData.data, .monthStatus, .rubroOrder and tracks new rubros
                     processSheetData(gastosSheet, scenarioData, 'gastos', newRubrosFound);
                     processSheetData(ingresosSheet, scenarioData, 'ingresos', newRubrosFound);

                     let addedMessage = ""; let settingsChanged = false;

                     // Add new rubros found to global settings & initialize config
                     ['gastos', 'ingresos'].forEach(type => {
                         newRubrosFound[type].forEach(rubro => {
                             if (!appState.settings.rubros[type].includes(rubro)) {
                                 appState.settings.rubros[type].push(rubro);
                                 settingsChanged = true;
                                 if (type === 'gastos' && !appState.settings.rubroConfig[rubro]) {
                                     // --- FIX: Set default collapsed state for new rubros ---
                                     appState.settings.rubroConfig[rubro] = { coefficientType: 'None', detailsCollapsed: true };
                                 }
                                 addedMessage += `\n- Nuevo rubro (${type}): ${rubro} (añadido a Configuración)`;
                             }
                         });
                     });

                    // --- FIX: Ensure data structures for all rubros (including new ones) are initialized IN THE CURRENT SCENARIO
                    // and ALSO in ALL other scenarios if global settings changed ---
                    initializeScenarioDataForRubros(scenarioData); // Ensure current one is fully initialized with potentially new details etc.
                     if(settingsChanged) {
                        // Re-initialize all scenarios to include the new global rubro definitions
                        Object.values(appState.scenarios).forEach(scenario => {
                            initializeScenarioDataForRubros(scenario);
                        });
                     }

                     feedbackDiv.textContent = `Archivo "${file.name}" procesado.${addedMessage}`;
                     feedbackDiv.style.color = 'var(--success-color)';
                     document.getElementById('excel-file-input').value = ''; // Reset file input

                     if (settingsChanged) {
                         saveState(); // Save updated global settings
                         updateSettingsPanel(); // Update the settings UI to show new rubros/configs
                     }

                     // Recalculate everything after processing the data
                     calculateAll(scenarioData); // This also saves state and updates UI
                     showSnackbar("Datos del Excel cargados y procesados.", false, 'success');

                 } catch (error) {
                     console.error("Error procesando archivo Excel:", error);
                     feedbackDiv.textContent = `Error: ${error.message}`;
                     feedbackDiv.style.color = 'var(--danger-color)';
                     showSnackbar(`Error procesando Excel: ${error.message}`, true, 'error', 6000);
                 }
             };
             reader.onerror = (e) => {
                 console.error("Error leyendo archivo:", e);
                 feedbackDiv.textContent = "Error al leer el archivo.";
                 feedbackDiv.style.color = 'var(--danger-color)';
                 showSnackbar("Error al intentar leer el archivo.", true, 'error');
             };
             reader.readAsArrayBuffer(file);
        }

        function processSheetData(sheet, scenarioData, type, newRubrosTracker) {
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: null });
            if (jsonData.length < 2) { console.warn(`Hoja "${type}" vacía o sin datos.`); return; }

            const header = jsonData[0].map(h => String(h ?? '').trim().toLowerCase());
            const rubroColIndex = header.indexOf('rubro');
            const detailColIndex = header.indexOf('detalle');
            if (rubroColIndex === -1) throw new Error(`Columna "Rubro" no encontrada en hoja "${type}".`);
            if (detailColIndex === -1) throw new Error(`Columna "Detalle" no encontrada en hoja "${type}".`);

            const monthColIndices = MONTHS.map(mShort => {
                const mShortLower = mShort.toLowerCase();
                // Allow full month name match as well (e.g., 'enero', 'febrero')
                const fullMonthLower = FULL_MONTHS[MONTHS.indexOf(mShort)].toLowerCase();
                 // Check for short name first, then full name, return the first match
                 const shortIndex = header.findIndex(h => h && h.startsWith(mShortLower) && h.length <= mShortLower.length + 1); // Allow slight variations like "Ene."
                 if (shortIndex !== -1) return shortIndex;
                 const fullIndex = header.findIndex(h => h === fullMonthLower);
                 return fullIndex;
            });

            const missingMonths = MONTHS.filter((_, i) => monthColIndices[i] === -1);
            if (missingMonths.length > 0) console.warn(`Meses no encontrados en hoja "${type}": [${missingMonths.join(', ')}]. Se usarán ceros.`);

             // Ensure scenario-level structures exist (these were reset just before calling this)
             scenarioData.rubroOrder[type] = scenarioData.rubroOrder[type] ?? [];
             scenarioData.data[type] = scenarioData.data[type] ?? {};
             scenarioData.monthStatus[type] = scenarioData.monthStatus[type] ?? {};


            // --- Row Processing ---
            for (let i = 1; i < jsonData.length; i++) {
                const row = jsonData[i];
                if (!row || !Array.isArray(row) || row.every(cell => cell === null || String(cell).trim() === '')) continue; // Skip empty/null rows

                const rubro = String(row[rubroColIndex] ?? '').trim();
                const detail = String(row[detailColIndex] ?? '').trim();
                if (!rubro || !detail) { console.warn(`Fila ${i+1} (${type}) omitida (falta Rubro o Detalle).`); continue; }

                // Add rubro to SCENARIO order if new
                if (!scenarioData.rubroOrder[type].includes(rubro)) {
                    scenarioData.rubroOrder[type].push(rubro);
                }
                // Initialize structures for the rubro in SCENARIO if first time
                if (!scenarioData.data[type][rubro]) {
                    scenarioData.data[type][rubro] = { detailOrder: [], detailsData: {} };
                }
                 // Initialize monthStatus object for the rubro if needed
                 if (!scenarioData.monthStatus[type][rubro]) {
                    scenarioData.monthStatus[type][rubro] = {};
                 }
                 // Add detail to SCENARIO order if new for this rubro
                 if (!scenarioData.data[type][rubro].detailOrder.includes(detail)) {
                    scenarioData.data[type][rubro].detailOrder.push(detail);
                 }
                // Initialize arrays for the specific detail in SCENARIO
                if (!scenarioData.data[type][rubro].detailsData[detail]) {
                    scenarioData.data[type][rubro].detailsData[detail] = Array(12).fill(0);
                }
                 // Initialize status array for the detail if needed (only for gastos)
                 if (type === 'gastos' && !scenarioData.monthStatus[type][rubro][detail]) {
                     scenarioData.monthStatus[type][rubro][detail] = Array(12).fill('Estimado');
                 }


                // Track new rubros for GLOBAL update later
                 if (!appState.settings.rubros[type].includes(rubro) && !newRubrosTracker[type].includes(rubro)) {
                    newRubrosTracker[type].push(rubro);
                 }

                // --- Process Monthly Values ---
                for (let m = 0; m < 12; m++) {
                    const colIndex = monthColIndices[m];
                    let value = 0;
                    let status = 'Estimado'; // Default status

                    if (colIndex !== -1 && row[colIndex] !== null) {
                        const cellValue = row[colIndex];
                        if (typeof cellValue === 'number' && !isNaN(cellValue)) {
                            value = cellValue;
                             if (type === 'gastos') status = 'REAL'; // Mark GASTOS with numbers as REAL
                        } else if (typeof cellValue === 'string' && cellValue.trim() !== '') {
                             // Try parsing string as number (handle currency symbols, thousands separators etc.)
                             const cleanedValue = cellValue.replace(/[$.]/g, '').replace(',', '.'); // Remove $, . (thousands), replace , (decimal) with .
                             const parsedNum = parseFloat(cleanedValue);
                             if (!isNaN(parsedNum)) {
                                 value = parsedNum;
                                 if (type === 'gastos') status = 'REAL';
                             } else {
                                  // console.warn(`Valor no numérico "${cellValue}" en ${type}/${rubro}/${detail} - ${MONTHS[m]}. Usando 0.`);
                             }
                         }
                    }
                    // Assign value to SCENARIO data
                    scenarioData.data[type][rubro].detailsData[detail][m] = value;
                     // Assign status ONLY for gastos based on Excel content
                     if (type === 'gastos') {
                         // Ensure the status array exists before assigning
                         if (!scenarioData.monthStatus[type][rubro][detail]) {
                             scenarioData.monthStatus[type][rubro][detail] = Array(12).fill('Estimado');
                         }
                         scenarioData.monthStatus[type][rubro][detail][m] = status;
                     }
                }
            }
             console.log(`Hoja "${type}" procesada. Rubros en orden: [${scenarioData.rubroOrder[type].join(', ')}]`);
        }


        function loadSampleData() {
            console.log("Cargando datos de ejemplo...");
            const scenarioData = getCurrentScenarioData();
            if (!scenarioData) { showSnackbar("No hay escenario activo. Crea o selecciona un año.", true, 'error'); return; }

            // Reset current scenario data
            scenarioData.data = { gastos: {}, ingresos: {} };
            scenarioData.monthStatus = { gastos: {}, ingresos: {} };
            scenarioData.rubroOrder = { gastos: [], ingresos: [] };
            // Calculated reset happens in calculateAll

            const sampleGastosRubros = ["Seguridad", "Jardinería", "Mantenimiento", "Administración", "Servicios Públicos"];
            // --- MODIFICADO: Usar constante ---
            const sampleIngresosRubros = [CUOTA_RUBRO_NAME, "Alquiler SUM", "Ingresos Extra", EXTRA_CUOTA_RUBRO_NAME];
            let settingsChanged = false;

            // Ensure sample rubros exist globally and locally
            sampleGastosRubros.forEach(r => {
                if (!appState.settings.rubros.gastos.includes(r)) { appState.settings.rubros.gastos.push(r); settingsChanged = true; }
                if (!appState.settings.rubroConfig[r]) appState.settings.rubroConfig[r] = { coefficientType: 'None', detailsCollapsed: true };
                if (!scenarioData.rubroOrder.gastos.includes(r)) scenarioData.rubroOrder.gastos.push(r);
            });
            sampleIngresosRubros.forEach(r => {
                 if (!appState.settings.rubros.ingresos.includes(r)) { appState.settings.rubros.ingresos.push(r); settingsChanged = true; }
                 if (!scenarioData.rubroOrder.ingresos.includes(r)) scenarioData.rubroOrder.ingresos.push(r);
            });

             // Initialize structures in the current scenario for these rubros AND ensure others are initialized
             initializeScenarioDataForRubros(scenarioData);
             if (settingsChanged) {
                 // Re-initialize all scenarios if global settings changed
                Object.values(appState.scenarios).forEach(scen => initializeScenarioDataForRubros(scen));
                saveState(); // Save settings early if they changed
             }

            // --- Gastos Data & Status ---
            scenarioData.data.gastos["Seguridad"].detailOrder = ["Vigilador Dia", "Vigilador Noche", "Monitoreo Cámaras"];
            scenarioData.data.gastos["Seguridad"].detailsData = {
                "Vigilador Dia":   [50000, 50500, 51000, 51500, 52000, 52500, 53000, 53500, 54000, 54500, 55000, 55500],
                "Vigilador Noche": [55000, 55500, 56000, 56500, 57000, 57500, 58000, 58500, 59000, 59500, 60000, 60500],
                "Monitoreo Cámaras": Array(12).fill(10000)
            };
            scenarioData.monthStatus.gastos["Seguridad"] = {
                "Vigilador Dia":   ['REAL','REAL','REAL','REAL',   'Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'],
                "Vigilador Noche": ['REAL','REAL','REAL','REAL',   'Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'],
                "Monitoreo Cámaras": ['REAL','REAL','REAL','REAL', 'Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'] // Example: Real first 4 months
            };
             scenarioData.data.gastos["Jardinería"].detailOrder = ["Mantenimiento Parque", "Reposición Plantas"];
             scenarioData.data.gastos["Jardinería"].detailsData = {
                 "Mantenimiento Parque": [30000, 30000, 30500, 30500, 31000, 31000, 31500, 31500, 32000, 32000, 32500, 32500],
                 "Reposición Plantas":   [0,     0,     5000,  0,     0,     0,     0,     0,     6000,  0,     0,     0]
             };
             scenarioData.monthStatus.gastos["Jardinería"] = {
                 "Mantenimiento Parque": ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'],
                 "Reposición Plantas":   ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','REAL','Estimado','Estimado','Estimado']
             };
            scenarioData.data.gastos["Mantenimiento"].detailOrder = ["Bomba Agua Pozo", "Limpieza Tanques", "Pintura General"];
            scenarioData.data.gastos["Mantenimiento"].detailsData = {
                "Bomba Agua Pozo":  [0,     12000, 0,     0,     0,     0,     0,     13500, 0,     0,     0,     0],
                "Limpieza Tanques": [0,     0,     0,     15000, 0,     0,     0,     0,     0,     15000, 0,     0],
                "Pintura General":  [0,     0,     0,     0,     0,     0,     0,     0,     45000, 0,     0,     0]
            };
             scenarioData.monthStatus.gastos["Mantenimiento"] = {
                "Bomba Agua Pozo":  ['REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','REAL','Estimado','Estimado','Estimado','Estimado'],
                "Limpieza Tanques": ['Estimado','Estimado','Estimado','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','REAL','Estimado','Estimado'],
                "Pintura General":  ['Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','REAL','Estimado','Estimado','Estimado']
             };
             scenarioData.data.gastos["Administración"].detailOrder = ["Honorarios Admin", "Gastos Bancarios", "Papelería"];
            scenarioData.data.gastos["Administración"].detailsData = {
                "Honorarios Admin": Array(12).fill(40000),
                "Gastos Bancarios": [500,   500,   550,   550,   600,   600,   600,   650,   650,   700,   700,   700],
                "Papelería":        [1000,  0,     0,     1200,  0,     0,     1500,  0,     0,     1000,  0,     0]
            };
             scenarioData.monthStatus.gastos["Administración"] = {
                 "Honorarios Admin": ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'], // Make first 4 real
                 "Gastos Bancarios": ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'],
                 "Papelería":        ['REAL','REAL','REAL','REAL','Estimado','Estimado','REAL','Estimado','Estimado','REAL','Estimado','Estimado']
             };
            scenarioData.data.gastos["Servicios Públicos"].detailOrder = ["Luz Espacios Comunes", "Agua Riego"];
            scenarioData.data.gastos["Servicios Públicos"].detailsData = {
                "Luz Espacios Comunes": [18000, 19500, 21000, 20500, 19000, 18500, 19000, 20000, 22000, 23000, 21500, 20000],
                "Agua Riego":           [5000,  6000,  7500,  8000,  7000,  6500,  6000,  7000,  8500,  9000,  8000,  6000]
            };
             scenarioData.monthStatus.gastos["Servicios Públicos"] = {
                 "Luz Espacios Comunes": ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'],
                 "Agua Riego":           ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado']
             };

            // --- Ingresos Data --- (No monthStatus here)
             // --- MODIFICADO: Usar constante en nombre de rubro ---
            scenarioData.data.ingresos[CUOTA_RUBRO_NAME].detailOrder = ["Valor Base UF"];
            scenarioData.data.ingresos[CUOTA_RUBRO_NAME].detailsData = { "Valor Base UF": [1500, 1500, 1550, 1550, 1600, 1600, 1650, 1650, 1700, 1700, 1750, 1750] }; // Varied example
            scenarioData.data.ingresos["Alquiler SUM"].detailOrder = ["Eventos Fin de Semana", "Eventos Semana"];
            scenarioData.data.ingresos["Alquiler SUM"].detailsData = {
                "Eventos Fin de Semana": [5000, 6000, 4000, 7000, 8000, 9000, 5000, 6000, 7500, 8500, 9500, 10000],
                "Eventos Semana":        [1000, 1500, 1000, 2000, 2500, 2000, 1500, 1800, 2200, 2500, 2000, 1500]
            };
            scenarioData.data.ingresos["Ingresos Extra"].detailOrder = ["Multas Reglamento", "Donaciones"];
            scenarioData.data.ingresos["Ingresos Extra"].detailsData = {
                "Multas Reglamento": [0,    1000, 500,  0,    1500, 0,    0,    500,  0,    1000, 0,    0],
                "Donaciones":        [0,    0,    0,    0,    5000, 0,    0,    0,    0,    0,    10000,0]
            };
            scenarioData.data.ingresos[EXTRA_CUOTA_RUBRO_NAME].detailOrder = ["Cuota Obra Pileta"];
            scenarioData.data.ingresos[EXTRA_CUOTA_RUBRO_NAME].detailsData = { "Cuota Obra Pileta": [0, 0, 0, 500, 500, 500, 500, 500, 0, 0, 0, 0] };


             // Update Settings panel if new rubros were added globally
            if (settingsChanged) {
                updateSettingsPanel();
            }

            const feedbackDiv = document.getElementById('file-upload-feedback');
            feedbackDiv.textContent = "Datos de ejemplo cargados.";
            feedbackDiv.style.color = 'var(--success-color)';

            // Recalculate with sample data
            calculateAll(scenarioData); // This also saves state & updates UI
            showSnackbar("Datos de ejemplo cargados y procesados.", false, 'success');
         }

        function downloadTemplate() {
             const wb = XLSX.utils.book_new();
             const year = appState.currentYear;

             // Gastos Sheet
             const ws_gastos_data = [
                 ["Rubro", "Detalle", "Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"],
                 ["Seguridad", "Vigilador Dia", 50000, 50500, 51000, null, null, null, null, null, null, null, null, null], // null = Estimado
                 ["Seguridad", "Monitoreo Cámaras", 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], // Con valor = REAL
                 ["Jardinería", "Mantenimiento Parque", 30000, 30000, null, null, null, null, null, null, null, null, null, null],
                 ["Mantenimiento", "Limpieza Pileta", null, null, 5000, 5000, null, null, null, null, null, 5500, null, null], // Gastos esporádicos
                 ["Administración", "Honorarios Admin", 40000, 40000, 40000, 40000, null, null, null, null, null, null, null, null],
             ];
             const ws_gastos = XLSX.utils.aoa_to_sheet(ws_gastos_data);
             ws_gastos['!cols'] = [ {wch:20}, {wch:25}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10} ];
             XLSX.utils.book_append_sheet(wb, ws_gastos, GASTOS_SHEET_NAME);

             // Ingresos Sheet - MODIFICADO
             const ws_ingresos_data = [
                 ["Rubro", "Detalle", "Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"],
                 [CUOTA_RUBRO_NAME, `Valor Base 1 UF`, 1500, 1500, 1500, 1600, 1600, 1600, 1700, 1700, 1700, 1800, 1800, 1800], // VALOR POR UF
                 [EXTRA_CUOTA_RUBRO_NAME, `Cuota Extra Obra (x UF)`, null, null, null, 500, 500, 500, 500, null, null, null, null, null], // VALOR POR UF
                 ["Alquiler SUM", "Evento Sabado", 5000, null, 6000, null, null, 7000, null, null, 8000, null, null, 9000], // Ingresos esporádicos
                 ["Ingresos Extra", "Multa Atraso", null, 1000, 500,  0,    1500, null, null, 500, null, null, null, null]
             ];
             const ws_ingresos = XLSX.utils.aoa_to_sheet(ws_ingresos_data);
             ws_ingresos['!cols'] = [ {wch:25}, {wch:25}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10} ];
             XLSX.utils.book_append_sheet(wb, ws_ingresos, INGRESOS_SHEET_NAME);

             XLSX.writeFile(wb, `Plantilla_Expensas_${year}.xlsx`);
             showSnackbar("Plantilla de ejemplo descargada.", false, 'success');
        }

        function saveReserveFund() {
             console.log("Guardando config fondo reserva...");
             const scenarioData = getCurrentScenarioData();
             if (!scenarioData) { showSnackbar("No hay escenario activo.", true, 'error'); return; }

             // Ensure reserveFund object and values array exist
             scenarioData.reserveFund = scenarioData.reserveFund ?? { type: 'percent', values: Array(12).fill(5) };
             if (!Array.isArray(scenarioData.reserveFund.values) || scenarioData.reserveFund.values.length !== 12) {
                 scenarioData.reserveFund.values = Array(12).fill(scenarioData.reserveFund.type === 'percent' ? 5 : 0);
             }

             const newType = document.getElementById('reserve-type-percent').checked ? 'percent' : 'fixed';
             let valuesChanged = scenarioData.reserveFund.type !== newType;
             scenarioData.reserveFund.type = newType;

             const inputs = document.querySelectorAll('#reserve-fund-panel input[type="number"]');
             let validationOk = true;

             inputs.forEach(input => {
                 const monthIndex = parseInt(input.dataset.month);
                 const value = parseFloat(input.value);

                 if (!isNaN(value) && value >= 0 && monthIndex >= 0 && monthIndex < 12) {
                     if (scenarioData.reserveFund.values[monthIndex] !== value) {
                         scenarioData.reserveFund.values[monthIndex] = value;
                         valuesChanged = true;
                     }
                 } else {
                     input.value = scenarioData.reserveFund.values[monthIndex]; // Revert display
                     showSnackbar(`Valor inválido para ${FULL_MONTHS[monthIndex]}. Debe ser >= 0.`, true, 'error');
                     validationOk = false;
                 }
             });

             if (!validationOk) { console.warn("Guardado fondo reserva cancelado por valores inválidos."); return; }

             if (valuesChanged) {
                 console.log("Cambios detectados en fondo reserva. Recalculando...");
                 // Recalculate handles saveState and success message
                 calculateAll(scenarioData);
             } else {
                 showSnackbar("No se detectaron cambios en la configuración del fondo.", false, 'info');
             }
        }

        function saveSettings() {
             console.log("Guardando configuración general...");
             const oldSettingsJson = JSON.stringify(appState.settings);

             // --- Save Cantidad UF ---
             const cantidadInput = document.getElementById('cantidad-unidades');
             const newCantidadUnidades = parseInt(cantidadInput.value);
             if (!isNaN(newCantidadUnidades) && newCantidadUnidades > 0) {
                 appState.settings.cantidadUnidades = newCantidadUnidades;
             } else {
                 cantidadInput.value = appState.settings.cantidadUnidades; // Revert
                 showSnackbar("Cantidad de UF inválida (> 0).", true, 'error');
                 return; // Stop saving
             }

             // --- Manual IPC Inputs are already saved in state by their onchange handlers ---
             // --- Rubro Config (Coef assignments, collapsed state) saved by handlers ---
             // --- Coefficient Type Values saved by handlers ---

             // --- Ensure IPC Manual array is valid before saving ---
             if (!Array.isArray(appState.settings.ipcManual) || appState.settings.ipcManual.length !== 12) {
                appState.settings.ipcManual = Array(12).fill(0);
             }

             saveState(); // Save potential UF change and ensure IPC values are persisted

             const newSettingsJson = JSON.stringify(appState.settings);
             const settingsChangedForCalc = newSettingsJson !== oldSettingsJson;

             if (settingsChangedForCalc) {
                 console.log("Configuración cambiada, recalculando escenario activo...");
                 const scenarioData = getCurrentScenarioData();
                 if (scenarioData) {
                     // calculateAll handles success message
                     calculateAll(scenarioData);
                 } else {
                     showSnackbar("Configuración guardada, pero no hay escenario activo para recalcular.", false, 'warning');
                 }
             } else {
                 showSnackbar("Configuración guardada (sin cambios que requieran recálculo).", false, 'success');
             }
             // Refresh the panel UI just in case (e.g., if UF was reverted)
             updateSettingsPanel();
        }

        function addRubro(type) {
            const inputId = `new-${type}-rubro-name`;
            const input = document.getElementById(inputId);
            if (!input) { console.error(`Input no encontrado: ${inputId}`); showSnackbar("Error interno.", true); return; }
            const newRubroName = input.value.trim();

            if (!newRubroName) { showSnackbar("Nombre de rubro vacío.", true, 'warning'); input.focus(); return; }

            if (appState.settings.rubros[type].some(r => r.toLowerCase() === newRubroName.toLowerCase())) {
                showSnackbar(`Rubro "${newRubroName}" ya existe en ${type}.`, true, 'warning');
                input.select(); return;
            }

            // Add to global settings
            appState.settings.rubros[type].push(newRubroName);
            if (type === 'gastos' && !appState.settings.rubroConfig[newRubroName]) {
                appState.settings.rubroConfig[newRubroName] = { coefficientType: 'None', detailsCollapsed: true };
            }

            // Initialize data structures for this new rubro in ALL existing scenarios
            Object.values(appState.scenarios).forEach(scenario => {
                 initializeScenarioDataForRubros(scenario);
            });

            input.value = '';
            console.log(`Rubro ${type} añadido: ${newRubroName}`);
            saveState(); // Save updated settings and scenario structures

            updateRubroList(type, `${type}-rubro-list`);
            // Update the other list too if it's gastos (to update coefficient dropdowns)
            if(type === 'ingresos' && document.getElementById('gasto-rubro-list')) {
                 updateRubroList('gastos', 'gasto-rubro-list');
            }

            showSnackbar(`Rubro "${newRubroName}" (${type}) añadido.`, false, 'success');
        }

        function deleteRubro(type, rubroToDelete) {
             if (!confirm(`¿Seguro que quieres eliminar el rubro "${rubroToDelete}" (${type})?\n\nSe borrarán todos sus datos en TODOS los escenarios.\n¡No se puede deshacer!`)) {
                 showSnackbar("Eliminación cancelada.", false, 'info'); return;
             }

             // --- Remove from Global Settings ---
             appState.settings.rubros[type] = appState.settings.rubros[type].filter(r => r !== rubroToDelete);
             delete appState.settings.rubroConfig[rubroToDelete];
             console.log(`Rubro "${rubroToDelete}" eliminado de config global.`);

             // --- Remove from ALL Scenarios ---
             Object.keys(appState.scenarios).forEach(scenarioKey => {
                 const scenario = appState.scenarios[scenarioKey];
                 if (scenario) { // Check if scenario exists
                     // Check if type exists in scenario data
                     if (scenario.data?.[type]) {
                         delete scenario.data[type][rubroToDelete];
                     }
                     if (scenario.monthStatus?.[type]) {
                         delete scenario.monthStatus[type][rubroToDelete];
                     }
                     if (scenario.calculated) { // Check if calculated exists
                         if (type === 'gastos') {
                             if (scenario.calculated.gastoAjustado) delete scenario.calculated.gastoAjustado[rubroToDelete];
                             if (scenario.calculated.totalGastoRubroMes) delete scenario.calculated.totalGastoRubroMes[rubroToDelete];
                             if (scenario.calculated.annualTotals?.gastos) delete scenario.calculated.annualTotals.gastos[rubroToDelete];
                         } else { // ingresos
                             if (scenario.calculated.ingresoAjustado) delete scenario.calculated.ingresoAjustado[rubroToDelete];
                             if (scenario.calculated.totalIngresoRubroMes) delete scenario.calculated.totalIngresoRubroMes[rubroToDelete];
                             if (scenario.calculated.annualTotals?.ingresos) delete scenario.calculated.annualTotals.ingresos[rubroToDelete];
                         }
                     }
                     if (scenario.rubroOrder?.[type]) {
                         scenario.rubroOrder[type] = scenario.rubroOrder[type].filter(r => r !== rubroToDelete);
                     }
                 }
             });

             saveState();

             const activeScenario = getCurrentScenarioData();
             if (activeScenario) {
                 // Recalculate handles saveState and success message
                 calculateAll(activeScenario);
             } else {
                 updateUI(); // Just refresh lists if no active scenario
                 showSnackbar(`Rubro "${rubroToDelete}" (${type}) eliminado.`, false, 'success');
             }
             // Update settings panel lists explicitly
             updateSettingsPanel();
        }

        function addCoefficientType() {
             const input = document.getElementById('new-coefficient-type-name');
             if (!input) { console.error("Input no encontrado: new-coefficient-type-name"); showSnackbar("Error interno.", true); return; }
             const name = input.value.trim();

             if (!name) { showSnackbar("Nombre de tipo vacío.", true, 'warning'); input.focus(); return; }

             const key = name.replace(/\s+/g, '_').toUpperCase();
             const nameExists = Object.values(appState.settings.coefficientTypes).some(t => t.name.toLowerCase() === name.toLowerCase());
             // Also check if the generated key already exists
             if (appState.settings.coefficientTypes[key] || nameExists) {
                 showSnackbar(`Tipo "${name}" o clave "${key}" ya existe.`, true, 'warning');
                 input.select(); return;
             }

             appState.settings.coefficientTypes[key] = { name: name, values: Array(12).fill(1), isDefault: false };

             input.value = '';
             console.log(`Tipo coeficiente añadido: "${name}" (${key})`);
             saveState();

             updateCoefficientTypeList();
             updateRubroList('gastos', 'gasto-rubro-list'); // Update selects in gasto list
             showSnackbar(`Tipo de coeficiente "${name}" añadido.`, false, 'success');
        }

        function deleteCoefficientType(typeKey) {
             const type = appState.settings.coefficientTypes[typeKey];
             if (!type) { showSnackbar("Tipo no encontrado.", true, 'error'); return; }
             if (typeKey === 'None' || type.isDefault) { // Cannot delete 'None' or other defaults
                 showSnackbar(`Tipo por defecto "${type.name}" no se puede eliminar.`, true, 'warning'); return;
             }

             const isInUse = appState.settings.rubros.gastos.some(rubro => appState.settings.rubroConfig[rubro]?.coefficientType === typeKey);
             if (isInUse) {
                 showSnackbar(`Tipo "${type.name}" está en uso por uno o más rubros de gasto. Reasigna los rubros (a 'Sin Coeficiente' u otro) antes de eliminar este tipo.`, true, 'warning', 9000);
                 return;
             }

             if (confirm(`¿Seguro que quieres eliminar el tipo de coeficiente "${type.name}"?`)) {
                 const deletedName = type.name;
                 delete appState.settings.coefficientTypes[typeKey];

                 if (appState.uiState.editingCoefficientType === typeKey) {
                     appState.uiState.editingCoefficientType = null;
                     renderCoefficientValuesEditor(null); // Clear editor
                 }

                 console.log(`Tipo coeficiente eliminado: ${deletedName} (${typeKey})`);
                 saveState();

                 updateCoefficientTypeList();
                 updateRubroList('gastos', 'gasto-rubro-list'); // Update selects in gasto list

                 showSnackbar(`Tipo de coeficiente "${deletedName}" eliminado.`, false, 'success');
             } else {
                 showSnackbar("Eliminación cancelada.", false, 'info');
             }
        }

        function updateReserveUI() {
             const scenarioData = getCurrentScenarioData();
             if (!scenarioData) return;

             const selectedType = document.getElementById('reserve-type-percent').checked ? 'percent' : 'fixed';
             const panel = document.getElementById('reserve-fund-panel');
             if (!panel) return;

             const unitLabel = scenarioData.reserveFund.type === 'percent' ? '%' : '$'; // Use scenarioData type for UI label
             const currentStep = scenarioData.reserveFund.type === 'percent' ? '0.1' : '100'; // Use scenarioData type for step

             // Note: The radio button change updates the scenarioData.reserveFund.type *after* updateReserveUI is called by the handler.
             // So it's better to get the *selected* radio value for UI updates, and the saved value for state logic in saveReserveFund.
             const uiSelectedType = document.getElementById('reserve-type-percent').checked ? 'percent' : 'fixed';
             const uiUnitLabel = uiSelectedType === 'percent' ? '%' : '$';
             const uiCurrentStep = uiSelectedType === 'percent' ? '0.1' : '100';


             panel.querySelectorAll('input[type="number"]').forEach(input => {
                 input.step = uiCurrentStep;
                 // Optional: Adjust value if switching types dramatically? No, better to keep input value as is.
             });
             panel.querySelectorAll('.month-config span').forEach(span => span.textContent = uiUnitLabel);

             console.log(`UI fondo reserva actualizada a tipo: ${uiSelectedType}`);
        }

        function exportToExcel() {
             console.log("Iniciando exportación Excel...");
             const scenarioData = getCurrentScenarioData();
             // --- FIX: Check for calculated data existence more thoroughly ---
             if (!scenarioData || !scenarioData.calculated || !scenarioData.calculated.annualTotals || !scenarioData.calculated.totalGastoProyectadoMes || !scenarioData.calculated.totalIngresoProyectadoMes) {
                 showSnackbar("No hay datos calculados válidos para exportar.", true, 'error'); return;
             }
             const { year, scenarioName, data, calculated, reserveFund, rubroOrder } = scenarioData;
             const { settings } = appState;
             const { rubros, rubroConfig, coefficientTypes, cantidadUnidades, ipcManual: ipcSettings } = settings; // Use settings IPC for reference row

             try {
                 const wb = XLSX.utils.book_new();

                 // Define basic cell formats (more complex styling is harder with aoa_to_sheet)
                 const headerStyle = { font: { bold: true }, alignment: { horizontal: "center" } };
                 const currencyFormat = "$ #,##0.00";
                 const percentFormat = "0.0%";
                 const numberFormat = "#,##0.00"; // Non-currency number

                 // --- Helper to create data for sheets ---
                 const createSheetData = (title, headers, dataRows) => {
                     // Filter out rows that are just placeholders (like section headers) before adding data
                     const validDataRows = dataRows.filter(row => Array.isArray(row) && row.length > 0);
                     return [[title], [], headers, ...validDataRows];
                 };

                 // --- 1. Detalle Gastos Sheet ---
                 const gastosHeaders = ["Rubro", "Detalle", "Coef. Aplicado", ...FULL_MONTHS, "Total Anual"];
                 const gastosRows = [];
                 (rubroOrder?.gastos || []).forEach(rubro => {
                     if (!settings.rubros.gastos.includes(rubro)) return;
                     const config = rubroConfig[rubro] || {};
                     const coefName = coefficientTypes[config.coefficientType || 'None']?.name || 'N/A';
                     const detailOrder = data.gastos?.[rubro]?.detailOrder || [];
                     detailOrder.forEach(detail => {
                         const values = calculated.gastoAjustado?.[rubro]?.[detail] || Array(12).fill(0);
                         const annualTotal = values.reduce((a, b) => a + (b || 0), 0);
                         gastosRows.push([rubro, detail, coefName, ...values, annualTotal]);
                     });
                 });
                 const ws_gastos_array = createSheetData(`DETALLE GASTOS ${year} - ${scenarioName}`, gastosHeaders, gastosRows);
                 const ws_gastos = XLSX.utils.aoa_to_sheet(ws_gastos_array);
                 // Basic Widths
                 ws_gastos['!cols'] = [{wch:20},{wch:25},{wch:18}, ...Array(12).fill({wch:12}), {wch:14}];
                 // Apply formatting (basic example for values)
                 // Data starts at row index 3 (0-based), col index 3 (0-based)
                 const dataStartRow = ws_gastos_array.findIndex(row => row === gastosHeaders) + 1; // Find header row, add 1
                 if (dataStartRow !== -1) {
                      for (let rowIndex = dataStartRow; rowIndex < ws_gastos_array.length; rowIndex++) {
                          for (let col = 3; col < 15 + 1; col++) { // Months (3-14) + Total (15)
                              const cellRef = XLSX.utils.encode_cell({r: rowIndex, c: col});
                               // Only apply format if cell exists and contains a number
                               if(ws_gastos[cellRef] && typeof ws_gastos[cellRef].v === 'number') {
                                   ws_gastos[cellRef].z = currencyFormat;
                                   // Ensure cell type is number 'n' (aoa_to_sheet usually handles this but explicit is safer)
                                   ws_gastos[cellRef].t = 'n';
                               }
                          }
                      }
                 }
                 XLSX.utils.book_append_sheet(wb, ws_gastos, "Detalle Gastos");


                 // --- 2. Detalle Ingresos Sheet (Shows BASE values) ---
                 const ingresosHeaders = ["Rubro", "Detalle", ...FULL_MONTHS, "Total Anual"];
                 const ingresosRows = [];
                 (rubroOrder?.ingresos || []).forEach(rubro => {
                    if (!settings.rubros.ingresos.includes(rubro)) return;
                    const detailOrder = data.ingresos?.[rubro]?.detailOrder || [];
                    detailOrder.forEach(detail => {
                        const values = calculated.ingresoAjustado?.[rubro]?.[detail] || Array(12).fill(0); // BASE values
                        const annualTotal = values.reduce((a, b) => a + (b || 0), 0);
                        const rubroNote = SPECIAL_INGRESO_RUBROS.includes(rubro) ? ` (Valor Base x UF)` : '';
                        ingresosRows.push([`${rubro}${rubroNote}`, detail, ...values, annualTotal]);
                    });
                 });
                 const ws_ingresos_array = createSheetData(`DETALLE INGRESOS (Valores Base) ${year} - ${scenarioName}`, ingresosHeaders, ingresosRows);
                 const ws_ingresos = XLSX.utils.aoa_to_sheet(ws_ingresos_array);
                 ws_ingresos['!cols'] = [{wch:25},{wch:25}, ...Array(12).fill({wch:12}), {wch:14}];
                 // Data starts at row index 3 (0-based), col index 2 (0-based)
                 const ingresosDataStartRow = ws_ingresos_array.findIndex(row => row === ingresosHeaders) + 1;
                  if (ingresosDataStartRow !== -1) {
                     for (let rowIndex = ingresosDataStartRow; rowIndex < ws_ingresos_array.length; rowIndex++) {
                         for (let col = 2; col < 14 + 1; col++) { // Months (2-13) + Total (14)
                             const cellRef = XLSX.utils.encode_cell({r: rowIndex, c: col});
                             if(ws_ingresos[cellRef] && typeof ws_ingresos[cellRef].v === 'number') {
                                  ws_ingresos[cellRef].z = currencyFormat;
                                  ws_ingresos[cellRef].t = 'n';
                              }
                         }
                     }
                  }
                 XLSX.utils.book_append_sheet(wb, ws_ingresos, "Detalle Ingresos (Base)");


                 // --- 3. Resumen General Sheet ---
                 const resumenHeaders = ["Concepto", ...FULL_MONTHS, "Total Anual"];
                 const resumenRows = [];
                 const addRow = (label, values, format, isPercent = false, isUF = false) => {
                    const annual = values.reduce ? values.reduce((a, b) => a + (b || 0), 0) : values; // Sum if array, else take value
                    resumenRows.push([label, ...values, annual]);
                    const lastRowIndex = resumenRows.length - 1; // 0-based index within resumenRows array
                    // Store formatting info for this row
                     resumenRows[lastRowIndex].formatInfo = { format, isPercent, isUF };
                 };

                 // Gastos Section
                 resumenRows.push(["--- GASTOS ---"]);
                 (rubroOrder?.gastos || []).forEach(rubro => {
                     if (!settings.rubros.gastos.includes(rubro)) return;
                     addRow(`Gasto - ${rubro}`, calculated.totalGastoRubroMes?.[rubro] || Array(12).fill(0), currencyFormat);
                 });
                 addRow("TOTAL GASTOS ($)", calculated.totalGastoProyectadoMes || [], currencyFormat);
                 resumenRows.push([]); // Spacer

                 // Ingresos Section (Calculated totals incl. UF mult)
                 resumenRows.push(["--- INGRESOS (Calculados) ---"]);
                 (rubroOrder?.ingresos || []).forEach(rubro => {
                     if (!settings.rubros.ingresos.includes(rubro)) return;
                     addRow(`Ingreso - ${rubro}`, calculated.totalIngresoRubroMes?.[rubro] || [], currencyFormat);
                 });
                 addRow("TOTAL INGRESOS ($)", calculated.totalIngresoProyectadoMes || [], currencyFormat);
                 resumenRows.push([]); // Spacer

                 // Fondo Reserva Section
                 resumenRows.push(["--- FONDO RESERVA ---"]);
                 // Ensure reserveFund object and values exist/are valid
                 const reserveValues = Array.isArray(reserveFund?.values) && reserveFund.values.length === 12
                                     ? reserveFund.values
                                     : Array(12).fill(reserveFund?.type === 'percent' ? 5 : 0);
                 const reserveType = reserveFund?.type === 'fixed' ? 'fixed' : 'percent'; // Default to percent
                 const reserveLabel = `Fondo Reserva Config (${reserveType === 'percent' ? '%' : '$'})`;
                 addRow(reserveLabel, reserveValues.map(v => parseFloat(v || 0)), reserveType === 'percent' ? percentFormat : currencyFormat, reserveType === 'percent');
                 addRow("Fondo Reserva Calculado ($)", calculated.fondoReservaMes || [], currencyFormat);
                 resumenRows.push([]); // Spacer

                 // Cuotas & IPC Section
                 resumenRows.push(["--- CUOTAS Y REFERENCIAS ---"]);
                 // UF row: put value only in first month column
                 const ufValues = Array(12).fill(null);
                 ufValues[0] = cantidadUnidades; // Put UF count in the first month column
                 addRow(`Unidades Funcionales (UF)`, ufValues, numberFormat, false, true); // Mark as UF row

                 addRow("Cuota s/Gtos Calculada ($)", calculated.cuotaSobreGastosMes || [], currencyFormat);
                 // Use the snapshot stored in calculated.ipcManual for the report
                 addRow("IPC Referencia (%)", calculated.ipcManual || Array(12).fill(0), percentFormat, true);
                 addRow("Cuota IPC Calculada ($)", calculated.cuotaIpcMes || [], currencyFormat);
                 addRow("Cuota Real Base ($)", calculated.cuotaRealBaseMes || [], currencyFormat);

                 // Create Resumen Sheet
                 const ws_resumen_array = createSheetData(`RESUMEN GENERAL ${year} - ${scenarioName}`, resumenHeaders, resumenRows);
                 const ws_resumen = XLSX.utils.aoa_to_sheet(ws_resumen_array);
                 ws_resumen['!cols'] = [{wch:30}, ...Array(12).fill({wch:12}), {wch:14}];

                  // Apply Formatting based on stored info
                  // Find the actual start row index for data in the sheet
                 const resumenDataStartRow = ws_resumen_array.findIndex(row => row === resumenHeaders) + 1; // Find header row, add 1

                 if (resumenDataStartRow !== -1) {
                     for (let arrayRowIndex = 0; arrayRowIndex < resumenRows.length; arrayRowIndex++) {
                          const rowInfo = resumenRows[arrayRowIndex].formatInfo;
                          if (rowInfo) {
                               const sheetRowIndex = resumenDataStartRow + arrayRowIndex; // Calculate corresponding row index in the sheet

                               for (let col = 1; col < 13 + 1; col++) { // Months (1-12) + Total (13)
                                   const cellRef = XLSX.utils.encode_cell({r: sheetRowIndex, c: col});
                                   // Only apply format if cell exists and contains a number
                                   if(ws_resumen[cellRef] && typeof ws_resumen[cellRef].v === 'number') {
                                       // Convert percent values for Excel (e.g., 5 -> 0.05) unless it's the UF row
                                       if (rowInfo.isPercent && !rowInfo.isUF) {
                                           ws_resumen[cellRef].v /= 100;
                                       }
                                       ws_resumen[cellRef].z = rowInfo.format;
                                        ws_resumen[cellRef].t = 'n';
                                   } else if (rowInfo.isUF && col === 1 && ws_resumen[cellRef] && typeof ws_resumen[cellRef].v === 'number') {
                                        // Apply number format specifically to the first month cell for UF row
                                        ws_resumen[cellRef].z = rowInfo.format;
                                         ws_resumen[cellRef].t = 'n';
                                   }
                               }
                          }
                     }
                 }
                 XLSX.utils.book_append_sheet(wb, ws_resumen, "Resumen General");


                 // --- Write File ---
                 const filename = `Reporte_Expensas_${year}_${scenarioName.replace(/\s+/g, '_')}.xlsx`;
                 XLSX.writeFile(wb, filename);
                 showSnackbar("Reporte Excel generado.", false, 'success');

             } catch (error) {
                  console.error("Error exportando a Excel:", error);
                  showSnackbar(`Error al generar Excel: ${error.message}`, true, 'error');
             }
        }


        function exportChart(canvasId, filename) {
             const canvas = document.getElementById(canvasId);
             const chartInstance = window[`${canvasId}_instance`];
             // Check if canvas and instance exist, and if there is any non-zero data in the first dataset
             if (!canvas || !chartInstance || !chartInstance.data || !chartInstance.data.datasets || chartInstance.data.datasets.length === 0 || chartInstance.data.datasets[0].data.every(d => d === null || d === undefined || d === 0)) {
                  showSnackbar(`Gráfico "${canvasId}" no encontrado o sin datos para exportar.`, true, 'warning');
                 return;
             }
             try {
                 chartInstance.update('none'); // Ensure rendered without animation for export
                 // Allow a small delay for the canvas to potentially re-render after update('none')
                 requestAnimationFrame(() => {
                    requestAnimationFrame(() => { // Double rAF for safety
                     const imageURL = canvas.toDataURL('image/png');
                     const link = document.createElement('a');
                     link.href = imageURL;
                     link.download = filename;
                     document.body.appendChild(link);
                     link.click();
                     document.body.removeChild(link);
                     showSnackbar(`Gráfico "${filename}" exportado como PNG.`, false, 'success');
                    });
                 });
             } catch (e) {
                 console.error(`Error exportando gráfico "${canvasId}":`, e);
                 showSnackbar("Error al exportar gráfico.", true, 'error');
             }
        }


        // --- Utilidades ---
        function formatCurrency(value) {
             const num = Number(value);
             if (isNaN(num)) return "$ 0,00";
             // Use es-AR locale for Argentinian Peso formatting
             return `$ ${num.toLocaleString('es-AR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
        }

        function hexToRgba(hex, alpha) {
            hex = String(hex).trim().replace('#', '');
            if (!/^[0-9A-F]{3,6}$/i.test(hex)) return `rgba(0,0,0,${alpha})`; // Fallback black
            if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
            const r = parseInt(hex.slice(0, 2), 16), g = parseInt(hex.slice(2, 4), 16), b = parseInt(hex.slice(4, 6), 16);
            return (isNaN(r) || isNaN(g) || isNaN(b)) ? `rgba(0,0,0,${alpha})` : `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function openTab(evt, tabName) {
             let i, tabcontent, tablinks;
             tabcontent = document.getElementsByClassName("tab-content");
             for (i = 0; i < tabcontent.length; i++) { tabcontent[i].classList.remove("active"); tabcontent[i].style.display = "none"; }
             tablinks = document.getElementsByClassName("tab-link");
             for (i = 0; i < tablinks.length; i++) { tablinks[i].classList.remove("active"); }
             const tabToShow = document.getElementById(tabName);
             if(tabToShow) { tabToShow.style.display = "block"; void tabToShow.offsetWidth; tabToShow.classList.add("active"); }
             if(evt?.currentTarget) evt.currentTarget.classList.add("active");

             if (tabName === 'dashboard') { // Resize charts when dashboard tab is shown
                 requestAnimationFrame(() => {
                    ['evolutivoCuotaChart', 'participacionGastosChart', 'participacionIngresosChart'].forEach(id => {
                        if (window[`${id}_instance`]) window[`${id}_instance`].resize();
                    });
                 });
             }
        }

        function showSnackbar(message, isError = false, level = null, duration = 4000) {
             const snackbar = document.getElementById('snackbar');
             if (!snackbar) return;
             snackbar.textContent = message;
             let effectiveLevel = level ?? (isError ? 'error' : 'success'); // Default to success if not error

             snackbar.className = 'show'; // Base class to make it visible and positioned
             if (effectiveLevel === 'error') snackbar.classList.add('error');
             else if (effectiveLevel === 'warning') snackbar.classList.add('warning');
             else if (effectiveLevel === 'info') snackbar.classList.add('info');
             // Success uses default style (no extra class needed)

             if (snackbar.timer) clearTimeout(snackbar.timer);
             snackbar.timer = setTimeout(() => {
                 snackbar.className = ''; // Remove all classes to hide
                 snackbar.timer = null;
             }, duration);
        }


        // --- Tema Oscuro/Claro ---
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia?.('(prefers-color-scheme: dark)').matches;
            appState.darkMode = (savedTheme === 'dark') || (!savedTheme && !!prefersDark); // Use saved or system pref
            applyTheme(false); // Apply initial theme without transition/chart update

            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                if (!localStorage.getItem('theme')) { // Only follow system if no explicit choice saved
                    appState.darkMode = event.matches;
                    applyTheme(); // Apply with transition/chart update
                    saveState(); // Save the implicit preference change
                }
            });
        }

        function toggleTheme() {
            appState.darkMode = !appState.darkMode;
            localStorage.setItem('theme', appState.darkMode ? 'dark' : 'light'); // Save explicit choice
            applyTheme();
            saveState();
        }

        function applyTheme(updateCharts = true){
            const body = document.body;
            const toggleButton = document.getElementById('theme-toggle');
            body.classList.toggle('dark-mode', appState.darkMode);
            if (toggleButton) {
                 toggleButton.innerHTML = appState.darkMode ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
                 toggleButton.title = appState.darkMode ? 'Cambiar a tema claro' : 'Cambiar a tema oscuro';
            }

            if (updateCharts) { // Avoid updating charts on initial load before they exist
                 requestAnimationFrame(() => { // Defer chart updates slightly
                     const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
                     const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
                     Chart.defaults.color = textColor;
                     Chart.defaults.borderColor = borderColor;
                     // Update existing instances
                     ['evolutivoCuotaChart', 'participacionGastosChart', 'participacionIngresosChart'].forEach(id => {
                          if (window[`${id}_instance`]) window[`${id}_instance`].update();
                     });
                 });
            }
        }

        // --- Persistencia (localStorage) ---
        function saveState() {
             try {
                 const stateToSave = {
                     currentYear: appState.currentYear,
                     scenarios: appState.scenarios,
                     activeScenarioKey: appState.activeScenarioKey,
                     settings: appState.settings,
                     darkMode: appState.darkMode,
                     // Don't save uiState intentionally
                 };
                 localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
                 // console.log("Estado guardado.");
             } catch (e) {
                 console.error("Error guardando estado:", e);
                 showSnackbar("Error al guardar estado.", true, 'error');
             }
         }

        function loadState() {
             try {
                 const savedState = localStorage.getItem(STORAGE_KEY);
                 if (savedState) {
                     const loadedState = JSON.parse(savedState);
                     appState = deepMerge(getDefaultAppState(), loadedState); // Merge loaded into default structure
                     console.log(`Estado ${STORAGE_KEY} cargado.`);
                 } else {
                     console.log("No hay estado guardado. Usando estado por defecto.");
                     appState = getDefaultAppState(); // Fallback
                 }
             } catch (e) {
                 console.error("Error cargando estado:", e);
                 showSnackbar("Error cargando estado guardado. Usando valores por defecto.", true, 'error');
                 appState = getDefaultAppState(); // Fallback
             }
             // Post-load validation is now handled by validateAndSetActiveScenario in DOMContentLoaded
        }

        function getDefaultAppState() {
            const defaultYear = new Date().getFullYear();
            // Use JSON parse/stringify for a clean deep copy
            return JSON.parse(JSON.stringify({
                 currentYear: defaultYear,
                 scenarios: {}, // Start with empty scenarios object
                 activeScenarioKey: null, // Will be set by validation logic
                 settings: {
                     cantidadUnidades: 100,
                     rubros: { gastos: [], ingresos: [] },
                     rubroConfig: {},
                     coefficientTypes: {
                         "None": { name: "Sin Coeficiente", values: Array(12).fill(1), isDefault: true },
                         "IPC": { name: "IPC (Ejemplo)", values: [1.05, 1.04, 1.06, 1.03, 1.04, 1.05, 1.03, 1.04, 1.05, 1.06, 1.04, 1.05], isDefault: true },
                         "UTEDYC": { name: "UTEDYC (Ejemplo)", values: [1, 1, 1.10, 1, 1, 1.08, 1, 1, 1.07, 1, 1, 1.05], isDefault: true },
                         "Sueldos": { name: "Sueldos Generales", values: [1, 1, 1.08, 1, 1, 1.06, 1, 1, 1.05, 1, 1, 1.04], isDefault: false }
                     },
                     ipcManual: [5, 4, 6, 3, 4, 5, 3, 4, 5, 6, 4, 5] // Default IPC ref values (%)
                 },
                 uiState: { // Transient state
                    editingCoefficientType: null
                 },
                 darkMode: false // Default theme
             }));
        }

        function deepMerge(target, source) {
             const output = { ...target };
             if (isObject(target) && isObject(source)) {
                 Object.keys(source).forEach(key => {
                     const targetValue = target[key];
                     const sourceValue = source[key];
                     if (isObject(sourceValue) && isObject(targetValue)) {
                         output[key] = deepMerge(targetValue, sourceValue);
                     } else if (Array.isArray(sourceValue) && Array.isArray(targetValue)) {
                         // Simple array merge: source overwrites target - adjust if needed
                          output[key] = [...sourceValue];
                     } else {
                          output[key] = sourceValue !== undefined ? sourceValue : targetValue;
                     }
                 });
             }
             return output;
         }

        function isObject(item) {
             return (item && typeof item === 'object' && !Array.isArray(item));
        }

        // --- Funciones Adicionales o de UI ---
        function updateReportsPanel() {
             const scenarioData = getCurrentScenarioData();
             const hasCalculatedData = scenarioData?.calculated && (
                (scenarioData.calculated.totalGastoProyectadoMes?.some(v => v !== 0) ?? false) ||
                (scenarioData.calculated.totalIngresoProyectadoMes?.some(v => v !== 0) ?? false)
             );
             const disable = !scenarioData || !hasCalculatedData;

             document.querySelectorAll('#reports button').forEach(btn => { btn.disabled = disable; });
        }

        function clearScenarioData() {
             const key = appState.activeScenarioKey;
             const scenario = appState.scenarios[key];
             if (!scenario) { showSnackbar('No hay escenario activo.', true, 'error'); return; }

             if (!confirm(`¿Borrar TODOS los datos (gastos, ingresos, estado meses) del escenario "${scenario.scenarioName}"?\n\nConfiguración de Fondo de Reserva se mantendrá.\n¡No se puede deshacer!`)) {
                 showSnackbar("Operación cancelada.", false, 'info'); return;
             }

             // Reset data, keep reserve fund
             scenario.rubroOrder = { gastos: [], ingresos: [] };
             scenario.data = { gastos: {}, ingresos: {} };
             scenario.monthStatus = { gastos: {}, ingresos: {} };
             // Calculated is reset within calculateAll

             console.log(`Datos borrados para escenario: ${key}`);
             saveState(); // Save cleared data structures
             // Recalculate to update totals to zero and refresh UI
             calculateAll(scenario); // Handles success message
        }

    </script>

<!-- Toggle Rubros -->
<style>
.rubro-detail.collapsed { display:none; }
.rubro-header { cursor:pointer; }
.toggle-all-btn { background:none; border:none; font-size:1.2rem; cursor:pointer; margin-left:.5rem;}
</style>
<script>
function initRubrosToggle(){
  document.querySelectorAll('.rubro-header').forEach(h=>{
    h.addEventListener('click', ()=> toggleDetail(h));
  });
}
function toggleDetail(header){
  const detail = header.nextElementSibling;
  if(detail){
    detail.classList.toggle('collapsed');
    const icon = header.querySelector('.arrow');
    if(icon) icon.textContent = detail.classList.contains('collapsed') ? '▼' : '▲';
  }
}
// Botones globales
function toggleSection(sectionId, collapse){
  document.querySelectorAll('#'+sectionId+' .rubro-detail').forEach(d=>{
     if(collapse===undefined){
        d.classList.toggle('collapsed');
     }else{
        d.classList.toggle('collapsed', collapse);
     }
  });
  // actualizar iconos
  document.querySelectorAll('#'+sectionId+' .rubro-header .arrow').forEach(i=>{
     const header=i.closest('.rubro-header');
     const det=header.nextElementSibling;
     i.textContent = det.classList.contains('collapsed') ? '▼':'▲';
  });
}
document.addEventListener('DOMContentLoaded', initRubrosToggle);
</script>
<!-- End Toggle Rubros -->


<!-- Auto-cálculo Expensa Real -->
<script>
/**
 * Busca en dataIngresos el rubro 'Expensas' / detalle 'Expensas Ordinarias'
 * y copia sus importes mensuales a la columna Expensa Real ($) del Resumen Mensual.
 *
 * Requiere:
 * - El archivo Excel ya cargado y parseado a window.appState.ingresos
 * - Función updateResumen() refresca la UI.
 */
function completarExpensaReal() {
  if(!window.appState || !appState.ingresos) return;
  const expRow = appState.ingresos.find(r =>
     r.rubro?.toLowerCase() === 'expensas' &&
     r.detalle?.toLowerCase() === 'expensas ordinarias');
  if(!expRow) return;

  // supongamos que los meses están en propiedades m1..m12 (enero=1)
  const target = appState.resumenMensual?.expensaReal || {};
  for(let m=1;m<=12;m++){
     const key = 'm'+m;
     if(expRow[key]!=null){
        target[key] = expRow[key];
     }
  }
  // guardar y refrescar UI
  appState.resumenMensual.expensaReal = target;
  if(typeof updateResumen === 'function') updateResumen();
}

// Llamar después de parsear Excel
document.addEventListener('DATA_READY', completarExpensaReal);
</script>

</body>
</html>

<!-- Plugin: legendTweaks v2 -->
<script>
const legendTweaks_v2 = {
  id: 'legendTweaks_v2',
  beforeInit(chart) {
    // 1) Quitar tachado
    chart.options.plugins ||= {};
    chart.options.plugins.legend ||= {};
    chart.options.plugins.legend.labels ||= {};
    chart.options.plugins.legend.labels.strikethrough = false;

    // 2) Reducir fuente 10 %
    const baseSize = (Chart.defaults.font && Chart.defaults.font.size) ? Chart.defaults.font.size : 12;
    chart.options.plugins.legend.labels.font = ctx => {
      return { size: Math.round(baseSize * 0.9) };
    };

    // 3) Ordenar etiquetas de mayor a menor según dato
    const originalGenerate = Chart.overrides.doughnut.plugins.legend.labels.generateLabels;
    chart.options.plugins.legend.labels.generateLabels = function(c) {
      const lbls = originalGenerate(c);
      const dataValues = c.data.datasets[0]?.data || [];
      lbls.sort((a,b) => (dataValues[b.index]||0) - (dataValues[a.index]||0));
      return lbls;
    };
  }
};

if (window.Chart && !Chart.registry.plugins.get('legendTweaks_v2')) {
  Chart.register(legendTweaks_v2);
}
</script>

<!-- Plugin: legendTweaks_v3 -->
<script>
const legendTweaks_v3 = {
  id: 'legendTweaks_v3',
  beforeInit(chart) {
    chart.options.plugins ||= {};
    chart.options.plugins.legend ||= {};
    chart.options.plugins.legend.labels ||= {};
    chart.options.plugins.legend.labels.strikethrough = false;

    // Reducir fuente 10 % y añadir % en etiqueta
    const baseSize = (Chart.defaults.font && Chart.defaults.font.size) ? Chart.defaults.font.size : 12;
    chart.options.plugins.legend.labels.generateLabels = function(c) {
      // Base labels
      const meta = c.getDatasetMeta(0);
      const total = c.data.datasets[0].data.reduce((a,b)=>a+b,0) || 1;
      return c.data.labels.map((label, i) => {
        const value = c.data.datasets[0].data[i];
        const percentage = ((value/total)*100).toFixed(1) + '%';
        const model = meta.data[i] && meta.data[i].tooltipPosition ? meta.data[i] : {};
        return {
          text: label + ' (' + percentage + ')',
          fillStyle: c.data.datasets[0].backgroundColor[i],
          hidden: isNaN(value) || meta.data[i].hidden,
          index: i,
          font: {size: Math.round(baseSize*0.9)}
        };
      }).sort((a,b)=> c.data.datasets[0].data[b.index] - c.data.datasets[0].data[a.index]);
    };
  }
};
if (window.Chart && !Chart.registry.plugins.get('legendTweaks_v3')) {
  Chart.register(legendTweaks_v3);
}
</script>
