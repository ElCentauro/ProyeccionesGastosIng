<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Favicon -->
<link rel="icon" type="image/png" href="favicon.png">
    <title>Proyección Expensas - Barrio El Centauro</title>
    <!-- Librería SheetJS (js-xlsx) para leer/escribir Excel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Librería Chart.js para gráficos -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

<!-- ******* FIX: destruye instancias de Chart.js de forma segura ******* -->
<script>
/**
 * Destruye (si existe) la instancia de Chart asociada a un <canvas>.
 * Evita errores "destroyChart is not defined" y fugas de memoria al recrear gráficos.
 * @param {string} canvasId - id del elemento <canvas>
 */
function destroyChart(canvasId) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    // Chart.js v3+ provee Chart.getChart(canvas) para obtener instancia existente
    const chart = window.Chart && typeof Chart.getChart === 'function'
        ? Chart.getChart(canvas)
        : (canvas.chart || null);
    if (chart && typeof chart.destroy === 'function') {
        chart.destroy();
    }
}


/**
 * Muestra un placeholder de "Sin datos" en el canvas indicado.
 * Si hide = true, oculta el canvas para liberar espacio.
 * @param {string} canvasId - id del elemento <canvas>
 * @param {boolean} hide - si se debe ocultar por completo
 */
function displayChartNoData(canvasId, hide = false) {
    const canvas = document.getElementById(canvasId);
    if (!canvas) return;
    if (hide) {
        canvas.style.display = 'none';
        return;
    }
    canvas.style.display = 'block';
    // Asegurar que tenga algo de tamaño por si el CSS lo colapsa
    if (!canvas.width) canvas.width = 400;
    if (!canvas.height) canvas.height = 200;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.fillStyle = '#b0b0b0';
    ctx.font = '600 14px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Sin datos', canvas.width / 2, canvas.height / 2);
    ctx.restore();
}



</script>
<!-- ******* FIN FIX ******* -->

<!-- Plugin doughnut 3D shadow -->
<script>
/* Plugin: doughnutShadow3D
   Añade una sombra suave debajo de cada porción para simular profundidad 3 D.
   Seguro para todos los datasets (evita NaN en createRadialGradient). */
const doughnutShadow3D = {
  id: 'doughnutShadow3D',
  afterDatasetDraw(chart, args, opts) {
    const {ctx} = chart;
    if (args.meta.type !== 'doughnut') return;

    args.meta.data.forEach(segment => {
      const {x, y, startAngle, endAngle, innerRadius, outerRadius} = segment;
      if (!isFinite(x) || !isFinite(y) || !isFinite(innerRadius) || !isFinite(outerRadius)) return;

      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.15)';      // shadow color
      ctx.translate(0, 4);                     // vertical offset
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.arc(x, y, outerRadius, startAngle, endAngle);
      ctx.arc(x, y, innerRadius, endAngle, startAngle, true);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    });
  }
};
// Registrar plugin globalmente
if (window.Chart && !Chart.registry.plugins.get('doughnutShadow3D')) {
  Chart.register(doughnutShadow3D);
}
</script>

    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts (Inter) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- Reset Básico y Fuentes --- */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; /* Base font size */ }
        body {
            font-family: 'Inter', 'Segoe UI', sans-serif;
            line-height: 1.7; /* Improved readability */
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* --- Variables de Color (Paleta Refinada) --- */
        :root {
            --bg-color: #f8f9fa;              /* Slightly off-white */
            --text-color: #343a40;            /* Darker gray */
            --primary-color: #007bff;          /* Classic blue */
            --primary-color-darker: #0056b3;   /* Darker blue for hover */
            --secondary-color: #6c757d;        /* Standard gray */
            --secondary-color-darker: #5a6268; /* Darker gray for hover */
            --accent-color: #28a745;           /* Vibrant green */
            --accent-color-darker: #218838;    /* Darker green for hover */
            --danger-color: #dc3545;           /* Red */
            --danger-color-darker: #c82333;    /* Darker red */
            --warning-color: #ffc107;           /* Yellow */
            --warning-color-darker: #e0a800;   /* Darker yellow */
            --info-color: #17a2b8;             /* Teal */
            --info-color-darker: #138496;      /* Darker teal */
            --success-color: var(--accent-color); /* Alias for consistency */
            --success-color-darker: var(--accent-color-darker); /* Alias */

            --border-color: #dee2e6;           /* Light gray border */
            --header-bg: #ffffff;              /* White header */
            --card-bg: #ffffff;                /* White cards */
            --shadow-color: rgba(0, 0, 0, 0.08); /* Softer shadow */
            --input-bg: #ffffff;
            --input-border: #ced4da;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(0, 123, 255, 0.25);
            --button-text: #ffffff;
            --button-warning-text: #212529; /* Dark text for yellow button */
            --table-header-bg: #eef2f7;        /* Lighter table header */
            --table-row-hover: #f1f3f5;        /* Subtle hover */
            --expandable-row-bg: #f8f9fa;      /* Same as body bg for subtle diff */
            --clickable-row-hover: #e9ecef;    /* Slightly darker hover for clickable rows */
            --disabled-bg: #e9ecef;
            --disabled-text: #6c757d;
            --disabled-border: #ced4da;

            /* >>> COLORES REAL/ESTIMADO <<< */
            --real-month-bg: #d1f7d9; /* Light, fresh green */
            --estimated-month-bg: #fff3cd; /* Soft Yellow */
             --estimated-month-border: #ffda6a; /* Yellow border for input */
        }

        body.dark-mode {
            --bg-color: #1a1a1a;              /* Very dark gray */
            --text-color: #e0e0e0;            /* Light gray text */
            --primary-color: #58a6ff;          /* Brighter blue */
            --primary-color-darker: #79b8ff;   /* Lighter blue for hover */
            --secondary-color: #8b949e;        /* Lighter gray */
            --secondary-color-darker: #a0a8b0; /* Lighter gray hover */
            --accent-color: #56d364;           /* Brighter green */
            --accent-color-darker: #6bde7a;    /* Lighter green hover */
            --danger-color: #f85149;           /* Bright red */
            --danger-color-darker: #fa6a61;    /* Lighter red */
            --warning-color: #f0b41e;          /* Bright yellow */
            --warning-color-darker: #f2c037;   /* Lighter yellow */
            --info-color: #6cb6f1;             /* Bright teal */
            --info-color-darker: #85c3f4;      /* Lighter teal */
            --success-color: var(--accent-color);
            --success-color-darker: var(--accent-color-darker);

            --border-color: #444c56;           /* Darker border */
            --header-bg: #2c2c2c;              /* Dark card background */
            --card-bg: #2c2c2c;                /* Dark card background */
            --shadow-color: rgba(255, 255, 255, 0.05); /* Subtle white shadow */
            --input-bg: #3a3f44;
            --input-border: #5a6268;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(88, 166, 255, 0.25);
            --button-text: #1a1a1a; /* Dark text on bright buttons */
            --button-warning-text: #1a1a1a;
            --table-header-bg: #343a40;        /* Darker header */
            --table-row-hover: #3e444a;        /* Subtle dark hover */
            --expandable-row-bg: #343a40;      /* Darker expandable row bg */
            --clickable-row-hover: #495057;    /* Darker hover for clickable */
            --disabled-bg: #495057;
            --disabled-text: #adb5bd;
            --disabled-border: #5a6268;

            /* >>> COLORES REAL/ESTIMADO OSCURO <<< */
            --real-month-bg: #1c4a2b; /* Darker Green */
            --estimated-month-bg: #5a4a1d; /* Dark Yellow/Brown */
            --estimated-month-border: #f0b41e; /* Brighter Yellow border for input */
        }

        /* --- Estilos Generales --- */
        .container { width: 95%; max-width: 1700px; margin: 0 auto; padding: 25px 20px; }
        h1, h2, h3, h4 { color: var(--primary-color); margin-bottom: 1em; font-weight: 600; }
        h1 { font-size: 2.2rem; text-align: center; }
        h2 { font-size: 1.8rem; border-bottom: 2px solid var(--accent-color); padding-bottom: 0.4em; }
        h3 { font-size: 1.4rem; margin-top: 1.8em; }
        h4 { font-size: 1.15rem; color: var(--secondary-color); margin-top: 1.2em; margin-bottom: 0.6em; }
        a { color: var(--primary-color); text-decoration: none; transition: color 0.2s ease; }
        a:hover { color: var(--primary-color-darker); text-decoration: underline; }

        button {
            padding: 12px 22px;
            border: 1px solid transparent; /* Added border for consistency */
            border-radius: 6px;
            background-color: var(--primary-color);
            color: var(--button-text);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out, transform 0.1s ease, box-shadow 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center; /* Center content */
            gap: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            line-height: 1.5; /* Ensure consistent height */
            text-align: center; /* Ensure text aligns center */
        }
        button:hover {
            background-color: var(--primary-color-darker);
            border-color: var(--primary-color-darker);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        button:focus {
            outline: none;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        button:disabled {
            background-color: var(--disabled-bg);
            color: var(--disabled-text);
            border-color: var(--disabled-border);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        button i { margin-right: 2px; /* Keep small margin */ }

        /* Button variants */
        .button-primary { background-color: var(--primary-color); border-color: var(--primary-color); color: var(--button-text); }
        .button-primary:hover { background-color: var(--primary-color-darker); border-color: var(--primary-color-darker); }
        .button-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: var(--button-text); }
        .button-secondary:hover { background-color: var(--secondary-color-darker); border-color: var(--secondary-color-darker); }
        .button-success { background-color: var(--success-color); border-color: var(--success-color); color: var(--button-text); }
        .button-success:hover { background-color: var(--success-color-darker); border-color: var(--success-color-darker); }
        .button-danger { background-color: var(--danger-color); border-color: var(--danger-color); color: var(--button-text); }
        .button-danger:hover { background-color: var(--danger-color-darker); border-color: var(--danger-color-darker); }
        .button-warning { background-color: var(--warning-color); border-color: var(--warning-color); color: var(--button-warning-text); }
        .button-warning:hover { background-color: var(--warning-color-darker); border-color: var(--warning-color-darker); }
        .button-info { background-color: var(--info-color); border-color: var(--info-color); color: var(--button-text); }
        .button-info:hover { background-color: var(--info-color-darker); border-color: var(--info-color-darker); }
        .button-sm { padding: 6px 12px; font-size: 0.85rem; gap: 6px;}

        /* --- Header --- */
        header {
            background-color: var(--header-bg);
            padding: 15px 0;
            box-shadow: 0 2px 5px var(--shadow-color);
            position: sticky; top: 0; z-index: 1000;
            border-bottom: 1px solid var(--border-color);
        }
        header .container { display: flex; justify-content: space-between; align-items: center; padding-top: 0; padding-bottom: 0; }
        .app-title { font-size: 1.6rem; font-weight: 700; color: var(--primary-color); }
        #theme-toggle { font-size: 1.3rem; background: none; border: none; color: var(--text-color); cursor: pointer; padding: 5px; border-radius: 50%; transition: background-color 0.2s;}
        #theme-toggle:hover { background-color: var(--table-row-hover); }

        /* --- Navegación / Pestañas --- */
        .tabs {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 5px;
        }
        .tab-link {
            padding: 12px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-bottom: -1px; /* Overlap bottom border */
            background-color: transparent;
            color: var(--secondary-color);
            font-size: 1rem;
            font-weight: 600;
            border-radius: 6px 6px 0 0;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            display: inline-flex; /* Align icon and text */
            align-items: center;
            gap: 8px;
        }
        .tab-link:hover {
             color: var(--primary-color);
             background-color: var(--table-row-hover);
        }
        .tab-link.active {
            background-color: var(--card-bg);
            border-color: var(--border-color);
            border-bottom-color: var(--card-bg); /* Hide bottom border part */
            color: var(--primary-color);
            font-weight: 700;
        }
        .tab-content {
            display: none;
            padding: 30px;
            border: 1px solid var(--border-color);
            border-top: none;
            background-color: var(--card-bg);
            border-radius: 0 0 6px 6px;
            box-shadow: 0 5px 15px var(--shadow-color);
        }
        .tab-content.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Formularios y Entradas --- */
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-color); font-size: 0.95rem;}
        input[type="text"], input[type="number"], input[type="file"], select, textarea {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid var(--input-border);
            border-radius: 6px;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        input:focus, select:focus, textarea:focus {
            border-color: var(--input-focus-border);
            outline: 0;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        input:disabled, select:disabled, textarea:disabled {
             background-color: var(--disabled-bg);
             color: var(--disabled-text);
             border-color: var(--disabled-border);
             cursor: not-allowed;
        }
        input[type="number"] { text-align: right; -moz-appearance: textfield; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { margin: 0; }
        input[type="file"] { padding: 8px; line-height: 1.5; } /* Adjust file input padding */
        .input-group { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
        .input-group label { margin-bottom: 0; font-weight: normal;}
        .input-group input[type="radio"] { width: auto; margin-right: 5px; }
        .input-small { width: 150px; display: inline-block; margin-left: 10px; }

        /* --- Tablas --- */
        .table-container { overflow-x: auto; margin-top: 25px; border: 1px solid var(--border-color); border-radius: 6px; }
        table { width: 100%; border-collapse: collapse; background-color: var(--card-bg); font-size: 0.9rem; }
        th, td {
            padding: 12px 15px;
            border: none;
            border-bottom: 1px solid var(--border-color);
            text-align: left;
            vertical-align: middle;
            white-space: nowrap;
        }
        th {
            background-color: var(--table-header-bg);
            font-weight: 600;
            position: sticky; top: 0; z-index: 10;
            border-bottom-width: 2px;
        }
        tbody tr:last-child td { border-bottom: none; }
        tbody tr:hover { background-color: var(--table-row-hover); }
        th:first-child, td:first-child { border-left: none; padding-left: 20px; /* More padding for first col */ }
        th:last-child, td:last-child { border-right: none; padding-right: 20px; /* More padding for last col */}

        /* Cell specific styles */
        td.real-month-cell { background-color: var(--real-month-bg) !important; /* Use important to override hover */ }
        td.estimated-month-cell { background-color: var(--estimated-month-bg) !important; }
        td.number-cell { text-align: right; font-variant-numeric: tabular-nums; }
        td.input-cell input { width: 100px; padding: 6px; font-size: 0.9rem; text-align: right; }
        td.input-cell input:disabled { background-color: transparent; border: none; color: var(--disabled-text);}
        .text-muted { color: var(--secondary-color); font-style: italic; font-size: 0.9em;}

        /* --- Tablas Desplegables --- */
        .collapsible-table tbody tr.rubro-total-row { font-weight: bold; cursor: pointer; background-color: var(--expandable-row-bg); transition: background-color 0.2s; }
        .collapsible-table tbody tr.rubro-total-row:hover { background-color: var(--clickable-row-hover); }
        .collapsible-table tbody tr.rubro-total-row td:first-child::before {
            content: '\f078'; /* fa-chevron-down */
            font-family: 'Font Awesome 6 Free'; font-weight: 900; margin-right: 12px; display: inline-block; transition: transform 0.2s ease-in-out; color: var(--primary-color);
        }
        .collapsible-table tbody tr.rubro-total-row.collapsed td:first-child::before { transform: rotate(-90deg); }
        .collapsible-table tbody tr.detail-row { display: table-row; background-color: var(--card-bg); transition: background-color 0.3s; }
        .collapsible-table tbody tr.detail-row.hidden { display: none; }
        .collapsible-table tbody tr.detail-row td { font-size: 0.85rem; color: var(--secondary-color); border-color: var(--border-color); }
        .collapsible-table tbody tr.detail-row td:first-child { padding-left: 40px; /* Indent details more */ }
        body.dark-mode .collapsible-table tbody tr.detail-row { background-color: #353535; }
        .collapsible-table tfoot tr { font-weight: bold; background-color: var(--table-header-bg); border-top: 2px solid var(--border-color); }

         /* Styles for Group/Ungroup All buttons */
        .table-actions {
            margin-bottom: 15px;
             display: flex;
             justify-content: flex-end; /* Align buttons to the right */
             gap: 10px;
             flex-wrap: wrap;
        }


        /* --- Componentes UI Específicos --- */
        #dashboard-summary { border-collapse: separate; border-spacing: 0; }
        #dashboard-summary th, #dashboard-summary td { text-align: center; white-space: normal; }
        #dashboard-summary tbody td, #dashboard-summary tfoot td { padding: 10px 8px; }
        #dashboard-summary .month-header { font-weight: bold; }

        .chart-container {
            margin-top: 35px; padding: 30px;
            background-color: var(--card-bg); border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-color);
            position: relative; min-height: 200px; /* Adjusted min height */
        }
        .chart-container canvas { max-width: 100%; height: 380px !important; }
        .chart-no-data { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--secondary-color); font-style: italic; font-size: 1.1rem; text-align: center; }

        #file-upload-area {
            border: 2px dashed var(--primary-color);
            padding: 45px; text-align: center; background-color: var(--bg-color);
            border-radius: 8px; margin-bottom: 25px; transition: background-color 0.2s ease, border-color 0.2s ease; cursor: pointer;
        }
        #file-upload-area:hover { background-color: var(--table-row-hover); border-color: var(--primary-color-darker); }
        #file-upload-area p { margin-bottom: 15px; font-size: 1.1rem; color: var(--secondary-color); }
        #file-upload-area i.fa-file-excel { font-size: 3rem; margin-bottom: 10px; color: var(--accent-color); }
        #file-upload-feedback { margin-top: 15px; font-weight: bold; white-space: pre-wrap; font-size: 0.95rem; min-height: 2em; }

        #reserve-fund-panel { margin-top: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 20px;} /* MODIFICADO: Usar grid como IPC */
        #reserve-fund-panel .month-config { /* Removed flex styles, grid handles layout */ padding: 0; border-radius: 0; background-color: transparent; transition: none; }
        #reserve-fund-panel .month-config label { width: 100%; margin-bottom: 5px; font-weight: 600;}
        #reserve-fund-panel .month-config input { width: 100%; }
        #reserve-fund-panel .month-config span { margin-left: 5px; color: var(--secondary-color); font-size: 0.9em; } /* Style the unit */


        .config-section {
            border: 1px solid var(--border-color); border-radius: 8px; padding: 25px;
            margin-bottom: 30px; background-color: var(--card-bg);
            box-shadow: 0 3px 7px var(--shadow-color);
        }
        .config-section h4 { border-bottom: 1px solid var(--border-color); padding-bottom: 0.6em; margin-bottom: 1.2em;}
        .management-list { list-style: none; padding: 0; max-height: 350px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 6px; padding: 10px; background-color: var(--bg-color); }
        body.dark-mode .management-list { background-color: #3a3f44; }
        .management-list li { display: flex; justify-content: space-between; align-items: center; padding: 10px 8px; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s; }
        .management-list li:last-child { border-bottom: none;}
        .management-list li:hover { background-color: var(--table-row-hover); }
        .management-list li span { flex-grow: 1; margin-right: 15px; font-weight: 500; }
        .management-list li select { width: 200px; font-size: 0.88rem; padding: 6px 8px; flex-shrink: 0; }
        .management-list li button { flex-shrink: 0; }

         /* Styles for the NEW Coefficient Editor */
         #coefficient-editor { margin-top: 25px; }
         #coefficient-editor h4 { margin-bottom: 15px;}
         #coefficient-values-editor {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); /* Similar grid to IPC */
             gap: 20px;
             padding: 20px; /* Add padding */
             border: 1px solid var(--border-color); /* Add border */
             border-radius: 6px; /* Add border-radius */
             background-color: var(--bg-color); /* Background like other lists/panels */
         }
         body.dark-mode #coefficient-values-editor { background-color: #3a3f44; }

         #coefficient-values-editor .form-group { margin-bottom: 0; } /* Adjust form-group margin inside grid */
         #coefficient-values-editor .form-group label { margin-bottom: 5px; font-weight: 600; width: 100%;} /* Adjust label */
         #coefficient-values-editor .form-group input { width: 100%; max-width: none; } /* Allow input to fill grid cell */
         #coefficient-values-editor .text-muted { grid-column: 1 / -1; text-align: center; padding: 20px; } /* Center and span info message */


        /* --- Snackbar --- */
        #snackbar {
            visibility: hidden; min-width: 300px; max-width: 90%;
            background-color: var(--success-color); /* Default to success */
            color: var(--button-text); text-align: center;
            border-radius: 6px; padding: 18px 25px; position: fixed; z-index: 1001;
            left: 50%; transform: translateX(-50%); bottom: 30px;
            font-size: 1.05rem; font-weight: 500;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            opacity: 0; transition: visibility 0s 0.5s, opacity 0.5s ease-out, bottom 0.5s ease-out;
        }
        #snackbar.show {
            visibility: visible; opacity: 1; bottom: 60px;
            transition: opacity 0.5s ease-in, bottom 0.5s ease-in;
        }
        #snackbar.error { background-color: var(--danger-color); color: var(--button-text); }
        #snackbar.warning { background-color: var(--warning-color); color: var(--button-warning-text); }
        #snackbar.info { background-color: var(--info-color); color: var(--button-text); }


        /* --- Footer --- */
        footer {
            margin-top: auto; padding: 20px 0; text-align: center; font-size: 0.95em;
            color: var(--secondary-color); background-color: var(--header-bg);
            border-top: 1px solid var(--border-color);
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 1200px) { .container { width: 98%; } .chart-container canvas { height: 320px !important; } }
        @media (max-width: 992px) {
             h1 { font-size: 2rem; } h2 { font-size: 1.6rem; } h3 { font-size: 1.3rem; }
             .tabs { justify-content: flex-start; }
             .tab-link { padding: 10px 18px; font-size: 0.95rem;}
             table { font-size: 0.88rem; } th,td {padding: 10px 12px;}
             .management-list li select { width: 150px; } /* Reduce select width */
        }
        @media (max-width: 768px) {
            body { line-height: 1.6; }
            .app-title { font-size: 1.3rem;} #theme-toggle { font-size: 1.1rem;}
            .chart-container { padding: 20px;} .chart-container canvas { height: 280px !important; }
            .input-group { flex-direction: column; align-items: stretch; gap: 10px;}
            .input-small { margin-left: 0; margin-top: 8px; width: 100%; }
            /* Adjust Reserve Fund and Coefficient Editor grid columns */
            #reserve-fund-panel, #coefficient-values-editor, #ipc-inputs { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px;}
            #reserve-fund-panel .month-config label { width: 100%; text-align: left; margin-bottom: 5px; }
            #reserve-fund-panel .month-config input { width: 100%; }
            table { font-size: 0.85rem; } th, td { padding: 9px 8px; white-space: normal; } /* Allow wrap */
            th:first-child, td:first-child { padding-left: 15px; }
            th:last-child, td:last-child { padding-right: 15px; }
            td.input-cell input { width: 80px; padding: 5px; }
            .management-list li { flex-wrap: wrap; gap: 8px; }
            .management-list li span { flex-basis: 100%; margin-right: 0; } /* Name takes full width */
            .management-list li select { width: calc(100% - 50px); margin-top: 5px; } /* Select almost full width */
            .management-list li button { margin-left: auto; } /* Push button right */
            button { font-size: 0.95rem; padding: 10px 18px;}
            .tabs { gap: 2px; }
            .tab-link { padding: 8px 10px; font-size: 0.85rem;}
             .table-actions { justify-content: center; }
        }
        @media (max-width: 576px) {
            h1 { font-size: 1.7rem; } .app-title { display: none; } header .container { justify-content: flex-end; }
            .tab-link { padding: 8px 10px; font-size: 0.85rem;}
            th, td { padding: 8px 6px; }
            th:first-child, td:first-child { padding-left: 10px; }
            th:last-child, td:last-child { padding-right: 10px; }
            .chart-container canvas { height: 220px !important; }
            #snackbar { min-width: 90%; bottom: 20px; font-size: 1rem; padding: 15px 20px; }
            #snackbar.show { bottom: 40px; }
            #file-upload-area { padding: 30px; }
            .management-list li select { width: 100%; } /* Select full width on smallest screens */
             /* Adjust Reserve Fund and Coefficient Editor grid columns */
             #reserve-fund-panel, #coefficient-values-editor, #ipc-inputs { grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px;}
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <span class="app-title">Proyección Expensas - El Centauro</span>
            <button id="theme-toggle" title="Cambiar tema"><i class="fas fa-moon"></i></button>
        </div>
    </header>

    <div class="container">
        <div class="tabs">
            <button class="tab-link active" onclick="openTab(event, 'dashboard')"><i class="fas fa-tachometer-alt"></i> Dashboard</button>
            <button class="tab-link" onclick="openTab(event, 'upload')"><i class="fas fa-upload"></i> Cargar Datos</button>
            <button class="tab-link" onclick="openTab(event, 'reserve')"><i class="fas fa-piggy-bank"></i> Fondo Reserva</button>
            <button class="tab-link" onclick="openTab(event, 'settings')"><i class="fas fa-cog"></i> Configuración</button>
            <button class="tab-link" onclick="openTab(event, 'reports')"><i class="fas fa-download"></i> Reportes</button>
        </div>

        <!-- ==================== DASHBOARD ==================== -->
        <div id="dashboard" class="tab-content active">
            <h2><i class="fas fa-tachometer-alt"></i> Dashboard Anual - <span id="dashboard-year"></span> (<span id="dashboard-scenario">Base</span>)</h2>
            <div class="form-group input-group">
                <label for="scenario-selector" style="flex-shrink: 0;">Escenario:</label>
                <select id="scenario-selector" style="flex-grow: 1;"></select>
                <button onclick="createScenario()" class="button-primary button-sm" title="Crear Escenario Nuevo"><i class="fas fa-plus"></i> Crear</button>
                <button onclick="cloneScenario()" class="button-secondary button-sm" title="Clonar Escenario Actual"><i class="fas fa-clone"></i> Clonar</button>
                <button onclick="deleteScenario()" class="button-danger button-sm" title="Eliminar Escenario Actual"><i class="fas fa-trash"></i> Eliminar</button>
                <button id="btnBorrarDatos" class="button-warning button-sm" title="Borrar Datos del Escenario Actual (Gastos, Ingresos, Status)" onclick="clearScenarioData()" ><i class="fas fa-broom"></i> Borrar Datos</button>
                <button onclick="recalculateEstimates()" class="button-info button-sm" title="Proyectar meses estimados basados en último mes real y coeficientes (acumulativo)"><i class="fas fa-calculator"></i> Calcular Estimados</button>
            </div>

            <h4>Resumen Mensual General</h4>
            <div class="table-container">
                <table id="dashboard-summary">
                    <thead>
                        <tr>
                            <th>Mes</th>
                            <th>Gasto ($)</th>
                            <th>Fondo ($)</th>
                            <th>Cuota s/Gs ($/UF)</th> <!-- Basado en Gasto+Fondo / UF -->
                            <th>IPC (%)</th>
                            <th>Cuota IPC ($/UF)</th>   <!-- NUEVO: Cuota s/Gs * (1 + IPC%) -->
                            <!-- MODIFICACIÓN INICIO - Encabezado de tabla -->
                            <th>Expensa Real ($/UF)</th> <!-- Ahora muestra el valor del rubro Expensas Ordinarias / UF -->
                            <!-- MODIFICACIÓN FIN -->
                        </tr>
                    </thead>
                    <tbody><!-- Contenido generado por JS --></tbody>
                    <tfoot><!-- Contenido generado por JS --></tfoot>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Detalle de Gastos Proyectados ($)</h4>
             <p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar los detalles. Las celdas mensuales de detalle se colorean según su origen: <span style="background-color: var(--real-month-bg); padding: 1px 4px; border-radius: 3px;">REAL</span> (cargado desde Excel con número) o <span style="background-color: var(--estimated-month-bg); padding: 1px 4px; border-radius: 3px;">ESTIMADO</span> (cargado sin número o proyectado/calculado).</p>

            <!-- Added Group/Ungroup Buttons for Gastos -->
            <div class="table-actions">
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('gastos', false)" title="Expandir todos los detalles de gastos"><i class="fas fa-expand"></i> Expandir Todo</button>
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('gastos', true)" title="Colapsar todos los detalles de gastos"><i class="fas fa-compress"></i> Colapsar Todo</button>
            </div>

            <div class="table-container">
                <table id="gastos-detail-table" class="collapsible-table">
                     <thead>
                        <tr>
                            <th>Rubro / Detalle</th>
                            <th>Coef. Aplicado</th> <!-- Add Coef. column header -->
                            <!-- Meses y Total Anual generados por JS -->
                         </tr>
                     </thead>
                     <tbody><!-- Contenido generado por JS --></tbody>
                     <tfoot><!-- Contenido generado por JS --></tfoot>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Detalle de Ingresos Proyectados ($)</h4>
             <p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar. Los valores aquí son la base de cálculo (valor individual o por UF). El Total de Ingresos en el Resumen General puede incluir la multiplicación por UF.</p>

             <!-- Added Group/Ungroup Buttons for Ingresos -->
             <div class="table-actions">
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('ingresos', false)" title="Expandir todos los detalles de ingresos"><i class="fas fa-expand"></i> Expandir Todo</button>
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('ingresos', true)" title="Colapsar todos los detalles de ingresos"><i class="fas fa-compress"></i> Colapsar Todo</button>
            </div>

            <div class="table-container">
                 <table id="ingresos-detail-table" class="collapsible-table">
                      <thead>
                         <tr>
                            <th>Rubro / Detalle</th>
                             <!-- Meses y Total Anual generados por JS -->
                         </tr>
                       </thead>
                      <tbody><!-- Contenido generado por JS --></tbody>
                      <tfoot><!-- Contenido generado por JS --></tfoot>
                 </table>
            </div>

            <div class="chart-container">
                 <h3>Evolutivo Expensa Mensual ($/UF)</h3> <!-- MODIFICADO -->
                 <canvas id="evolutivoCuotaChart"></canvas>
                 <div class="chart-no-data" style="display: none;">No hay datos suficientes para graficar.</div>
            </div>

            <div style="display: flex; gap: 25px; flex-wrap: wrap; margin-top: 35px;">
                <div class="chart-container" style="flex: 1; min-width: 320px;">
                    <h3>Participación Gastos (%)</h3>
                    <canvas id="participacionGastosChart"></canvas>
                    <div class="chart-no-data" style="display: none;">No hay datos de gastos<br>para mostrar el gráfico.</div>
                </div>
                <div class="chart-container" style="flex: 1; min-width: 320px;">
                    <h3>Participación Ingresos (%)</h3>
                    <canvas id="participacionIngresosChart"></canvas>
                    <div class="chart-no-data" style="display: none;">No hay datos de ingresos<br>para mostrar el gráfico.</div>
                </div>
            </div>
        </div>

        <!-- ==================== UPLOAD ==================== -->
        <div id="upload" class="tab-content">
            <h2><i class="fas fa-upload"></i> Cargar Datos Reales / Base</h2>
            <div class="form-group input-group">
                <label for="exercise-year">Año del Ejercicio:</label>
                <input type="number" id="exercise-year" min="2020" max="2099" value="2024" style="width: 120px;">
                <button onclick="createNewExercise()" class="button-success"><i class="fas fa-calendar-plus"></i> Crear/Seleccionar Año</button>
             </div>
            <p>Sube tu archivo Excel con las hojas <strong>"Gastos"</strong> e <strong>"Ingresos"</strong>. Los rubros nuevos se añadirán automáticamente a la sección de Configuración.</p>
            <p><strong>Importante:</strong>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>Las celdas con **números** en la hoja "Gastos" marcarán ese mes/detalle como '<strong style="color: var(--accent-color)">REAL</strong>' (fondo verde claro en detalle). Las celdas vacías o con texto se considerarán '<strong style="color: var(--warning-color)">ESTIMADO</strong>'.</li>
                    <li>Los rubros de Ingreso llamados "<strong id="cuota-rubro-name-info">Expensas Ordinarias</strong>" y "<strong>Expensas Extraordinarias</strong>" tendrán sus valores base multiplicados por la cantidad de UF (definida en Configuración) al calcular el *total* de ingresos en el Resumen General. La columna "Expensa Real ($/UF)" en el resumen muestra el valor del rubro "<strong id="cuota-rubro-name-info2">Expensas Ordinarias</strong>" <strong style="color: var(--primary-color)">dividido por la cantidad de UF</strong>.</li>
                </ul>
            </p>
            <div id="file-upload-area" onclick="document.getElementById('excel-file-input').click()">
                 <p><i class="fas fa-file-excel"></i><br>Arrastra tu archivo Excel aquí (.xlsx, .xls) o haz clic para seleccionar</p>
                 <input type="file" id="excel-file-input" accept=".xlsx, .xls" style="display: none;" onchange="handleFileUpload(this.files)">
                 <button type="button" class="button-primary" onclick="event.stopPropagation(); document.getElementById('excel-file-input').click()" style="pointer-events: auto;"><i class="fas fa-folder-open"></i> Seleccionar Archivo</button>
                 <button type="button" onclick="event.stopPropagation(); loadSampleData()" style="margin-left: 10px; pointer-events: auto;" class="button-secondary"><i class="fas fa-database"></i> Cargar Datos Ejemplo</button>
            </div>
            <div id="file-upload-feedback"></div>
            <a href="#" onclick="event.preventDefault(); downloadTemplate();" title="Descargar archivo Excel con estructura de ejemplo"><i class="fas fa-download"></i> Descargar Plantilla Ejemplo</a>
        </div>

        <!-- ==================== RESERVE FUND ==================== -->
        <div id="reserve" class="tab-content">
             <h2><i class="fas fa-piggy-bank"></i> Configurar Fondo de Reserva - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
             <div class="form-group">
                 <label>Método de Cálculo del Fondo:</label>
                 <div class="input-group">
                     <input type="radio" id="reserve-type-percent" name="reserve-type" value="percent" checked onchange="updateReserveUI()">
                     <label for="reserve-type-percent">Porcentaje (%) sobre Gastos Mensuales</label>
                     <input type="radio" id="reserve-type-fixed" name="reserve-type" value="fixed" onchange="updateReserveUI()">
                     <label for="reserve-type-fixed">Valor Fijo Mensual ($)</label>
                 </div>
             </div>
             <div id="reserve-fund-panel">
                 <!-- Inputs generados por JS -->
             </div>
             <button onclick="saveReserveFund()" style="margin-top: 25px; width: 100%; padding: 15px;" class="button-success button-lg" title="Guardar los valores mensuales y el tipo de cálculo del fondo">
                 <i class="fas fa-save"></i> GUARDAR FONDO DE RESERVA Y RECALCULAR
            </button>
        </div>

        <!-- ==================== SETTINGS ==================== -->
        <div id="settings" class="tab-content">
             <h2><i class="fas fa-cog"></i> Configuración General y de Cálculo</h2>

             <div class="config-section">
                 <h4><i class="fas fa-building"></i> Ajustes Generales del Barrio</h4>
                 <div class="form-group">
                     <label for="cantidad-unidades">Cantidad Total de Unidades Funcionales (UF):</label>
                     <input type="number" id="cantidad-unidades" min="1" value="100" style="width: 180px;" title="Número total de UF para calcular cuotas base">
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-list-alt"></i> Gestión de Rubros (Categorías)</h4>
                 <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                     <div style="flex: 1; min-width: 320px;">
                         <h5><i class="fas fa-arrow-down" style="color:var(--danger-color)"></i> Rubros de GASTOS</h5>
                         <div class="form-group input-group">
                             <input type="text" id="new-gasto-rubro-name" placeholder="Nombre nuevo rubro de gasto" style="flex-grow: 1;">
                             <button onclick="addRubro('gastos')" class="button-sm button-success" title="Añadir este nuevo rubro a la lista de gastos"><i class="fas fa-plus"></i> Añadir</button>
                         </div>
                         <ul id="gasto-rubro-list" class="management-list"></ul>
                     </div>
                     <div style="flex: 1; min-width: 320px;">
                          <h5><i class="fas fa-arrow-up" style="color:var(--success-color)"></i> Rubros de INGRESOS</h5>
                          <div class="form-group input-group">
                              <input type="text" id="new-ingreso-rubro-name" placeholder="Nombre nuevo rubro de ingreso" style="flex-grow: 1;">
                              <button onclick="addRubro('ingresos')" class="button-sm button-success" title="Añadir este nuevo rubro a la lista de ingresos"><i class="fas fa-plus"></i> Añadir</button>
                          </div>
                          <ul id="ingreso-rubro-list" class="management-list"></ul>
                     </div>
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-percentage"></i> Gestión de Coeficientes de Ajuste (para Gastos Estimados)</h4>
                 <p class="text-muted" style="font-size: 0.9em;">Define tipos de coeficientes (ej. Inflación, Aumento Gremial) y asigna uno a cada rubro de Gasto. Al usar "Calcular Estimados" en el Dashboard, el sistema proyectará los meses sin datos '<strong style="color: var(--accent-color)">REAL</strong>' (marcados en amarillo) multiplicando el último valor '<strong style="color: var(--accent-color)">REAL</strong>' por el coeficiente acumulado correspondiente a cada mes futuro.</p>
                 <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                     <div style="flex: 1; min-width: 280px;">
                         <h5>Tipos de Coeficientes Disponibles</h5>
                         <div class="form-group input-group">
                             <input type="text" id="new-coefficient-type-name" placeholder="Nuevo tipo (ej: Aumento Sindicato)" style="flex-grow: 1;">
                             <button onclick="addCoefficientType()" class="button-sm button-success" title="Añadir este nuevo tipo de coeficiente a la lista"><i class="fas fa-plus"></i> Añadir Tipo</button>
                         </div>
                         <ul id="coefficient-type-list" class="management-list"></ul>
                     </div>
                     <div id="coefficient-editor" style="flex: 2; min-width: 450px;">
                          <h5><i class="fas fa-edit"></i> Editar Valores Mensuales para: <span id="editing-coefficient-name" style="color: var(--primary-color); font-weight: bold;"></span></h5>
                           <!-- MODIFICACIÓN FIX: Reemplazar tabla por grid similar a IPC -->
                          <div id="coefficient-values-editor">
                              <p class="text-muted">Selecciona un tipo de coeficiente (que no sea "Sin Coeficiente" o "IPC") de la lista de la izquierda para editar sus valores porcentuales (%) mes a mes.</p>
                          </div>
                         <!-- END MODIFICACIÓN FIX -->
                     </div>
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-chart-line"></i> Índices IPC Mensuales de Referencia (%)</h4>
                 <p class="text-muted">Introduce el porcentaje (%) de IPC estimado o real para cada mes. Se usa únicamente para calcular la columna "Cuota IPC ($/UF)" como referencia en el Dashboard y está disponible como tipo de coeficiente ("IPC"). Sus valores son gestionados en esta sección y se reflejan en la lista de tipos de coeficientes.</p> <!-- MODIFICACIÓN FIX: Clarify IPC usage -->
                 <div id="ipc-inputs" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 20px;">
                     <!-- Inputs generados por JS -->
                 </div>
             </div>

             <button onclick="saveSettings()" style="margin-top: 20px; width: 100%; padding: 15px;" class="button-success button-lg" title="Guardar todos los cambios realizados en esta pestaña (UF, Rubros, Coeficientes, IPC) y recalcular el escenario actual">
                 <i class="fas fa-save"></i> GUARDAR TODA LA CONFIGURACIÓN Y RECALCULAR
             </button>
        </div>

        <!-- ==================== REPORTS ==================== -->
        <div id="reports" class="tab-content">
             <h2><i class="fas fa-download"></i> Descargar Reportes - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
             <p>Genera y descarga los datos del ejercicio y escenario actual en formato Excel, incluyendo detalles y resumen.</p>
             <button onclick="exportToExcel()" class="button-success" title="Descargar un archivo .xlsx con el detalle y resumen del escenario actual"><i class="fas fa-file-excel"></i> Descargar Reporte Completo (.xlsx)</button>

             <h3 style="margin-top: 35px;">Exportar Gráficos Individuales</h3>
             <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                 <button onclick="exportChart('evolutivoCuotaChart', 'evolutivo_expensa.png')" class="button-secondary" title="Descargar el gráfico de evolución de expensas como imagen PNG"><i class="fas fa-chart-line"></i> Gráfico Evolutivo (PNG)</button> <!-- MODIFICADO -->
                 <button onclick="exportChart('participacionGastosChart', 'participacion_gastos.png')" class="button-secondary" title="Descargar el gráfico de torta de gastos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Gastos (PNG)</button>
                 <button onclick="exportChart('participacionIngresosChart', 'participacion_ingresos.png')" class="button-secondary" title="Descargar el gráfico de torta de ingresos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Ingresos (PNG)</button>
             </div>
        </div>
    </div> <!-- /container -->

    <footer>
        <div class="container">
            &copy; <span id="footer-year"></span> Proyección Expensas El Centauro. v2.9 (Rubros Fix)
        </div>
    </footer>
    <div id="snackbar">Mensaje</div>

    <!-- ==================== SCRIPT PRINCIPAL ==================== -->
    <script>
        // --- Constantes y Estado Global ---
        const MONTHS = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
        const FULL_MONTHS = ["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"];
        const GASTOS_SHEET_NAME = "Gastos";
        const INGRESOS_SHEET_NAME = "Ingresos";
        const STORAGE_KEY = 'expensasAppCentauroState_v2.9_RubrosFix'; // Nueva version por corrección
        const CUOTA_RUBRO_NAME = "Expensas Ordinarias";
        const EXTRA_CUOTA_RUBRO_NAME = "Expensas Extraordinarias";
        const SPECIAL_INGRESO_RUBROS = [CUOTA_RUBRO_NAME, EXTRA_CUOTA_RUBRO_NAME];

        let appState = getDefaultAppState();

        let evolutivoCuotaChart_instance = null;
        let participacionGastosChart_instance = null;
        let participacionIngresosChart_instance = null;


        // --- Inicialización ---
        document.addEventListener('DOMContentLoaded', () => {
            // --- Limpieza de nodos de texto huérfanos (código visible encima del encabezado)
            while (document.body.firstChild && document.body.firstChild.nodeType === Node.TEXT_NODE) {
                // Elimina cualquier texto suelto que quede antes de <header>
                document.body.removeChild(document.body.firstChild);
            }

            console.log(`DOM Cargado. Inicializando App ${STORAGE_KEY}...`);
            loadState();
            initTheme();
            validateAndSetActiveScenario();

            const cuotaInfoSpan = document.getElementById('cuota-rubro-name-info');
            if (cuotaInfoSpan) cuotaInfoSpan.textContent = CUOTA_RUBRO_NAME;
            const cuotaInfoSpan2 = document.getElementById('cuota-rubro-name-info2');
            if (cuotaInfoSpan2) cuotaInfoSpan2.textContent = CUOTA_RUBRO_NAME;

            initUI();
            addEventListeners();
            updateUI();
            console.log(`App ${STORAGE_KEY} Inicializada.`);
        });

        // --- Validación y Selección de Escenario Activo ---
        function validateAndSetActiveScenario() {
            console.log("Iniciando validación de escenario activo...");
            let activeKeyIsValid = false;
            let fallbackNeeded = true;

            if (appState.activeScenarioKey && appState.scenarios && appState.scenarios[appState.activeScenarioKey]) {
                 const scenario = appState.scenarios[appState.activeScenarioKey];
                 const activeYear = parseInt(appState.activeScenarioKey.split('_')[0]);
                 if (!isNaN(activeYear) && scenario.year === activeYear) {
                    console.log(`Valid active scenario key found: ${appState.activeScenarioKey}`);
                   appState.currentYear = activeYear;
                   activeKeyIsValid = true;
                   fallbackNeeded = false;
                 } else {
                   console.warn(`Active scenario key "${appState.activeScenarioKey}" invalid: key year (${activeYear}) != stored year (${scenario?.year}) or scenario data corrupted.`);
                   appState.activeScenarioKey = null;
                 }
            } else if (appState.activeScenarioKey !== null) {
                 console.warn(`Active scenario key "${appState.activeScenarioKey}" is missing in scenarios object.`);
                 appState.activeScenarioKey = null;
            } else {
                console.log("No active scenario key was set.");
            }

            if (!activeKeyIsValid) {
                console.log(`Clave activa inválida o ausente. Buscando alternativa o creando base...`);
                const defaultYear = new Date().getFullYear();
                const defaultYearBaseKey = `${defaultYear}_Base`;
                const scenariosForCurrentYear = Object.keys(appState.scenarios || {}).filter(k => appState.scenarios[k]?.year === appState.currentYear); // Corrected to use scenario.year
                 const scenariosForDefaultYear = Object.keys(appState.scenarios || {}).filter(k => appState.scenarios[k]?.year === defaultYear); // Corrected

                let fallbackKey = null;

                 if (appState.scenarios?.[`${appState.currentYear}_Base`]) {
                     fallbackKey = `${appState.currentYear}_Base`;
                 }
                 else if (scenariosForCurrentYear.length > 0) {
                    fallbackKey = scenariosForCurrentYear.sort((a,b) => (appState.scenarios[a]?.scenarioName || '').localeCompare(appState.scenarios[b]?.scenarioName || ''))[0];
                 }
                 else if (appState.scenarios?.[defaultYearBaseKey]) {
                    fallbackKey = defaultYearBaseKey;
                 }
                 else if (scenariosForDefaultYear.length > 0) {
                     fallbackKey = scenariosForDefaultYear.sort((a,b) => (appState.scenarios[a]?.scenarioName || '').localeCompare(appState.scenarios[b]?.scenarioName || ''))[0];
                 }
                else {
                    const allScenarioKeys = Object.keys(appState.scenarios || {}).sort((a,b) => a.localeCompare(b));
                    if (allScenarioKeys.length > 0 && appState.scenarios[allScenarioKeys[0]]) {
                         fallbackKey = allScenarioKeys[0];
                    }
                 }

                if (fallbackKey && appState.scenarios?.[fallbackKey]) {
                    console.log(`Cambiando a escenario de fallback: ${fallbackKey}`);
                    appState.activeScenarioKey = fallbackKey;
                     appState.currentYear = appState.scenarios[fallbackKey].year || parseInt(fallbackKey.split('_')[0]) || defaultYear;
                    fallbackNeeded = false;
                }
            }

            if (fallbackNeeded) {
                console.log("No se encontraron escenarios válidos. Creando escenario Base para el año actual.");
                const defaultYear = new Date().getFullYear();
                appState.currentYear = defaultYear;
                initScenarioData(appState.currentYear, 'Base');
                appState.activeScenarioKey = `${appState.currentYear}_Base`;
                 console.log(`Escenario "${appState.activeScenarioKey}" creado.`);
            }

             const currentScenario = getCurrentScenarioData();
             if (currentScenario) {
                 console.log(`Escenario activo final: ${appState.activeScenarioKey}. Año: ${appState.currentYear}`);
                initializeScenarioDataForRubros(currentScenario);
                 ensureDefaultCoefficientTypes();
             } else {
                 console.error("validateAndSetActiveScenario: Algo falló críticamente. No se pudo establecer un escenario activo válido.");
             }

             saveState();
             console.log("Validación de escenario activo completada.");
        }

        function ensureDefaultCoefficientTypes() {
              const defaultTypes = getDefaultAppState().settings.coefficientTypes;
             appState.settings.coefficientTypes = appState.settings.coefficientTypes || {};

             for (const key in defaultTypes) {
                 if (!appState.settings.coefficientTypes[key]) {
                     console.log(`Adding missing default coefficient type: ${key}`);
                     appState.settings.coefficientTypes[key] = JSON.parse(JSON.stringify(defaultTypes[key]));
                 } else {
                      appState.settings.coefficientTypes[key].isDefault = defaultTypes[key].isDefault ?? false;
                     if (key === 'IPC') {
                          const manualIPC = appState.settings.ipcManual;
                          if (!Array.isArray(manualIPC) || manualIPC.length !== 12) {
                               console.warn("ipcManual array invalid during default coef type sync. Resetting.");
                               appState.settings.ipcManual = Array(12).fill(0);
                          }
                           appState.settings.coefficientTypes[key].values = [...appState.settings.ipcManual.map(v => parseFloat(v||0))];
                           console.log(`Synced IPC coefficient values with ipcManual array.`);
                      } else if (key === 'None') {
                         appState.settings.coefficientTypes[key].values = Array(12).fill(1);
                      } else if (Array.isArray(appState.settings.coefficientTypes[key].values) && appState.settings.coefficientTypes[key].values.length === 12) {
                           appState.settings.coefficientTypes[key].values = appState.settings.coefficientTypes[key].values.map(val => {
                                const numVal = parseFloat(val);
                                return (!isNaN(numVal) && numVal >= -100) ? numVal : 0;
                           });
                      } else {
                          console.warn(`Coefficient type "${key}" has invalid values array structure.`);
                          appState.settings.coefficientTypes[key].values = Array(12).fill(0);
                      }
                 }
             }
         }

        // --- Gestión de Datos del Escenario ---
        function getCurrentScenarioData() {
             if (appState.activeScenarioKey && appState.scenarios && appState.scenarios[appState.activeScenarioKey] && appState.scenarios[appState.activeScenarioKey].year !== undefined) {
                 return appState.scenarios[appState.activeScenarioKey];
             }
             console.warn("getCurrentScenarioData: No valid active scenario found in current state. Attempting validation.");
             validateAndSetActiveScenario();
             return appState.scenarios?.[appState.activeScenarioKey] || null;
        }

        function initScenarioData(year, scenarioName = 'Base') {
             if (typeof year !== 'number' || year < 2000 || year > 2099) {
                  console.error(`initScenarioData: Año inválido "${year}". Usando año actual como fallback.`);
                  year = new Date().getFullYear();
             }
             const key = `${year}_${scenarioName.replace(/\s+/g, '_').replace(/[^\w-]/g, '')}`;

             if (appState.scenarios[key]) {
                 console.warn(`initScenarioData: Escenario "${key}" ya existe. No se inicializa de nuevo.`);
                return appState.scenarios[key];
             }

            console.log(`Inicializando nuevo escenario: ${key}`);
             const defaultScenarioTemplate = getDefaultAppState().BaseScenarioStructureTemplate;
             appState.scenarios[key] = JSON.parse(JSON.stringify(defaultScenarioTemplate));
            appState.scenarios[key].year = year;
            appState.scenarios[key].scenarioName = scenarioName;
            initializeScenarioDataForRubros(appState.scenarios[key]);
             return appState.scenarios[key];
        }

        function initializeScenarioDataForRubros(scenarioData) {
             if (!scenarioData || typeof scenarioData !== 'object' || scenarioData.year === undefined) {
                console.error("initializeScenarioDataForRubros llamado con datos de escenario inválidos.");
                return;
             }
            console.log(`Initializing structures for scenario ${scenarioData.year}_${scenarioData.scenarioName} based on global settings...`);

             scenarioData.rubroOrder = scenarioData.rubroOrder ?? { gastos: [], ingresos: [] };
             scenarioData.rubroOrder.gastos = Array.isArray(scenarioData.rubroOrder.gastos) ? scenarioData.rubroOrder.gastos : [];
             scenarioData.rubroOrder.ingresos = Array.isArray(scenarioData.rubroOrder.ingresos) ? scenarioData.rubroOrder.ingresos : [];

             scenarioData.data = scenarioData.data ?? { gastos: {}, ingresos: {} };
             scenarioData.data.gastos = scenarioData.data.gastos ?? {};
             scenarioData.data.ingresos = scenarioData.data.ingresos ?? {};

             scenarioData.monthStatus = scenarioData.monthStatus ?? { gastos: {}, ingresos: {} };
             scenarioData.monthStatus.gastos = scenarioData.monthStatus.gastos ?? {};

             scenarioData.reserveFund = scenarioData.reserveFund ?? { type: 'percent', values: Array(12).fill(5) };
              scenarioData.reserveFund.values = (Array.isArray(scenarioData.reserveFund.values) && scenarioData.reserveFund.values.length === 12)
                                                 ? scenarioData.reserveFund.values.map(v => parseFloat(v||0)) : Array(12).fill(scenarioData.reserveFund.type === 'fixed' ? 0 : 5);

             scenarioData.calculated = scenarioData.calculated ?? {};
             const defaultCalcTemplate = getDefaultAppState().BaseScenarioStructureTemplate?.calculated || {};

             for(const key in defaultCalcTemplate) {
                 if(scenarioData.calculated[key] === undefined || scenarioData.calculated[key] === null) {
                     if (Array.isArray(defaultCalcTemplate[key])) {
                          scenarioData.calculated[key] = Array(12).fill(0);
                     } else if (typeof defaultCalcTemplate[key] === 'object' && defaultCalcTemplate[key] !== null) {
                         scenarioData.calculated[key] = {};
                     } else {
                         scenarioData.calculated[key] = defaultCalcTemplate[key];
                     }
                 } else if (Array.isArray(scenarioData.calculated[key]) && scenarioData.calculated[key].length !== 12) {
                      console.warn(`Calculated array "${key}" in scenario ${scenarioData.scenarioName} has wrong length (${scenarioData.calculated[key].length}). Resetting to 12 zeros.`);
                     scenarioData.calculated[key] = Array(12).fill(0);
                 }
             }

              scenarioData.calculated.annualTotals = scenarioData.calculated.annualTotals ?? {};
              scenarioData.calculated.annualTotals.gastos = scenarioData.calculated.annualTotals.gastos ?? { __TOTAL__: 0 };
              scenarioData.calculated.annualTotals.ingresos = scenarioData.calculated.annualTotals.ingresos ?? { __TOTAL__: 0 };

             if (!Array.isArray(scenarioData.calculated.ipcManual) || scenarioData.calculated.ipcManual.length !== 12) {
                console.warn(`Scenario ${scenarioData.year}-${scenarioData.scenarioName} IPC snapshot invalid. Copying from settings.`);
                scenarioData.calculated.ipcManual = [...(appState.settings?.ipcManual || Array(12).fill(0))];
             } else {
                  scenarioData.calculated.ipcManual = scenarioData.calculated.ipcManual.map(v => parseFloat(v||0));
             }

             ['gastos', 'ingresos'].forEach(type => {
                 const globalRubros = (appState.settings && appState.settings.rubros && Array.isArray(appState.settings.rubros[type]))
                                    ? appState.settings.rubros[type]
                                    : [];
                 globalRubros.forEach(rubro => {
                      if (!scenarioData.data[type][rubro]) {
                           scenarioData.data[type][rubro] = { detailOrder: [], detailsData: {} };
                      }
                       scenarioData.data[type][rubro].detailOrder = Array.isArray(scenarioData.data[type][rubro].detailOrder) ? scenarioData.data[type][rubro].detailOrder : [];
                       scenarioData.data[type][rubro].detailsData = typeof scenarioData.data[type][rubro].detailsData === 'object' && scenarioData.data[type][rubro].detailsData !== null ? scenarioData.data[type][rubro].detailsData : {};

                       if (type === 'gastos') {
                           scenarioData.monthStatus[type][rubro] = typeof scenarioData.monthStatus[type][rubro] === 'object' && scenarioData.monthStatus[type][rubro] !== null ? scenarioData.monthStatus[type][rubro] : {};
                       }

                      if (type === 'gastos') {
                           scenarioData.calculated.gastoAjustado[rubro] = scenarioData.calculated.gastoAjustado[rubro] ?? {};
                           scenarioData.calculated.totalGastoRubroMes[rubro] = Array.isArray(scenarioData.calculated.totalGastoRubroMes[rubro]) && scenarioData.calculated.totalGastoRubroMes[rubro].length === 12 ? scenarioData.calculated.totalGastoRubroMes[rubro].map(v=>parseFloat(v||0)) : Array(12).fill(0);
                       } else {
                           scenarioData.calculated.ingresoAjustado[rubro] = scenarioData.calculated.ingresoAjustado[rubro] ?? {};
                           scenarioData.calculated.totalIngresoRubroMes[rubro] = Array.isArray(scenarioData.calculated.totalIngresoRubroMes[rubro]) && scenarioData.calculated.totalIngresoRubroMes[rubro].length === 12 ? scenarioData.calculated.totalIngresoRubroMes[rubro].map(v=>parseFloat(v||0)) : Array(12).fill(0);
                       }
                       scenarioData.calculated.annualTotals[type][rubro] = scenarioData.calculated.annualTotals[type][rubro] ?? 0;

                     const detailOrder = scenarioData.data[type][rubro].detailOrder;
                     Object.keys(scenarioData.data[type][rubro].detailsData).forEach(detail => {
                           if (!detailOrder.includes(detail)) {
                               console.warn(`Detail "${detail}" for ${type}/${rubro} found in data but not order. Adding to order.`);
                               detailOrder.push(detail);
                           }
                          if(scenarioData.data[type][rubro].detailsData[detail] === undefined || !Array.isArray(scenarioData.data[type][rubro].detailsData[detail]) || scenarioData.data[type][rubro].detailsData[detail].length !== 12) {
                               console.warn(`Detail data for ${type}/${rubro}/${detail} invalid length/type. Resetting to 12 zeros.`);
                               scenarioData.data[type][rubro].detailsData[detail] = Array(12).fill(0);
                           } else {
                                scenarioData.data[type][rubro].detailsData[detail] = scenarioData.data[type][rubro].detailsData[detail].map(v => parseFloat(v||0));
                           }
                           if (type === 'gastos') {
                                if (scenarioData.monthStatus[type][rubro]?.[detail] === undefined || !Array.isArray(scenarioData.monthStatus[type][rubro][detail]) || scenarioData.monthStatus[type][rubro][detail].length !== 12) {
                                    console.warn(`Detail status for ${type}/${rubro}/${detail} invalid length/type. Resetting to 12 'Estimado'.`);
                                   scenarioData.monthStatus[type][rubro][detail] = Array(12).fill('Estimado');
                               } else {
                                   scenarioData.monthStatus[type][rubro][detail] = scenarioData.monthStatus[type][rubro][detail].map(s => String(s || 'Estimado'));
                                }
                           }
                           if (type === 'gastos') scenarioData.calculated.gastoAjustado[rubro][detail] = Array.isArray(scenarioData.calculated.gastoAjustado[rubro][detail]) && scenarioData.calculated.gastoAjustado[rubro][detail].length === 12 ? scenarioData.calculated.gastoAjustado[rubro][detail].map(v=>parseFloat(v||0)) : Array(12).fill(0);
                           else scenarioData.calculated.ingresoAjustado[rubro][detail] = Array.isArray(scenarioData.calculated.ingresoAjustado[rubro][detail]) && scenarioData.calculated.ingresoAjustado[rubro][detail].length === 12 ? scenarioData.calculated.ingresoAjustado[rubro][detail].map(v=>parseFloat(v||0)) : Array(12).fill(0);
                       });
                 });

                ['gastos', 'ingresos'].forEach(type => {
                   const globalRubrosForType = (appState.settings && appState.settings.rubros && Array.isArray(appState.settings.rubros[type]))
                                        ? appState.settings.rubros[type]
                                        : [];
                   const scenarioRubrosInData = Object.keys(scenarioData.data[type] || {});
                   scenarioRubrosInData.forEach(rubro => {
                       if (!globalRubrosForType.includes(rubro)) {
                            console.warn(`Rubro "${rubro}" exists in scenario.data[${type}] but not in global settings. Removing from scenario data.`);
                           delete scenarioData.data[type][rubro];
                           if (type === 'gastos') delete scenarioData.monthStatus[type][rubro];
                       }
                   });
                     scenarioData.rubroOrder[type] = scenarioData.rubroOrder[type].filter(rubro => globalRubrosForType.includes(rubro));
                });
             });
            console.log(`Initialization for ${scenarioData.scenarioName} completed.`);
         }


        // --- Lógica de Negocio y Cálculos ---
        function calculateAll(scenarioData) {
             console.log(`Recalculando TODO para: ${scenarioData?.year} - ${scenarioData?.scenarioName}`);
             if (!scenarioData) { console.error("CalculateAll: No scenario data provided."); renderEmptyState(); return; }

             initializeScenarioDataForRubros(scenarioData);

             const { data, monthStatus, reserveFund } = scenarioData;
             const { settings } = appState;
             const { rubroConfig, coefficientTypes, cantidadUnidades } = settings;
             const calculated = scenarioData.calculated;

             if (Array.isArray(settings.ipcManual) && settings.ipcManual.length === 12) {
                 calculated.ipcManual = [...settings.ipcManual.map(v=>parseFloat(v||0))];
             } else {
                  console.warn("Global settings.ipcManual array invalid. Using 12 zeros for scenario snapshot.");
                 calculated.ipcManual = Array(12).fill(0);
             }

             calculated.gastoAjustado = {}; calculated.totalGastoRubroMes = {}; calculated.totalGastoProyectadoMes = Array(12).fill(0);
             calculated.ingresoAjustado = {}; calculated.totalIngresoRubroMes = {}; calculated.totalIngresoProyectadoMes = Array(12).fill(0);
             calculated.fondoReservaMes = Array(12).fill(0);
             calculated.cuotaSobreGastosMes = Array(12).fill(0);
             calculated.cuotaIpcMes = Array(12).fill(0);
             calculated.cuotaRealBaseMes = Array(12).fill(0);

             calculated.annualTotals = calculated.annualTotals ?? { gastos: {}, ingresos: {}, fondoReserva: 0, cuotaSobreGastos: 0, cuotaIpc: 0, cuotaRealBase: 0 };
             calculated.annualTotals.gastos = calculated.annualTotals.gastos ?? { __TOTAL__: 0 };
             calculated.annualTotals.ingresos = calculated.annualTotals.ingresos ?? { __TOTAL__: 0 };
             calculated.annualTotals.gastos.__TOTAL__ = 0;
             calculated.annualTotals.ingresos.__TOTAL__ = 0;
             calculated.annualTotals.fondoReserva = 0;
             calculated.annualTotals.cuotaSobreGastos = 0;
             calculated.annualTotals.cuotaIpc = 0;
             calculated.annualTotals.cuotaRealBase = 0;

            const globalGastosRubros = (settings && settings.rubros && Array.isArray(settings.rubros.gastos)) ? settings.rubros.gastos : [];
            const gastoRubros = (Array.isArray(scenarioData.rubroOrder?.gastos) && scenarioData.rubroOrder.gastos.length > 0)
                                ? scenarioData.rubroOrder.gastos.filter(rubro => globalGastosRubros.includes(rubro) && data.gastos?.[rubro]?.detailsData)
                                : (globalGastosRubros || []).filter(rubro => data.gastos?.[rubro]?.detailsData);

             gastoRubros.forEach(rubro => {
                 if (!data.gastos || !data.gastos[rubro] || !data.gastos[rubro].detailsData) {
                    console.warn(`Data missing for gasto rubro "${rubro}" filtered for calculation.`);
                    return;
                 }
                 calculated.gastoAjustado[rubro] = {};
                 calculated.totalGastoRubroMes[rubro] = Array(12).fill(0);
                 calculated.annualTotals.gastos[rubro] = 0;

                 const detailOrder = (Array.isArray(data.gastos[rubro].detailOrder) && data.gastos[rubro].detailOrder.length > 0)
                                     ? data.gastos[rubro].detailOrder.filter(detail => data.gastos[rubro].detailsData?.[detail] !== undefined && Array.isArray(data.gastos[rubro].detailsData[detail]) && data.gastos[rubro].detailsData[detail].length === 12)
                                     : Object.keys(data.gastos[rubro].detailsData || {}).filter(detail => Array.isArray(data.gastos[rubro].detailsData[detail]) && data.gastos[rubro].detailsData[detail].length === 12);

                  if (detailOrder.length === 0) {
                     console.warn(`No valid detail data found for gasto rubro "${rubro}". Skipping calculation for this rubro.`);
                     return;
                  }

                 const rubroCoefConfig = rubroConfig[rubro] || {};
                 const coefTypeKey = rubroCoefConfig.coefficientType || 'None';
                 const currentCoefficientType = coefficientTypes[coefTypeKey];
                 const rawCoefValues = currentCoefficientType?.values;
                 const monthlyMultipliers = Array(12).fill(1);

                 if (currentCoefficientType && coefTypeKey !== 'None' && Array.isArray(rawCoefValues) && rawCoefValues.length === 12) {
                      for(let i = 0; i < 12; i++) {
                           const percentage = parseFloat(rawCoefValues[i] || 0);
                            if (!isNaN(percentage)) {
                               monthlyMultipliers[i] = 1 + percentage / 100;
                            } else {
                                console.warn(`Coef type "${coefTypeKey}", month ${MONTHS[i]}: Invalid percentage value "${rawCoefValues[i]}". Using 0% (multiplier 1).`);
                            }
                      }
                 }

                 detailOrder.forEach(detail => {
                     const sourceDetailValues = Array.isArray(data.gastos[rubro]?.detailsData?.[detail]) && data.gastos[rubro].detailsData[detail].length === 12
                                       ? data.gastos[rubro].detailsData[detail].map(v => parseFloat(v || 0))
                                       : Array(12).fill(0);
                      const adjustedDetailValues = sourceDetailValues.map((value, index) => value * (monthlyMultipliers[index] ?? 1));
                     calculated.gastoAjustado[rubro][detail] = adjustedDetailValues;
                     for (let i = 0; i < 12; i++) {
                          calculated.totalGastoRubroMes[rubro][i] += (adjustedDetailValues[i] || 0);
                     }
                 });
                 for (let i = 0; i < 12; i++) {
                     const monthTotalRubro = calculated.totalGastoRubroMes[rubro]?.[i] || 0;
                     calculated.totalGastoProyectadoMes[i] += monthTotalRubro;
                 }
                 calculated.annualTotals.gastos[rubro] = calculated.totalGastoRubroMes[rubro].reduce((a, b) => a + (b || 0), 0);
             });
             calculated.annualTotals.gastos.__TOTAL__ = calculated.totalGastoProyectadoMes.reduce((a, b) => a + (b || 0), 0);

             const unidades = parseInt(cantidadUnidades) || 1;
             const unidadesForCuotaReal = unidades > 0 ? unidades : 1;

            const globalIngresosRubros = (settings && settings.rubros && Array.isArray(settings.rubros.ingresos)) ? settings.rubros.ingresos : [];
             const ingresoRubros = (Array.isArray(scenarioData.rubroOrder?.ingresos) && scenarioData.rubroOrder.ingresos.length > 0)
                                   ? scenarioData.rubroOrder.ingresos.filter(rubro => globalIngresosRubros.includes(rubro) && data.ingresos?.[rubro]?.detailsData)
                                   : (globalIngresosRubros || []).filter(rubro => data.ingresos?.[rubro]?.detailsData);

             ingresoRubros.forEach(rubro => {
                  if (!data.ingresos || !data.ingresos[rubro] || !data.ingresos[rubro].detailsData) return;
                 calculated.ingresoAjustado[rubro] = {};
                 calculated.totalIngresoRubroMes[rubro] = Array(12).fill(0);
                 calculated.annualTotals.ingresos[rubro] = 0;

                 const detailOrder = (Array.isArray(data.ingresos[rubro].detailOrder) && data.ingresos[rubro].detailOrder.length > 0)
                                     ? data.ingresos[rubro].detailOrder.filter(detail => data.ingresos[rubro].detailsData?.[detail] !== undefined && Array.isArray(data.ingresos[rubro].detailsData[detail]) && data.ingresos[rubro].detailsData[detail].length === 12)
                                     : Object.keys(data.ingresos[rubro].detailsData || {}).filter(detail => Array.isArray(data.ingresos[rubro].detailsData[detail]) && data.ingresos[rubro].detailsData[detail].length === 12);

                  if (detailOrder.length === 0) {
                     console.warn(`No valid detail data found for ingreso rubro "${rubro}". Skipping calculation for this rubro.`);
                     return;
                  }

                 detailOrder.forEach(detail => {
                      const baseValues = Array.isArray(data.ingresos[rubro]?.detailsData?.[detail]) && data.ingresos[rubro].detailsData[detail].length === 12
                                         ? data.ingresos[rubro].detailsData[detail].map(v => parseFloat(v || 0))
                                         : Array(12).fill(0);
                     calculated.ingresoAjustado[rubro][detail] = baseValues;
                     for (let i = 0; i < 12; i++) {
                          const detailFinalMonthly = SPECIAL_INGRESO_RUBROS.includes(rubro)
                                                    ? baseValues[i] * unidades
                                                    : baseValues[i];
                           calculated.totalIngresoRubroMes[rubro][i] += (detailFinalMonthly || 0);
                     }
                 });
                 for (let i = 0; i < 12; i++) {
                     const monthTotalRubroFinal = calculated.totalIngresoRubroMes[rubro]?.[i] || 0;
                     calculated.totalIngresoProyectadoMes[i] += monthTotalRubroFinal;
                 }
                 calculated.annualTotals.ingresos[rubro] = calculated.totalIngresoRubroMes[rubro].reduce((a, b) => a + (b || 0), 0);
             });
             calculated.annualTotals.ingresos.__TOTAL__ = calculated.totalIngresoProyectadoMes.reduce((a, b) => a + (b || 0), 0);

             if (unidadesForCuotaReal <= 0) {
                 calculated.cuotaRealBaseMes = Array(12).fill(0);
             } else if (calculated.totalIngresoRubroMes?.[CUOTA_RUBRO_NAME]) {
                 calculated.cuotaRealBaseMes = Array(12);
                 for (let i = 0; i < 12; i++) {
                     const totalRubroMes = calculated.totalIngresoRubroMes[CUOTA_RUBRO_NAME][i] || 0;
                     calculated.cuotaRealBaseMes[i] = totalRubroMes / unidadesForCuotaReal;
                 }
             } else {
                 calculated.cuotaRealBaseMes = Array(12).fill(0);
             }
             calculated.annualTotals.cuotaRealBase = calculated.cuotaRealBaseMes.reduce((a,b)=>a+(b||0),0);

             const reserveFundData = scenarioData.reserveFund ?? getDefaultAppState().BaseScenarioStructureTemplate.reserveFund;
             const reserveValues = (Array.isArray(reserveFundData.values) && reserveFundData.values.length === 12)
                                     ? reserveFundData.values.map(v => parseFloat(v || 0)) : Array(12).fill(reserveFundData.type === 'fixed' ? 0 : 5);
             const reserveType = reserveFundData.type === 'fixed' ? 'fixed' : 'percent';

             calculated.fondoReservaMes = Array(12);
             for (let i = 0; i < 12; i++) {
                 const reserveValueInput = reserveValues[i];
                 calculated.fondoReservaMes[i] = reserveType === 'percent'
                     ? (calculated.totalGastoProyectadoMes[i] || 0) * (reserveValueInput / 100)
                     : (reserveValueInput || 0);
             }
             calculated.annualTotals.fondoReserva = calculated.fondoReservaMes.reduce((a, b) => a + (b || 0), 0);

             calculated.cuotaSobreGastosMes = Array(12);
             for (let i = 0; i < 12; i++) {
                 const totalGastoYFondo = (calculated.totalGastoProyectadoMes[i] || 0) + (calculated.fondoReservaMes[i] || 0);
                 calculated.cuotaSobreGastosMes[i] = unidadesForCuotaReal > 0 ? totalGastoYFondo / unidadesForCuotaReal : 0;
             }
             calculated.annualTotals.cuotaSobreGastos = calculated.cuotaSobreGastosMes.reduce((a,b)=>a+(b||0),0);

             const ipcSnapshot = (Array.isArray(calculated.ipcManual) && calculated.ipcManual.length === 12)
                                  ? calculated.ipcManual.map(v => parseFloat(v || 0)) : Array(12).fill(0);
             calculated.cuotaIpcMes = Array(12).fill(0);
             const baseEneroCuotaReal = (calculated.cuotaRealBaseMes?.[0] || 0);
             if (baseEneroCuotaReal > 0) {
                  let accumulatedMultiplier = 1;
                  for (let i = 0; i < 12; i++) {
                     const monthlyIPC = ipcSnapshot[i];
                      const monthlyIPCMultiplier = (!isNaN(monthlyIPC) && monthlyIPC >= 0) ? (1 + monthlyIPC / 100) : 1;
                     accumulatedMultiplier *= monthlyIPCMultiplier;
                     calculated.cuotaIpcMes[i] = baseEneroCuotaReal * accumulatedMultiplier;
                  }
             }
             calculated.annualTotals.cuotaIpc = calculated.cuotaIpcMes.reduce((a, b) => a + (b || 0), 0);

             console.log("Recálculo Finalizado.", calculated);
             saveState();
             updateUI();
             showSnackbar("Cálculos actualizados correctamente.", false, 'success');
        }


        // --- Recalcular Estimados (ACUMULATIVO) ---
        function recalculateEstimates() {
            const scenarioData = getCurrentScenarioData();
            if (!scenarioData) { showSnackbar("No hay escenario activo para calcular estimados.", true, 'error'); return; }
            console.log(`Calculando estimados (Acumulativo) para: ${scenarioData.scenarioName}`);

            const { data, monthStatus, rubroOrder } = scenarioData;
            const { settings } = appState;
            const { rubroConfig, coefficientTypes } = settings; // Removed 'rubros' here, use 'settings.rubros'
            let changesMade = false;
            let projectedCellCount = 0;

            const globalGastosRubros = (settings && settings.rubros && Array.isArray(settings.rubros.gastos)) ? settings.rubros.gastos : [];
            const gastoRubrosToProcess = (Array.isArray(rubroOrder?.gastos) && rubroOrder.gastos.length > 0)
                                          ? rubroOrder.gastos.filter(rubro => globalGastosRubros.includes(rubro) && data.gastos?.[rubro]?.detailsData)
                                          : (globalGastosRubros || []).filter(rubro => data.gastos?.[rubro]?.detailsData);

            if (gastoRubrosToProcess.length === 0) {
                 showSnackbar("No hay rubros de gasto definidos o con datos cargados para proyectar.", false, 'info', 3000);
                 return;
            }
             let totalDetailsProcessed = 0;

            gastoRubrosToProcess.forEach(rubro => {
                if (!data.gastos || !data.gastos[rubro] || !data.gastos[rubro].detailsData) return;

                const detailOrder = (Array.isArray(data.gastos[rubro].detailOrder) && data.gastos[rubro].detailOrder.length > 0)
                                     ? data.gastos[rubro].detailOrder.filter(detail => data.gastos[rubro].detailsData?.[detail] !== undefined && Array.isArray(data.gastos[rubro].detailsData[detail]) && data.gastos[rubro].detailsData[detail].length === 12)
                                     : Object.keys(data.gastos[rubro].detailsData || {}).filter(detail => Array.isArray(data.gastos[rubro].detailsData[detail]) && data.gastos[rubro].detailsData[detail].length === 12);

                 if (detailOrder.length === 0) return;
                totalDetailsProcessed += detailOrder.length;

                const rubroCoefConfig = rubroConfig[rubro] || {};
                const coefTypeKey = rubroCoefConfig.coefficientType || 'None';
                const currentCoefficientType = coefficientTypes[coefTypeKey];
                 const rawCoefValues = currentCoefficientType?.values;
                 const monthlyMultipliers = Array(12).fill(1);

                 if (currentCoefficientType && coefTypeKey !== 'None' && Array.isArray(rawCoefValues) && rawCoefValues.length === 12) {
                      for(let i = 0; i < 12; i++) {
                           const percentage = parseFloat(rawCoefValues[i] || 0);
                            if (!isNaN(percentage)) {
                               monthlyMultipliers[i] = 1 + percentage / 100;
                            } else {
                                console.warn(`Coef type "${coefTypeKey}", month ${MONTHS[i]}: Invalid percentage value "${rawCoefValues[i]}" during estimate calculation. Using 0% (multiplier 1).`);
                            }
                      }
                 }

                detailOrder.forEach(detail => {
                    const currentStatuses = (monthStatus.gastos && monthStatus.gastos[rubro]?.[detail] && Array.isArray(monthStatus.gastos[rubro][detail]) && monthStatus.gastos[rubro][detail].length === 12)
                                            ? monthStatus.gastos[rubro][detail]
                                            : Array(12).fill('Estimado');
                    const currentDataValues = Array.isArray(data.gastos[rubro]?.detailsData?.[detail]) && data.gastos[rubro].detailsData[detail].length === 12
                                            ? data.gastos[rubro].detailsData[detail].map(v => parseFloat(v || 0))
                                            : Array(12).fill(0);

                    let lastRealMonthIndex = -1;
                    for (let i = 11; i >= 0; i--) {
                        if (currentStatuses[i] === 'REAL') {
                            lastRealMonthIndex = i;
                            break;
                        }
                    }

                    if (lastRealMonthIndex === -1 || lastRealMonthIndex === 11) {
                         return;
                    }

                    let previousMonthValue = currentDataValues[lastRealMonthIndex];

                    for (let j = lastRealMonthIndex + 1; j < 12; j++) {
                        if (currentStatuses[j] === 'Estimado') {
                             const multiplier = monthlyMultipliers[j];
                            const projectedValue = previousMonthValue * multiplier;
                            data.gastos[rubro].detailsData[detail][j] = projectedValue;
                            changesMade = true;
                            projectedCellCount++;
                            previousMonthValue = projectedValue;
                        } else if (currentStatuses[j] === 'REAL') {
                            previousMonthValue = currentDataValues[j];
                        }
                    }
                });
            });

             if (totalDetailsProcessed === 0) {
                  showSnackbar("No se encontraron detalles de gastos con datos válidos para proyectar.", false, 'info', 3000);
                  return;
             }

            if (changesMade) {
                console.log(`Se proyectaron ${projectedCellCount} celdas. Recalculando todo...`);
                showSnackbar(`Estimados recalculados (${projectedCellCount} celdas afectadas). Actualizando dashboard...`, false, 'info', 4000);
                calculateAll(scenarioData);
            } else {
                console.log("No se necesitaron cambios en los estimados.");
                showSnackbar("No se encontraron meses estimados que requieran recalcular (no hay meses estimados después del último REAL, o no se configuró coeficiente).", false, 'info', 4000);
            }
        }

        // --- Actualización de la Interfaz (UI) ---
        function initUI() {
             const yearInput = document.getElementById('exercise-year');
             const footerYear = document.getElementById('footer-year');
             if (yearInput) yearInput.setAttribute('value', appState.currentYear);
             if (footerYear) footerYear.textContent = new Date().getFullYear();
             updateScenarioSelector();
             updateCurrentYearAndScenarioInUI();
        }

        function updateUI() {
             console.log("Actualizando UI completa...");
             const scenarioData = getCurrentScenarioData();

             if (!scenarioData) {
                 console.warn("updateUI: No hay escenario activo o datos válidos disponibles. Renderizando estado vacío.");
                 renderEmptyState();
                 updateCurrentYearAndScenarioInUI();
                 updateScenarioSelector();
                 return;
             }

             updateCurrentYearAndScenarioInUI();
             updateScenarioSelector();
             updateDashboardTables(scenarioData);
             updateCharts(scenarioData);
             updateReserveFundPanel(scenarioData);
             updateSettingsPanel();
             updateReportsPanel();
             console.log("UI Actualizada.");
        }

        function updateDashboardTables(scenarioData) {
            const summaryTable = document.getElementById('dashboard-summary');
            if (!summaryTable) { console.warn("Dashboard summary table not found."); return; }

            const tbody = summaryTable.querySelector('tbody');
            const tfoot = summaryTable.querySelector('tfoot');
            if (!tbody || !tfoot) { console.error("Dashboard summary table body/foot not found."); return; }

            tbody.innerHTML = '';
            tfoot.innerHTML = '';

            if (!scenarioData || !scenarioData.calculated) {
                const headerCount = summaryTable.querySelector('thead tr')?.cells.length || 7;
                tbody.innerHTML = `<tr><td colspan="${headerCount}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos calculados para mostrar.</td></tr>`;
                return;
            }

            const calculated = scenarioData.calculated;
            const annualTotals = calculated.annualTotals || {};

            let annualGasto = 0;
            let annualFondo = 0;
            let annualCuotaSGs = 0;
            let annualCuotaIPC = 0;
            let annualExpensaReal = 0;

            for (let i = 0; i < 12; i++) {
                const row = tbody.insertRow();
                row.insertCell().textContent = MONTHS[i];

                const gastoMes = calculated.totalGastoProyectadoMes?.[i] || 0;
                row.insertCell().textContent = formatCurrency(gastoMes);
                annualGasto += gastoMes;

                const fondoMes = calculated.fondoReservaMes?.[i] || 0;
                row.insertCell().textContent = formatCurrency(fondoMes);
                annualFondo += fondoMes;

                const cuotaSGsMes = calculated.cuotaSobreGastosMes?.[i] || 0;
                row.insertCell().textContent = formatCurrency(cuotaSGsMes);
                annualCuotaSGs += cuotaSGsMes;

                const ipcMes = calculated.ipcManual?.[i] || 0;
                row.insertCell().textContent = `${ipcMes.toFixed(1)}%`;

                const cuotaIPCMes = calculated.cuotaIpcMes?.[i] || 0;
                row.insertCell().textContent = formatCurrency(cuotaIPCMes);
                annualCuotaIPC += cuotaIPCMes;

                const expensaRealMes = calculated.cuotaRealBaseMes?.[i] || 0;
                row.insertCell().textContent = formatCurrency(expensaRealMes);
                annualExpensaReal += expensaRealMes;
            }

            const footerRow = tfoot.insertRow();
            footerRow.insertCell().textContent = "TOTAL ANUAL";
            footerRow.cells[0].style.fontWeight = "bold";

            footerRow.insertCell().textContent = formatCurrency(annualTotals.gastos?.__TOTAL__ || annualGasto);
            footerRow.cells[1].style.fontWeight = "bold";
            footerRow.insertCell().textContent = formatCurrency(annualTotals.fondoReserva || annualFondo);
            footerRow.cells[2].style.fontWeight = "bold";
            footerRow.insertCell().textContent = formatCurrency(annualTotals.cuotaSobreGastos || annualCuotaSGs);
            footerRow.cells[3].style.fontWeight = "bold";
            footerRow.insertCell().textContent = "-";
            footerRow.insertCell().textContent = formatCurrency(annualTotals.cuotaIpc || annualCuotaIPC);
            footerRow.cells[5].style.fontWeight = "bold";
            footerRow.insertCell().textContent = formatCurrency(annualTotals.cuotaRealBase || annualExpensaReal);
            footerRow.cells[6].style.fontWeight = "bold";

            updateCollapsibleTable('gastos', scenarioData);
            updateCollapsibleTable('ingresos', scenarioData);
        }


        function updateScenarioSelector() {
            const selector = document.getElementById('scenario-selector');
            if (!selector) {
                console.warn("Scenario selector element not found.");
                return;
            }

            const previousValue = selector.value;
            selector.innerHTML = '';

            const scenariosForCurrentYear = Object.keys(appState.scenarios || {})
                .filter(key => appState.scenarios[key]?.year === appState.currentYear)
                .sort((a, b) => {
                    const nameA = appState.scenarios[a]?.scenarioName || a;
                    const nameB = appState.scenarios[b]?.scenarioName || b;
                    return nameA.localeCompare(nameB);
                });

            if (scenariosForCurrentYear.length === 0) {
                const option = document.createElement('option');
                option.value = "";
                option.textContent = "No hay escenarios para este año";
                option.disabled = true;
                selector.appendChild(option);
                selector.value = "";
            } else {
                scenariosForCurrentYear.forEach(key => {
                    const scenario = appState.scenarios[key];
                    if (scenario) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = `${scenario.scenarioName} (${scenario.year})`;
                        selector.appendChild(option);
                    }
                });

                if (appState.activeScenarioKey && scenariosForCurrentYear.includes(appState.activeScenarioKey)) {
                    selector.value = appState.activeScenarioKey;
                } else if (scenariosForCurrentYear.includes(previousValue)) {
                     selector.value = previousValue;
                } else if (scenariosForCurrentYear.length > 0) {
                    const baseKeyForYear = `${appState.currentYear}_Base`;
                    if (scenariosForCurrentYear.includes(baseKeyForYear)) {
                        selector.value = baseKeyForYear;
                    } else {
                        selector.value = scenariosForCurrentYear[0];
                    }
                }
            }
            if (appState.activeScenarioKey && selector.value !== appState.activeScenarioKey && scenariosForCurrentYear.includes(appState.activeScenarioKey)) {
                console.warn(`Selector value (${selector.value}) differs from activeScenarioKey (${appState.activeScenarioKey}). Forcing selector to active key.`);
                selector.value = appState.activeScenarioKey;
            }
            console.log("Scenario selector updated. Current selection:", selector.value);
        }

        function updateCurrentYearAndScenarioInUI() {
            const dashboardYearSpan = document.getElementById('dashboard-year');
            const dashboardScenarioSpan = document.getElementById('dashboard-scenario');
            const currentYearSpans = document.querySelectorAll('.current-year');
            const currentScenarioSpans = document.querySelectorAll('.current-scenario');

            const scenarioData = getCurrentScenarioData();
            const yearToDisplay = scenarioData ? scenarioData.year : (appState.currentYear || new Date().getFullYear());
            const scenarioNameToDisplay = scenarioData ? scenarioData.scenarioName : "Ninguno";

            if (dashboardYearSpan) dashboardYearSpan.textContent = yearToDisplay;
            if (dashboardScenarioSpan) dashboardScenarioSpan.textContent = scenarioNameToDisplay;
            currentYearSpans.forEach(span => span.textContent = yearToDisplay);
            currentScenarioSpans.forEach(span => span.textContent = scenarioNameToDisplay);
        }

        function renderEmptyState() {
            console.log("Renderizando estado vacío...");
            const summaryTable = document.getElementById('dashboard-summary');
            const summaryTbody = summaryTable?.querySelector('tbody');
            const summaryTfoot = summaryTable?.querySelector('tfoot');
             const summaryHeaderCount = document.getElementById('dashboard-summary')?.querySelector('thead tr')?.cells.length || 7;

            if(summaryTbody) summaryTbody.innerHTML = `<tr><td colspan="${summaryHeaderCount}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos calculados para este escenario. Carga datos o usa los de ejemplo.</td></tr>`;
            if(summaryTfoot) summaryTfoot.innerHTML = '';

            const gastosTable = document.getElementById('gastos-detail-table');
             const gastosHeaderCount = document.getElementById('gastos-detail-table')?.querySelector('thead tr')?.cells.length || 16;
            const gastosTbody = gastosTable?.querySelector('tbody');
            const gastosTfoot = gastosTable?.querySelector('tfoot');
            if(gastosTbody) gastosTbody.innerHTML = `<tr><td colspan="${gastosHeaderCount}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos de gastos.</td></tr>`;
            if(gastosTfoot) gastosTfoot.innerHTML = '';

            const ingresosTable = document.getElementById('ingresos-detail-table');
             const ingresosHeaderCount = document.getElementById('ingresos-detail-table')?.querySelector('thead tr')?.cells.length || 15;
            const ingresosTbody = ingresosTable?.querySelector('tbody');
            const ingresosTfoot = ingresosTable?.querySelector('tfoot');
            if(ingresosTbody) ingresosTbody.innerHTML = `<tr><td colspan="${ingresosHeaderCount}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos de ingresos.</td></tr>`;
            if(ingresosTfoot) ingresosTfoot.innerHTML = '';

            destroyChart('evolutivoCuotaChart'); displayChartNoData('evolutivoCuotaChart', true);
            destroyChart('participacionGastosChart'); displayChartNoData('participacionGastosChart', true);
            destroyChart('participacionIngresosChart'); displayChartNoData('participacionIngresosChart', true);

            const coefEditor = document.getElementById('coefficient-values-editor');
            const coefNameSpan = document.getElementById('editing-coefficient-name');
            if(coefEditor) coefEditor.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente (que no sea "Sin Coeficiente" o "IPC") de la lista de la izquierda para editar sus valores porcentuales (%) mes a mes.</p>';
            if(coefNameSpan) coefNameSpan.textContent = 'Ninguno';
            if(appState.uiState) appState.uiState.editingCoefficientType = null;

             const reservePercentRadio = document.getElementById('reserve-type-percent');
             const reserveFixedRadio = document.getElementById('reserve-type-fixed');
             if (reservePercentRadio && reserveFixedRadio) {
                  const defaultReserveData = getDefaultAppState().BaseScenarioStructureTemplate.reserveFund;
                 reservePercentRadio.checked = (appState.scenarios?.[appState.activeScenarioKey]?.reserveFund?.type ?? defaultReserveData.type) === 'percent';
                 reserveFixedRadio.checked = !(reservePercentRadio.checked);
                 updateReserveUI();
             }
             updateSettingsPanel();
             updateReportsPanel();
        }

        function updateCollapsibleTable(type, scenarioData) {
             const tableId = `${type}-detail-table`;
             const table = document.getElementById(tableId);
             if (!table) { console.warn(`Tabla ${tableId} no encontrada.`); return; }

             const thead = table.querySelector('thead');
             const tbody = table.querySelector('tbody');
             const tfoot = table.querySelector('tfoot');
             if (!thead || !tbody || !tfoot) { console.error(`Elementos internos de ${tableId} no encontrados.`); return;}

             tbody.innerHTML = '';
             tfoot.innerHTML = '';

             const expectedHeaderCount = (type === 'gastos' ? 2 : 1) + MONTHS.length + 1;

             if (!scenarioData || !scenarioData.data || !scenarioData.calculated || !appState.settings ) { // Removed !appState.settings.rubros for now, handled by globalRubrosForType
                 const actualHeaderCount = thead.querySelector('tr')?.cells.length || expectedHeaderCount;
                 tbody.innerHTML = `<tr><td colspan="${actualHeaderCount}" class="text-muted" style="text-align: center; padding: 20px;">Faltan datos o configuración para mostrar el detalle.</td></tr>`;
                 ensureCollapsibleTableHeaderFooterCells(thead, tfoot, type);
                 return;
             }
             const globalRubrosForType = (appState.settings && appState.settings.rubros && Array.isArray(appState.settings.rubros[type]))
                                        ? appState.settings.rubros[type]
                                        : [];
             if (globalRubrosForType.length === 0 && (type === 'gastos' || type === 'ingresos') ) { // Check if any rubros are defined
                console.warn(`No hay rubros globales definidos para el tipo "${type}" en appState.settings.rubros.`);
             }


             const { data, calculated, monthStatus, rubroOrder } = scenarioData;
             const config = appState.settings.rubroConfig || {};
             const calculatedDetailData = calculated[type === 'gastos' ? 'gastoAjustado' : 'ingresoAjustado'] || {};
             const totalRubroSet = calculated[type === 'gastos' ? 'totalGastoRubroMes' : 'totalIngresoRubroMes'] || {};
             const annualRubroTotals = calculated.annualTotals?.[type] || { __TOTAL__: 0 };


             const rubrosToDisplay = (Array.isArray(rubroOrder[type]) && rubroOrder[type].length > 0)
                                    ? rubroOrder[type].filter(rubro => globalRubrosForType.includes(rubro) && data[type]?.[rubro]?.detailsData)
                                    : (globalRubrosForType || []).filter(rubro => data[type]?.[rubro]?.detailsData);

             ensureCollapsibleTableHeaderFooterCells(thead, tfoot, type);
             const actualHeaderCount = thead.querySelector('tr')?.cells.length || expectedHeaderCount;

             if (rubrosToDisplay.length === 0) {
                 tbody.innerHTML = `<tr><td colspan="${actualHeaderCount}" class="text-muted" style="text-align: center; padding: 20px;">No hay rubros definidos o cargados con datos para ${type} en este escenario.</td></tr>`;
                 return;
             }

             rubrosToDisplay.forEach(rubro => {
                 if (!data[type]?.[rubro] || !data[type][rubro].detailsData || !calculatedDetailData[rubro] || !totalRubroSet[rubro] || annualRubroTotals[rubro] === undefined) {
                      console.warn(`Inconsistent data/calculated structures for rubro "${rubro}" in ${type}. Skipping render.`);
                     return;
                 }
                 const rubroData = data[type][rubro];
                  const detailsToDisplay = (Array.isArray(rubroData.detailOrder) && rubroData.detailOrder.length > 0)
                                            ? rubroData.detailOrder.filter(detail =>
                                                 rubroData.detailsData?.[detail] !== undefined && Array.isArray(rubroData.detailsData[detail]) && rubroData.detailsData[detail].length === 12 &&
                                                calculatedDetailData[rubro]?.[detail] !== undefined && Array.isArray(calculatedDetailData[rubro][detail]) && calculatedDetailData[rubro][detail].length === 12
                                              )
                                            : Object.keys(rubroData.detailsData || {}).filter(detail =>
                                                 Array.isArray(rubroData.detailsData[detail]) && rubroData.detailsData[detail].length === 12 &&
                                                calculatedDetailData[rubro]?.[detail] !== undefined && Array.isArray(calculatedDetailData[rubro][detail]) && calculatedDetailData[rubro][detail].length === 12
                                              );
                 if (detailsToDisplay.length === 0) return;
                 const isCollapsed = appState.settings.rubroConfig?.[rubro]?.detailsCollapsed ?? true;
                 const totalRow = tbody.insertRow();
                 totalRow.classList.add('rubro-total-row');
                 if (isCollapsed) totalRow.classList.add('collapsed');
                 totalRow.dataset.rubro = rubro;
                 totalRow.dataset.type = type;
                 totalRow.insertCell().textContent = rubro;
                 if(type === 'gastos') totalRow.insertCell().textContent = '';
                 const monthlyTotals = totalRubroSet[rubro] || Array(12).fill(0);
                 monthlyTotals.forEach(val => {
                     const cell = totalRow.insertCell();
                     cell.textContent = formatCurrency(val);
                     cell.classList.add('number-cell');
                 });
                 const cellAnnualTotal = totalRow.insertCell();
                 cellAnnualTotal.textContent = formatCurrency(annualRubroTotals[rubro] || 0);
                 cellAnnualTotal.classList.add('number-cell');

                 const coefName = type === 'gastos' ? (appState.settings.coefficientTypes[config[rubro]?.coefficientType || 'None']?.name || 'N/A') : '';
                 detailsToDisplay.forEach(detail => {
                     const detailValues = calculatedDetailData[rubro][detail];
                     const detailStatuses = (type === 'gastos' && monthStatus.gastos?.[rubro]?.[detail] && Array.isArray(monthStatus.gastos[rubro][detail]) && monthStatus.gastos[rubro][detail].length === 12)
                                            ? monthStatus.gastos[rubro][detail].map(s => String(s || 'Estimado'))
                                            : Array(12).fill('Estimado');
                     let annualDetailTotal = 0;
                     const detailRow = tbody.insertRow();
                     detailRow.classList.add('detail-row');
                     detailRow.dataset.rubro = rubro;
                     detailRow.dataset.type = type;
                      if (isCollapsed) detailRow.classList.add('hidden');
                     const cellDetailName = detailRow.insertCell();
                     cellDetailName.textContent = detail;
                     cellDetailName.classList.add('text-muted');
                      if (type === 'gastos') {
                         const cellCoef = detailRow.insertCell();
                         cellCoef.textContent = coefName;
                         cellCoef.classList.add('text-muted');
                     }
                     detailValues.forEach((val, index) => {
                         const cell = detailRow.insertCell();
                         cell.textContent = formatCurrency(val || 0);
                         cell.classList.add('number-cell');
                          if (type === 'gastos') {
                             const monthStatusValue = detailStatuses[index] || 'Estimado';
                             cell.classList.add(monthStatusValue === 'REAL' ? 'real-month-cell' : 'estimated-month-cell');
                          }
                         annualDetailTotal += (val || 0);
                     });
                     const cellAnnualDetail = detailRow.insertCell();
                     cellAnnualDetail.textContent = formatCurrency(annualDetailTotal);
                     cellAnnualDetail.classList.add('number-cell');
                 });
             });
             addCollapsibleListeners();
              ensureCollapsibleTableHeaderFooterCells(thead, tfoot, type);
        }

        function ensureCollapsibleTableHeaderFooterCells(thead, tfoot, type) {
             let theadRow = thead.querySelector('tr');
             if (!theadRow) theadRow = thead.insertRow();
             const expectedHeaderCellCount = (type === 'gastos' ? 2 : 1) + MONTHS.length + 1;
             let headersNeedRebuild = false;
             if (theadRow.cells.length !== expectedHeaderCellCount) headersNeedRebuild = true;
              if (!headersNeedRebuild) {
                   const firstCellText = theadRow.cells[0]?.textContent;
                   const coefCellText = type === 'gastos' ? theadRow.cells[1]?.textContent : null;
                   const totalCellText = theadRow.cells[theadRow.cells.length - 1]?.textContent;
                  if (firstCellText !== "Rubro / Detalle") headersNeedRebuild = true;
                  if (type === 'gastos' && coefCellText !== "Coef. Aplicado") headersNeedRebuild = true;
                  if (totalCellText !== "Total Anual") headersNeedRebuild = true;
              }
             if (headersNeedRebuild) {
                 console.warn(`Table head for ${type} is inconsistent or has wrong cell count (${theadRow.cells.length} vs ${expectedHeaderCellCount}). Rebuilding header.`);
                 theadRow.innerHTML = '';
                 theadRow.insertCell().textContent = "Rubro / Detalle";
                 if (type === 'gastos') {
                       const thCoef = document.createElement('th');
                       thCoef.textContent = "Coef. Aplicado";
                       theadRow.appendChild(thCoef);
                   }
                 MONTHS.forEach(month => {
                     const th = document.createElement('th');
                     th.textContent = month;
                     th.classList.add('number-cell');
                     theadRow.appendChild(th);
                 });
                 const thTotal = document.createElement('th');
                 thTotal.textContent = "Total Anual";
                 thTotal.classList.add('number-cell');
                 theadRow.appendChild(thTotal);
             }
            let tfootRow = tfoot.querySelector('tr');
             if (!tfootRow || tfootRow.cells.length === 0) {
                  tfootRow = tfoot.insertRow();
             }
             const footerDescriptionCols = type === 'gastos' ? 2 : 1;
             const expectedFooterCellCount = footerDescriptionCols + 12 + 1;
             let footerLabelCell = tfootRow.cells[0];
             if (!footerLabelCell) footerLabelCell = tfootRow.insertCell(0);
             footerLabelCell.colSpan = footerDescriptionCols;
             footerLabelCell.textContent = `TOTAL GENERAL ${type.toUpperCase()}`;
              footerLabelCell.classList.remove('number-cell');
              while (tfootRow.cells.length < expectedFooterCellCount) {
                  tfootRow.insertCell();
              }
              while (tfootRow.cells.length > expectedFooterCellCount) {
                   tfootRow.deleteCell(tfootRow.cells.length - 1);
              }
              for(let i = footerDescriptionCols; i < expectedFooterCellCount; i++) {
                  if(tfootRow.cells[i]) tfootRow.cells[i].classList.add('number-cell');
              }
              tfootRow.classList.add('font-weight-bold');
        }

        function updateCharts(scenarioData) {
             if (!scenarioData || !scenarioData.calculated || !scenarioData.calculated.annualTotals) {
                 console.warn("Datos insuficientes para actualizar gráficos.");
                 destroyChart('evolutivoCuotaChart'); displayChartNoData('evolutivoCuotaChart', true);
                 destroyChart('participacionGastosChart'); displayChartNoData('participacionGastosChart', true);
                 destroyChart('participacionIngresosChart'); displayChartNoData('participacionIngresosChart', true);
                 return;
             }
             const { calculated } = scenarioData;
             const labels = MONTHS;
             const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
             const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim();
             const secondaryColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color').trim();
             const cardBg = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim();
             const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
             const chartColors = [
                primaryColor, accentColor, '#ffc107', '#6f42c1', '#fd7e14', '#17a2b8',
                '#dc3545', secondaryColor, '#20c997', '#0d6efd', '#198754', '#adb5bd'
             ];

             destroyChart('evolutivoCuotaChart');
             const ctxEvolutivo = document.getElementById('evolutivoCuotaChart')?.getContext('2d');
             const evolutivoHasData = (calculated.cuotaSobreGastosMes?.some(v => (v || 0) !== 0) ?? false) ||
                                       (calculated.cuotaRealBaseMes?.some(v => (v || 0) !== 0) ?? false) ||
                                       (calculated.cuotaIpcMes?.some(v => (v || 0) !== 0) ?? false);
             displayChartNoData('evolutivoCuotaChart', !evolutivoHasData);
             if (ctxEvolutivo && evolutivoHasData) {
                window.evolutivoCuotaChart_instance = new Chart(ctxEvolutivo, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            { label: 'Cuota s/Gtos ($/UF)', data: calculated.cuotaSobreGastosMes.map(v => (v || 0)), borderColor: primaryColor, backgroundColor: hexToRgba(primaryColor, 0.1), tension: 0.2, fill: true, yAxisID: 'yCuota', pointRadius: 3, pointHoverRadius: 6, pointHitRadius: 10, pointBorderColor: 'white', pointBackgroundColor: primaryColor },
                            { label: 'Expensa Real ($/UF)', data: calculated.cuotaRealBaseMes.map(v => (v || 0)), borderColor: accentColor, backgroundColor: hexToRgba(accentColor, 0.1), tension: 0.2, fill: true, yAxisID: 'yCuota', pointRadius: 3, pointHoverRadius: 6, pointHitRadius: 10, pointBorderColor: 'white', pointBackgroundColor: accentColor },
                             { label: 'Cuota IPC ($/UF)', data: calculated.cuotaIpcMes.map(v => (v || 0)), borderColor: secondaryColor, backgroundColor: hexToRgba(secondaryColor, 0.1), tension: 0.2, fill: false, borderDash: [5, 5], yAxisID: 'yCuota', pointRadius: 3, pointHoverRadius: 6, pointHitRadius: 10, pointBorderColor: 'white', pointBackgroundColor: secondaryColor }
                        ]
                    },
                    options: commonChartOptions('yCuota')
                 });
             }

             destroyChart('participacionGastosChart');
             const ctxGastos = document.getElementById('participacionGastosChart')?.getContext('2d');
             const activeGastoRubros = ((appState.settings && appState.settings.rubros && appState.settings.rubros.gastos) ? appState.settings.rubros.gastos : []).filter(rubro => (calculated.annualTotals?.gastos?.[rubro] || 0) > 0);
             const gastoLabels = activeGastoRubros;
             const gastoData = activeGastoRubros.map(rubro => calculated.annualTotals.gastos[rubro] || 0);
             displayChartNoData('participacionGastosChart', gastoData.length === 0 || gastoData.every(d => d === 0));
             if (ctxGastos && gastoData.length > 0 && gastoData.some(d => d > 0)) {
                 window.participacionGastosChart_instance = new Chart(ctxGastos, {
                     type: 'doughnut',
                     data: { labels: gastoLabels, datasets: [{ data: gastoData, backgroundColor: generateColors(gastoData.length, chartColors, 0.8), borderColor: cardBg, borderWidth: 2, hoverOffset: 8 }] },
                     options: pieChartOptions('Gasto Anual')
                 });
             }

             destroyChart('participacionIngresosChart');
             const ctxIngresos = document.getElementById('participacionIngresosChart')?.getContext('2d');
              const activeIngresoRubros = ((appState.settings && appState.settings.rubros && appState.settings.rubros.ingresos) ? appState.settings.rubros.ingresos : []).filter(rubro => (calculated.annualTotals?.ingresos?.[rubro] || 0) > 0);
             const ingresoLabels = activeIngresoRubros;
             const ingresoData = activeIngresoRubros.map(rubro => calculated.annualTotals.ingresos[rubro] || 0);
             displayChartNoData('participacionIngresosChart', ingresoData.length === 0 || ingresoData.every(d => d === 0));
             if (ctxIngresos && ingresoData.length > 0 && ingresoData.some(d => d > 0)) {
                 window.participacionIngresosChart_instance = new Chart(ctxIngresos, {
                     type: 'doughnut',
                     data: { labels: ingresoLabels, datasets: [{ data: ingresoData, backgroundColor: generateColors(ingresoData.length, chartColors.slice().reverse(), 0.8), borderColor: cardBg, borderWidth: 2, hoverOffset: 8 }] },
                     options: pieChartOptions('Ingreso Anual')
                 });
             }
         }

         function generateColors(count, palette, alpha = 1) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                colors.push(hexToRgba(palette[i % palette.length], alpha));
            }
            return colors;
         }

        function commonChartOptions(mainYAxisID = 'y') {
            const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
            const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
             Chart.defaults.backgroundColor = 'transparent';
             const units = { yCuota: ' $/UF' };
             return {
                 responsive: true, maintainAspectRatio: false,
                 scales: {
                    [mainYAxisID]: { beginAtZero: true, ticks: { color: textColor, padding: 10, callback: function(value, index, values) { let formatted = formatCurrency(value || 0).replace(",00", ""); if (units[mainYAxisID]) formatted += units[mainYAxisID]; return formatted; } }, title: { display: true, text: mainYAxisID === 'yCuota' ? 'Valor por UF' : '', color: textColor, font: { size: 14, weight: 'bold' } }, grid: { color: borderColor, drawTicks: false, drawOnChartArea: true, drawTicks: true}, border: { color: borderColor, display: true, width: 1} },
                    x: { ticks: { color: textColor, padding: 10 }, grid: { display: false, drawTicks: true}, border: { color: borderColor, display: true, width: 1 } },
                 },
                 plugins: {
                     legend: { position: 'bottom', labels: { color: textColor, boxWidth: 15, padding: 20 } },
                     tooltip: { backgroundColor: hexToRgba(getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim(), 0.9), titleColor: textColor, bodyColor: textColor, borderColor: getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim(), borderWidth: 1, padding: 10,
                         callbacks: {
                             title: tooltipItems => tooltipItems[0]?.label ? FULL_MONTHS[MONTHS.indexOf(tooltipItems[0].label)] || tooltipItems[0].label : '',
                             label: context => { let label = context.dataset.label || ''; if (label) label += ': '; if (context.parsed.y !== null) { let formatted = formatCurrency(context.parsed.y); const scaleId = context.dataset.yAxisID || mainYAxisID; if (units[scaleId]) formatted += units[scaleId]; label += formatted; } return label; }
                         }
                     }
                 },
                 interaction: { mode: 'index', intersect: false },
             };
         }

        function pieChartOptions(labelPrefix = '') {
             const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
             const cardBg = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim();
             const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
             const baseFontSize = parseFloat(getComputedStyle(document.body).fontSize);
             const legendFontSize = Math.round(baseFontSize * 0.95);
              const plugins = ['doughnutShadow3D'];
              if (!Chart.registry.plugins.get('doughnutShadow3D')) {
                  plugins.splice(plugins.indexOf('doughnutShadow3D'), 1);
             }
             return {
                 responsive: true, maintainAspectRatio: false,
                 plugins: {
                      plugin: plugins,
                     legend: { position: 'right', labels: { color: textColor, boxWidth: 15, padding: 15, font: { size: legendFontSize },
                             generateLabels: chart => { const data = chart.data; if (!data.labels.length || !data.datasets.length) return []; const { labels } = data; const dataset = data.datasets[0]; const total = dataset.data.reduce((a, b) => (a || 0) + (b || 0), 0);
                                return labels.map((label, i) => { const value = dataset.data[i] || 0; const percentage = total > 0 ? ((value / total) * 100).toFixed(1).replace(/\.0$/, '') + '%' : '0%'; const textLabel = `${label} (${percentage})`;
                                    return { text: textLabel, fillStyle: Array.isArray(dataset.backgroundColor) ? dataset.backgroundColor[i] : dataset.backgroundColor, strokeStyle: dataset.borderColor || (Array.isArray(dataset.backgroundColor) ? dataset.backgroundColor[i] : dataset.backgroundColor), lineWidth: dataset.borderWidth || 0, hidden: chart.getDatasetMeta(0)?.data[i]?.hidden || (value === 0 && total !== 0), index: i, datasetIndex: 0 }; });
                             }
                         }
                     },
                     tooltip: { backgroundColor: hexToRgba(cardBg, 0.9), titleColor: textColor, bodyColor: textColor, borderColor: borderColor, borderWidth: 1, padding: 10,
                         callbacks: {
                            label: context => { let label = context.label || ''; if (context.parsed !== null) { const total = context.dataset.data.reduce((a, b) => (a||0) + (b||0), 0); const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1).replace(/\.0$/, '') + '%' : '0%'; label = `${label}: ${formatCurrency(context.parsed || 0)} (${percentage})`; } return label; },
                            title: context => { return context[0]?.label ? (labelPrefix || '') : ''; }
                         }
                     }
                 },
                 cutout: '30%'
             };
         }

        function updateReserveFundPanel(scenarioData) {
             const panel = document.getElementById('reserve-fund-panel');
             const percentRadio = document.getElementById('reserve-type-percent');
             const fixedRadio = document.getElementById('reserve-type-fixed');
             if (!panel || !percentRadio || !fixedRadio) {
                console.warn("Reserve fund UI elements not found.");
                return;
             }
             const defaultReserveData = getDefaultAppState().BaseScenarioStructureTemplate.reserveFund;
             const reserveFundData = (scenarioData?.reserveFund && Array.isArray(scenarioData.reserveFund.values) && scenarioData.reserveFund.values.length === 12 && typeof scenarioData.reserveFund.type === 'string')
                                             ? scenarioData.reserveFund
                                             : defaultReserveData;
             const typeFromState = reserveFundData.type === 'fixed' ? 'fixed' : 'percent';
             percentRadio.checked = typeFromState === 'percent';
             fixedRadio.checked = typeFromState === 'fixed';
             const uiUnitLabel = typeFromState === 'percent' ? '%' : '$';
             const uiCurrentStep = typeFromState === 'percent' ? '0.1' : '100';
              const reserveValues = reserveFundData.values.map(v => parseFloat(v || 0));
             const inputs = panel.querySelectorAll('input[type="number"]');
             if (inputs.length === 12) {
                   console.log("Updating existing reserve fund inputs.");
                   inputs.forEach((input, i) => {
                       if (!isNaN(reserveValues[i])) {
                            input.value = reserveValues[i];
                       } else {
                            input.value = typeFromState === 'fixed' ? 0 : 5;
                            console.warn(`Reserve value for month ${i} is NaN. Displaying default.`);
                       }
                       input.step = uiCurrentStep;
                       input.placeholder = uiUnitLabel;
                       input.title = `Valor de fondo de reserva para ${FULL_MONTHS[i]} (${uiUnitLabel})`;
                   });
             } else {
                   console.log("Reserve fund inputs missing or count incorrect. Rebuilding panel.");
                   renderReserveFundInputsInPanel(panel, reserveFundData);
             }
        }

        function renderReserveFundInputsInPanel(panelElement, reserveFundData) {
             panelElement.innerHTML = '';
             const uiUnitLabel = reserveFundData.type === 'percent' ? '%' : '$';
             const uiCurrentStep = reserveFundData.type === 'percent' ? '0.1' : '100';
             const reserveValues = (Array.isArray(reserveFundData.values) && reserveFundData.values.length === 12)
                                     ? reserveFundData.values.map(v => parseFloat(v || 0))
                                     : Array(12).fill(reserveFundData.type === 'percent' ? 5 : 0);
             for (let i = 0; i < 12; i++) {
                 const monthDiv = document.createElement('div');
                 monthDiv.classList.add('form-group');
                 const label = document.createElement('label');
                 label.textContent = FULL_MONTHS[i];
                 label.htmlFor = `reserve-month-${i}`;
                 const input = document.createElement('input');
                 input.type = 'number';
                 input.id = `reserve-month-${i}`;
                 input.dataset.month = i;
                 input.value = reserveValues[i];
                 input.step = uiCurrentStep;
                 input.min = '0';
                 input.placeholder = uiUnitLabel;
                 input.style.textAlign = 'right';
                 input.title = `Valor de fondo de reserva para ${FULL_MONTHS[i]} (${uiUnitLabel})`;
                 monthDiv.appendChild(label);
                 monthDiv.appendChild(input);
                 panelElement.appendChild(monthDiv);
             }
             console.log(`Reserve fund inputs rendered.`);
        }

        function updateSettingsPanel() {
            const ufInput = document.getElementById('cantidad-unidades');
            appState.settings.cantidadUnidades = parseInt(appState.settings.cantidadUnidades) || 100;
             if(appState.settings.cantidadUnidades < 0) appState.settings.cantidadUnidades = 100;
            if (ufInput) ufInput.value = appState.settings.cantidadUnidades;
            updateRubroList('gastos', 'gasto-rubro-list');
            updateRubroList('ingresos', 'ingreso-rubro-list');
            ensureDefaultCoefficientTypes();
            updateCoefficientTypeList();
            const currentEditing = appState.uiState.editingCoefficientType;
            const editingTypeData = appState.settings.coefficientTypes?.[currentEditing];
            const canEditValuesInThisUI = currentEditing !== 'None' && currentEditing !== 'IPC' && editingTypeData;
            if (canEditValuesInThisUI) {
                 renderCoefficientValuesEditor(currentEditing);
             } else {
                 const editorDiv = document.getElementById('coefficient-values-editor');
                 const nameSpan = document.getElementById('editing-coefficient-name');
                 if (editorDiv) editorDiv.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente (que no sea "Sin Coeficiente" o "IPC") de la lista de la izquierda para editar sus valores porcentuales (%) mes a mes.</p>';
                 if (nameSpan) nameSpan.textContent = 'Ninguno';
                  appState.uiState.editingCoefficientType = null;
             }
             updateIPCManualInputs();
        }

        // --- Manejo de Eventos ---
        function addEventListeners() {
             const themeToggle = document.getElementById('theme-toggle');
             const scenarioSelector = document.getElementById('scenario-selector');
             const uploadArea = document.getElementById('file-upload-area');

             themeToggle?.addEventListener('click', toggleTheme);
             scenarioSelector?.addEventListener('change', (event) => {
                 const newKey = event.target.value;
                 const newScenario = appState.scenarios?.[newKey];
                 if (newKey && newScenario) {
                     console.log(`Attempting to switch to scenario: ${newKey}`);
                     appState.activeScenarioKey = newKey;
                     appState.currentYear = newScenario.year || parseInt(newKey.split('_')[0]) || new Date().getFullYear();
                     console.log(`Switched scenario to: ${appState.activeScenarioKey} (Year ${appState.currentYear})`);
                     initializeScenarioDataForRubros(newScenario);
                      calculateAll(newScenario);
                 } else if (newKey === "") {
                      console.warn("Scenario selector changed to empty value. Attempting re-validation.");
                       appState.activeScenarioKey = null;
                      validateAndSetActiveScenario();
                      updateUI();
                 } else {
                      console.error(`Attempt to switch to invalid or non-existent scenario key: "${newKey}". Current key: "${appState.activeScenarioKey}".`);
                       showSnackbar(`Error: El escenario seleccionado no es válido o no fue encontrado.`, true, 'error', 5000);
                      if (appState.activeScenarioKey && appState.scenarios?.[appState.activeScenarioKey]) {
                         event.target.value = appState.activeScenarioKey;
                      } else {
                           // selector is not defined here, should be event.target.value = ""
                           event.target.value = "";
                      }
                       updateUI();
                 }
             });

             if (uploadArea) {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                     document.body.addEventListener(eventName, preventDefaults, false);
                 });
                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => uploadArea.style.backgroundColor = 'var(--clickable-row-hover)', false);
                });
                ['dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => uploadArea.style.backgroundColor = 'var(--bg-color)', false);
                 });
                 uploadArea.addEventListener('drop', (event) => {
                    const files = event.dataTransfer.files;
                    if (files.length > 0) {
                         console.log(`File(s) dropped: ${files[0].name}`);
                        handleFileUpload(files);
                    }
                 }, false);
                 window.addEventListener('beforeunload', () => {
                     ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                           document.body.removeEventListener(eventName, preventDefaults, false);
                      });
                 });
             }
             addCollapsibleListeners();
        }

        function preventDefaults (e) {
            e.preventDefault();
            e.stopPropagation();
        }

        let collapsibleListenersAdded = false;
        function addCollapsibleListeners() {
             const container = document.querySelector('.container');
             if (!container || collapsibleListenersAdded) return;
             container.addEventListener('click', (event) => {
                 const targetRow = event.target.closest('tr.rubro-total-row');
                 if (targetRow && (targetRow.closest('#gastos-detail-table') || targetRow.closest('#ingresos-detail-table'))) {
                     const rubro = targetRow.dataset.rubro;
                     const type = targetRow.dataset.type;
                     if (rubro && type) {
                         toggleRubroDetails(type, rubro);
                     }
                 }
             });
             collapsibleListenersAdded = true;
             console.log("Listeners delegados para filas colapsables añadidos al contenedor.");
        }

        function toggleRubroDetails(type, rubro) {
              appState.settings.rubroConfig = appState.settings.rubroConfig ?? {};
              appState.settings.rubroConfig[rubro] = appState.settings.rubroConfig[rubro] ?? { detailsCollapsed: true };
              if (appState.settings.rubroConfig[rubro].detailsCollapsed === undefined) {
                   appState.settings.rubroConfig[rubro].detailsCollapsed = true;
              }
             const currentState = appState.settings.rubroConfig[rubro].detailsCollapsed;
             const newState = !currentState;
             appState.settings.rubroConfig[rubro].detailsCollapsed = newState;
             const tableId = `${type}-detail-table`;
             const totalRow = document.querySelector(`#${tableId} tr.rubro-total-row[data-rubro="${rubro}"][data-type="${type}"]`);
             if (!totalRow) {
                 console.warn(`Toggle: Could not find the total row element for type/rubro: ${type}/${rubro}`);
                 saveState();
                 return;
             }
             totalRow.classList.toggle('collapsed', newState);
             let nextSibling = totalRow.nextElementSibling;
             while (nextSibling) {
                 if (nextSibling.classList.contains('detail-row') &&
                     nextSibling.dataset.rubro === rubro && nextSibling.dataset.type === type) {
                     nextSibling.classList.toggle('hidden', newState);
                     nextSibling = nextSibling.nextElementSibling;
                 } else {
                     break;
                 }
             }
             saveState();
        }

         function toggleAllRubroDetails(type, collapse) {
             console.log(`${collapse ? 'Colapsando' : 'Expandiendo'} todos los rubros de ${type}...`);
             const tableId = `${type}-detail-table`;
             const table = document.getElementById(tableId);
             if (!table) { console.warn(`Table ${tableId} not found.`); return; }
             const tbody = table.querySelector('tbody');
             if (!tbody) { console.warn(`Table ${tableId} tbody not found.`); return; }
             const totalRows = tbody.querySelectorAll('tr.rubro-total-row');
             if (totalRows.length === 0) {
                  showSnackbar(`No hay rubros de ${type} con datos visibles para expandir/colapsar.`, false, 'info', 3000);
                  return;
             }
             let changesMade = false;
             totalRows.forEach(totalRow => {
                  const rubro = totalRow.dataset.rubro;
                  const rowType = totalRow.dataset.type;
                 if (!rubro || rowType !== type) return;
                  appState.settings.rubroConfig = appState.settings.rubroConfig ?? {};
                  appState.settings.rubroConfig[rubro] = appState.settings.rubroConfig[rubro] ?? { detailsCollapsed: true };
                 if (appState.settings.rubroConfig[rubro].detailsCollapsed === undefined) {
                      appState.settings.rubroConfig[rubro].detailsCollapsed = true;
                 }
                 const currentState = appState.settings.rubroConfig[rubro].detailsCollapsed;
                 if (currentState !== collapse) {
                      appState.settings.rubroConfig[rubro].detailsCollapsed = collapse;
                      changesMade = true;
                      totalRow.classList.toggle('collapsed', collapse);
                       let nextSibling = totalRow.nextElementSibling;
                       while (nextSibling) {
                           if (nextSibling.classList.contains('detail-row') &&
                               nextSibling.dataset.rubro === rubro && nextSibling.dataset.type === type) {
                               nextSibling.classList.toggle('hidden', collapse);
                               nextSibling = nextSibling.nextElementSibling;
                           } else {
                               break;
                           }
                       }
                 }
             });
             if (changesMade) {
                 saveState();
                 showSnackbar(`${collapse ? 'Todos los detalles colapsados.' : 'Todos los detalles expandidos.'}`, false, 'info', 3000);
             } else {
                  showSnackbar(`Los detalles de ${type} ya están todos ${collapse ? 'colapsados' : 'expandidos'}.`, false, 'info', 3000);
             }
         }

         function handleCoefficientAssignmentChange(event) {
             const select = event.target;
             const rubro = select.dataset.rubro;
             const newCoefType = select.value;
             if (rubro && newCoefType !== undefined && appState.settings.rubroConfig) {
                 appState.settings.rubroConfig[rubro] = appState.settings.rubroConfig[rubro] ?? {};
                 appState.settings.rubroConfig[rubro].coefficientType = newCoefType;
                 console.log(`Coeficiente para rubro "${rubro}" asignado a "${newCoefType}".`);
                 saveState();
                 showSnackbar(`Coeficiente para "${rubro}" asignado. Haz clic en "GUARDAR" para recalcular estimados.`, false, 'info', 3000);
             } else {
                  console.error("Error handling coefficient assignment change.", {rubro, newCoefType, rubroConfigExists: !!appState.settings.rubroConfig});
                 showSnackbar("Error interno al asignar coeficiente.", true, 'error', 6000);
             }
         }

         function handleCoefficientValueChange(event) {
             const input = event.target;
             const monthIndex = parseInt(input.dataset.month);
             const typeKey = input.dataset.typeKey;
             const value = parseFloat(input.value);
              const typeData = appState.settings.coefficientTypes?.[typeKey];
             if (!typeKey || !typeData || isNaN(monthIndex) || monthIndex < 0 || monthIndex > 11) {
                  console.error(`Error handling coefficient value change: Invalid type key "${typeKey}" or month index "${monthIndex}".`);
                 const lastSavedValue = (typeKey && typeData && Array.isArray(typeData.values) && typeData.values.length > monthIndex) ? typeData.values[monthIndex] : 0;
                 input.value = lastSavedValue;
                 showSnackbar("Error interno: Coeficiente o mes inválido.", true, 'error', 6000);
                 return;
             }
             const isNoneType = typeKey === 'None';
             const isValidValue = !isNaN(value) && (isNoneType || value >= -100);
             if (isValidValue) {
                 if (!Array.isArray(typeData.values) || typeData.values.length !== 12) {
                     console.warn(`Coefficient type "${typeKey}" values array in state is invalid (${typeData.values?.length || 'null/undefined'} elements). Resetting to 12 default values before updating.`);
                    typeData.values = Array(12).fill(isNoneType ? 1 : 0);
                 }
                  typeData.values[monthIndex] = value;
                  console.log(`Valor mes ${MONTHS[monthIndex]} para tipo "${typeData.name}" (${typeKey}) actualizado a ${value}%.`);
                  saveState();
             } else {
                  const errorMessage = `Valor inválido para ${FULL_MONTHS[monthIndex]}. Debe ser un número igual o mayor a -100 (o igual a 1 si es "Sin Coeficiente", lo cual se gestiona automáticamente).`;
                 console.warn(`Validation failed for coefficient value: "${input.value}". ${errorMessage}`);
                 const lastSavedValue = (typeKey && typeData && Array.isArray(typeData.values) && typeData.values.length > monthIndex)
                                       ? typeData.values[monthIndex]
                                        : (isNoneType ? 1 : 0);
                 input.value = lastSavedValue;
                 showSnackbar(errorMessage, true, 'error', 5000);
             }
         }

        function updateIPCManualInputs() {
             const ipcDiv = document.getElementById('ipc-inputs');
             if (!ipcDiv) { console.warn("IPC inputs container not found."); return; }
             ipcDiv.innerHTML = '';
             appState.settings.ipcManual = Array.isArray(appState.settings.ipcManual) && appState.settings.ipcManual.length === 12
                                ? appState.settings.ipcManual.map(v => parseFloat(v || 0))
                                : Array(12).fill(0);
             const ipcValues = appState.settings.ipcManual;
             const ipcCoefficientType = appState.settings.coefficientTypes?.['IPC'];
             for (let i = 0; i < 12; i++) {
                 const monthDiv = document.createElement('div');
                 monthDiv.classList.add('form-group');
                 const label = document.createElement('label');
                 label.textContent = FULL_MONTHS[i];
                 label.htmlFor = `ipc-month-${i}`;
                 const input = document.createElement('input');
                 input.type = 'number';
                 input.id = `ipc-month-${i}`;
                 input.dataset.month = i;
                 input.value = ipcValues[i];
                 input.step = '0.1';
                 input.min = '0';
                 input.placeholder = '%';
                 input.style.textAlign = 'right';
                 input.style.maxWidth = '120px';
                 input.title = `IPC de referencia para ${FULL_MONTHS[i]} (%)`;
                 input.addEventListener('change', (event) => {
                     const monthIndex = parseInt(event.target.dataset.month);
                     const value = parseFloat(event.target.value);
                     if (!isNaN(monthIndex) && monthIndex >= 0 && monthIndex < 12) {
                         const validatedValue = (!isNaN(value) && value >= 0) ? value : 0;
                         appState.settings.ipcManual[monthIndex] = validatedValue;
                          console.log(`IPC manual for ${FULL_MONTHS[monthIndex]} updated to ${validatedValue}%.`);
                          if(ipcCoefficientType && Array.isArray(ipcCoefficientType.values) && ipcCoefficientType.values.length === 12) {
                               ipcCoefficientType.values[monthIndex] = validatedValue;
                               console.log(`Synced IPC Coefficient type value for ${FULL_MONTHS[monthIndex]} to ${validatedValue}%.`);
                          } else {
                              console.warn("IPC Coefficient type not found or invalid during manual IPC change sync.");
                               if (!ipcCoefficientType || !Array.isArray(ipcCoefficientType.values) || ipcCoefficientType.values.length !== 12) {
                                    console.warn("Attempting to fix missing/invalid IPC coefficient type structure during IPC input change.");
                                     const defaultIpcCoefType = getDefaultAppState().settings.coefficientTypes['IPC'];
                                     if (defaultIpcCoefType && Array.isArray(defaultIpcCoefType.values) && defaultIpcCoefType.values.length === 12) {
                                         appState.settings.coefficientTypes['IPC'] = JSON.parse(JSON.stringify(defaultIpcCoefType));
                                         appState.settings.coefficientTypes['IPC'].values[monthIndex] = validatedValue;
                                     } else {
                                        console.error("Fixing IPC coefficient type structure failed.");
                                     }
                                }
                          }
                     } else {
                         const lastValidatedValue = appState.settings.ipcManual[monthIndex] ?? 0;
                         event.target.value = lastValidatedValue;
                         showSnackbar(`Valor IPC inválido para ${FULL_MONTHS[monthIndex]}. Debe ser un número >= 0.`, true, 'error', 4000);
                     }
                 });
                 monthDiv.appendChild(label);
                 monthDiv.appendChild(input);
                 ipcDiv.appendChild(monthDiv);
             }
        }

        // --- DEFINICIONES DE FUNCIONES NUEVAS ---
        function createNewExercise() {
            const yearInput = document.getElementById('exercise-year');
            if (!yearInput) {
                showSnackbar("Error: Elemento de entrada de año no encontrado.", true, 'error');
                return;
            }
            const newYear = parseInt(yearInput.value);

            if (isNaN(newYear) || newYear < 2000 || newYear > 2099) {
                showSnackbar("Año inválido. Por favor, ingrese un año entre 2000 y 2099.", true, 'error', 5000);
                yearInput.value = appState.currentYear;
                return;
            }

            if (newYear === appState.currentYear && appState.scenarios && Object.keys(appState.scenarios).some(k => appState.scenarios[k]?.year === newYear)) { // Corrected check
                showSnackbar(`El año ${newYear} ya está seleccionado y tiene escenarios.`, false, 'info');
                return;
            }

            console.log(`Cambiando/Creando ejercicio para el año: ${newYear}`);
            appState.currentYear = newYear;
            validateAndSetActiveScenario();
            updateUI();
            showSnackbar(`Ejercicio para el año ${appState.currentYear} seleccionado/creado.`, false, 'success');
            saveState();
        }

        function createScenario() {
            const scenarioName = prompt(`Ingrese el nombre para el nuevo escenario (Año ${appState.currentYear}):`, `Escenario ${Object.keys(appState.scenarios).filter(k => appState.scenarios[k]?.year === appState.currentYear).length + 1}`); // Corrected filter
            if (!scenarioName || scenarioName.trim() === '') {
                showSnackbar("Creación de escenario cancelada (nombre vacío).", false, 'info');
                return;
            }
            const sanitizedName = scenarioName.trim().replace(/\s+/g, '_').replace(/[^\w-]/g, '');
            if (sanitizedName === '') {
                showSnackbar("Nombre de escenario inválido después de sanitizar.", true, 'error');
                return;
            }
            const newKey = `${appState.currentYear}_${sanitizedName}`;
            if (appState.scenarios[newKey]) {
                showSnackbar(`El escenario "${scenarioName}" ya existe para el año ${appState.currentYear}.`, true, 'error', 5000);
                return;
            }
            initScenarioData(appState.currentYear, scenarioName.trim()); // Pass trimmed name
            appState.activeScenarioKey = newKey;
            initializeScenarioDataForRubros(appState.scenarios[newKey]);
            calculateAll(appState.scenarios[newKey]);
            showSnackbar(`Escenario "${scenarioName.trim()}" creado y activado.`, false, 'success');
        }

        function cloneScenario() {
            const currentScenario = getCurrentScenarioData();
            if (!currentScenario) {
                showSnackbar("No hay escenario activo para clonar.", true, 'error');
                return;
            }
            const newScenarioName = prompt(`Ingrese el nombre para el escenario clonado (base: "${currentScenario.scenarioName}"):`, `${currentScenario.scenarioName}_Copia`);
            if (!newScenarioName || newScenarioName.trim() === '') {
                showSnackbar("Clonación cancelada (nombre vacío).", false, 'info');
                return;
            }
            const sanitizedNewName = newScenarioName.trim().replace(/\s+/g, '_').replace(/[^\w-]/g, '');
             if (sanitizedNewName === '') {
                showSnackbar("Nombre de escenario inválido después de sanitizar.", true, 'error');
                return;
            }
            const newKey = `${currentScenario.year}_${sanitizedNewName}`;
            if (appState.scenarios[newKey]) {
                showSnackbar(`El escenario "${newScenarioName}" ya existe para el año ${currentScenario.year}.`, true, 'error', 5000);
                return;
            }
            appState.scenarios[newKey] = JSON.parse(JSON.stringify(currentScenario));
            appState.scenarios[newKey].scenarioName = newScenarioName.trim();
            appState.activeScenarioKey = newKey;
            appState.currentYear = currentScenario.year;
            initializeScenarioDataForRubros(appState.scenarios[newKey]);
            calculateAll(appState.scenarios[newKey]);
            showSnackbar(`Escenario "${currentScenario.scenarioName}" clonado como "${newScenarioName.trim()}" y activado.`, false, 'success');
        }

        function deleteScenario() {
            const currentKey = appState.activeScenarioKey;
            const currentScenario = getCurrentScenarioData();
            if (!currentScenario) {
                showSnackbar("No hay escenario activo para eliminar.", true, 'error');
                return;
            }
            const scenariosForCurrentYear = Object.keys(appState.scenarios).filter(k => appState.scenarios[k]?.year === currentScenario.year);
            if (scenariosForCurrentYear.length <= 1 && currentScenario.scenarioName.toLowerCase() === 'base') {
                 showSnackbar(`No se puede eliminar el único escenario "Base" del año ${currentScenario.year}.`, true, 'warning', 6000);
                 return;
            }
            if (!confirm(`¿Seguro que quieres eliminar el escenario "${currentScenario.scenarioName}" (Año ${currentScenario.year})?\n¡Esta acción no se puede deshacer!`)) {
                showSnackbar("Eliminación cancelada.", false, 'info');
                return;
            }
            delete appState.scenarios[currentKey];
            appState.activeScenarioKey = null;
            validateAndSetActiveScenario();
            updateUI();
            saveState();
            showSnackbar(`Escenario "${currentScenario.scenarioName}" eliminado.`, false, 'success');
        }

        function saveReserveFund() {
            const scenarioData = getCurrentScenarioData();
            if (!scenarioData) {
                showSnackbar("No hay escenario activo para guardar el fondo de reserva.", true, 'error');
                return;
            }
            const type = document.getElementById('reserve-type-percent').checked ? 'percent' : 'fixed';
            scenarioData.reserveFund.type = type;
            scenarioData.reserveFund.values = [];
            const inputs = document.querySelectorAll('#reserve-fund-panel input[type="number"]');
            let allValid = true;
            inputs.forEach((input, i) => {
                const val = parseFloat(input.value);
                if (isNaN(val) || val < 0) {
                    showSnackbar(`Valor inválido para ${FULL_MONTHS[i]} en Fondo de Reserva. Debe ser un número >= 0.`, true, 'error', 5000);
                    input.value = scenarioData.reserveFund.values[i] || (type === 'percent' ? 5 : 0);
                    allValid = false;
                    return; // from forEach callback
                }
                scenarioData.reserveFund.values[i] = val;
            });
            if (!allValid) return;
            showSnackbar("Fondo de reserva guardado. Recalculando...", false, 'info', 2000);
            calculateAll(scenarioData);
        }

        function saveSettings() {
            const ufInput = document.getElementById('cantidad-unidades');
            const cantidadUF = parseInt(ufInput.value);
            if (isNaN(cantidadUF) || cantidadUF < 1) {
                showSnackbar("Cantidad de Unidades Funcionales inválida. Debe ser un número mayor o igual a 1.", true, 'error', 5000);
                ufInput.value = appState.settings.cantidadUnidades;
                return;
            }
            appState.settings.cantidadUnidades = cantidadUF;
            const scenarioData = getCurrentScenarioData();
            if (!scenarioData) {
                showSnackbar("No hay escenario activo para aplicar la configuración.", true, 'error', 5000);
                saveState(); // Save settings even if no scenario active
                updateSettingsPanel();
                return;
            }
            showSnackbar("Configuración guardada. Recalculando escenario actual...", false, 'info', 2000);
            calculateAll(scenarioData); // This also saves state
        }

        function handleFileUpload(files) {
            const file = files[0];
            const feedbackDiv = document.getElementById('file-upload-feedback');
            if (!feedbackDiv) {
                console.error("File upload feedback div not found.");
                showSnackbar("Error interno: no se puede mostrar feedback de carga.", true, 'error');
                return;
            }
            feedbackDiv.textContent = '';

            if (!file) {
                feedbackDiv.textContent = "No se seleccionó ningún archivo.";
                feedbackDiv.style.color = 'var(--danger-color)';
                return;
            }
            if (!file.name.endsWith('.xlsx') && !file.name.endsWith('.xls')) {
                feedbackDiv.textContent = `Archivo no válido: ${file.name}. Por favor, sube un archivo Excel (.xlsx o .xls).`;
                feedbackDiv.style.color = 'var(--danger-color)';
                showSnackbar("Tipo de archivo no válido. Use .xlsx o .xls.", true, 'error');
                return;
            }
            feedbackDiv.textContent = `Cargando ${file.name}...`;
            feedbackDiv.style.color = 'var(--info-color)';

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array', cellDates: true });
                    const scenarioData = getCurrentScenarioData();
                    if (!scenarioData) {
                        showSnackbar("Error: No hay escenario activo para cargar datos. Intenta crear/seleccionar un año y escenario.", true, 'error', 6000);
                        feedbackDiv.textContent = "Error: No hay escenario activo.";
                        feedbackDiv.style.color = 'var(--danger-color)';
                        return;
                    }
                    let newGastosRubros = [];
                    let newIngresosRubros = [];
                    let newGastosDetails = {};
                    let newIngresosDetails = {};
                    let fileProcessedSuccessfully = false;

                    const gastosSheet = workbook.Sheets[GASTOS_SHEET_NAME];
                    if (gastosSheet) {
                        const gastosJson = XLSX.utils.sheet_to_json(gastosSheet, { header: 1, blankrows: false });
                        if (gastosJson.length > 1) {
                            scenarioData.data.gastos = {};
                            scenarioData.monthStatus.gastos = {};
                             // Ensure global rubros list for gastos exists
                            if (!Array.isArray(appState.settings.rubros.gastos)) appState.settings.rubros.gastos = [];

                            for (let i = 1; i < gastosJson.length; i++) {
                                const row = gastosJson[i];
                                const rubroName = String(row[0] || '').trim();
                                const detailName = String(row[1] || '').trim();
                                if (!rubroName || !detailName) continue;
                                if (!appState.settings.rubros.gastos.includes(rubroName)) {
                                    appState.settings.rubros.gastos.push(rubroName);
                                    if(!newGastosRubros.includes(rubroName)) newGastosRubros.push(rubroName);
                                    appState.settings.rubroConfig[rubroName] = appState.settings.rubroConfig[rubroName] || { coefficientType: 'None', detailsCollapsed: true };
                                }
                                if (!scenarioData.rubroOrder.gastos.includes(rubroName)) {
                                    scenarioData.rubroOrder.gastos.push(rubroName);
                                }
                                if (!scenarioData.data.gastos[rubroName]) {
                                    scenarioData.data.gastos[rubroName] = { detailOrder: [], detailsData: {} };
                                    scenarioData.monthStatus.gastos[rubroName] = {};
                                }
                                if (!scenarioData.data.gastos[rubroName].detailOrder.includes(detailName)) {
                                    scenarioData.data.gastos[rubroName].detailOrder.push(detailName);
                                    if (!newGastosDetails[rubroName]) newGastosDetails[rubroName] = [];
                                    if (!newGastosDetails[rubroName].includes(detailName)) newGastosDetails[rubroName].push(detailName);
                                }
                                scenarioData.data.gastos[rubroName].detailsData[detailName] = [];
                                scenarioData.monthStatus.gastos[rubroName][detailName] = [];
                                for (let m = 0; m < 12; m++) {
                                    const cellValue = row[2 + m];
                                    let numericValue = parseFloat(cellValue);
                                    if (typeof cellValue === 'number' && !isNaN(numericValue)) {
                                        scenarioData.data.gastos[rubroName].detailsData[detailName][m] = numericValue;
                                        scenarioData.monthStatus.gastos[rubroName][detailName][m] = 'REAL';
                                    } else {
                                        scenarioData.data.gastos[rubroName].detailsData[detailName][m] = 0;
                                        scenarioData.monthStatus.gastos[rubroName][detailName][m] = 'Estimado';
                                    }
                                }
                            }
                            fileProcessedSuccessfully = true;
                            console.log("Hoja Gastos procesada.");
                        } else {
                            feedbackDiv.textContent += `\nHoja "${GASTOS_SHEET_NAME}" está vacía o mal formateada.`;
                            feedbackDiv.style.color = 'var(--warning-color)';
                        }
                    } else {
                        feedbackDiv.textContent += `\nHoja "${GASTOS_SHEET_NAME}" no encontrada en el archivo.`;
                        feedbackDiv.style.color = 'var(--warning-color)';
                    }

                    const ingresosSheet = workbook.Sheets[INGRESOS_SHEET_NAME];
                    if (ingresosSheet) {
                        const ingresosJson = XLSX.utils.sheet_to_json(ingresosSheet, { header: 1, blankrows: false });
                        if (ingresosJson.length > 1) {
                            scenarioData.data.ingresos = {};
                            // Ensure global rubros list for ingresos exists
                            if (!Array.isArray(appState.settings.rubros.ingresos)) appState.settings.rubros.ingresos = [];

                            for (let i = 1; i < ingresosJson.length; i++) {
                                const row = ingresosJson[i];
                                const rubroName = String(row[0] || '').trim();
                                const detailName = String(row[1] || '').trim();
                                if (!rubroName || !detailName) continue;
                                if (!appState.settings.rubros.ingresos.includes(rubroName)) {
                                    appState.settings.rubros.ingresos.push(rubroName);
                                     if(!newIngresosRubros.includes(rubroName)) newIngresosRubros.push(rubroName);
                                    appState.settings.rubroConfig[rubroName] = appState.settings.rubroConfig[rubroName] || { detailsCollapsed: true };
                                }
                                if (!scenarioData.rubroOrder.ingresos.includes(rubroName)) {
                                    scenarioData.rubroOrder.ingresos.push(rubroName);
                                }
                                if (!scenarioData.data.ingresos[rubroName]) {
                                    scenarioData.data.ingresos[rubroName] = { detailOrder: [], detailsData: {} };
                                }
                                if (!scenarioData.data.ingresos[rubroName].detailOrder.includes(detailName)) {
                                    scenarioData.data.ingresos[rubroName].detailOrder.push(detailName);
                                     if (!newIngresosDetails[rubroName]) newIngresosDetails[rubroName] = [];
                                     if (!newIngresosDetails[rubroName].includes(detailName)) newIngresosDetails[rubroName].push(detailName);
                                }
                                scenarioData.data.ingresos[rubroName].detailsData[detailName] = [];
                                for (let m = 0; m < 12; m++) {
                                    const cellValue = row[2 + m];
                                    let numericValue = parseFloat(cellValue);
                                    scenarioData.data.ingresos[rubroName].detailsData[detailName][m] = (typeof cellValue === 'number' && !isNaN(numericValue)) ? numericValue : 0;
                                }
                            }
                            fileProcessedSuccessfully = fileProcessedSuccessfully || true;
                            console.log("Hoja Ingresos procesada.");
                        } else {
                            feedbackDiv.textContent += `\nHoja "${INGRESOS_SHEET_NAME}" está vacía o mal formateada.`;
                             feedbackDiv.style.color = 'var(--warning-color)';
                        }
                    } else {
                         feedbackDiv.textContent += `\nHoja "${INGRESOS_SHEET_NAME}" no encontrada en el archivo.`;
                         feedbackDiv.style.color = 'var(--warning-color)';
                    }

                    if (fileProcessedSuccessfully) {
                        let newItemsMessage = "";
                        if (newGastosRubros.length > 0) newItemsMessage += `\nNuevos rubros de Gasto: ${newGastosRubros.join(', ')}.`;
                        if (newIngresosRubros.length > 0) newItemsMessage += `\nNuevos rubros de Ingreso: ${newIngresosRubros.join(', ')}.`;
                        feedbackDiv.textContent = `Archivo "${file.name}" procesado.${newItemsMessage}\nRecalculando...`;
                        feedbackDiv.style.color = 'var(--success-color)';
                        initializeScenarioDataForRubros(scenarioData);
                        calculateAll(scenarioData);
                        showSnackbar(`Datos de "${file.name}" cargados y calculados. ${newItemsMessage}`, false, 'success', 6000);
                        updateSettingsPanel();
                    } else {
                        if (!feedbackDiv.textContent.includes("Error:")) {
                           feedbackDiv.textContent = "No se encontraron datos válidos para procesar en las hojas esperadas.";
                           feedbackDiv.style.color = 'var(--danger-color)';
                        }
                        showSnackbar("No se pudieron procesar datos del archivo.", true, 'error');
                    }
                } catch (error) {
                    console.error("Error procesando archivo Excel:", error);
                    feedbackDiv.textContent = `Error al procesar el archivo: ${error.message}`;
                    feedbackDiv.style.color = 'var(--danger-color)';
                    showSnackbar("Error grave al procesar el archivo Excel.", true, 'error');
                }
            };
            reader.onerror = function(error) {
                console.error("Error leyendo archivo:", error);
                feedbackDiv.textContent = "Error al leer el archivo.";
                feedbackDiv.style.color = 'var(--danger-color)';
                showSnackbar("Error al leer el archivo.", true, 'error');
            };
            reader.readAsArrayBuffer(file);
        }

        function downloadTemplate() {
            const wb = XLSX.utils.book_new();
            const gastosHeader = ["Rubro", "Detalle", ...MONTHS, "Total Anual (Calculado)"];
            const ingresosHeader = ["Rubro", "Detalle", ...MONTHS, "Total Anual (Calculado)"];
            const sampleGastoRow = ["Ej: Seguridad", "Ej: Vigilador Turno Noche", ...Array(12).fill(""), ""];
            const sampleIngresoRow = ["Ej: Expensas Ordinarias", "Base por UF", ...Array(12).fill(""), ""];
            const wsGastos = XLSX.utils.aoa_to_sheet([gastosHeader, sampleGastoRow]);
            const wsIngresos = XLSX.utils.aoa_to_sheet([ingresosHeader, sampleIngresoRow]);
            XLSX.utils.book_append_sheet(wb, wsGastos, GASTOS_SHEET_NAME);
            XLSX.utils.book_append_sheet(wb, wsIngresos, INGRESOS_SHEET_NAME);
            XLSX.writeFile(wb, `Plantilla_Expensas_${appState.currentYear}.xlsx`);
            showSnackbar("Plantilla de ejemplo descargada.", false, 'success');
        }

        function loadSampleData() {
            if (!confirm("¿Cargar datos de ejemplo? Esto reemplazará los datos del escenario actual si ya existen.")) {
                showSnackbar("Carga de datos de ejemplo cancelada.", false, 'info');
                return;
            }
            const scenario = getCurrentScenarioData();
            if (!scenario) {
                showSnackbar("No hay escenario activo. Por favor, cree o seleccione un año y escenario primero.", true, 'error', 6000);
                return;
            }
            appState.settings.rubros = {
                gastos: ["Seguridad", "Mantenimiento", "Administración"],
                ingresos: [CUOTA_RUBRO_NAME, "Alquiler SUM", "Intereses Plazo Fijo"]
            };
            appState.settings.cantidadUnidades = 150;
            appState.settings.ipcManual = [1.0, 1.2, 0.8, 1.5, 2.0, 1.3, 1.0, 0.5, 0.7, 1.1, 1.4, 1.0];
            ensureDefaultCoefficientTypes();
            appState.settings.coefficientTypes["SueldosAdmin"] = { name: "Sueldos Admin", values: Array(12).fill(2.5), isDefault: false };
            appState.settings.rubroConfig = {
                "Seguridad": { coefficientType: "UTEDYC", detailsCollapsed: false },
                "Mantenimiento": { coefficientType: "IPC", detailsCollapsed: true },
                "Administración": { coefficientType: "SueldosAdmin", detailsCollapsed: false },
                [CUOTA_RUBRO_NAME]: { detailsCollapsed: false },
                "Alquiler SUM": { detailsCollapsed: true },
                "Intereses Plazo Fijo": { detailsCollapsed: false }
            };
            scenario.data.gastos = {
                "Seguridad": { detailOrder: ["Vigiladores", "Monitoreo"], detailsData: { "Vigiladores": [100000, 101000, 102000, 103000, 110000, 111000, 112000, 113000, 120000, 121000, 122000, 123000], "Monitoreo": Array(12).fill(25000) } },
                "Mantenimiento": { detailOrder: ["Limpieza", "Jardinería"], detailsData: { "Limpieza": Array(12).fill(30000), "Jardinería": [15000, 15000, 16000, 16000, 17000, 17000, 18000, 18000, 19000, 19000, 20000, 20000] } },
                "Administración": { detailOrder: ["Honorarios Admin", "Gastos Bancarios"], detailsData: { "Honorarios Admin": Array(12).fill(50000), "Gastos Bancarios": Array(12).fill(5000) } }
            };
            scenario.monthStatus.gastos = {
                "Seguridad": { "Vigiladores": Array(12).fill('REAL'), "Monitoreo": Array(12).fill('REAL') },
                "Mantenimiento": { "Limpieza": Array(12).fill('REAL'), "Jardinería": Array(12).fill('REAL') },
                "Administración": { "Honorarios Admin": Array(12).fill('REAL'), "Gastos Bancarios": Array(12).fill('REAL') }
            };
            scenario.rubroOrder.gastos = ["Seguridad", "Mantenimiento", "Administración"];
            scenario.data.ingresos = {
                [CUOTA_RUBRO_NAME]: { detailOrder: ["Cuota Base UF"], detailsData: { "Cuota Base UF": Array(12).fill(35.50) } },
                "Alquiler SUM": { detailOrder: ["Eventos FinDeSemana"], detailsData: { "Eventos FinDeSemana": [5000, 0, 7000, 0, 10000, 0, 12000, 0, 8000, 0, 6000, 0] } },
                "Intereses Plazo Fijo": { detailOrder: ["Fondo Común Inv."], detailsData: { "Fondo Común Inv.": [1000,1100,1050,1200,1150,1300,1250,1400,1350,1500,1450,1600] } }
            };
            scenario.rubroOrder.ingresos = [CUOTA_RUBRO_NAME, "Alquiler SUM", "Intereses Plazo Fijo"];
            scenario.reserveFund = { type: 'percent', values: [5,5,5,6,6,6,7,7,7,8,8,8] };
            initializeScenarioDataForRubros(scenario);
            calculateAll(scenario);
            updateSettingsPanel();
            showSnackbar("Datos de ejemplo cargados y calculados.", false, 'success');
        }

        function exportToExcel() {
            const scenario = getCurrentScenarioData();
            if (!scenario) {
                showSnackbar("No hay datos de escenario para exportar.", true, 'error');
                return;
            }
            const wb = XLSX.utils.book_new();
            const summaryData = [ ["Mes", "Gasto ($)", "Fondo ($)", "Cuota s/Gs ($/UF)", "IPC (%)", "Cuota IPC ($/UF)", "Expensa Real ($/UF)"] ];
            for (let i = 0; i < 12; i++) {
                summaryData.push([ MONTHS[i], scenario.calculated.totalGastoProyectadoMes?.[i] || 0, scenario.calculated.fondoReservaMes?.[i] || 0, scenario.calculated.cuotaSobreGastosMes?.[i] || 0, scenario.calculated.ipcManual?.[i] || 0, scenario.calculated.cuotaIpcMes?.[i] || 0, scenario.calculated.cuotaRealBaseMes?.[i] || 0 ]);
            }
            summaryData.push([ "TOTAL ANUAL", scenario.calculated.annualTotals.gastos?.__TOTAL__ || 0, scenario.calculated.annualTotals.fondoReserva || 0, scenario.calculated.annualTotals.cuotaSobreGastos || 0, "-", scenario.calculated.annualTotals.cuotaIpc || 0, scenario.calculated.annualTotals.cuotaRealBase || 0 ]);
            const wsSummary = XLSX.utils.aoa_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, wsSummary, "Resumen General");

            const gastosReportData = [["Rubro", "Detalle", "Coef. Aplicado", ...MONTHS, "Total Anual"]];
            ((appState.settings && appState.settings.rubros && appState.settings.rubros.gastos) ? appState.settings.rubros.gastos : []).forEach(rubro => { // Use global rubro list for order
                if (!scenario.data.gastos[rubro]) return; // Skip if no data for this rubro in scenario
                const config = appState.settings.rubroConfig[rubro] || {};
                const coefTypeKey = config.coefficientType || 'None';
                const coefName = appState.settings.coefficientTypes[coefTypeKey]?.name || 'N/A';
                const rubroTotals = scenario.calculated.totalGastoRubroMes?.[rubro] || Array(12).fill(0);
                gastosReportData.push([ rubro, "TOTAL RUBRO", "", ...rubroTotals, scenario.calculated.annualTotals.gastos?.[rubro] || 0 ]);
                (scenario.data.gastos[rubro]?.detailOrder || []).forEach(detail => {
                    const detailValues = scenario.calculated.gastoAjustado?.[rubro]?.[detail] || Array(12).fill(0);
                    const annualDetailTotal = detailValues.reduce((s,v)=>s+v,0);
                    gastosReportData.push([ "", detail, coefName, ...detailValues, annualDetailTotal ]);
                });
            });
            const wsGastos = XLSX.utils.aoa_to_sheet(gastosReportData);
            XLSX.utils.book_append_sheet(wb, wsGastos, "Detalle Gastos");

            const ingresosReportData = [["Rubro", "Detalle", ...MONTHS, "Total Anual"]];
             ((appState.settings && appState.settings.rubros && appState.settings.rubros.ingresos) ? appState.settings.rubros.ingresos : []).forEach(rubro => { // Use global rubro list for order
                if (!scenario.data.ingresos[rubro]) return; // Skip if no data
                const rubroTotals = scenario.calculated.totalIngresoRubroMes?.[rubro] || Array(12).fill(0);
                ingresosReportData.push([ rubro, "TOTAL RUBRO (Calculado)", ...rubroTotals, scenario.calculated.annualTotals.ingresos?.[rubro] || 0 ]);
                (scenario.data.ingresos[rubro]?.detailOrder || []).forEach(detail => {
                    const detailBaseValues = scenario.calculated.ingresoAjustado?.[rubro]?.[detail] || Array(12).fill(0);
                    const annualDetailBaseTotal = detailBaseValues.reduce((s,v)=>s+v,0);
                    ingresosReportData.push([ "", detail + (SPECIAL_INGRESO_RUBROS.includes(rubro) ? " (Valor Base x UF)" : " (Valor Base)"), ...detailBaseValues, annualDetailBaseTotal ]);
                });
            });
            const wsIngresos = XLSX.utils.aoa_to_sheet(ingresosReportData);
            XLSX.utils.book_append_sheet(wb, wsIngresos, "Detalle Ingresos (Base)");

            const configData = [ ["Parámetro", "Valor"], ["Año Ejercicio", scenario.year], ["Nombre Escenario", scenario.scenarioName], ["Cantidad UF", appState.settings.cantidadUnidades], ["Fondo Reserva Tipo", scenario.reserveFund.type], ...scenario.reserveFund.values.map((val,i) => [`Fondo Reserva ${MONTHS[i]}`, val]), ...appState.settings.ipcManual.map((val,i) => [`IPC Manual ${MONTHS[i]} (%)`, val]), ];
            Object.entries(appState.settings.coefficientTypes).forEach(([key, type]) => {
                configData.push([`Coef. Tipo: ${type.name} (${key})`, "Valores Mensuales (%)"]);
                type.values.forEach((val,i) => configData.push([MONTHS[i], val]));
            });
            ((appState.settings && appState.settings.rubros && appState.settings.rubros.gastos) ? appState.settings.rubros.gastos : []).forEach(rubro => {
                const coefKey = appState.settings.rubroConfig[rubro]?.coefficientType || 'None';
                configData.push([`Rubro Gasto: ${rubro}`, `Coef. Asignado: ${appState.settings.coefficientTypes[coefKey]?.name || 'N/A'}`]);
            });
            const wsConfig = XLSX.utils.aoa_to_sheet(configData);
            XLSX.utils.book_append_sheet(wb, wsConfig, "Configuración Aplicada");

            XLSX.writeFile(wb, `Reporte_Expensas_${scenario.year}_${scenario.scenarioName.replace(/\s+/g, '_')}.xlsx`);
            showSnackbar("Reporte Excel generado.", false, 'success');
        }

        function exportChart(chartId, filename) {
            const chartInstance = window[`${chartId}_instance`];
            if (chartInstance) {
                try {
                    const image = chartInstance.toBase64Image();
                    const link = document.createElement('a');
                    link.href = image;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    showSnackbar(`Gráfico "${filename}" descargado.`, false, 'success');
                } catch (e) {
                    console.error("Error exportando gráfico:", e);
                    showSnackbar("Error al exportar el gráfico.", true, 'error');
                }
            } else {
                showSnackbar("El gráfico no está disponible para exportar (sin datos o no renderizado).", true, 'warning');
            }
        }


        // --- Utilidades ---
        function formatCurrency(value) {
             const num = Number(value);
             if (isNaN(num) || !isFinite(num)) return "$ 0,00";
             try {
                 return `$ ${num.toLocaleString('es-AR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
             } catch (e) {
                 console.error("Error formatting currency:", value, e);
                 return `$ ${num.toFixed(2).replace('.', ',').replace(/\B(?=(\d{3})+(?!\d))/g, '.')}`;
             }
        }

        function hexToRgba(hex, alpha) {
            hex = String(hex || '#000000').trim().replace('#', '');
            if (!/^[0-9A-F]{3,6}$/i.test(hex)) {
                 console.warn(`Invalid hex color provided: "${hex}". Using rgba(0,0,0,${alpha}).`);
                hex = '000000';
            }
            if (hex.length === 3) {
                hex = hex.split('').map(c => c + c).join('');
            }
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
             if (isNaN(r) || isNaN(g) || isNaN(b)) {
                  console.error(`Error parsing hex "${hex}" to RGB.`);
                  return `rgba(0,0,0,${alpha})`;
             }
             const validAlpha = typeof alpha === 'number' ? Math.max(0, Math.min(1, alpha)) : 1;
            return `rgba(${r}, ${g}, ${b}, ${validAlpha})`;
        }

        function openTab(evt, tabName) {
             if (typeof tabName !== 'string' || !tabName) {
                 console.error("Invalid tab name provided:", tabName);
                 return;
             }
             const tabcontents = document.getElementsByClassName("tab-content");
             for (let i = 0; i < tabcontents.length; i++) {
                 tabcontents[i].classList.remove("active");
                 tabcontents[i].style.display = "none";
             }
             const tablinks = document.getElementsByClassName("tab-link");
             for (let i = 0; i < tablinks.length; i++) {
                 tablinks[i].classList.remove("active");
             }
             const tabToShow = document.getElementById(tabName);
             if(tabToShow) {
                  tabToShow.style.display = "block";
                 void tabToShow.offsetWidth;
                 tabToShow.classList.add("active");
             } else {
                 console.warn(`Tab content element not found for id: ${tabName}`);
                 showSnackbar(`Error interno: Pestaña "${tabName}" no encontrada.`, true, 'error', 5000);
             }
             if(evt?.currentTarget) {
                  evt.currentTarget.classList.add("active");
             }
             if (tabName === 'dashboard') {
                 requestAnimationFrame(() => {
                    ['evolutivoCuotaChart', 'participacionGastosChart', 'participacionIngresosChart'].forEach(id => {
                        if (window[`${id}_instance`]) {
                             window[`${id}_instance`].resize();
                            console.log(`Resized chart: ${id}`);
                        } else {
                            console.log(`Chart instance not found to resize: ${id}`);
                        }
                    });
                 });
             }
         }

        function showSnackbar(message, isError = false, level = null, duration = 4000) {
             const snackbar = document.getElementById('snackbar');
             if (!snackbar) {
                 console.warn("Snackbar element not found. Message:", message);
                 return;
             }
             snackbar.textContent = message;
             let effectiveLevel = level ?? (isError ? 'error' : 'success');
             snackbar.className = 'show';
             snackbar.classList.remove('error', 'warning', 'info');
             if (effectiveLevel === 'error') snackbar.classList.add('error');
             else if (effectiveLevel === 'warning') snackbar.classList.add('warning');
             else if (effectiveLevel === 'info') snackbar.classList.add('info');
             if (snackbar.timer) {
                 clearTimeout(snackbar.timer);
                 snackbar.timer = null;
             }
             snackbar.timer = setTimeout(() => {
                 snackbar.className = '';
                 snackbar.timer = null;
             }, duration);
         }

        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia?.('(prefers-color-scheme: dark)')?.matches ?? false;
            appState.darkMode = (savedTheme === 'dark') || (!savedTheme && prefersDark);
            if (window.matchMedia) {
                 const systemThemeQuery = window.matchMedia('(prefers-color-scheme: dark)');
                 systemThemeQuery.addEventListener('change', event => {
                    if (!localStorage.getItem('theme')) {
                        appState.darkMode = event.matches;
                        applyTheme(true);
                         saveState();
                    }
                 });
            }
            applyTheme(false);
             console.log(`Initial theme set to ${appState.darkMode ? 'dark' : 'light'}.`);
        }

        function toggleTheme() {
            appState.darkMode = !appState.darkMode;
            localStorage.setItem('theme', appState.darkMode ? 'dark' : 'light');
            applyTheme(true);
            saveState();
             console.log(`Theme toggled to ${appState.darkMode ? 'dark' : 'light'}. Explicit choice saved.`);
        }

        function applyTheme(updateCharts = true){
            const body = document.body;
            const toggleButton = document.getElementById('theme-toggle');
            body.classList.toggle('dark-mode', appState.darkMode);
            if (toggleButton) {
                 toggleButton.innerHTML = appState.darkMode ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
                 toggleButton.title = appState.darkMode ? 'Cambiar a tema claro' : 'Cambiar a tema oscuro';
            }
            if (updateCharts) {
                 requestAnimationFrame(() => {
                     const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
                     const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
                     Chart.defaults.color = textColor;
                     ['evolutivoCuotaChart', 'participacionGastosChart', 'participacionIngresosChart'].forEach(id => {
                          if (window[`${id}_instance`]) {
                               window[`${id}_instance`].update();
                                console.log(`Updated theme colors for chart: ${id}`);
                           }
                     });
                 });
            }
        }

        function saveState() {
             try {
                 const stateToSave = {
                     currentYear: appState.currentYear,
                     scenarios: appState.scenarios,
                     activeScenarioKey: appState.activeScenarioKey,
                     settings: appState.settings,
                     darkMode: appState.darkMode,
                 };
                 const jsonState = JSON.stringify(stateToSave);
                 localStorage.setItem(STORAGE_KEY, jsonState);
                 console.log("Estado guardado a localStorage.");

             } catch (e) {
                 console.error(`Error guardando estado a localStorage con key "${STORAGE_KEY}":`, e);
                 showSnackbar("Error al guardar estado en el navegador.", true, 'error', 6000);
             }
         }

        function loadState() {
             try {
                 const savedState = localStorage.getItem(STORAGE_KEY);
                 if (savedState) {
                     console.log(`Encontrado estado guardado para key "${STORAGE_KEY}".`);
                     const loadedState = JSON.parse(savedState);
                     console.log("Estado guardado parseado:", loadedState);
                     appState = deepMerge(getDefaultAppState(), loadedState);
                     console.log(`Estado ${STORAGE_KEY} cargado y fusionado con estado por defecto.`);

                    // --- INICIO: Verificación adicional de estructura post-carga ---
                    if (!appState.settings) {
                        appState.settings = getDefaultAppState().settings;
                        console.warn("appState.settings estaba ausente después de la carga. Restaurado a default.");
                    }
                    if (!appState.settings.rubros || typeof appState.settings.rubros !== 'object' || appState.settings.rubros === null) { // Added null check
                        appState.settings.rubros = { gastos: [], ingresos: [] };
                        console.warn("appState.settings.rubros estaba ausente o no era un objeto. Restaurado a default.");
                    }
                    if (!Array.isArray(appState.settings.rubros.gastos)) {
                        appState.settings.rubros.gastos = [];
                        console.warn("appState.settings.rubros.gastos no era un array. Restaurado a array vacío.");
                    }
                    if (!Array.isArray(appState.settings.rubros.ingresos)) {
                        appState.settings.rubros.ingresos = [];
                        console.warn("appState.settings.rubros.ingresos no era un array. Restaurado a array vacío.");
                    }
                    // --- FIN: Verificación adicional ---

                 } else {
                     console.log(`No hay estado guardado para key "${STORAGE_KEY}". Usando estado por defecto.`);
                     appState = getDefaultAppState();
                 }
             } catch (e) {
                 console.error(`Error cargando estado desde localStorage con key "${STORAGE_KEY}":`, e);
                 showSnackbar(`Error cargando estado guardado (${STORAGE_KEY}). Usando valores por defecto. Si has actualizado la aplicación, esto puede ser normal.`, true, 'error', 8000);
                 appState = getDefaultAppState();
             }
        }

        function getDefaultAppState() {
            const defaultYear = new Date().getFullYear();
            const baseScenarioStructure = {
                year: defaultYear,
                scenarioName: 'Base',
                rubroOrder: { gastos: [], ingresos: [] },
                data: { gastos: {}, ingresos: {} },
                monthStatus: { gastos: {}, ingresos: {} },
                reserveFund: { type: 'percent', values: Array(12).fill(5) },
                calculated: {
                    gastoAjustado: {}, totalGastoRubroMes: {}, totalGastoProyectadoMes: Array(12).fill(0),
                    ingresoAjustado: {}, totalIngresoRubroMes: {}, totalIngresoProyectadoMes: Array(12).fill(0),
                    fondoReservaMes: Array(12).fill(0),
                    cuotaSobreGastosMes: Array(12).fill(0),
                    ipcManual: Array(12).fill(0),
                    cuotaIpcMes: Array(12).fill(0),
                    cuotaRealBaseMes: Array(12).fill(0),
                    annualTotals: { gastos: {__TOTAL__:0}, ingresos: {__TOTAL__:0}, fondoReserva: 0, cuotaSobreGastos: 0, cuotaIpc: 0, cuotaRealBase: 0 }
                }
            };
            const defaultSettings = {
                 cantidadUnidades: 100,
                 rubros: { gastos: [], ingresos: [] }, // ASEGURAR QUE ESTO SIEMPRE SEA UN OBJETO CON ARRAYS
                 rubroConfig: {},
                 coefficientTypes: {
                     "None": { name: "Sin Coeficiente", values: Array(12).fill(1), isDefault: true },
                     "IPC": { name: "IPC", values: Array(12).fill(0), isDefault: true },
                     "UTEDYC": { name: "UTEDYC (Ejemplo)", values: [0, 0, 10, 0, 0, 8, 0, 0, 7, 0, 0, 5], isDefault: true },
                 },
                 ipcManual: [5, 4, 6, 3, 4, 5, 3, 4, 5, 6, 4, 5]
            };
            return {
                 currentYear: defaultYear,
                 scenarios: {},
                 activeScenarioKey: null,
                 settings: defaultSettings,
                 uiState: { editingCoefficientType: null },
                 darkMode: false,
                 BaseScenarioStructureTemplate: baseScenarioStructure
             };
         }

        function deepMerge(target, source) {
             const output = { ...target };
             if (isObject(target) && isObject(source)) {
                 Object.keys(source).forEach(key => {
                     const targetValue = target[key];
                     const sourceValue = source[key];
                     if (isObject(sourceValue) && isObject(targetValue)) {
                         output[key] = deepMerge(targetValue, sourceValue);
                     } else if (Array.isArray(sourceValue)) {
                         output[key] = [...sourceValue];
                     } else {
                           output[key] = sourceValue;
                     }
                 });
             }
             return output;
         }

        function isObject(item) {
             return (item !== null && typeof item === 'object' && !Array.isArray(item));
        }

        function updateReportsPanel() {
             const reportsDiv = document.getElementById('reports');
             if (!reportsDiv) { console.warn("Reports panel not found."); return; }
             const scenarioData = getCurrentScenarioData();
             const hasMeaningfulCalculatedData = scenarioData?.calculated && (
                (scenarioData.calculated.totalGastoProyectadoMes?.some(v => (v || 0) !== 0) ?? false) ||
                (scenarioData.calculated.totalIngresoProyectadoMes?.some(v => (v || 0) !== 0) ?? false) ||
                (scenarioData.calculated.cuotaRealBaseMes?.some(v => (v || 0) !== 0) ?? false)
             );
             const disableButtons = !scenarioData || !hasMeaningfulCalculatedData;
             reportsDiv.querySelectorAll('button').forEach(btn => {
                 btn.disabled = disableButtons;
                 btn.classList.toggle('disabled', disableButtons);
             });
              console.log(`Reports panel buttons are ${disableButtons ? 'disabled' : 'enabled'}.`);
        }

        function clearScenarioData() {
             const key = appState.activeScenarioKey;
             const scenario = appState.scenarios?.[key];
             if (!scenario) {
                 showSnackbar('No hay escenario activo para borrar datos.', true, 'error', 4000);
                 return;
             }
             if (!confirm(`¿Seguro que quieres borrar TODOS los datos (gastos, ingresos, estado meses) del escenario "${scenario.scenarioName}" (Año ${scenario.year})?\n\nLa Configuración de Fondo de Reserva, los Coeficientes y la asignación de rubros se mantendrán.\n¡Esta acción no se puede deshacer!`)) {
                 showSnackbar("Operación cancelada.", false, 'info', 3000);
                 return;
             }
             scenario.data = { gastos: {}, ingresos: {} };
             scenario.monthStatus = { gastos: {}, ingresos: {} };
             scenario.rubroOrder = { gastos: [], ingresos: [] };
             console.log(`Datos de gastos, ingresos y status borrados para escenario: ${key}.`);
             saveState();
             calculateAll(scenario);
        }

    

function updateRubroList(type, listId) {
             const list = document.getElementById(listId);
             if (!list) return;
             list.innerHTML = '';

             const rubros = appState.settings.rubros[type]?.slice().sort((a, b) => a.localeCompare(b)) || [];
             const config = appState.settings.rubroConfig || {};
             const coefTypes = appState.settings.coefficientTypes || {};

             if (rubros.length === 0) {
                 list.innerHTML = '<li class="text-muted" style="padding: 10px 8px;">No hay rubros definidos. Añade uno o carga un Excel.</li>';
                 return;
             }

             rubros.forEach(rubro => {
                 const li = document.createElement('li');
                 const span = document.createElement('span');
                 span.textContent = rubro;
                 li.appendChild(span);

                 if (type === 'gastos') {
                     const select = document.createElement('select');
                     select.title = `Asignar coeficiente de ajuste para ${rubro}`;
                     select.dataset.rubro = rubro;
                     select.onchange = handleCoefficientAssignmentChange;

                     // Sort coefficient types alphabetically by name for the dropdown
                     Object.keys(coefTypes)
                         .sort((a, b) => coefTypes[a].name.localeCompare(coefTypes[b].name))
                         .forEach(coefKey => {
                             const option = document.createElement('option');
                             option.value = coefKey;
                             option.textContent = coefTypes[coefKey].name;
                             // Ensure config[rubro] exists before accessing coefficientType
                             if (config[rubro]?.coefficientType === coefKey) {
                                 option.selected = true;
                             }
                             select.appendChild(option);
                         });
                     li.appendChild(select);
                 }

                 const deleteBtn = document.createElement('button');
                 deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                 deleteBtn.classList.add('button-danger', 'button-sm');
                 deleteBtn.title = `Eliminar rubro "${rubro}" (¡no se puede deshacer!)`;
                 deleteBtn.onclick = () => deleteRubro(type, rubro);
                 li.appendChild(deleteBtn);

                 list.appendChild(li);
             });
        }

        function updateCoefficientTypeList() {
             const list = document.getElementById('coefficient-type-list');
             if (!list) return;
             list.innerHTML = '';

             const types = appState.settings.coefficientTypes || {};
             const currentEditing = appState.uiState.editingCoefficientType;

             const sortedKeys = Object.keys(types)
                 .filter(key => key !== 'None') // Exclude the default 'None' type from the deletable list
                 .sort((a, b) => types[a].name.localeCompare(types[b].name));

             // Always add the 'None' type first, non-interactively
              const noneType = types['None'];
              if (noneType) {
                    const liNone = document.createElement('li');
                    const spanNone = document.createElement('span');
                    spanNone.textContent = noneType.name;
                    liNone.appendChild(spanNone);
                    const lockIcon = document.createElement('i');
                    lockIcon.className = 'fas fa-lock fa-fw';
                    lockIcon.title = 'Tipo por defecto (no eliminable ni editable).';
                    lockIcon.style.color = 'var(--secondary-color)';
                    lockIcon.style.marginLeft = 'auto';
                    liNone.appendChild(lockIcon);
                    liNone.style.opacity = '0.7'; // Visually distinct
                    list.appendChild(liNone);
              }


             if (sortedKeys.length === 0) {
                 list.innerHTML += '<li class="text-muted" style="padding: 10px 8px;">No hay tipos de coeficientes definidos (además de los por defecto).</li>';
                 return;
             }

             sortedKeys.forEach(key => {
                 const typeData = types[key];
                 const li = document.createElement('li');
                 li.style.cursor = 'pointer';
                 li.onclick = () => selectCoefficientTypeForEditing(key);

                 if (key === currentEditing) {
                     li.style.backgroundColor = 'var(--clickable-row-hover)';
                     li.style.fontWeight = 'bold';
                 }

                 const span = document.createElement('span');
                 span.textContent = typeData.name;
                 li.appendChild(span);

                 const actionsDiv = document.createElement('div');
                 actionsDiv.style.marginLeft = 'auto'; // Push actions right
                 actionsDiv.style.display = 'flex';
                 actionsDiv.style.alignItems = 'center';
                 actionsDiv.style.gap = '5px';

                 if (typeData.isDefault) { // Should only be true for built-ins if we add more
                     const lockIcon = document.createElement('i');
                     lockIcon.className = 'fas fa-lock fa-fw';
                     lockIcon.title = 'Tipo por defecto (no eliminable).';
                     lockIcon.style.color = 'var(--secondary-color)';
                     actionsDiv.appendChild(lockIcon);
                 } else {
                     const deleteBtn = document.createElement('button');
                     deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                     deleteBtn.classList.add('button-danger', 'button-sm');
                     deleteBtn.title = `Eliminar tipo "${typeData.name}"`;
                     deleteBtn.onclick = (e) => { e.stopPropagation(); deleteCoefficientType(key); };
                     actionsDiv.appendChild(deleteBtn);
                 }
                li.appendChild(actionsDiv);
                 list.appendChild(li);
             });
        }

        function selectCoefficientTypeForEditing(typeKey) {
             if (typeKey === 'None') {
                showSnackbar("El tipo 'Sin Coeficiente' no es editable.", false, 'info');
                return;
             }
             if (appState.settings.coefficientTypes[typeKey]) {
                 appState.uiState.editingCoefficientType = typeKey;
                 updateCoefficientTypeList(); // Re-render list to show selection highlight
                 renderCoefficientValuesEditor(typeKey);
             } else {
                 console.error(`Intentando editar tipo de coeficiente inexistente: ${typeKey}`);
             }
        }

        function renderCoefficientValuesEditor(typeKey) {
             const editorDiv = document.getElementById('coefficient-values-editor');
             const nameSpan = document.getElementById('editing-coefficient-name');
             if (!editorDiv || !nameSpan) return;
             editorDiv.innerHTML = '';

             if (!typeKey || !appState.settings.coefficientTypes[typeKey] || typeKey === 'None') {
                 editorDiv.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente de la lista (que no sea "Sin Coeficiente") para editar sus valores.</p>';
                 nameSpan.textContent = 'Ninguno';
                 appState.uiState.editingCoefficientType = null;
                 return;
             }

             const typeData = appState.settings.coefficientTypes[typeKey];
             nameSpan.textContent = typeData.name;

             const table = document.createElement('table');
             table.style.width = '100%';
             const thead = table.createTHead().insertRow();
             const tbody = table.createTBody().insertRow();

             // thead.insertCell().textContent = "Mes"; // Removed, using col headers
             tbody.insertCell().textContent = "Valor Coef.";
             tbody.cells[0].style.fontWeight = "600"; // Bold the row header

             // Ensure values array exists and has 12 elements
             const values = Array.isArray(typeData.values) && typeData.values.length === 12
                             ? typeData.values
                             : Array(12).fill(1);


             MONTHS.forEach((month, index) => {
                 const th = thead.insertCell();
                 th.textContent = month;
                 th.classList.add('number-cell');
                 th.style.textAlign = 'center';

                 const td = tbody.insertCell();
                 td.classList.add('input-cell');
                 td.style.textAlign = 'center';

                 const input = document.createElement('input');
                 input.type = 'number';
                 input.step = '0.01';
                 input.min = '0';
                 input.value = values[index]; // Use validated array
                 input.dataset.month = index;
                 input.dataset.typeKey = typeKey;
                 input.onchange = handleCoefficientValueChange;
                 input.style.maxWidth = '80px';
                 input.title = `Coeficiente para ${FULL_MONTHS[index]}`;

                 td.appendChild(input);
             });

             editorDiv.appendChild(table);
        }

        function updateIPCManualInputs() {
             const ipcDiv = document.getElementById('ipc-inputs');
             if (!ipcDiv) return;
             ipcDiv.innerHTML = '';

             // Ensure IPC array exists and has 12 elements
             const ipcValues = Array.isArray(appState.settings.ipcManual) && appState.settings.ipcManual.length === 12
                                ? appState.settings.ipcManual
                                : Array(12).fill(0);

             for (let i = 0; i < 12; i++) {
                 const monthDiv = document.createElement('div');
                 monthDiv.classList.add('form-group');

                 const label = document.createElement('label');
                 label.textContent = FULL_MONTHS[i];
                 label.htmlFor = `ipc-month-${i}`;

                 const input = document.createElement('input');
                 input.type = 'number';
                 input.id = `ipc-month-${i}`;
                 input.dataset.month = i;
                 input.value = ipcValues[i]; // Use validated array
                 input.step = '0.1';
                 input.min = '0'; // Allow zero IPC
                 input.placeholder = '%';
                 input.style.textAlign = 'right';
                 input.style.maxWidth = '120px';
                 input.title = `IPC de referencia para ${FULL_MONTHS[i]} (%)`;

                 input.onchange = (event) => {
                     const monthIndex = parseInt(event.target.dataset.month);
                     const value = parseFloat(event.target.value);
                      if (!isNaN(monthIndex) && monthIndex >= 0 && monthIndex < 12) { // Added NaN check
                          // Allow 0 and positive numbers
                          // Ensure the global array exists before writing
                          if (!Array.isArray(appState.settings.ipcManual) || appState.settings.ipcManual.length !== 12) {
                            appState.settings.ipcManual = Array(12).fill(0);
                          }
                          appState.settings.ipcManual[monthIndex] = (!isNaN(value) && value >= 0) ? value : 0;
                          // No saveState/recalc here; happens on main Save button
                      } else {
                          console.error("Invalid month index for IPC input.");
                      }
                 };

                 monthDiv.appendChild(label);
                 monthDiv.appendChild(input);
                 ipcDiv.appendChild(monthDiv);
             }
        }


        // --- Manejo de Eventos ---
        function addEventListeners() {
             document.getElementById('theme-toggle')?.addEventListener('click', toggleTheme);

             document.getElementById('scenario-selector')?.addEventListener('change', (event) => {
                 const newKey = event.target.value;
                 if (newKey && appState.scenarios[newKey]) {
                     appState.activeScenarioKey = newKey;
                     appState.currentYear = parseInt(newKey.split('_')[0]);
                     console.log(`Escenario cambiado a: ${newKey}`);
                     saveState();
                     updateUI(); // Refresh UI for the new scenario
                 } else if (newKey === "") {
                     console.warn("Selector de escenario cambió a valor vacío (puede ocurrir si no hay escenarios).");
                 } else {
                      console.error(`Intento de cambiar a escenario inválido o no encontrado: ${newKey}`);
                      event.target.value = appState.activeScenarioKey; // Revert selection
                 }
             });

             // Drag & Drop Upload Area
             const uploadArea = document.getElementById('file-upload-area');
             if (uploadArea) {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, preventDefaults, false);
                    document.body.addEventListener(eventName, preventDefaults, false); // Prevent browser opening file
                });
                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => uploadArea.style.backgroundColor = 'var(--clickable-row-hover)', false);
                });
                ['dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => uploadArea.style.backgroundColor = 'var(--bg-color)', false);
                });
                 uploadArea.addEventListener('drop', (event) => {
                    const files = event.dataTransfer.files;
                    if (files.length > 0) handleFileUpload(files);
                 }, false);
             }

             // Add collapsible listeners only once using delegation
             addCollapsibleListeners();
        }

        function preventDefaults (e) {
            e.preventDefault();
            e.stopPropagation();
        }

        let collapsibleListenersAdded = false; // Flag to prevent adding multiple times
        function addCollapsibleListeners() {
             // Use event delegation on a parent element that exists reliably (e.g., the main container)
             const container = document.querySelector('.container');
             // Only add the listener once
             if (!container || collapsibleListenersAdded) return;

             container.addEventListener('click', (event) => {
                 // Find the closest ancestor that is a collapsible total row
                 const targetRow = event.target.closest('tr.rubro-total-row');
                 // Check if the click happened inside one of the detail tables
                 if (targetRow && (targetRow.closest('#gastos-detail-table') || targetRow.closest('#ingresos-detail-table'))) {
                     const rubro = targetRow.dataset.rubro;
                     const type = targetRow.dataset.type;
                     if (rubro && type) {
                         toggleRubroDetails(type, rubro);
                     }
                 }
             });

             collapsibleListenersAdded = true; // Set flag
             console.log("Listeners delegados para filas colapsables añadidos al contenedor.");
        }


        function toggleRubroDetails(type, rubro) {
             // Toggle state in GLOBAL settings.rubroConfig
             // Ensure the config object exists for the rubro
             if (!appState.settings.rubroConfig[rubro]) {
                 appState.settings.rubroConfig[rubro] = { coefficientType: 'None', detailsCollapsed: false }; // Default expanded on first click if config didn't exist
             } else {
                 // Toggle the existing value, default to false (expanded) if property doesn't exist
                 appState.settings.rubroConfig[rubro].detailsCollapsed = !(appState.settings.rubroConfig[rubro].detailsCollapsed ?? false);
             }
             const isNowCollapsed = appState.settings.rubroConfig[rubro].detailsCollapsed;
             console.log(`Toggling ${type}/${rubro}. Now collapsed: ${isNowCollapsed}`);

             // Update UI for the current table
             const tableId = `${type}-detail-table`;
             const totalRow = document.querySelector(`#${tableId} tr.rubro-total-row[data-rubro="${rubro}"]`);
             const detailRows = document.querySelectorAll(`#${tableId} tr.detail-row[data-rubro="${rubro}"]`);

             if (totalRow) {
                totalRow.classList.toggle('collapsed', isNowCollapsed);
             } else {
                 console.warn(`Total row not found for ${type}/${rubro} during toggle.`);
             }

             detailRows.forEach(row => {
                 row.classList.toggle('hidden', isNowCollapsed);
             });

             saveState(); // Save the changed collapsed preference
        }

         // New function to toggle all rubro details for a given type
         function toggleAllRubroDetails(type, collapse) {
             console.log(`${collapse ? 'Colapsando' : 'Expandiendo'} todos los rubros de ${type}...`);
             const scenarioData = getCurrentScenarioData();
             if (!scenarioData) { showSnackbar("No hay escenario activo.", true, 'error'); return; }

             const rubrosToToggle = appState.settings.rubros[type] || [];
             let changesMade = false;

             rubrosToToggle.forEach(rubro => {
                 // Ensure config object exists before modifying
                 if (!appState.settings.rubroConfig[rubro]) {
                     appState.settings.rubroConfig[rubro] = { coefficientType: 'None', detailsCollapsed: true }; // Default collapsed
                 }
                 if ((appState.settings.rubroConfig[rubro].detailsCollapsed ?? true) !== collapse) { // Only change if different
                      appState.settings.rubroConfig[rubro].detailsCollapsed = collapse;
                      changesMade = true;
                 }
             });

             if (changesMade) {
                 saveState(); // Save the changed collapsed preferences
                 // Update UI for the affected table directly
                 const tableId = `${type}-detail-table`;
                 const totalRows = document.querySelectorAll(`#${tableId} tr.rubro-total-row`);
                 const detailRows = document.querySelectorAll(`#${tableId} tr.detail-row`);

                 totalRows.forEach(row => {
                     const rubro = row.dataset.rubro;
                      const isCollapsed = appState.settings.rubroConfig[rubro]?.detailsCollapsed ?? true;
                      row.classList.toggle('collapsed', isCollapsed);
                 });

                 detailRows.forEach(row => {
                     const rubro = row.dataset.rubro;
                      const isCollapsed = appState.settings.rubroConfig[rubro]?.detailsCollapsed ?? true;
                      row.classList.toggle('hidden', isCollapsed);
                 });

                 showSnackbar(`${collapse ? 'Todos los detalles colapsados.' : 'Todos los detalles expandidos.'}`, false, 'info', 3000);
             } else {
                  showSnackbar(`Los detalles ya están ${collapse ? 'colapsados' : 'expandidos'}.`, false, 'info', 3000);
             }
         }


         function handleCoefficientAssignmentChange(event) {
             const select = event.target;
             const rubro = select.dataset.rubro;
             const newCoefType = select.value;

             if (rubro && newCoefType !== undefined) {
                 // Ensure config object exists before assigning
                 if (!appState.settings.rubroConfig[rubro]) {
                     appState.settings.rubroConfig[rubro] = { detailsCollapsed: true }; // Keep default collapsed state
                 }
                 appState.settings.rubroConfig[rubro].coefficientType = newCoefType;
                 console.log(`Coeficiente para "${rubro}" asignado a "${newCoefType}".`);
                 saveState(); // Save assignment immediately
                  showSnackbar(`Coeficiente para "${rubro}" asignado. Guardar Configuración recalculará los estimados.`, false, 'info', 3000);
             } else {
                  console.error("Error al asignar coeficiente: falta rubro o valor.", {rubro, newCoefType});
             }
         }

         function handleCoefficientValueChange(event) {
             const input = event.target;
             const monthIndex = parseInt(input.dataset.month);
             const typeKey = input.dataset.typeKey;
             const newValue = parseFloat(input.value);

             if (typeKey && appState.settings.coefficientTypes[typeKey] && !isNaN(monthIndex) && monthIndex >= 0 && monthIndex < 12) {
                 // Ensure values array exists before modifying
                 if (!Array.isArray(appState.settings.coefficientTypes[typeKey].values) || appState.settings.coefficientTypes[typeKey].values.length !== 12) {
                    appState.settings.coefficientTypes[typeKey].values = Array(12).fill(1);
                 }

                 if (!isNaN(newValue) && newValue >= 0) {
                     appState.settings.coefficientTypes[typeKey].values[monthIndex] = newValue;
                     console.log(`Valor mes ${MONTHS[monthIndex]} para "${typeKey}" actualizado a ${newValue}.`);
                     saveState(); // Save immediately
                     showSnackbar(`Valor para ${FULL_MONTHS[monthIndex]} de "${appState.settings.coefficientTypes[typeKey].name}" actualizado. Guardar Configuración recalculará.`, false, 'info', 3000);
                 } else {
                     input.value = appState.settings.coefficientTypes[typeKey].values[monthIndex]; // Revert invalid input
                     showSnackbar(`Valor inválido para ${FULL_MONTHS[monthIndex]}. Debe ser >= 0.`, true, 'error', 4000);
                 }
             } else {
                 console.error("Error al manejar cambio de valor de coeficiente.", { typeKey, monthIndex, newValue });
             }
         }


        // --- Funciones de Acción (Botones, etc.) ---
        function createNewExercise(year = null) {
             const inputYearElement = document.getElementById('exercise-year');
             const inputYear = year || parseInt(inputYearElement?.value);

             if (!inputYear || isNaN(inputYear) || inputYear < 2000 || inputYear > 2099) {
                 showSnackbar("Año inválido. Introduce un año entre 2000 y 2099.", true, 'error');
                 if(inputYearElement) inputYearElement.focus();
                 return;
             }

             console.log(`Creando o seleccionando Ejercicio ${inputYear}`);
             // Initialize the 'Base' scenario if it doesn't exist
             initScenarioData(inputYear, 'Base');

             // Set the application's current year and active scenario
             appState.currentYear = inputYear;
             appState.activeScenarioKey = `${inputYear}_Base`;

             saveState();

             // Update UI elements
             updateScenarioSelector();
             const selector = document.getElementById('scenario-selector');
             if (selector) selector.value = appState.activeScenarioKey;

             updateUI();
             showSnackbar(`Ejercicio ${inputYear} (Escenario Base) seleccionado/creado.`, false, 'success');
        }

        function createScenario(){
             const year = appState.currentYear;
             const existingScenariosCount = Object.keys(appState.scenarios).filter(k => k.startsWith(year + '_')).length;
             const defaultName = `Escenario ${existingScenariosCount + 1}`;

             let nombre = prompt(`Nombre para el nuevo escenario del año ${year}:`, defaultName);
             if (nombre === null) { showSnackbar("Creación cancelada.", false, 'info'); return; } // Handle Cancel
             nombre = nombre.trim();
             if (!nombre) { showSnackbar("El nombre no puede estar vacío.", true, 'error'); return; }

             const key = `${year}_${nombre.replace(/\s+/g,'_')}`;
             if (appState.scenarios[key]) {
                 showSnackbar(`El escenario "${nombre}" ya existe para ${year}. Elige otro nombre.`, true, 'warning');
                 return;
             }

             // Create a fresh, empty scenario
             console.log("Creando un escenario nuevo vacío.");
             initScenarioData(year, nombre); // Initialize with the new name

             appState.activeScenarioKey = key;
             saveState();

             updateScenarioSelector();
             const selector = document.getElementById('scenario-selector');
             if(selector) selector.value = key;
             updateUI();
             showSnackbar(`Escenario "${nombre}" creado y seleccionado.`, false, 'success');
        }

        function cloneScenario() {
             const currentScenario = getCurrentScenarioData();
             if (!currentScenario) {
                 showSnackbar("No hay un escenario activo para clonar.", true, 'error');
                 return;
             }

             const currentName = currentScenario.scenarioName;
             const defaultNewName = `${currentName} - Copia`;
             const newScenarioName = prompt(`Nombre para la copia del escenario "${currentName}":`, defaultNewName);

             if (newScenarioName === null) { showSnackbar("Clonación cancelada.", false, 'info'); return; }
             const trimmedNewName = newScenarioName.trim();
             if (!trimmedNewName) { showSnackbar("El nombre no puede estar vacío.", true, 'error'); return; }

             const newKey = `${currentScenario.year}_${trimmedNewName.replace(/\s+/g, '_')}`;
             if (appState.scenarios[newKey]) {
                 showSnackbar(`Ya existe un escenario "${trimmedNewName}" para ${currentScenario.year}.`, true, 'warning');
                 return;
             }

             // Deep clone using JSON methods for safety
             appState.scenarios[newKey] = JSON.parse(JSON.stringify(currentScenario));
             // Update specific properties for the new scenario
             appState.scenarios[newKey].scenarioName = trimmedNewName;
             appState.scenarios[newKey].year = currentScenario.year; // Ensure year is correct

             appState.activeScenarioKey = newKey;
             console.log(`Escenario clonado: ${appState.activeScenarioKey} -> ${newKey}`);
             saveState();

             updateScenarioSelector();
             const selector = document.getElementById('scenario-selector');
             if(selector) selector.value = newKey;
             updateUI();
             showSnackbar(`Escenario "${trimmedNewName}" clonado y seleccionado.`, false, 'success');
        }

        function deleteScenario() {
             const keyToDelete = appState.activeScenarioKey;
             const scenarioToDelete = appState.scenarios[keyToDelete];

             if (!scenarioToDelete) {
                 showSnackbar("No hay escenario activo para eliminar.", true, 'error');
                 return;
             }

             const scenariosForYear = Object.keys(appState.scenarios).filter(k => k.startsWith(`${scenarioToDelete.year}_`));
             if (scenariosForYear.length <= 1) {
                 showSnackbar(`No se puede eliminar el último escenario ("${scenarioToDelete.scenarioName}") para ${scenarioToDelete.year}.`, true, 'warning');
                 return;
             }

             if (confirm(`¿Seguro que quieres eliminar el escenario "${scenarioToDelete.scenarioName}"?\n\n¡Esta acción no se puede deshacer!`)) {
                 const year = scenarioToDelete.year;
                 const deletedName = scenarioToDelete.scenarioName;

                 delete appState.scenarios[keyToDelete];
                 console.log(`Escenario eliminado: ${keyToDelete}`);

                 // Determine next active scenario
                 const baseKey = `${year}_Base`;
                 const remainingKeysForYear = Object.keys(appState.scenarios).filter(k => k.startsWith(`${year}_`));
                 const firstGlobalKey = Object.keys(appState.scenarios)[0];

                 let nextActiveKey = null;
                 if (appState.scenarios[baseKey]) { nextActiveKey = baseKey; }
                 else if (remainingKeysForYear.length > 0) { nextActiveKey = remainingKeysForYear.sort((a,b) => appState.scenarios[a].scenarioName.localeCompare(appState.scenarios[b].scenarioName))[0]; }
                 else if (firstGlobalKey) { nextActiveKey = firstGlobalKey; }

                 appState.activeScenarioKey = nextActiveKey;

                 if (!appState.activeScenarioKey) {
                     console.log("No quedan escenarios, creando uno base para el año actual.");
                     appState.currentYear = new Date().getFullYear();
                     initScenarioData(appState.currentYear);
                     appState.activeScenarioKey = `${appState.currentYear}_Base`;
                 } else {
                     appState.currentYear = parseInt(appState.activeScenarioKey.split('_')[0]);
                 }

                 saveState();

                 updateScenarioSelector();
                 const selector = document.getElementById('scenario-selector');
                 if (selector && appState.activeScenarioKey) selector.value = appState.activeScenarioKey;
                 updateUI();
                 showSnackbar(`Escenario "${deletedName}" eliminado.`, false, 'success');
             } else {
                 showSnackbar("Eliminación cancelada.", false, 'info');
             }
        }


        function updateScenarioSelector() {
            const selector = document.getElementById('scenario-selector');
            if (!selector) return;
            const currentActiveKey = appState.activeScenarioKey; // Store current key before clearing
            selector.innerHTML = '';

            const currentYearScenariosKeys = Object.keys(appState.scenarios)
                .filter(key => key.startsWith(`${appState.currentYear}_`))
                .sort((a, b) => appState.scenarios[a].scenarioName.localeCompare(appState.scenarios[b].scenarioName));

            if (currentYearScenariosKeys.length === 0) {
                const opt = document.createElement('option');
                opt.value = "";
                opt.textContent = `(No hay escenarios para ${appState.currentYear})`;
                opt.disabled = true;
                selector.appendChild(opt);
                selector.disabled = true;
                // If the active key was from this year, it's now invalid. validateAndSetActiveScenario should handle this on next load/update.
                return;
            }

            selector.disabled = false;
            let activeKeyFoundInList = false;
            currentYearScenariosKeys.forEach(key => {
                const scenario = appState.scenarios[key];
                if (scenario) {
                    const opt = document.createElement('option');
                    opt.value = key;
                    opt.textContent = scenario.scenarioName;
                    if (key === currentActiveKey) {
                        opt.selected = true;
                        activeKeyFoundInList = true;
                    }
                    selector.appendChild(opt);
                }
            });

            // If the previously active key wasn't found in the current year's list,
            // default to the first one in the list, update state, and save.
            if (!activeKeyFoundInList && currentYearScenariosKeys.length > 0) {
                 const newActiveKey = currentYearScenariosKeys[0];
                 console.warn(`Active scenario key "${currentActiveKey}" not valid for year ${appState.currentYear}. Defaulting to "${newActiveKey}".`);
                 appState.activeScenarioKey = newActiveKey;
                 selector.value = newActiveKey; // Update selector display
                 saveState(); // Save the corrected active key
            } else if (activeKeyFoundInList) {
                 selector.value = currentActiveKey; // Ensure visual selection matches state
            }
         }

        // --- Carga de Archivo Excel ---
        function handleFileUpload(files) {
             if (!files || files.length === 0) { showSnackbar("No se seleccionó archivo.", true, 'warning'); return; }
             const file = files[0];
             const validTypes = ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/vnd.ms-excel'];
             if (!validTypes.includes(file.type)) { showSnackbar("Archivo inválido. Sube .xlsx o .xls.", true, 'error'); return; }

             const reader = new FileReader();
             const feedbackDiv = document.getElementById('file-upload-feedback');
             feedbackDiv.textContent = `Procesando: ${file.name}...`;
             feedbackDiv.style.color = 'var(--info-color)';

             reader.onload = (e) => {
                 try {
                     const data = new Uint8Array(e.target.result);
                     const workbook = XLSX.read(data, { type: 'array', cellDates: false, cellNF: false });

                     const gastosSheet = workbook.Sheets[GASTOS_SHEET_NAME];
                     const ingresosSheet = workbook.Sheets[INGRESOS_SHEET_NAME];

                     if (!gastosSheet) throw new Error(`Hoja "${GASTOS_SHEET_NAME}" no encontrada.`);
                     if (!ingresosSheet) throw new Error(`Hoja "${INGRESOS_SHEET_NAME}" no encontrada.`);

                     const scenarioData = getCurrentScenarioData();
                     if (!scenarioData) throw new Error("No hay escenario activo para cargar datos.");

                     // --- Reset specific data parts for the current scenario before processing ---
                     scenarioData.data = { gastos: {}, ingresos: {} };
                     scenarioData.monthStatus = { gastos: {}, ingresos: {} };
                     scenarioData.rubroOrder = { gastos: [], ingresos: [] }; // Will be rebuilt from Excel
                     // Calculated data is reset inside calculateAll which is called later

                     let newRubrosFound = { gastos: [], ingresos: [] };

                     // Process sheets - This populates scenarioData.data, .monthStatus, .rubroOrder and tracks new rubros
                     processSheetData(gastosSheet, scenarioData, 'gastos', newRubrosFound);
                     processSheetData(ingresosSheet, scenarioData, 'ingresos', newRubrosFound);

                     let addedMessage = ""; let settingsChanged = false;

                     // Add new rubros found to global settings & initialize config
                     ['gastos', 'ingresos'].forEach(type => {
                         newRubrosFound[type].forEach(rubro => {
                             if (!appState.settings.rubros[type].includes(rubro)) {
                                 appState.settings.rubros[type].push(rubro);
                                 settingsChanged = true;
                                 if (type === 'gastos' && !appState.settings.rubroConfig[rubro]) {
                                     // --- FIX: Set default collapsed state for new rubros ---
                                     appState.settings.rubroConfig[rubro] = { coefficientType: 'None', detailsCollapsed: true };
                                 }
                                 addedMessage += `\n- Nuevo rubro (${type}): ${rubro} (añadido a Configuración)`;
                             }
                         });
                     });

                    // --- FIX: Ensure data structures for all rubros (including new ones) are initialized IN THE CURRENT SCENARIO
                    // and ALSO in ALL other scenarios if global settings changed ---
                    initializeScenarioDataForRubros(scenarioData); // Ensure current one is fully initialized with potentially new details etc.
                     if(settingsChanged) {
                        // Re-initialize all scenarios to include the new global rubro definitions
                        Object.values(appState.scenarios).forEach(scenario => {
                            initializeScenarioDataForRubros(scenario);
                        });
                     }

                     feedbackDiv.textContent = `Archivo "${file.name}" procesado.${addedMessage}`;
                     feedbackDiv.style.color = 'var(--success-color)';
                     document.getElementById('excel-file-input').value = ''; // Reset file input

                     if (settingsChanged) {
                         saveState(); // Save updated global settings
                         updateSettingsPanel(); // Update the settings UI to show new rubros/configs
                     }

                     // Recalculate everything after processing the data
                     calculateAll(scenarioData); // This also saves state and updates UI
                     showSnackbar("Datos del Excel cargados y procesados.", false, 'success');

                 } catch (error) {
                     console.error("Error procesando archivo Excel:", error);
                     feedbackDiv.textContent = `Error: ${error.message}`;
                     feedbackDiv.style.color = 'var(--danger-color)';
                     showSnackbar(`Error procesando Excel: ${error.message}`, true, 'error', 6000);
                 }
             };
             reader.onerror = (e) => {
                 console.error("Error leyendo archivo:", e);
                 feedbackDiv.textContent = "Error al leer el archivo.";
                 feedbackDiv.style.color = 'var(--danger-color)';
                 showSnackbar("Error al intentar leer el archivo.", true, 'error');
             };
             reader.readAsArrayBuffer(file);
        }

        function processSheetData(sheet, scenarioData, type, newRubrosTracker) {
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: null });
            if (jsonData.length < 2) { console.warn(`Hoja "${type}" vacía o sin datos.`); return; }

            const header = jsonData[0].map(h => String(h ?? '').trim().toLowerCase());
            const rubroColIndex = header.indexOf('rubro');
            const detailColIndex = header.indexOf('detalle');
            if (rubroColIndex === -1) throw new Error(`Columna "Rubro" no encontrada en hoja "${type}".`);
            if (detailColIndex === -1) throw new Error(`Columna "Detalle" no encontrada en hoja "${type}".`);

            const monthColIndices = MONTHS.map(mShort => {
                const mShortLower = mShort.toLowerCase();
                // Allow full month name match as well (e.g., 'enero', 'febrero')
                const fullMonthLower = FULL_MONTHS[MONTHS.indexOf(mShort)].toLowerCase();
                 // Check for short name first, then full name, return the first match
                 const shortIndex = header.findIndex(h => h && h.startsWith(mShortLower) && h.length <= mShortLower.length + 1); // Allow slight variations like "Ene."
                 if (shortIndex !== -1) return shortIndex;
                 const fullIndex = header.findIndex(h => h === fullMonthLower);
                 return fullIndex;
            });

            const missingMonths = MONTHS.filter((_, i) => monthColIndices[i] === -1);
            if (missingMonths.length > 0) console.warn(`Meses no encontrados en hoja "${type}": [${missingMonths.join(', ')}]. Se usarán ceros.`);

             // Ensure scenario-level structures exist (these were reset just before calling this)
             scenarioData.rubroOrder[type] = scenarioData.rubroOrder[type] ?? [];
             scenarioData.data[type] = scenarioData.data[type] ?? {};
             scenarioData.monthStatus[type] = scenarioData.monthStatus[type] ?? {};


            // --- Row Processing ---
            for (let i = 1; i < jsonData.length; i++) {
                const row = jsonData[i];
                if (!row || !Array.isArray(row) || row.every(cell => cell === null || String(cell).trim() === '')) continue; // Skip empty/null rows

                const rubro = String(row[rubroColIndex] ?? '').trim();
                const detail = String(row[detailColIndex] ?? '').trim();
                if (!rubro || !detail) { console.warn(`Fila ${i+1} (${type}) omitida (falta Rubro o Detalle).`); continue; }

                // Add rubro to SCENARIO order if new
                if (!scenarioData.rubroOrder[type].includes(rubro)) {
                    scenarioData.rubroOrder[type].push(rubro);
                }
                // Initialize structures for the rubro in SCENARIO if first time
                if (!scenarioData.data[type][rubro]) {
                    scenarioData.data[type][rubro] = { detailOrder: [], detailsData: {} };
                }
                 // Initialize monthStatus object for the rubro if needed
                 if (!scenarioData.monthStatus[type][rubro]) {
                    scenarioData.monthStatus[type][rubro] = {};
                 }
                 // Add detail to SCENARIO order if new for this rubro
                 if (!scenarioData.data[type][rubro].detailOrder.includes(detail)) {
                    scenarioData.data[type][rubro].detailOrder.push(detail);
                 }
                // Initialize arrays for the specific detail in SCENARIO
                if (!scenarioData.data[type][rubro].detailsData[detail]) {
                    scenarioData.data[type][rubro].detailsData[detail] = Array(12).fill(0);
                }
                 // Initialize status array for the detail if needed (only for gastos)
                 if (type === 'gastos' && !scenarioData.monthStatus[type][rubro][detail]) {
                     scenarioData.monthStatus[type][rubro][detail] = Array(12).fill('Estimado');
                 }


                // Track new rubros for GLOBAL update later
                 if (!appState.settings.rubros[type].includes(rubro) && !newRubrosTracker[type].includes(rubro)) {
                    newRubrosTracker[type].push(rubro);
                 }

                // --- Process Monthly Values ---
                for (let m = 0; m < 12; m++) {
                    const colIndex = monthColIndices[m];
                    let value = 0;
                    let status = 'Estimado'; // Default status

                    if (colIndex !== -1 && row[colIndex] !== null) {
                        const cellValue = row[colIndex];
                        if (typeof cellValue === 'number' && !isNaN(cellValue)) {
                            value = cellValue;
                             if (type === 'gastos') status = 'REAL'; // Mark GASTOS with numbers as REAL
                        } else if (typeof cellValue === 'string' && cellValue.trim() !== '') {
                             // Try parsing string as number (handle currency symbols, thousands separators etc.)
                             const cleanedValue = cellValue.replace(/[$.]/g, '').replace(',', '.'); // Remove $, . (thousands), replace , (decimal) with .
                             const parsedNum = parseFloat(cleanedValue);
                             if (!isNaN(parsedNum)) {
                                 value = parsedNum;
                                 if (type === 'gastos') status = 'REAL';
                             } else {
                                  // console.warn(`Valor no numérico "${cellValue}" en ${type}/${rubro}/${detail} - ${MONTHS[m]}. Usando 0.`);
                             }
                         }
                    }
                    // Assign value to SCENARIO data
                    scenarioData.data[type][rubro].detailsData[detail][m] = value;
                     // Assign status ONLY for gastos based on Excel content
                     if (type === 'gastos') {
                         // Ensure the status array exists before assigning
                         if (!scenarioData.monthStatus[type][rubro][detail]) {
                             scenarioData.monthStatus[type][rubro][detail] = Array(12).fill('Estimado');
                         }
                         scenarioData.monthStatus[type][rubro][detail][m] = status;
                     }
                }
            }
             console.log(`Hoja "${type}" procesada. Rubros en orden: [${scenarioData.rubroOrder[type].join(', ')}]`);
        }


        function loadSampleData() {
            console.log("Cargando datos de ejemplo...");
            const scenarioData = getCurrentScenarioData();
            if (!scenarioData) { showSnackbar("No hay escenario activo. Crea o selecciona un año.", true, 'error'); return; }

            // Reset current scenario data
            scenarioData.data = { gastos: {}, ingresos: {} };
            scenarioData.monthStatus = { gastos: {}, ingresos: {} };
            scenarioData.rubroOrder = { gastos: [], ingresos: [] };
            // Calculated reset happens in calculateAll

            const sampleGastosRubros = ["Seguridad", "Jardinería", "Mantenimiento", "Administración", "Servicios Públicos"];
            // --- MODIFICADO: Usar constante ---
            const sampleIngresosRubros = [CUOTA_RUBRO_NAME, "Alquiler SUM", "Ingresos Extra", EXTRA_CUOTA_RUBRO_NAME];
            let settingsChanged = false;

            // Ensure sample rubros exist globally and locally
            sampleGastosRubros.forEach(r => {
                if (!appState.settings.rubros.gastos.includes(r)) { appState.settings.rubros.gastos.push(r); settingsChanged = true; }
                if (!appState.settings.rubroConfig[r]) appState.settings.rubroConfig[r] = { coefficientType: 'None', detailsCollapsed: true };
                if (!scenarioData.rubroOrder.gastos.includes(r)) scenarioData.rubroOrder.gastos.push(r);
            });
            sampleIngresosRubros.forEach(r => {
                 if (!appState.settings.rubros.ingresos.includes(r)) { appState.settings.rubros.ingresos.push(r); settingsChanged = true; }
                 if (!scenarioData.rubroOrder.ingresos.includes(r)) scenarioData.rubroOrder.ingresos.push(r);
            });

             // Initialize structures in the current scenario for these rubros AND ensure others are initialized
             initializeScenarioDataForRubros(scenarioData);
             if (settingsChanged) {
                 // Re-initialize all scenarios if global settings changed
                Object.values(appState.scenarios).forEach(scen => initializeScenarioDataForRubros(scen));
                saveState(); // Save settings early if they changed
             }

            // --- Gastos Data & Status ---
            scenarioData.data.gastos["Seguridad"].detailOrder = ["Vigilador Dia", "Vigilador Noche", "Monitoreo Cámaras"];
            scenarioData.data.gastos["Seguridad"].detailsData = {
                "Vigilador Dia":   [50000, 50500, 51000, 51500, 52000, 52500, 53000, 53500, 54000, 54500, 55000, 55500],
                "Vigilador Noche": [55000, 55500, 56000, 56500, 57000, 57500, 58000, 58500, 59000, 59500, 60000, 60500],
                "Monitoreo Cámaras": Array(12).fill(10000)
            };
            scenarioData.monthStatus.gastos["Seguridad"] = {
                "Vigilador Dia":   ['REAL','REAL','REAL','REAL',   'Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'],
                "Vigilador Noche": ['REAL','REAL','REAL','REAL',   'Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'],
                "Monitoreo Cámaras": ['REAL','REAL','REAL','REAL', 'Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'] // Example: Real first 4 months
            };
             scenarioData.data.gastos["Jardinería"].detailOrder = ["Mantenimiento Parque", "Reposición Plantas"];
             scenarioData.data.gastos["Jardinería"].detailsData = {
                 "Mantenimiento Parque": [30000, 30000, 30500, 30500, 31000, 31000, 31500, 31500, 32000, 32000, 32500, 32500],
                 "Reposición Plantas":   [0,     0,     5000,  0,     0,     0,     0,     0,     6000,  0,     0,     0]
             };
             scenarioData.monthStatus.gastos["Jardinería"] = {
                 "Mantenimiento Parque": ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'],
                 "Reposición Plantas":   ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','REAL','Estimado','Estimado','Estimado']
             };
            scenarioData.data.gastos["Mantenimiento"].detailOrder = ["Bomba Agua Pozo", "Limpieza Tanques", "Pintura General"];
            scenarioData.data.gastos["Mantenimiento"].detailsData = {
                "Bomba Agua Pozo":  [0,     12000, 0,     0,     0,     0,     0,     13500, 0,     0,     0,     0],
                "Limpieza Tanques": [0,     0,     0,     15000, 0,     0,     0,     0,     0,     15000, 0,     0],
                "Pintura General":  [0,     0,     0,     0,     0,     0,     0,     0,     45000, 0,     0,     0]
            };
             scenarioData.monthStatus.gastos["Mantenimiento"] = {
                "Bomba Agua Pozo":  ['REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','REAL','Estimado','Estimado','Estimado','Estimado'],
                "Limpieza Tanques": ['Estimado','Estimado','Estimado','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','REAL','Estimado','Estimado'],
                "Pintura General":  ['Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','REAL','Estimado','Estimado','Estimado']
             };
             scenarioData.data.gastos["Administración"].detailOrder = ["Honorarios Admin", "Gastos Bancarios", "Papelería"];
            scenarioData.data.gastos["Administración"].detailsData = {
                "Honorarios Admin": Array(12).fill(40000),
                "Gastos Bancarios": [500,   500,   550,   550,   600,   600,   600,   650,   650,   700,   700,   700],
                "Papelería":        [1000,  0,     0,     1200,  0,     0,     1500,  0,     0,     1000,  0,     0]
            };
             scenarioData.monthStatus.gastos["Administración"] = {
                 "Honorarios Admin": ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'], // Make first 4 real
                 "Gastos Bancarios": ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'],
                 "Papelería":        ['REAL','REAL','REAL','REAL','Estimado','Estimado','REAL','Estimado','Estimado','REAL','Estimado','Estimado']
             };
            scenarioData.data.gastos["Servicios Públicos"].detailOrder = ["Luz Espacios Comunes", "Agua Riego"];
            scenarioData.data.gastos["Servicios Públicos"].detailsData = {
                "Luz Espacios Comunes": [18000, 19500, 21000, 20500, 19000, 18500, 19000, 20000, 22000, 23000, 21500, 20000],
                "Agua Riego":           [5000,  6000,  7500,  8000,  7000,  6500,  6000,  7000,  8500,  9000,  8000,  6000]
            };
             scenarioData.monthStatus.gastos["Servicios Públicos"] = {
                 "Luz Espacios Comunes": ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'],
                 "Agua Riego":           ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado']
             };

            // --- Ingresos Data --- (No monthStatus here)
             // --- MODIFICADO: Usar constante en nombre de rubro ---
            scenarioData.data.ingresos[CUOTA_RUBRO_NAME].detailOrder = ["Valor Base UF"];
            scenarioData.data.ingresos[CUOTA_RUBRO_NAME].detailsData = { "Valor Base UF": [1500, 1500, 1550, 1550, 1600, 1600, 1650, 1650, 1700, 1700, 1750, 1750] }; // Varied example
            scenarioData.data.ingresos["Alquiler SUM"].detailOrder = ["Eventos Fin de Semana", "Eventos Semana"];
            scenarioData.data.ingresos["Alquiler SUM"].detailsData = {
                "Eventos Fin de Semana": [5000, 6000, 4000, 7000, 8000, 9000, 5000, 6000, 7500, 8500, 9500, 10000],
                "Eventos Semana":        [1000, 1500, 1000, 2000, 2500, 2000, 1500, 1800, 2200, 2500, 2000, 1500]
            };
            scenarioData.data.ingresos["Ingresos Extra"].detailOrder = ["Multas Reglamento", "Donaciones"];
            scenarioData.data.ingresos["Ingresos Extra"].detailsData = {
                "Multas Reglamento": [0,    1000, 500,  0,    1500, 0,    0,    500,  0,    1000, 0,    0],
                "Donaciones":        [0,    0,    0,    0,    5000, 0,    0,    0,    0,    0,    10000,0]
            };
            scenarioData.data.ingresos[EXTRA_CUOTA_RUBRO_NAME].detailOrder = ["Cuota Obra Pileta"];
            scenarioData.data.ingresos[EXTRA_CUOTA_RUBRO_NAME].detailsData = { "Cuota Obra Pileta": [0, 0, 0, 500, 500, 500, 500, 500, 0, 0, 0, 0] };


             // Update Settings panel if new rubros were added globally
            if (settingsChanged) {
                updateSettingsPanel();
            }

            const feedbackDiv = document.getElementById('file-upload-feedback');
            feedbackDiv.textContent = "Datos de ejemplo cargados.";
            feedbackDiv.style.color = 'var(--success-color)';

            // Recalculate with sample data
            calculateAll(scenarioData); // This also saves state & updates UI
            showSnackbar("Datos de ejemplo cargados y procesados.", false, 'success');
         }

        function downloadTemplate() {
             const wb = XLSX.utils.book_new();
             const year = appState.currentYear;

             // Gastos Sheet
             const ws_gastos_data = [
                 ["Rubro", "Detalle", "Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"],
                 ["Seguridad", "Vigilador Dia", 50000, 50500, 51000, null, null, null, null, null, null, null, null, null], // null = Estimado
                 ["Seguridad", "Monitoreo Cámaras", 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], // Con valor = REAL
                 ["Jardinería", "Mantenimiento Parque", 30000, 30000, null, null, null, null, null, null, null, null, null, null],
                 ["Mantenimiento", "Limpieza Pileta", null, null, 5000, 5000, null, null, null, null, null, 5500, null, null], // Gastos esporádicos
                 ["Administración", "Honorarios Admin", 40000, 40000, 40000, 40000, null, null, null, null, null, null, null, null],
             ];
             const ws_gastos = XLSX.utils.aoa_to_sheet(ws_gastos_data);
             ws_gastos['!cols'] = [ {wch:20}, {wch:25}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10} ];
             XLSX.utils.book_append_sheet(wb, ws_gastos, GASTOS_SHEET_NAME);

             // Ingresos Sheet - MODIFICADO
             const ws_ingresos_data = [
                 ["Rubro", "Detalle", "Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"],
                 [CUOTA_RUBRO_NAME, `Valor Base 1 UF`, 1500, 1500, 1500, 1600, 1600, 1600, 1700, 1700, 1700, 1800, 1800, 1800], // VALOR POR UF
                 [EXTRA_CUOTA_RUBRO_NAME, `Cuota Extra Obra (x UF)`, null, null, null, 500, 500, 500, 500, null, null, null, null, null], // VALOR POR UF
                 ["Alquiler SUM", "Evento Sabado", 5000, null, 6000, null, null, 7000, null, null, 8000, null, null, 9000], // Ingresos esporádicos
                 ["Ingresos Extra", "Multa Atraso", null, 1000, 500,  0,    1500, null, null, 500, null, null, null, null]
             ];
             const ws_ingresos = XLSX.utils.aoa_to_sheet(ws_ingresos_data);
             ws_ingresos['!cols'] = [ {wch:25}, {wch:25}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10} ];
             XLSX.utils.book_append_sheet(wb, ws_ingresos, INGRESOS_SHEET_NAME);

             XLSX.writeFile(wb, `Plantilla_Expensas_${year}.xlsx`);
             showSnackbar("Plantilla de ejemplo descargada.", false, 'success');
        }

        function saveReserveFund() {
             console.log("Guardando config fondo reserva...");
             const scenarioData = getCurrentScenarioData();
             if (!scenarioData) { showSnackbar("No hay escenario activo.", true, 'error'); return; }

             // Ensure reserveFund object and values array exist
             scenarioData.reserveFund = scenarioData.reserveFund ?? { type: 'percent', values: Array(12).fill(5) };
             if (!Array.isArray(scenarioData.reserveFund.values) || scenarioData.reserveFund.values.length !== 12) {
                 scenarioData.reserveFund.values = Array(12).fill(scenarioData.reserveFund.type === 'percent' ? 5 : 0);
             }

             const newType = document.getElementById('reserve-type-percent').checked ? 'percent' : 'fixed';
             let valuesChanged = scenarioData.reserveFund.type !== newType;
             scenarioData.reserveFund.type = newType;

             const inputs = document.querySelectorAll('#reserve-fund-panel input[type="number"]');
             let validationOk = true;

             inputs.forEach(input => {
                 const monthIndex = parseInt(input.dataset.month);
                 const value = parseFloat(input.value);

                 if (!isNaN(value) && value >= 0 && monthIndex >= 0 && monthIndex < 12) {
                     if (scenarioData.reserveFund.values[monthIndex] !== value) {
                         scenarioData.reserveFund.values[monthIndex] = value;
                         valuesChanged = true;
                     }
                 } else {
                     input.value = scenarioData.reserveFund.values[monthIndex]; // Revert display
                     showSnackbar(`Valor inválido para ${FULL_MONTHS[monthIndex]}. Debe ser >= 0.`, true, 'error');
                     validationOk = false;
                 }
             });

             if (!validationOk) { console.warn("Guardado fondo reserva cancelado por valores inválidos."); return; }

             if (valuesChanged) {
                 console.log("Cambios detectados en fondo reserva. Recalculando...");
                 // Recalculate handles saveState and success message
                 calculateAll(scenarioData);
             } else {
                 showSnackbar("No se detectaron cambios en la configuración del fondo.", false, 'info');
             }
        }

        function saveSettings() {
             console.log("Guardando configuración general...");
             const oldSettingsJson = JSON.stringify(appState.settings);

             // --- Save Cantidad UF ---
             const cantidadInput = document.getElementById('cantidad-unidades');
             const newCantidadUnidades = parseInt(cantidadInput.value);
             if (!isNaN(newCantidadUnidades) && newCantidadUnidades > 0) {
                 appState.settings.cantidadUnidades = newCantidadUnidades;
             } else {
                 cantidadInput.value = appState.settings.cantidadUnidades; // Revert
                 showSnackbar("Cantidad de UF inválida (> 0).", true, 'error');
                 return; // Stop saving
             }

             // --- Manual IPC Inputs are already saved in state by their onchange handlers ---
             // --- Rubro Config (Coef assignments, collapsed state) saved by handlers ---
             // --- Coefficient Type Values saved by handlers ---

             // --- Ensure IPC Manual array is valid before saving ---
             if (!Array.isArray(appState.settings.ipcManual) || appState.settings.ipcManual.length !== 12) {
                appState.settings.ipcManual = Array(12).fill(0);
             }

             saveState(); // Save potential UF change and ensure IPC values are persisted

             const newSettingsJson = JSON.stringify(appState.settings);
             const settingsChangedForCalc = newSettingsJson !== oldSettingsJson;

             if (settingsChangedForCalc) {
                 console.log("Configuración cambiada, recalculando escenario activo...");
                 const scenarioData = getCurrentScenarioData();
                 if (scenarioData) {
                     // calculateAll handles success message
                     calculateAll(scenarioData);
                 } else {
                     showSnackbar("Configuración guardada, pero no hay escenario activo para recalcular.", false, 'warning');
                 }
             } else {
                 showSnackbar("Configuración guardada (sin cambios que requieran recálculo).", false, 'success');
             }
             // Refresh the panel UI just in case (e.g., if UF was reverted)
             updateSettingsPanel();
        }

        function addRubro(type) {
            const inputId = `new-${type}-rubro-name`;
            const input = document.getElementById(inputId);
            if (!input) { console.error(`Input no encontrado: ${inputId}`); showSnackbar("Error interno.", true); return; }
            const newRubroName = input.value.trim();

            if (!newRubroName) { showSnackbar("Nombre de rubro vacío.", true, 'warning'); input.focus(); return; }

            if (appState.settings.rubros[type].some(r => r.toLowerCase() === newRubroName.toLowerCase())) {
                showSnackbar(`Rubro "${newRubroName}" ya existe en ${type}.`, true, 'warning');
                input.select(); return;
            }

            // Add to global settings
            appState.settings.rubros[type].push(newRubroName);
            if (type === 'gastos' && !appState.settings.rubroConfig[newRubroName]) {
                appState.settings.rubroConfig[newRubroName] = { coefficientType: 'None', detailsCollapsed: true };
            }

            // Initialize data structures for this new rubro in ALL existing scenarios
            Object.values(appState.scenarios).forEach(scenario => {
                 initializeScenarioDataForRubros(scenario);
            });

            input.value = '';
            console.log(`Rubro ${type} añadido: ${newRubroName}`);
            saveState(); // Save updated settings and scenario structures

            updateRubroList(type, `${type}-rubro-list`);
            // Update the other list too if it's gastos (to update coefficient dropdowns)
            if(type === 'ingresos' && document.getElementById('gasto-rubro-list')) {
                 updateRubroList('gastos', 'gasto-rubro-list');
            }

            showSnackbar(`Rubro "${newRubroName}" (${type}) añadido.`, false, 'success');
        }

        function deleteRubro(type, rubroToDelete) {
             if (!confirm(`¿Seguro que quieres eliminar el rubro "${rubroToDelete}" (${type})?\n\nSe borrarán todos sus datos en TODOS los escenarios.\n¡No se puede deshacer!`)) {
                 showSnackbar("Eliminación cancelada.", false, 'info'); return;
             }

             // --- Remove from Global Settings ---
             appState.settings.rubros[type] = appState.settings.rubros[type].filter(r => r !== rubroToDelete);
             delete appState.settings.rubroConfig[rubroToDelete];
             console.log(`Rubro "${rubroToDelete}" eliminado de config global.`);

             // --- Remove from ALL Scenarios ---
             Object.keys(appState.scenarios).forEach(scenarioKey => {
                 const scenario = appState.scenarios[scenarioKey];
                 if (scenario) { // Check if scenario exists
                     // Check if type exists in scenario data
                     if (scenario.data?.[type]) {
                         delete scenario.data[type][rubroToDelete];
                     }
                     if (scenario.monthStatus?.[type]) {
                         delete scenario.monthStatus[type][rubroToDelete];
                     }
                     if (scenario.calculated) { // Check if calculated exists
                         if (type === 'gastos') {
                             if (scenario.calculated.gastoAjustado) delete scenario.calculated.gastoAjustado[rubroToDelete];
                             if (scenario.calculated.totalGastoRubroMes) delete scenario.calculated.totalGastoRubroMes[rubroToDelete];
                             if (scenario.calculated.annualTotals?.gastos) delete scenario.calculated.annualTotals.gastos[rubroToDelete];
                         } else { // ingresos
                             if (scenario.calculated.ingresoAjustado) delete scenario.calculated.ingresoAjustado[rubroToDelete];
                             if (scenario.calculated.totalIngresoRubroMes) delete scenario.calculated.totalIngresoRubroMes[rubroToDelete];
                             if (scenario.calculated.annualTotals?.ingresos) delete scenario.calculated.annualTotals.ingresos[rubroToDelete];
                         }
                     }
                     if (scenario.rubroOrder?.[type]) {
                         scenario.rubroOrder[type] = scenario.rubroOrder[type].filter(r => r !== rubroToDelete);
                     }
                 }
             });

             saveState();

             const activeScenario = getCurrentScenarioData();
             if (activeScenario) {
                 // Recalculate handles saveState and success message
                 calculateAll(activeScenario);
             } else {
                 updateUI(); // Just refresh lists if no active scenario
                 showSnackbar(`Rubro "${rubroToDelete}" (${type}) eliminado.`, false, 'success');
             }
             // Update settings panel lists explicitly
             updateSettingsPanel();
        }

        function addCoefficientType() {
             const input = document.getElementById('new-coefficient-type-name');
             if (!input) { console.error("Input no encontrado: new-coefficient-type-name"); showSnackbar("Error interno.", true); return; }
             const name = input.value.trim();

             if (!name) { showSnackbar("Nombre de tipo vacío.", true, 'warning'); input.focus(); return; }

             const key = name.replace(/\s+/g, '_').toUpperCase();
             const nameExists = Object.values(appState.settings.coefficientTypes).some(t => t.name.toLowerCase() === name.toLowerCase());
             // Also check if the generated key already exists
             if (appState.settings.coefficientTypes[key] || nameExists) {
                 showSnackbar(`Tipo "${name}" o clave "${key}" ya existe.`, true, 'warning');
                 input.select(); return;
             }

             appState.settings.coefficientTypes[key] = { name: name, values: Array(12).fill(1), isDefault: false };

             input.value = '';
             console.log(`Tipo coeficiente añadido: "${name}" (${key})`);
             saveState();

             updateCoefficientTypeList();
             updateRubroList('gastos', 'gasto-rubro-list'); // Update selects in gasto list
             showSnackbar(`Tipo de coeficiente "${name}" añadido.`, false, 'success');
        }

        function deleteCoefficientType(typeKey) {
             const type = appState.settings.coefficientTypes[typeKey];
             if (!type) { showSnackbar("Tipo no encontrado.", true, 'error'); return; }
             if (typeKey === 'None' || type.isDefault) { // Cannot delete 'None' or other defaults
                 showSnackbar(`Tipo por defecto "${type.name}" no se puede eliminar.`, true, 'warning'); return;
             }

             const isInUse = appState.settings.rubros.gastos.some(rubro => appState.settings.rubroConfig[rubro]?.coefficientType === typeKey);
             if (isInUse) {
                 showSnackbar(`Tipo "${type.name}" está en uso por uno o más rubros de gasto. Reasigna los rubros (a 'Sin Coeficiente' u otro) antes de eliminar este tipo.`, true, 'warning', 9000);
                 return;
             }

             if (confirm(`¿Seguro que quieres eliminar el tipo de coeficiente "${type.name}"?`)) {
                 const deletedName = type.name;
                 delete appState.settings.coefficientTypes[typeKey];

                 if (appState.uiState.editingCoefficientType === typeKey) {
                     appState.uiState.editingCoefficientType = null;
                     renderCoefficientValuesEditor(null); // Clear editor
                 }

                 console.log(`Tipo coeficiente eliminado: ${deletedName} (${typeKey})`);
                 saveState();

                 updateCoefficientTypeList();
                 updateRubroList('gastos', 'gasto-rubro-list'); // Update selects in gasto list

                 showSnackbar(`Tipo de coeficiente "${deletedName}" eliminado.`, false, 'success');
             } else {
                 showSnackbar("Eliminación cancelada.", false, 'info');
             }
        }

        function updateReserveUI() {
             const scenarioData = getCurrentScenarioData();
             if (!scenarioData) return;

             const selectedType = document.getElementById('reserve-type-percent').checked ? 'percent' : 'fixed';
             const panel = document.getElementById('reserve-fund-panel');
             if (!panel) return;

             const unitLabel = scenarioData.reserveFund.type === 'percent' ? '%' : '$'; // Use scenarioData type for UI label
             const currentStep = scenarioData.reserveFund.type === 'percent' ? '0.1' : '100'; // Use scenarioData type for step

             // Note: The radio button change updates the scenarioData.reserveFund.type *after* updateReserveUI is called by the handler.
             // So it's better to get the *selected* radio value for UI updates, and the saved value for state logic in saveReserveFund.
             const uiSelectedType = document.getElementById('reserve-type-percent').checked ? 'percent' : 'fixed';
             const uiUnitLabel = uiSelectedType === 'percent' ? '%' : '$';
             const uiCurrentStep = uiSelectedType === 'percent' ? '0.1' : '100';


             panel.querySelectorAll('input[type="number"]').forEach(input => {
                 input.step = uiCurrentStep;
                 // Optional: Adjust value if switching types dramatically? No, better to keep input value as is.
             });
             panel.querySelectorAll('.month-config span').forEach(span => span.textContent = uiUnitLabel);

             console.log(`UI fondo reserva actualizada a tipo: ${uiSelectedType}`);
        }

        function exportToExcel() {
             console.log("Iniciando exportación Excel...");
             const scenarioData = getCurrentScenarioData();
             // --- FIX: Check for calculated data existence more thoroughly ---
             if (!scenarioData || !scenarioData.calculated || !scenarioData.calculated.annualTotals || !scenarioData.calculated.totalGastoProyectadoMes || !scenarioData.calculated.totalIngresoProyectadoMes) {
                 showSnackbar("No hay datos calculados válidos para exportar.", true, 'error'); return;
             }
             const { year, scenarioName, data, calculated, reserveFund, rubroOrder } = scenarioData;
             const { settings } = appState;
             const { rubros, rubroConfig, coefficientTypes, cantidadUnidades, ipcManual: ipcSettings } = settings; // Use settings IPC for reference row

             try {
                 const wb = XLSX.utils.book_new();

                 // Define basic cell formats (more complex styling is harder with aoa_to_sheet)
                 const headerStyle = { font: { bold: true }, alignment: { horizontal: "center" } };
                 const currencyFormat = "$ #,##0.00";
                 const percentFormat = "0.0%";
                 const numberFormat = "#,##0.00"; // Non-currency number

                 // --- Helper to create data for sheets ---
                 const createSheetData = (title, headers, dataRows) => {
                     // Filter out rows that are just placeholders (like section headers) before adding data
                     const validDataRows = dataRows.filter(row => Array.isArray(row) && row.length > 0);
                     return [[title], [], headers, ...validDataRows];
                 };

                 // --- 1. Detalle Gastos Sheet ---
                 const gastosHeaders = ["Rubro", "Detalle", "Coef. Aplicado", ...FULL_MONTHS, "Total Anual"];
                 const gastosRows = [];
                 (rubroOrder?.gastos || []).forEach(rubro => {
                     if (!settings.rubros.gastos.includes(rubro)) return;
                     const config = rubroConfig[rubro] || {};
                     const coefName = coefficientTypes[config.coefficientType || 'None']?.name || 'N/A';
                     const detailOrder = data.gastos?.[rubro]?.detailOrder || [];
                     detailOrder.forEach(detail => {
                         const values = calculated.gastoAjustado?.[rubro]?.[detail] || Array(12).fill(0);
                         const annualTotal = values.reduce((a, b) => a + (b || 0), 0);
                         gastosRows.push([rubro, detail, coefName, ...values, annualTotal]);
                     });
                 });
                 const ws_gastos_array = createSheetData(`DETALLE GASTOS ${year} - ${scenarioName}`, gastosHeaders, gastosRows);
                 const ws_gastos = XLSX.utils.aoa_to_sheet(ws_gastos_array);
                 // Basic Widths
                 ws_gastos['!cols'] = [{wch:20},{wch:25},{wch:18}, ...Array(12).fill({wch:12}), {wch:14}];
                 // Apply formatting (basic example for values)
                 // Data starts at row index 3 (0-based), col index 3 (0-based)
                 const dataStartRow = ws_gastos_array.findIndex(row => row === gastosHeaders) + 1; // Find header row, add 1
                 if (dataStartRow !== -1) {
                      for (let rowIndex = dataStartRow; rowIndex < ws_gastos_array.length; rowIndex++) {
                          for (let col = 3; col < 15 + 1; col++) { // Months (3-14) + Total (15)
                              const cellRef = XLSX.utils.encode_cell({r: rowIndex, c: col});
                               // Only apply format if cell exists and contains a number
                               if(ws_gastos[cellRef] && typeof ws_gastos[cellRef].v === 'number') {
                                   ws_gastos[cellRef].z = currencyFormat;
                                   // Ensure cell type is number 'n' (aoa_to_sheet usually handles this but explicit is safer)
                                   ws_gastos[cellRef].t = 'n';
                               }
                          }
                      }
                 }
                 XLSX.utils.book_append_sheet(wb, ws_gastos, "Detalle Gastos");


                 // --- 2. Detalle Ingresos Sheet (Shows BASE values) ---
                 const ingresosHeaders = ["Rubro", "Detalle", ...FULL_MONTHS, "Total Anual"];
                 const ingresosRows = [];
                 (rubroOrder?.ingresos || []).forEach(rubro => {
                    if (!settings.rubros.ingresos.includes(rubro)) return;
                    const detailOrder = data.ingresos?.[rubro]?.detailOrder || [];
                    detailOrder.forEach(detail => {
                        const values = calculated.ingresoAjustado?.[rubro]?.[detail] || Array(12).fill(0); // BASE values
                        const annualTotal = values.reduce((a, b) => a + (b || 0), 0);
                        const rubroNote = SPECIAL_INGRESO_RUBROS.includes(rubro) ? ` (Valor Base x UF)` : '';
                        ingresosRows.push([`${rubro}${rubroNote}`, detail, ...values, annualTotal]);
                    });
                 });
                 const ws_ingresos_array = createSheetData(`DETALLE INGRESOS (Valores Base) ${year} - ${scenarioName}`, ingresosHeaders, ingresosRows);
                 const ws_ingresos = XLSX.utils.aoa_to_sheet(ws_ingresos_array);
                 ws_ingresos['!cols'] = [{wch:25},{wch:25}, ...Array(12).fill({wch:12}), {wch:14}];
                 // Data starts at row index 3 (0-based), col index 2 (0-based)
                 const ingresosDataStartRow = ws_ingresos_array.findIndex(row => row === ingresosHeaders) + 1;
                  if (ingresosDataStartRow !== -1) {
                     for (let rowIndex = ingresosDataStartRow; rowIndex < ws_ingresos_array.length; rowIndex++) {
                         for (let col = 2; col < 14 + 1; col++) { // Months (2-13) + Total (14)
                             const cellRef = XLSX.utils.encode_cell({r: rowIndex, c: col});
                             if(ws_ingresos[cellRef] && typeof ws_ingresos[cellRef].v === 'number') {
                                  ws_ingresos[cellRef].z = currencyFormat;
                                  ws_ingresos[cellRef].t = 'n';
                              }
                         }
                     }
                  }
                 XLSX.utils.book_append_sheet(wb, ws_ingresos, "Detalle Ingresos (Base)");


                 // --- 3. Resumen General Sheet ---
                 const resumenHeaders = ["Concepto", ...FULL_MONTHS, "Total Anual"];
                 const resumenRows = [];
                 const addRow = (label, values, format, isPercent = false, isUF = false) => {
                    const annual = values.reduce ? values.reduce((a, b) => a + (b || 0), 0) : values; // Sum if array, else take value
                    resumenRows.push([label, ...values, annual]);
                    const lastRowIndex = resumenRows.length - 1; // 0-based index within resumenRows array
                    // Store formatting info for this row
                     resumenRows[lastRowIndex].formatInfo = { format, isPercent, isUF };
                 };

                 // Gastos Section
                 resumenRows.push(["--- GASTOS ---"]);
                 (rubroOrder?.gastos || []).forEach(rubro => {
                     if (!settings.rubros.gastos.includes(rubro)) return;
                     addRow(`Gasto - ${rubro}`, calculated.totalGastoRubroMes?.[rubro] || Array(12).fill(0), currencyFormat);
                 });
                 addRow("TOTAL GASTOS ($)", calculated.totalGastoProyectadoMes || [], currencyFormat);
                 resumenRows.push([]); // Spacer

                 // Ingresos Section (Calculated totals incl. UF mult)
                 resumenRows.push(["--- INGRESOS (Calculados) ---"]);
                 (rubroOrder?.ingresos || []).forEach(rubro => {
                     if (!settings.rubros.ingresos.includes(rubro)) return;
                     addRow(`Ingreso - ${rubro}`, calculated.totalIngresoRubroMes?.[rubro] || [], currencyFormat);
                 });
                 addRow("TOTAL INGRESOS ($)", calculated.totalIngresoProyectadoMes || [], currencyFormat);
                 resumenRows.push([]); // Spacer

                 // Fondo Reserva Section
                 resumenRows.push(["--- FONDO RESERVA ---"]);
                 // Ensure reserveFund object and values exist/are valid
                 const reserveValues = Array.isArray(reserveFund?.values) && reserveFund.values.length === 12
                                     ? reserveFund.values
                                     : Array(12).fill(reserveFund?.type === 'percent' ? 5 : 0);
                 const reserveType = reserveFund?.type === 'fixed' ? 'fixed' : 'percent'; // Default to percent
                 const reserveLabel = `Fondo Reserva Config (${reserveType === 'percent' ? '%' : '$'})`;
                 addRow(reserveLabel, reserveValues.map(v => parseFloat(v || 0)), reserveType === 'percent' ? percentFormat : currencyFormat, reserveType === 'percent');
                 addRow("Fondo Reserva Calculado ($)", calculated.fondoReservaMes || [], currencyFormat);
                 resumenRows.push([]); // Spacer

                 // Cuotas & IPC Section
                 resumenRows.push(["--- CUOTAS Y REFERENCIAS ---"]);
                 // UF row: put value only in first month column
                 const ufValues = Array(12).fill(null);
                 ufValues[0] = cantidadUnidades; // Put UF count in the first month column
                 addRow(`Unidades Funcionales (UF)`, ufValues, numberFormat, false, true); // Mark as UF row

                 addRow("Cuota s/Gtos Calculada ($)", calculated.cuotaSobreGastosMes || [], currencyFormat);
                 // Use the snapshot stored in calculated.ipcManual for the report
                 addRow("IPC Referencia (%)", calculated.ipcManual || Array(12).fill(0), percentFormat, true);
                 addRow("Cuota IPC Calculada ($)", calculated.cuotaIpcMes || [], currencyFormat);
                 addRow("Cuota Real Base ($)", calculated.cuotaRealBaseMes || [], currencyFormat);

                 // Create Resumen Sheet
                 const ws_resumen_array = createSheetData(`RESUMEN GENERAL ${year} - ${scenarioName}`, resumenHeaders, resumenRows);
                 const ws_resumen = XLSX.utils.aoa_to_sheet(ws_resumen_array);
                 ws_resumen['!cols'] = [{wch:30}, ...Array(12).fill({wch:12}), {wch:14}];

                  // Apply Formatting based on stored info
                  // Find the actual start row index for data in the sheet
                 const resumenDataStartRow = ws_resumen_array.findIndex(row => row === resumenHeaders) + 1; // Find header row, add 1

                 if (resumenDataStartRow !== -1) {
                     for (let arrayRowIndex = 0; arrayRowIndex < resumenRows.length; arrayRowIndex++) {
                          const rowInfo = resumenRows[arrayRowIndex].formatInfo;
                          if (rowInfo) {
                               const sheetRowIndex = resumenDataStartRow + arrayRowIndex; // Calculate corresponding row index in the sheet

                               for (let col = 1; col < 13 + 1; col++) { // Months (1-12) + Total (13)
                                   const cellRef = XLSX.utils.encode_cell({r: sheetRowIndex, c: col});
                                   // Only apply format if cell exists and contains a number
                                   if(ws_resumen[cellRef] && typeof ws_resumen[cellRef].v === 'number') {
                                       // Convert percent values for Excel (e.g., 5 -> 0.05) unless it's the UF row
                                       if (rowInfo.isPercent && !rowInfo.isUF) {
                                           ws_resumen[cellRef].v /= 100;
                                       }
                                       ws_resumen[cellRef].z = rowInfo.format;
                                        ws_resumen[cellRef].t = 'n';
                                   } else if (rowInfo.isUF && col === 1 && ws_resumen[cellRef] && typeof ws_resumen[cellRef].v === 'number') {
                                        // Apply number format specifically to the first month cell for UF row
                                        ws_resumen[cellRef].z = rowInfo.format;
                                         ws_resumen[cellRef].t = 'n';
                                   }
                               }
                          }
                     }
                 }
                 XLSX.utils.book_append_sheet(wb, ws_resumen, "Resumen General");


                 // --- Write File ---
                 const filename = `Reporte_Expensas_${year}_${scenarioName.replace(/\s+/g, '_')}.xlsx`;
                 XLSX.writeFile(wb, filename);
                 showSnackbar("Reporte Excel generado.", false, 'success');

             } catch (error) {
                  console.error("Error exportando a Excel:", error);
                  showSnackbar(`Error al generar Excel: ${error.message}`, true, 'error');
             }
        }


        function exportChart(canvasId, filename) {
             const canvas = document.getElementById(canvasId);
             const chartInstance = window[`${canvasId}_instance`];
             // Check if canvas and instance exist, and if there is any non-zero data in the first dataset
             if (!canvas || !chartInstance || !chartInstance.data || !chartInstance.data.datasets || chartInstance.data.datasets.length === 0 || chartInstance.data.datasets[0].data.every(d => d === null || d === undefined || d === 0)) {
                  showSnackbar(`Gráfico "${canvasId}" no encontrado o sin datos para exportar.`, true, 'warning');
                 return;
             }
             try {
                 chartInstance.update('none'); // Ensure rendered without animation for export
                 // Allow a small delay for the canvas to potentially re-render after update('none')
                 requestAnimationFrame(() => {
                    requestAnimationFrame(() => { // Double rAF for safety
                     const imageURL = canvas.toDataURL('image/png');
                     const link = document.createElement('a');
                     link.href = imageURL;
                     link.download = filename;
                     document.body.appendChild(link);
                     link.click();
                     document.body.removeChild(link);
                     showSnackbar(`Gráfico "${filename}" exportado como PNG.`, false, 'success');
                    });
                 });
             } catch (e) {
                 console.error(`Error exportando gráfico "${canvasId}":`, e);
                 showSnackbar("Error al exportar gráfico.", true, 'error');
             }
        }


        // --- Utilidades ---
        function formatCurrency(value) {
             const num = Number(value);
             if (isNaN(num)) return "$ 0,00";
             // Use es-AR locale for Argentinian Peso formatting
             return `$ ${num.toLocaleString('es-AR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
        }

        function hexToRgba(hex, alpha) {
            hex = String(hex).trim().replace('#', '');
            if (!/^[0-9A-F]{3,6}$/i.test(hex)) return `rgba(0,0,0,${alpha})`; // Fallback black
            if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
            const r = parseInt(hex.slice(0, 2), 16), g = parseInt(hex.slice(2, 4), 16), b = parseInt(hex.slice(4, 6), 16);
            return (isNaN(r) || isNaN(g) || isNaN(b)) ? `rgba(0,0,0,${alpha})` : `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function openTab(evt, tabName) {
             let i, tabcontent, tablinks;
             tabcontent = document.getElementsByClassName("tab-content");
             for (i = 0; i < tabcontent.length; i++) { tabcontent[i].classList.remove("active"); tabcontent[i].style.display = "none"; }
             tablinks = document.getElementsByClassName("tab-link");
             for (i = 0; i < tablinks.length; i++) { tablinks[i].classList.remove("active"); }
             const tabToShow = document.getElementById(tabName);
             if(tabToShow) { tabToShow.style.display = "block"; void tabToShow.offsetWidth; tabToShow.classList.add("active"); }
             if(evt?.currentTarget) evt.currentTarget.classList.add("active");

             if (tabName === 'dashboard') { // Resize charts when dashboard tab is shown
                 requestAnimationFrame(() => {
                    ['evolutivoCuotaChart', 'participacionGastosChart', 'participacionIngresosChart'].forEach(id => {
                        if (window[`${id}_instance`]) window[`${id}_instance`].resize();
                    });
                 });
             }
        }

        function showSnackbar(message, isError = false, level = null, duration = 4000) {
             const snackbar = document.getElementById('snackbar');
             if (!snackbar) return;
             snackbar.textContent = message;
             let effectiveLevel = level ?? (isError ? 'error' : 'success'); // Default to success if not error

             snackbar.className = 'show'; // Base class to make it visible and positioned
             if (effectiveLevel === 'error') snackbar.classList.add('error');
             else if (effectiveLevel === 'warning') snackbar.classList.add('warning');
             else if (effectiveLevel === 'info') snackbar.classList.add('info');
             // Success uses default style (no extra class needed)

             if (snackbar.timer) clearTimeout(snackbar.timer);
             snackbar.timer = setTimeout(() => {
                 snackbar.className = ''; // Remove all classes to hide
                 snackbar.timer = null;
             }, duration);
        }


        // --- Tema Oscuro/Claro ---
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia?.('(prefers-color-scheme: dark)').matches;
            appState.darkMode = (savedTheme === 'dark') || (!savedTheme && !!prefersDark); // Use saved or system pref
            applyTheme(false); // Apply initial theme without transition/chart update

            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                if (!localStorage.getItem('theme')) { // Only follow system if no explicit choice saved
                    appState.darkMode = event.matches;
                    applyTheme(); // Apply with transition/chart update
                    saveState(); // Save the implicit preference change
                }
            });
        }

        function toggleTheme() {
            appState.darkMode = !appState.darkMode;
            localStorage.setItem('theme', appState.darkMode ? 'dark' : 'light'); // Save explicit choice
            applyTheme();
            saveState();
        }

        function applyTheme(updateCharts = true){
            const body = document.body;
            const toggleButton = document.getElementById('theme-toggle');
            body.classList.toggle('dark-mode', appState.darkMode);
            if (toggleButton) {
                 toggleButton.innerHTML = appState.darkMode ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
                 toggleButton.title = appState.darkMode ? 'Cambiar a tema claro' : 'Cambiar a tema oscuro';
            }

            if (updateCharts) { // Avoid updating charts on initial load before they exist
                 requestAnimationFrame(() => { // Defer chart updates slightly
                     const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
                     const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
                     Chart.defaults.color = textColor;
                     Chart.defaults.borderColor = borderColor;
                     // Update existing instances
                     ['evolutivoCuotaChart', 'participacionGastosChart', 'participacionIngresosChart'].forEach(id => {
                          if (window[`${id}_instance`]) window[`${id}_instance`].update();
                     });
                 });
            }
        }

        // --- Persistencia (localStorage) ---
        function saveState() {
             try {
                 const stateToSave = {
                     currentYear: appState.currentYear,
                     scenarios: appState.scenarios,
                     activeScenarioKey: appState.activeScenarioKey,
                     settings: appState.settings,
                     darkMode: appState.darkMode,
                     // Don't save uiState intentionally
                 };
                 localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
                 // console.log("Estado guardado.");
             } catch (e) {
                 console.error("Error guardando estado:", e);
                 showSnackbar("Error al guardar estado.", true, 'error');
             }
         }

        function loadState() {
             try {
                 const savedState = localStorage.getItem(STORAGE_KEY);
                 if (savedState) {
                     const loadedState = JSON.parse(savedState);
                     appState = deepMerge(getDefaultAppState(), loadedState); // Merge loaded into default structure
                     console.log(`Estado ${STORAGE_KEY} cargado.`);
                 } else {
                     console.log("No hay estado guardado. Usando estado por defecto.");
                     appState = getDefaultAppState(); // Fallback
                 }
             } catch (e) {
                 console.error("Error cargando estado:", e);
                 showSnackbar("Error cargando estado guardado. Usando valores por defecto.", true, 'error');
                 appState = getDefaultAppState(); // Fallback
             }
             // Post-load validation is now handled by validateAndSetActiveScenario in DOMContentLoaded
        }

        function getDefaultAppState() {
            const defaultYear = new Date().getFullYear();
            // Use JSON parse/stringify for a clean deep copy
            return JSON.parse(JSON.stringify({
                 currentYear: defaultYear,
                 scenarios: {}, // Start with empty scenarios object
                 activeScenarioKey: null, // Will be set by validation logic
                 settings: {
                     cantidadUnidades: 100,
                     rubros: { gastos: [], ingresos: [] },
                     rubroConfig: {},
                     coefficientTypes: {
                         "None": { name: "Sin Coeficiente", values: Array(12).fill(1), isDefault: true },
                         "IPC": { name: "IPC (Ejemplo)", values: [1.05, 1.04, 1.06, 1.03, 1.04, 1.05, 1.03, 1.04, 1.05, 1.06, 1.04, 1.05], isDefault: true },
                         "UTEDYC": { name: "UTEDYC (Ejemplo)", values: [1, 1, 1.10, 1, 1, 1.08, 1, 1, 1.07, 1, 1, 1.05], isDefault: true },
                         "Sueldos": { name: "Sueldos Generales", values: [1, 1, 1.08, 1, 1, 1.06, 1, 1, 1.05, 1, 1, 1.04], isDefault: false }
                     },
                     ipcManual: [5, 4, 6, 3, 4, 5, 3, 4, 5, 6, 4, 5] // Default IPC ref values (%)
                 },
                 uiState: { // Transient state
                    editingCoefficientType: null
                 },
                 darkMode: false // Default theme
             }));
        }

        function deepMerge(target, source) {
             const output = { ...target };
             if (isObject(target) && isObject(source)) {
                 Object.keys(source).forEach(key => {
                     const targetValue = target[key];
                     const sourceValue = source[key];
                     if (isObject(sourceValue) && isObject(targetValue)) {
                         output[key] = deepMerge(targetValue, sourceValue);
                     } else if (Array.isArray(sourceValue) && Array.isArray(targetValue)) {
                         // Simple array merge: source overwrites target - adjust if needed
                          output[key] = [...sourceValue];
                     } else {
                          output[key] = sourceValue !== undefined ? sourceValue : targetValue;
                     }
                 });
             }
             return output;
         }

        function isObject(item) {
             return (item && typeof item === 'object' && !Array.isArray(item));
        }

        // --- Funciones Adicionales o de UI ---
        function updateReportsPanel() {
             const scenarioData = getCurrentScenarioData();
             const hasCalculatedData = scenarioData?.calculated && (
                (scenarioData.calculated.totalGastoProyectadoMes?.some(v => v !== 0) ?? false) ||
                (scenarioData.calculated.totalIngresoProyectadoMes?.some(v => v !== 0) ?? false)
             );
             const disable = !scenarioData || !hasCalculatedData;

             document.querySelectorAll('#reports button').forEach(btn => { btn.disabled = disable; });
        }

        function clearScenarioData() {
             const key = appState.activeScenarioKey;
             const scenario = appState.scenarios[key];
             if (!scenario) { showSnackbar('No hay escenario activo.', true, 'error'); return; }

             if (!confirm(`¿Borrar TODOS los datos (gastos, ingresos, estado meses) del escenario "${scenario.scenarioName}"?\n\nConfiguración de Fondo de Reserva se mantendrá.\n¡No se puede deshacer!`)) {
                 showSnackbar("Operación cancelada.", false, 'info'); return;
             }

             // Reset data, keep reserve fund
             scenario.rubroOrder = { gastos: [], ingresos: [] };
             scenario.data = { gastos: {}, ingresos: {} };
             scenario.monthStatus = { gastos: {}, ingresos: {} };
             // Calculated is reset within calculateAll

             console.log(`Datos borrados para escenario: ${key}`);
             saveState(); // Save cleared data structures
             // Recalculate to update totals to zero and refresh UI
             calculateAll(scenario); // Handles success message
        }

    </script>

<!-- Toggle Rubros -->
<style>
.rubro-detail.collapsed { display:none; }
.rubro-header { cursor:pointer; }
.toggle-all-btn { background:none; border:none; font-size:1.2rem; cursor:pointer; margin-left:.5rem;}
</style>
<script>
function initRubrosToggle(){
  document.querySelectorAll('.rubro-header').forEach(h=>{
    h.addEventListener('click', ()=> toggleDetail(h));
  });
}
</script>
</body>
</html>
```