
¡Excelente! Me parece perfecto refinar el comportamiento de los coeficientes para usar porcentajes, integrar el IPC de forma limpia, mejorar la visualización de tablas y gráficos, y añadir esos detalles de pintado de celdas. Eso hará la herramienta mucho más potente e intuitiva.

Aquí tienes el código completo (`index14.html`) con todas estas modificaciones implementadas. He comentado los cambios importantes en el código mismo para que puedas seguir la lógica.

--- START OF FILE index14.html ---

```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="favicon.png">
    <title>Proyección Expensas - Barrio El Centauro</title>
    <!-- Librería SheetJS (js-xlsx) para leer/escribir Excel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Librería Chart.js para gráficos -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- Plugin doughnut 3D shadow -->
<script>
/* Plugin: doughnutShadow3D
   Añade una sombra suave debajo de cada porción para simular profundidad 3 D.
   Seguro para todos los datasets (evita NaN en createRadialGradient). */
const doughnutShadow3D = {
  id: 'doughnutShadow3D',
  afterDatasetDraw(chart, args, opts) {
    const {ctx} = chart;
    if (args.meta.type !== 'doughnut') return;

    args.meta.data.forEach(segment => {
      const {x, y, startAngle, endAngle, innerRadius, outerRadius} = segment;
      // Ensure numeric validity before attempting to draw
      if (!isFinite(x) || !isFinite(y) || !isFinite(startAngle) || !isFinite(endAngle) || !isFinite(innerRadius) || !isFinite(outerRadius)) {
          console.warn("Skipping shadow for segment due to invalid dimensions:", segment);
          return;
      }

      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.15)';      // shadow color
      ctx.translate(0, 4);                     // vertical offset
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.arc(x, y, outerRadius, startAngle, endAngle);
      ctx.arc(x, y, innerRadius, endAngle, startAngle, true);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    });
  }
};
// Registrar plugin globalmente
if (window.Chart && !Chart.registry.plugins.get('doughnutShadow3D')) {
  Chart.register(doughnutShadow3D);
}
</script>

    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts (Inter) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- Reset Básico y Fuentes --- */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; /* Base font size */ }
        body {
            font-family: 'Inter', 'Segoe UI', sans-serif;
            line-height: 1.7; /* Improved readability */
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* --- Variables de Color (Paleta Refinada) --- */
        :root {
            --bg-color: #f8f9fa;              /* Slightly off-white */
            --text-color: #343a40;            /* Darker gray */
            --primary-color: #007bff;          /* Classic blue */
            --primary-color-darker: #0056b3;   /* Darker blue for hover */
            --secondary-color: #6c757d;        /* Standard gray */
            --secondary-color-darker: #5a6268; /* Darker gray for hover */
            --accent-color: #28a745;           /* Vibrant green */
            --accent-color-darker: #218838;    /* Darker green for hover */
            --danger-color: #dc3545;           /* Red */
            --danger-color-darker: #c82333;    /* Darker red */
            --warning-color: #ffc107;           /* Yellow */
            --warning-color-darker: #e0a800;   /* Darker yellow */
            --info-color: #17a2b8;             /* Teal */
            --info-color-darker: #138496;      /* Darker teal */
            --success-color: var(--accent-color); /* Alias for consistency */
            --success-color-darker: var(--accent-color-darker); /* Alias */

            --border-color: #dee2e6;           /* Light gray border */
            --header-bg: #ffffff;              /* White header */
            --card-bg: #ffffff;                /* White cards */
            --shadow-color: rgba(0, 0, 0, 0.08); /* Softer shadow */
            --input-bg: #ffffff;
            --input-border: #ced4da;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(0, 123, 255, 0.25);
            --button-text: #ffffff;
            --button-warning-text: #212529; /* Dark text for yellow button */
            --table-header-bg: #eef2f7;        /* Lighter table header */
            --table-row-hover: #f1f3f5;        /* Subtle hover */
            --expandable-row-bg: #f8f9fa;      /* Same as body bg for subtle diff */
            --clickable-row-hover: #e9ecef;    /* Slightly darker hover for clickable rows */
            --disabled-bg: #e9ecef;
            --disabled-text: #6c757d;
            --disabled-border: #ced4da;

            /* >>> COLORES REAL/ESTIMADO <<< */
            --real-month-bg: #d1f7d9; /* Light, fresh green */
            --estimated-month-bg: #fff3cd; /* Soft Yellow */
        }

        body.dark-mode {
            --bg-color: #1a1a1a;              /* Very dark gray */
            --text-color: #e0e0e0;            /* Light gray text */
            --primary-color: #58a6ff;          /* Brighter blue */
            --primary-color-darker: #79b8ff;   /* Lighter blue for hover */
            --secondary-color: #8b949e;        /* Lighter gray */
            --secondary-color-darker: #a0a8b0; /* Lighter gray hover */
            --accent-color: #56d364;           /* Brighter green */
            --accent-color-darker: #6bde7a;    /* Lighter green hover */
            --danger-color: #f85149;           /* Bright red */
            --danger-color-darker: #fa6a61;    /* Lighter red */
            --warning-color: #f0b41e;          /* Bright yellow */
            --warning-color-darker: #f2c037;   /* Lighter yellow */
            --info-color: #6cb6f1;             /* Bright teal */
            --info-color-darker: #85c3f4;      /* Lighter teal */
            --success-color: var(--accent-color);
            --success-color-darker: var(--accent-color-darker);

            --border-color: #444c56;           /* Darker border */
            --header-bg: #2c2c2c;              /* Dark card background */
            --card-bg: #2c2c2c;                /* Dark card background */
            --shadow-color: rgba(255, 255, 255, 0.05); /* Subtle white shadow */
            --input-bg: #3a3f44;
            --input-border: #5a6268;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(88, 166, 255, 0.25);
            --button-text: #1a1a1a; /* Dark text on bright buttons */
            --button-warning-text: #1a1a1a;
            --table-header-bg: #343a40;        /* Darker header */
            --table-row-hover: #3e444a;        /* Subtle dark hover */
            --expandable-row-bg: #343a40;      /* Darker expandable row bg */
            --clickable-row-hover: #495057;    /* Darker hover for clickable */
            --disabled-bg: #495057;
            --disabled-text: #adb5bd;
            --disabled-border: #5a6268;

            /* >>> COLORES REAL/ESTIMADO OSCURO <<< */
            --real-month-bg: #1c4a2b; /* Darker Green */
            --estimated-month-bg: #5a4a1d; /* Dark Yellow/Brown */
        }

        /* --- Estilos Generales --- */
        *{ /* Add a smoother color transition to elements not covered by explicit transitions */
            transition-property: background-color, color, border-color, box-shadow, fill, stroke;
            transition-duration: 0.3s;
            transition-timing-function: ease-in-out;
        }
        html { scroll-behavior: smooth; font-size: 16px; /* Base font size */ }
        body {
            font-family: 'Inter', 'Segoe UI', sans-serif;
            line-height: 1.7; /* Improved readability */
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        h1, h2, h3, h4 { color: var(--primary-color); margin-bottom: 1em; font-weight: 600; }
        h1 { font-size: 2.2rem; text-align: center; }
        h2 { font-size: 1.8rem; border-bottom: 2px solid var(--accent-color); padding-bottom: 0.4em; }
        h3 { font-size: 1.4rem; margin-top: 1.8em; }
        h4 { font-size: 1.15rem; color: var(--secondary-color); margin-top: 1.2em; margin-bottom: 0.6em; }
        a { color: var(--primary-color); text-decoration: none; transition: color 0.2s ease; }
        a:hover { color: var(--primary-color-darker); text-decoration: underline; }

        button {
            padding: 12px 22px;
            border: 1px solid transparent; /* Added border for consistency */
            border-radius: 6px;
            background-color: var(--primary-color);
            color: var(--button-text);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out, transform 0.1s ease, box-shadow 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center; /* Center content */
            gap: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            line-height: 1.5; /* Ensure consistent height */
            text-align: center; /* Ensure text aligns center */
        }
        button:hover {
            background-color: var(--primary-color-darker);
            border-color: var(--primary-color-darker);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        button:focus {
            outline: none;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        button:disabled {
            background-color: var(--disabled-bg);
            color: var(--disabled-text);
            border-color: var(--disabled-border);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.7; /* Visually indicate disabled state */
        }
        button i { margin-right: 2px; /* Keep small margin */ }

        /* Button variants */
        .button-primary { background-color: var(--primary-color); border-color: var(--primary-color); color: var(--button-text); }
        .button-primary:hover { background-color: var(--primary-color-darker); border-color: var(--primary-color-darker); }
        .button-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: var(--button-text); }
        .button-secondary:hover { background-color: var(--secondary-color-darker); border-color: var(--secondary-color-darker); }
        .button-success { background-color: var(--success-color); border-color: var(--success-color); color: var(--button-text); }
        .button-success:hover { background-color: var(--success-color-darker); border-color: var(--success-color-darker); }
        .button-danger { background-color: var(--danger-color); border-color: var(--danger-color); color: var(--button-text); }
        .button-danger:hover { background-color: var(--danger-color-darker); border-color: var(--danger-color-darker); }
        .button-warning { background-color: var(--warning-color); border-color: var(--warning-color); color: var(--button-warning-text); }
        .button-warning:hover { background-color: var(--warning-color-darker); border-color: var(--warning-color-darker); }
        .button-info { background-color: var(--info-color); border-color: var(--info-color); color: var(--button-text); }
        .button-info:hover { background-color: var(--info-color-darker); border-color: var(--info-color-darker); }
        .button-sm { padding: 6px 12px; font-size: 0.85rem; gap: 6px;}
        .button-lg { padding: 15px 30px; font-size: 1.1rem; }


        /* --- Header --- */
        header {
            background-color: var(--header-bg);
            padding: 15px 0;
            box-shadow: 0 2px 5px var(--shadow-color);
            position: sticky; top: 0; z-index: 1000;
            border-bottom: 1px solid var(--border-color);
        }
        header .container { display: flex; justify-content: space-between; align-items: center; padding-top: 0; padding-bottom: 0; }
        .app-title { font-size: 1.6rem; font-weight: 700; color: var(--primary-color); }
        #theme-toggle { font-size: 1.3rem; background: none; border: none; color: var(--text-color); cursor: pointer; padding: 5px; border-radius: 50%; } /* Removed transition as '*' covers it */
        #theme-toggle:hover { background-color: var(--table-row-hover); }

        /* --- Navegación / Pestañas --- */
        .tabs {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 5px;
        }
        .tab-link {
            padding: 12px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-bottom: -1px; /* Overlap bottom border */
            background-color: transparent;
            color: var(--secondary-color);
            font-size: 1rem;
            font-weight: 600;
            border-radius: 6px 6px 0 0;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            display: inline-flex; /* Align icon and text */
            align-items: center;
            gap: 8px;
        }
        .tab-link:hover {
             color: var(--primary-color);
             background-color: var(--table-row-hover);
        }
        .tab-link.active {
            background-color: var(--card-bg);
            border-color: var(--border-color);
            border-bottom-color: var(--card-bg); /* Hide bottom border part */
            color: var(--primary-color);
            font-weight: 700;
        }
        .tab-content {
            display: none;
            padding: 30px;
            border: 1px solid var(--border-color);
            border-top: none;
            background-color: var(--card-bg);
            border-radius: 0 0 6px 6px;
            box-shadow: 0 5px 15px var(--shadow-color);
        }
        .tab-content.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Formularios y Entradas --- */
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-color); font-size: 0.95rem;}
        input[type="text"], input[type="number"], input[type="file"], select, textarea {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid var(--input-border);
            border-radius: 6px;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1rem;
        }
        input:focus, select:focus, textarea:focus {
            border-color: var(--input-focus-border);
            outline: 0;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        input:disabled, select:disabled, textarea:disabled {
             background-color: var(--disabled-bg);
             color: var(--disabled-text);
             border-color: var(--disabled-border);
             cursor: not-allowed;
        }
        input[type="number"] { text-align: right; -moz-appearance: textfield; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { margin: 0; }
        input[type="file"] { padding: 8px; line-height: 1.5; } /* Adjust file input padding */
        .input-group { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
        .input-group label { margin-bottom: 0; font-weight: normal;}
        .input-group input[type="radio"] { width: auto; margin-right: 5px; }
        .input-small { width: 150px; display: inline-block; margin-left: 10px; }

        /* --- Tablas --- */
        .table-container { overflow-x: auto; margin-top: 25px; border: 1px solid var(--border-color); border-radius: 6px; }
        table { width: 100%; border-collapse: collapse; background-color: var(--card-bg); font-size: 0.9rem; }
        th, td {
            padding: 12px 15px;
            border: none;
            border-bottom: 1px solid var(--border-color);
            text-align: left;
            vertical-align: middle;
            white-space: nowrap;
        }
        th {
            background-color: var(--table-header-bg);
            font-weight: 600;
            position: sticky; top: 0; z-index: 10;
            border-bottom-width: 2px;
        }
        tbody tr:last-child td { border-bottom: none; }
        /* Use a more specific selector for hover not overriding background colors below */
        tbody tr:hover td { background-color: var(--table-row-hover); }


        /* Cell specific styles */
        /* Target only cells within .collapsible-table .detail-row for coloring */
        .collapsible-table tbody tr.detail-row td.real-month-cell { background-color: var(--real-month-bg); }
        .collapsible-table tbody tr.detail-row td.estimated-month-cell { background-color: var(--estimated-month-bg); }

         /* Handle hover for colored cells more explicitly for detail rows */
        .collapsible-table tbody tr.detail-row:hover td.real-month-cell { background-color: color-mix(in srgb, var(--real-month-bg), var(--table-row-hover) 30%); }
        .collapsible-table tbody tr.detail-row:hover td.estimated-month-cell { background-color: color-mix(in srgb, var(--estimated-month-bg), var(--table-row-hover) 30%); }


        td.number-cell { text-align: right; font-variant-numeric: tabular-nums; }
        /*td.input-cell input { width: 100px; padding: 6px; font-size: 0.9rem; text-align: right; }*/ /* Now using monthly-inputs-grid styles */
        /*td.input-cell input:disabled { background-color: transparent; border: none; color: var(--disabled-text);}*/ /* Now using monthly-inputs-grid styles */
        .text-muted { color: var(--secondary-color); font-style: italic; font-size: 0.9em;}

        /* --- Tablas Desplegables --- */
        .collapsible-table tbody tr.rubro-total-row { font-weight: bold; cursor: pointer; background-color: var(--expandable-row-bg); } /* Removed transition as '*' covers it */
        .collapsible-table tbody tr.rubro-total-row:hover { background-color: var(--clickable-row-hover); }
        .collapsible-table tbody tr.rubro-total-row td:first-child::before {
            content: '\f078'; /* fa-chevron-down */
            font-family: 'Font Awesome 6 Free'; font-weight: 900; margin-right: 12px; display: inline-block; transition: transform 0.2s ease-in-out; color: var(--primary-color);
        }
        .collapsible-table tbody tr.rubro-total-row.collapsed td:first-child::before { transform: rotate(-90deg); }
        .collapsible-table tbody tr.detail-row { display: table-row; background-color: var(--card-bg); } /* Removed transition as '*' covers it */
        .collapsible-table tbody tr.detail-row.hidden { display: none; }
        .collapsible-table tbody tr.detail-row td { font-size: 0.85rem; color: var(--secondary-color); border-color: var(--border-color); }
        .collapsible-table tbody tr.detail-row td:first-child { padding-left: 40px; /* Indent details more */ }
        body.dark-mode .collapsible-table tbody tr.detail-row { background-color: #353535; }
        .collapsible-table tfoot tr { font-weight: bold; background-color: var(--table-header-bg); border-top: 2px solid var(--border-color); }

         /* Styles for Group/Ungroup All buttons */
        .table-actions {
            margin-bottom: 15px;
             display: flex;
             justify-content: flex-end; /* Align buttons to the right */
             gap: 10px;
             flex-wrap: wrap;
        }


        /* --- Componentes UI Específicos --- */
        #dashboard-summary { border-collapse: separate; border-spacing: 0; }
        #dashboard-summary th, #dashboard-summary td { text-align: center; white-space: normal; }
        #dashboard-summary tbody td, #dashboard-summary tfoot td { padding: 10px 8px; }
        #dashboard-summary .month-header { font-weight: bold; }

        .chart-container {
            margin-top: 35px; padding: 30px;
            background-color: var(--card-bg); border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-color);
            position: relative; min-height: 200px; /* Adjusted min height */
        }
        /* Fixed height needed for chart.js responsive container logic */
        .chart-container canvas { max-width: 100%; height: 380px; display: block;}
        .chart-container.no-data canvas { display: none; }

        .chart-no-data {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--secondary-color);
            font-style: italic; font-size: 1.1rem; text-align: center;
             display: none; /* Hidden by default */
        }
         .chart-container.no-data .chart-no-data {
             display: block; /* Shown when container has 'no-data' class */
         }


        #file-upload-area {
            border: 2px dashed var(--primary-color);
            padding: 45px; text-align: center; background-color: var(--bg-color);
            border-radius: 8px; margin-bottom: 25px; cursor: pointer; /* Removed transition as '*' covers it */
        }
        #file-upload-area:hover { background-color: var(--table-row-hover); border-color: var(--primary-color-darker); }
        #file-upload-area p { margin-bottom: 15px; font-size: 1.1rem; color: var(--secondary-color); }
        #file-upload-area i.fa-file-excel { font-size: 3rem; margin-bottom: 10px; color: var(--accent-color); }
        #file-upload-feedback { margin-top: 15px; font-weight: bold; white-space: pre-wrap; font-size: 0.95rem; min-height: 2em; }

        #reserve-fund-panel { /* This div is now a monthly-inputs-grid */
            margin-top: 20px;
        }


        .config-section {
            border: 1px solid var(--border-color); border-radius: 8px; padding: 25px;
            margin-bottom: 30px; background-color: var(--card-bg);
            box-shadow: 0 3px 7px var(--shadow-color);
        }
        .config-section h4 { border-bottom: 1px solid var(--border-color); padding-bottom: 0.6em; margin-bottom: 1.2em;}
        .management-list { list-style: none; padding: 0; max-height: 350px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 6px; padding: 10px; background-color: var(--bg-color); }
        body.dark-mode .management-list { background-color: #3a3f44; }
        .management-list li { display: flex; justify-content: space-between; align-items: center; padding: 10px 8px; border-bottom: 1px solid var(--border-color); } /* Removed transition as '*' covers it */
        .management-list li:last-child { border-bottom: none;}
        .management-list li:hover { background-color: var(--table-row-hover); }
        .management-list li span { flex-grow: 1; margin-right: 15px; font-weight: 500; }
        .management-list li select { width: 200px; font-size: 0.88rem; padding: 6px 8px; flex-shrink: 0; }
        .management-list li button { flex-shrink: 0; }
        #coefficient-editor { margin-top: 25px; }
        #coefficient-editor h4 { margin-bottom: 15px;}
        /* #coefficient-editor .table-container { max-height: 450px; overflow-y: auto;} No longer a table-container directly */

        /* Monthly inputs grid style - Applied to #reserve-fund-panel and #coefficient-values-editor */
        .monthly-inputs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); /* Adjusted min-width */
            gap: 15px; /* Slightly reduced gap */
            margin-top: 20px;
            padding: 15px; /* Added padding */
            border: 1px solid var(--border-color); /* Added border */
            border-radius: 6px; /* Added border-radius */
            background-color: var(--bg-color); /* Match management list bg */
             /* Removed transition as '*' covers it */
        }
        body.dark-mode .monthly-inputs-grid { background-color: #3a3f44; }

        .monthly-inputs-grid .form-group {
            margin-bottom: 0; /* Remove default form-group margin */
        }
         .monthly-inputs-grid .form-group label {
             margin-bottom: 5px; /* Smaller margin below label */
             font-weight: normal; /* Normal weight label */
         }
        .monthly-inputs-grid .form-group input {
             width: 100%; /* Make input fill grid cell */
             padding: 8px 10px; /* Adjusted padding */
             font-size: 0.9rem; /* Smaller font size */
             text-align: right; /* Align numbers right */
         }
         .monthly-inputs-grid .input-with-unit {
             display: flex;
             align-items: center;
             gap: 5px; /* Gap between input and unit */
         }
         .monthly-inputs-grid .input-with-unit input {
             flex-grow: 1; /* Input takes available space */
         }
         .monthly-inputs-grid .input-with-unit span {
              flex-shrink: 0; /* Unit doesn't shrink */
              font-weight: normal; /* Unit text normal */
         }


        /* --- Snackbar --- */
        #snackbar {
            visibility: hidden; min-width: 300px; max-width: 90%;
            background-color: var(--success-color); /* Default to success */
            color: var(--button-text); text-align: center;
            border-radius: 6px; padding: 18px 25px; position: fixed; z-index: 1001;
            left: 50%; transform: translateX(-50%); bottom: 30px;
            font-size: 1.05rem; font-weight: 500;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            opacity: 0; transition: visibility 0s 0.5s, opacity 0.5s ease-out, bottom 0.5s ease-out;
        }
        #snackbar.show {
            visibility: visible; opacity: 1; bottom: 60px;
            transition: opacity 0.5s ease-in, bottom 0.5s ease-in;
        }
        #snackbar.error { background-color: var(--danger-color); color: var(--button-text); }
        #snackbar.warning { background-color: var(--warning-color); color: var(--button-warning-text); }
        #snackbar.info { background-color: var(--info-color); color: var(--button-text); }


        /* --- Footer --- */
        footer {
            margin-top: auto; padding: 20px 0; text-align: center; font-size: 0.95em;
            color: var(--secondary-color); background-color: var(--header-bg);
            border-top: 1px solid var(--border-color);
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 1200px) { .container { width: 98%; } .chart-container canvas { height: 320px; } }
        @media (max-width: 992px) {
             h1 { font-size: 2rem; } h2 { font-size: 1.6rem; } h3 { font-size: 1.3rem; }
             .tabs { justify-content: flex-start; }
             .tab-link { padding: 10px 18px; font-size: 0.95rem;}
             table { font-size: 0.88rem; } th,td {padding: 10px 12px;}
             .management-list li select { width: 150px; } /* Reduce select width */
             .monthly-inputs-grid { grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; }
             /* Allow wrapping text in narrow tables */
            th, td { white-space: normal; }
             /* Adjusting cell padding slightly for smaller screens */
             th:first-child, td:first-child { padding-left: 15px; }
             th:last-child, td:last-child { padding-right: 15px; }
        }
        @media (max-width: 768px) {
            body { line-height: 1.6; }
            .app-title { font-size: 1.3rem;} #theme-toggle { font-size: 1.1rem;}
            .chart-container { padding: 20px;} .chart-container canvas { height: 280px; }
            .input-group { flex-direction: column; align-items: stretch; gap: 10px;}
            .input-small { margin-left: 0; margin-top: 8px; width: 100%; }
            #reserve-fund-panel .month-config { flex-direction: column; align-items: stretch; }
            #reserve-fund-panel .month-config label { width: 100%; text-align: left; margin-bottom: 5px; }
            #reserve-fund-panel .month-config input { width: 100%; }
            table { font-size: 0.85rem; } /*th, td { padding: 9px 8px; white-space: normal; }*/
            th:first-child, td:first-child { padding-left: 15px; }
            th:last-child, td:last-child { padding-right: 15px; }
            /*td.input-cell input { width: 80px; padding: 5px; }*/ /* Now using monthly-inputs-grid styles */
            .management-list li { flex-wrap: wrap; gap: 8px; }
            .management-list li span { flex-basis: 100%; margin-right: 0; } /* Name takes full width */
            .management-list li select { width: calc(100% - 50px); margin-top: 5px; } /* Select almost full width */
            .management-list li button { margin-left: auto; } /* Push button right */
            button { font-size: 0.95rem; padding: 10px 18px;}
            .tabs { gap: 2px; }
            .tab-link { padding: 8px 10px; font-size: 0.85rem;}
             .table-actions { justify-content: center; }
             .monthly-inputs-grid { grid-template-columns: repeat(auto-fit, minmax(80px, 1fr)); gap: 8px; padding: 10px; }
              .monthly-inputs-grid .form-group label { margin-bottom: 3px; font-size: 0.9em;}
              .monthly-inputs-grid .form-group input { padding: 6px 8px; font-size: 0.85em;}

        }
        @media (max-width: 576px) {
            h1 { font-size: 1.7rem; } .app-title { display: none; } header .container { justify-content: flex-end; }
            .tab-link { padding: 8px 10px; font-size: 0.85rem;}
            th, td { padding: 8px 6px; }
            th:first-child, td:first-child { padding-left: 10px; }
            th:last-child, td:last-child { padding-right: 10px; }
            .chart-container canvas { height: 220px; }
            #snackbar { min-width: 90%; bottom: 20px; font-size: 1rem; padding: 15px 20px; }
            #snackbar.show { bottom: 40px; }
            #file-upload-area { padding: 30px; }
            .management-list li select { width: 100%; } /* Select full width on smallest screens */
             .monthly-inputs-grid { grid-template-columns: repeat(3, 1fr); /* Fixed 3 columns on small screens */ }
        }
         @media (max-width: 380px) {
             .monthly-inputs-grid { grid-template-columns: repeat(2, 1fr); /* Fixed 2 columns on very small screens */ }
         }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <span class="app-title">Proyección Expensas - El Centauro</span>
            <button id="theme-toggle" title="Cambiar tema"><i class="fas fa-moon"></i></button>
        </div>
    </header>

    <div class="container">
        <div class="tabs">
            <button class="tab-link active" onclick="openTab(event, 'dashboard')"><i class="fas fa-tachometer-alt"></i> Dashboard</button>
            <button class="tab-link" onclick="openTab(event, 'upload')"><i class="fas fa-upload"></i> Cargar Datos</button>
            <button class="tab-link" onclick="openTab(event, 'reserve')"><i class="fas fa-piggy-bank"></i> Fondo Reserva</button>
            <button class="tab-link" onclick="openTab(event, 'settings')"><i class="fas fa-cog"></i> Configuración</button>
            <button class="tab-link" onclick="openTab(event, 'reports')"><i class="fas fa-download"></i> Reportes</button>
        </div>

        <!-- ==================== DASHBOARD ==================== -->
        <div id="dashboard" class="tab-content active">
            <h2><i class="fas fa-tachometer-alt"></i> Dashboard Anual - <span id="dashboard-year"></span> (<span id="dashboard-scenario">Base</span>)</h2>
            <div class="form-group input-group">
                <label for="scenario-selector" style="flex-shrink: 0;">Escenario:</label>
                <select id="scenario-selector" style="flex-grow: 1;"></select>
                <button onclick="createScenario()" class="button-primary button-sm" title="Crear Escenario Nuevo"><i class="fas fa-plus"></i> Crear</button>
                <button onclick="cloneScenario()" class="button-secondary button-sm" title="Clonar Escenario Actual"><i class="fas fa-clone"></i> Clonar</button>
                <button onclick="deleteScenario()" class="button-danger button-sm" title="Eliminar Escenario Actual"><i class="fas fa-trash"></i> Eliminar</button>
                <button id="btnBorrarDatos" class="button-warning button-sm" title="Borrar Datos del Escenario Actual (Gastos, Ingresos, Status)" onclick="clearScenarioData()" ><i class="fas fa-broom"></i> Borrar Datos</button>
                <button onclick="recalculateEstimates()" class="button-info button-sm" title="Proyectar meses estimados de gastos basados en último mes real y coeficientes (acumulativo)"><i class="fas fa-calculator"></i> Calcular Estimados</button>
            </div>

            <h4>Resumen Mensual General</h4>
            <div class="table-container">
                <table id="dashboard-summary">
                    <thead>
                        <tr>
                            <th>Mes</th>
                            <th>Gasto ($)</th>
                            <th>Fondo ($)</th>
                            <th>Cuota s/Gs ($/UF)</th> <!-- Basado en Gasto+Fondo / UF -->
                            <th>IPC Ref (%)</th> <!-- Referencia, now from settings.coefficientTypes.IPC snapshot-->
                            <th>Cuota IPC ($/UF)</th>   <!-- Cuota s/Gs base Enero + IPC acumulado -->
                            <th>Expensa Real ($/UF)</th> <!-- Muestra el valor del rubro Expensas Ordinarias / UF -->
                        </tr>
                    </thead>
                    <tbody><!-- Contenido generado por JS --></tbody>
                    <tfoot><!-- Contenido generado por JS --></tfoot>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Detalle de Gastos Proyectados ($)</h4>
             <p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar los detalles. Las celdas mensuales de detalle se colorean según su origen: <span style="background-color: var(--real-month-bg); padding: 1px 4px; border-radius: 3px; border: 1px solid var(--border-color);">REAL</span> (cargado) o <span style="background-color: var(--estimated-month-bg); padding: 1px 4px; border-radius: 3px; border: 1px solid var(--border-color);">ESTIMADO</span> (proyectado/calculado).</p>

            <!-- Added Group/Ungroup Buttons for Gastos -->
            <div class="table-actions">
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('gastos', false)" title="Expandir todos los detalles de gastos"><i class="fas fa-expand"></i> Expandir Todo</button>
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('gastos', true)" title="Colapsar todos los detalles de gastos"><i class="fas fa-compress"></i> Colapsar Todo</button>
            </div>

            <div class="table-container">
                <table id="gastos-detail-table" class="collapsible-table">
                     <thead>
                        <tr>
                            <th>Rubro / Detalle</th>
                            <th>Coef. Aplicado</th> <!-- Added Coef Aplicado Header -->
                            <!-- Meses y Total Anual generados por JS -->
                         </tr>
                     </thead>
                     <tbody><!-- Contenido generado por JS --></tbody>
                     <tfoot><!-- Contenido generado por JS --></tfoot>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Detalle de Ingresos Proyectados (Valores Base $)</h4>
             <p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar. Los valores aquí son la base de cálculo (valor individual o por UF) como fueron cargados. El Total de Ingresos en el Resumen General incluye la multiplicación por la Cantidad de UF (definida en Configuración) para los rubros específicos.</p>

             <!-- Added Group/Ungroup Buttons for Ingresos -->
             <div class="table-actions">
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('ingresos', false)" title="Expandir todos los detalles de ingresos"><i class="fas fa-expand"></i> Expandir Todo</button>
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('ingresos', true)" title="Colapsar todos los detalles de ingresos"><i class="fas fa-compress"></i> Colapsar Todo</button>
            </div>

            <div class="table-container">
                 <table id="ingresos-detail-table" class="collapsible-table">
                      <thead>
                         <tr>
                            <th>Rubro / Detalle</th>
                             <!-- Meses y Total Anual generados por JS -->
                         </tr>
                       </thead>
                      <tbody><!-- Contenido generado por JS --></tbody>
                      <tfoot><!-- Contenido generado por JS --></tfoot>
                 </table>
            </div>

            <div class="chart-container">
                 <h3>Evolutivo Expensa Mensual ($/UF)</h3>
                 <canvas id="evolutivoCuotaChart"></canvas>
                 <div class="chart-no-data">No hay datos suficientes para graficar.</div>
            </div>

            <div style="display: flex; gap: 25px; flex-wrap: wrap; margin-top: 35px;">
                <div class="chart-container" style="flex: 1; min-width: 320px;">
                    <h3>Participación Gastos (%)</h3>
                    <canvas id="participacionGastosChart"></canvas>
                    <div class="chart-no-data">No hay datos de gastos<br>para mostrar el gráfico.</div>
                </div>
                <div class="chart-container" style="flex: 1; min-width: 320px;">
                    <h3>Participación Ingresos (%)</h3>
                    <canvas id="participacionIngresosChart"></canvas>
                    <div class="chart-no-data">No hay datos de ingresos<br>para mostrar el gráfico.</div>
                </div>
            </div>
        </div>

        <!-- ==================== UPLOAD ==================== -->
        <div id="upload" class="tab-content">
            <h2><i class="fas fa-upload"></i> Cargar Datos Reales / Base</h2>
            <div class="form-group input-group">
                <label for="exercise-year">Año del Ejercicio:</label>
                <input type="number" id="exercise-year" min="2020" max="2099" value="2024" style="width: 120px;">
                <button onclick="createNewExercise()" class="button-success"><i class="fas fa-calendar-plus"></i> Crear/Seleccionar Año</button>
             </div>
            <p>Sube tu archivo Excel con las hojas <strong>"Gastos"</strong> e <strong>"Ingresos"</strong>. Los rubros y detalles nuevos encontrados se añadirán automáticamente a la sección de Configuración.</p>
            <p><strong>Importante:</strong>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>En la hoja "Gastos", las celdas con valores numéricos serán marcadas como 'REAL'. Las celdas vacías o con valores no numéricos se interpretarán como 'Estimado' y podrán ser proyectadas por la función "Calcular Estimados".</li>
                    <li>Los rubros de Ingreso llamados "<strong id="cuota-rubro-name-info">Expensas Ordinarias</strong>" y "<strong>Expensas Extraordinarias</strong>" tendrán sus valores base multiplicados por la cantidad de UF (definida en Configuración) al calcular el *total* de ingresos en el Resumen General. La columna "Expensa Real ($/UF)" en el resumen muestra el valor del rubro "<strong id="cuota-rubro-name-info2">Expensas Ordinarias</strong>" <strong style="color: var(--primary-color)">dividido por la cantidad de UF</strong>.</li>
                </ul>
            </p>
            <div id="file-upload-area" onclick="document.getElementById('excel-file-input').click()">
                 <p><i class="fas fa-file-excel"></i><br>Arrastra tu archivo Excel aquí (.xlsx, .xls) o haz clic para seleccionar</p>
                 <input type="file" id="excel-file-input" accept=".xlsx, .xls" style="display: none;" onchange="handleFileUpload(this.files)">
                 <button type="button" class="button-primary" onclick="event.stopPropagation(); document.getElementById('excel-file-input').click()" style="pointer-events: auto;"><i class="fas fa-folder-open"></i> Seleccionar Archivo</button>
                 <button type="button" onclick="event.stopPropagation(); loadSampleData()" style="margin-left: 10px; pointer-events: auto;" class="button-secondary"><i class="fas fa-database"></i> Cargar Datos Ejemplo</button>
            </div>
            <div id="file-upload-feedback"></div>
            <a href="#" onclick="event.preventDefault(); downloadTemplate();" title="Descargar archivo Excel con estructura de ejemplo"><i class="fas fa-download"></i> Descargar Plantilla Ejemplo</a>
        </div>

        <!-- ==================== RESERVE FUND ==================== -->
        <div id="reserve" class="tab-content">
             <h2><i class="fas fa-piggy-bank"></i> Configurar Fondo de Reserva - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
             <div class="form-group">
                 <label>Método de Cálculo del Fondo:</label>
                 <div class="input-group">
                     <input type="radio" id="reserve-type-percent" name="reserve-type" value="percent" checked onchange="updateReserveUI()">
                     <label for="reserve-type-percent">Porcentaje (%) sobre Gastos Mensuales</label>
                     <input type="radio" id="reserve-type-fixed" name="reserve-type" value="fixed" onchange="updateReserveUI()">
                     <label for="reserve-type-fixed">Valor Fijo Mensual ($)</label>
                 </div>
             </div>
              <h4>Valores Mensuales del Fondo</h4>
              <!-- Used the new monthly-inputs-grid class -->
             <div id="reserve-fund-panel" class="monthly-inputs-grid">
                 <!-- Inputs generados por JS -->
             </div>
             <button onclick="saveReserveFund()" style="margin-top: 25px;" class="button-success" title="Guardar los valores mensuales y el tipo de cálculo del fondo"><i class="fas fa-save"></i> Guardar Configuración del Fondo y Recalcular</button>
        </div>

        <!-- ==================== SETTINGS ==================== -->
        <div id="settings" class="tab-content">
             <h2><i class="fas fa-cog"></i> Configuración General y de Cálculo</h2>

             <div class="config-section">
                 <h4><i class="fas fa-building"></i> Ajustes Generales del Barrio</h4>
                 <div class="form-group">
                     <label for="cantidad-unidades">Cantidad Total de Unidades Funcionales (UF):</label>
                     <input type="number" id="cantidad-unidades" min="1" value="100" style="width: 180px;" title="Número total de UF para calcular cuotas base">
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-list-alt"></i> Gestión de Rubros (Categorías)</h4>
                 <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                     <div style="flex: 1; min-width: 320px;">
                         <h5><i class="fas fa-arrow-down" style="color:var(--danger-color)"></i> Rubros de GASTOS</h5>
                         <p class="text-muted">Asigna un coeficiente a cada rubro para proyectar sus gastos estimados.</p>
                         <div class="form-group input-group">
                             <input type="text" id="new-gasto-rubro-name" placeholder="Nombre nuevo rubro de gasto" style="flex-grow: 1;">
                             <button onclick="addRubro('gastos')" class="button-sm button-success" title="Añadir este nuevo rubro a la lista de gastos"><i class="fas fa-plus"></i> Añadir</button>
                         </div>
                         <ul id="gasto-rubro-list" class="management-list"></ul>
                     </div>
                     <div style="flex: 1; min-width: 320px;">
                          <h5><i class="fas fa-arrow-up" style="color:var(--success-color)"></i> Rubros de INGRESOS</h5>
                          <p class="text-muted">Solo los rubros Expensa Ordinaria y Extraordinaria se multiplican por UF.</p>
                          <div class="form-group input-group">
                              <input type="text" id="new-ingreso-rubro-name" placeholder="Nombre nuevo rubro de ingreso" style="flex-grow: 1;">
                              <button onclick="addRubro('ingresos')" class="button-sm button-success" title="Añadir este nuevo rubro a la lista de ingresos"><i class="fas fa-plus"></i> Añadir</button>
                          </div>
                          <ul id="ingreso-rubro-list" class="management-list"></ul>
                     </div>
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-percentage"></i> Gestión de Coeficientes de Ajuste (%)</h4>
                 <p class="text-muted" style="font-size: 0.9em;">Define tipos de coeficientes (ej. Inflación, Aumento Gremial). Edita sus valores mensuales en porcentaje. <strong style="color: var(--primary-color);">0 %</strong> implica un multiplicador de <strong style="color: var(--primary-color);">1</strong> (sin cambio). <strong style="color: var(--primary-color);">+2.5 %</strong> implica un multiplicador de <strong style="color: var(--primary-color);">1.025</strong>.</p>
                 <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                     <div style="flex: 1; min-width: 280px;">
                         <h5>Tipos de Coeficientes Disponibles</h5>
                         <div class="form-group input-group">
                             <input type="text" id="new-coefficient-type-name" placeholder="Nuevo tipo (ej: Aumento Sindicato)" style="flex-grow: 1;">
                             <button onclick="addCoefficientType()" class="button-sm button-success" title="Añadir este nuevo tipo de coeficiente a la lista"><i class="fas fa-plus"></i> Añadir Tipo</button>
                         </div>
                         <ul id="coefficient-type-list" class="management-list"></ul>
                     </div>
                     <div id="coefficient-editor" style="flex: 2; min-width: 450px;">
                          <h5><i class="fas fa-edit"></i> Editar Valores Mensuales (%) para: <span id="editing-coefficient-name" style="color: var(--primary-color); font-weight: bold;"></span></h5>
                          <!-- Changed to use the monthly-inputs-grid class -->
                          <div id="coefficient-values-editor">
                              <p class="text-muted">Selecciona un tipo de coeficiente de la lista (que no sea "Sin Coeficiente") para editar sus valores (en porcentaje %).</p>
                          </div>
                     </div>
                 </div>
             </div>

             <button onclick="saveSettings()" style="margin-top: 20px; width: 100%; padding: 15px;" class="button-success button-lg" title="Guardar todos los cambios realizados en esta pestaña (UF, Rubros, Coeficientes) y recalcular el escenario actual">
                 <i class="fas fa-save"></i> GUARDAR TODA LA CONFIGURACIÓN Y RECALCULAR
             </button>
        </div>

        <!-- ==================== REPORTS ==================== -->
        <div id="reports" class="tab-content">
             <h2><i class="fas fa-download"></i> Descargar Reportes - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
             <p>Genera y descarga los datos del ejercicio y escenario actual en formato Excel, incluyendo detalles y resumen.</p>
             <button onclick="exportToExcel()" class="button-success" title="Descargar un archivo .xlsx con el detalle y resumen del escenario actual"><i class="fas fa-file-excel"></i> Descargar Reporte Completo (.xlsx)</button>

             <h3 style="margin-top: 35px;">Exportar Gráficos Individuales</h3>
             <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                 <button onclick="exportChart('evolutivoCuotaChart', 'evolutivo_expensa_por_uf.png')" class="button-secondary" title="Descargar el gráfico de evolución de expensas como imagen PNG"><i class="fas fa-chart-line"></i> Gráfico Evolutivo ($/UF PNG)</button>
                 <button onclick="exportChart('participacionGastosChart', 'participacion_gastos.png')" class="button-secondary" title="Descargar el gráfico de torta de gastos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Gastos (PNG)</button>
                 <button onclick="exportChart('participacionIngresosChart', 'participacion_ingresos.png')" class="button-secondary" title="Descargar el gráfico de torta de ingresos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Ingresos (PNG)</button>
             </div>
        </div>
    </div> <!-- /container -->

    <footer>
        <div class="container">
            &copy; <span id="footer-year"></span> Proyección Expensas El Centauro. v2.7 (PctCoef_IPCRubro_Style)
        </div>
    </footer>
    <div id="snackbar">Mensaje</div>

    <!-- ==================== SCRIPT PRINCIPAL ==================== -->
    <script>
        // --- Constantes y Estado Global ---
        const MONTHS = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
        const FULL_MONTHS = ["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"];
        const GASTOS_SHEET_NAME = "Gastos";
        const INGRESOS_SHEET_NAME = "Ingresos";
        // MODIFICACIÓN STORAGE KEY V2.7 - Introduce coeficientes en porcentaje, IPC como rubro coeficiente y estilos de tablas/graficos
        const STORAGE_KEY = 'expensasAppCentauroState_v2.7_PctCoef_IPCRubro_Style';
        const CUOTA_RUBRO_NAME = "Expensas Ordinarias"; // Rubro principal para multiplicar x UF y base de Expensa Real
        const EXTRA_CUOTA_RUBRO_NAME = "Expensas Extraordinarias"; // Otro rubro a multiplicar x UF
        const SPECIAL_INGRESO_RUBROS = [CUOTA_RUBRO_NAME, EXTRA_CUOTA_RUBRO_NAME]; // Rubros que se multiplican por UF para el total
        const IPC_COEFFICIENT_KEY = "IPC"; // Key for the default IPC coefficient type


        let appState = getDefaultAppState(); // Iniciar con estado por defecto limpio

        // Chart instances (moved to scope variables)
        let evolutivoCuotaChart_instance = null;
        let participacionGastosChart_instance = null;
        let participacionIngresosChart_instance = null;


        // --- Inicialización ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log(`DOM Cargado. Inicializando App ${STORAGE_KEY}...`);
            loadState(); // Cargar estado guardado si existe
            initTheme(); // Aplicar tema (antes de cualquier render que dependa de él)

            // Asegurar que exista al menos un escenario activo y válido
            validateAndSetActiveScenario();

            // --- MODIFIED: Update UI instructions with the correct name ---
            const cuotaInfoSpan = document.getElementById('cuota-rubro-name-info');
            if (cuotaInfoSpan) cuotaInfoSpan.textContent = CUOTA_RUBRO_NAME; // Usa la constante actualizada
            const cuotaInfoSpan2 = document.getElementById('cuota-rubro-name-info2');
            if (cuotaInfoSpan2) cuotaInfoSpan2.textContent = CUOTA_RUBRO_NAME;


            initUI(); // Inicializar elementos de la UI que dependen del estado inicial
            addEventListeners(); // Añadir listeners globales
            updateUI(); // Renderizar todo con el estado actual/cargado
            console.log(`App ${STORAGE_KEY} Inicializada.`);
        });

         // --- Migración (if needed from previous versions) ---
         function migrateState(loadedState) {
            let changed = false;

             // Migration from v2.6 (IPC manual was a top-level array) to v2.7 (IPC is a Coefficient Type)
            // Check if the old ipcManual array exists and if the new IPC coefficient type is NOT yet properly initialized (e.g. name mismatch or values mismatch)
            if (Array.isArray(loadedState?.settings?.ipcManual)) {
                console.log("Detectada estructura IPC Manual anterior. Iniciando migración a Coefficient Type...");

                // Ensure settings.coefficientTypes exists or get defaults
                loadedState.settings.coefficientTypes = loadedState.settings.coefficientTypes || getDefaultAppState().settings.coefficientTypes;

                const currentIpcCoefType = loadedState.settings.coefficientTypes?.[IPC_COEFFICIENT_KEY];
                 const defaultIpcCoefType = getDefaultAppState().settings.coefficientTypes?.[IPC_COEFFICIENT_KEY];

                 // Check if the IPC type exists and seems like the default one
                if (currentIpcCoefType && currentIpcCoefType.isDefault && currentIpcCoefType.name === defaultIpcCoefType.name) {
                     // IPC type already exists and seems like the target structure.
                     // Overwrite its values with the migrated ipcManual values if they look different.
                     const migratedValues = loadedState.settings.ipcManual.slice(0, 12).map(v => typeof v === 'number' ? v : 0);
                     if (JSON.stringify(currentIpcCoefType.values) !== JSON.stringify(migratedValues)) {
                          console.log("Sobrescribiendo valores IPC existentes con valores migrados.");
                          currentIpcCoefType.values = migratedValues;
                         changed = true;
                     } else {
                         console.log("Valores IPC existentes coinciden con valores migrados. No se sobrescribe.");
                     }

                } else {
                    // IPC type is missing or doesn't match the default structure, create/overwrite it using default name/isDefault and migrated values
                    console.log("IPC Coefficient type missing or doesn't match default structure. Creating/Overwriting.");
                     loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY] = {
                         name: defaultIpcCoefType?.name || "IPC", // Use default name or fallback
                         values: loadedState.settings.ipcManual.slice(0, 12).map(v => typeof v === 'number' ? v : 0), // Copy the values
                         isDefault: defaultIpcCoefType?.isDefault ?? true // Use default flag or fallback to true
                     };
                     changed = true;
                }
                 delete loadedState.settings.ipcManual; // Remove old manual IPC array
                 console.log("Migración de IPC manual completada.");
             }


             // Add any new default coefficient types introduced in this version if they don't exist or ensure their structure
             const defaultCoefficientTypes = getDefaultAppState().settings.coefficientTypes;
              loadedState.settings.coefficientTypes = loadedState.settings.coefficientTypes || {};
             Object.keys(defaultCoefficientTypes).forEach(key => {
                 // If the type is completely missing, add the default one
                if (!loadedState.settings.coefficientTypes[key]) {
                     console.log(`Añadiendo tipo de coeficiente por defecto "${key}".`);
                     // Use JSON stringify/parse for deep copy to avoid modifying the default structure definition
                     loadedState.settings.coefficientTypes[key] = JSON.parse(JSON.stringify(defaultCoefficientTypes[key]));
                     changed = true;
                } else {
                     // If type exists, ensure its structure (name, isDefault, values array) is valid based on the default definition
                     const loadedType = loadedState.settings.coefficientTypes[key];
                     const defaultType = defaultCoefficientTypes[key]; // Get the definition from getDefaultAppState

                     // Ensure structure of 'values' array: must be array of 12 numbers.
                      const isValidLoadedValues = Array.isArray(loadedType.values) && loadedType.values.length === 12 && loadedType.values.every(v => typeof v === 'number');

                      if (!isValidLoadedValues) {
                           console.warn(`Coefficient values array for "${key}" is corrupted/invalid. Resetting to default values.`);
                          loadedType.values = Array.isArray(defaultType?.values) ? JSON.parse(JSON.stringify(defaultType.values)) : Array(12).fill(key === 'None' ? 1 : 0); // Copy default values or set default fill based on key
                          changed = true;
                     } else {
                          // Even if the structure is valid, ensure values are non-negative for percentage types (especially if migrated from old multiplier logic)
                           // And for 'None' type, values *must* be 1
                          if (key === 'None') {
                             if (!loadedType.values.every(v => v === 1)) {
                                 console.warn(`"None" coefficient type values should all be 1. Correcting.`);
                                 loadedType.values = Array(12).fill(1);
                                changed = true;
                             }
                           } else { // For non-None types, ensure values are non-negative percentages (they will be treated as such)
                              loadedType.values = loadedType.values.map(v => v >= 0 ? v : 0); // Ensure non-negative
                           }

                     }


                     // Ensure name and isDefault flags match the default definition if they are missing or seem incorrect for default types
                     if (defaultType?.isDefault) { // If the definition in getDefaultAppState says this *should* be a default type
                           if (loadedType.isDefault !== defaultType.isDefault || loadedType.name !== defaultType.name) {
                                console.log(`Correcting name/isDefault for default coefficient type "${key}".`);
                               loadedType.isDefault = defaultType.isDefault;
                                loadedType.name = defaultType.name;
                               changed = true;
                           }
                     } else { // If the definition says this is NOT a default type, ensure loaded state doesn't incorrectly flag it as default
                          if (loadedType.isDefault !== false) { // Should be false
                              console.warn(`Correcting isDefault flag for non-default coefficient type "${key}".`);
                                loadedType.isDefault = false; // Ensure it's explicitly false
                                changed = true;
                          }
                          // Name can be custom for non-default types, no check needed unless missing
                           if (!loadedType.name) {
                                loadedType.name = defaultType?.name || key; // Fallback to default name or key if missing
                                changed = true;
                           }
                     }
                }
             });


             // Ensure scenario structure is complete (handled by validateAndSetActiveScenario and subsequent initialize calls)
             // No explicit check needed here just for calculated.ipcManual structure after the main loop.
             // initializeScenarioDataForRubros will handle setting calculated.ipcManual based on the (migrated/corrected) settings.coefficientTypes.IPC.values.

            // Ensure rubroConfig structure is okay and default collapse is true for missing configs or new rubros
            loadedState.settings.rubroConfig = loadedState.settings.rubroConfig || {};
            // Iterate through rubros *in settings* to ensure their config exists and is valid
             ['gastos', 'ingresos'].forEach(type => {
                  (loadedState.settings.rubros?.[type] || []).forEach(rubroKey => {
                     if (!loadedState.settings.rubroConfig[rubroKey]) {
                          console.log(`Creating default rubroConfig for "${rubroKey}"`);
                          // Default collapsed true, default coef type None
                          loadedState.settings.rubroConfig[rubroKey] = { coefficientType: 'None', detailsCollapsed: true };
                           changed = true;
                     } else {
                         const config = loadedState.settings.rubroConfig[rubroKey];
                         // Ensure boolean state for detailsCollapsed, default to true if undefined/null
                         if (config.detailsCollapsed === undefined || config.detailsCollapsed === null) {
                              console.warn(`detailsCollapsed for "${rubroKey}" undefined. Setting to true.`);
                              config.detailsCollapsed = true;
                               changed = true;
                         } else if (typeof config.detailsCollapsed !== 'boolean') {
                              console.warn(`detailsCollapsed for "${rubroKey}" invalid type (${typeof config.detailsCollapsed}). Setting to boolean equivalent.`);
                                config.detailsCollapsed = !!config.detailsCollapsed; // Convert to boolean
                                changed = true;
                         }
                         // Ensure coefficientType key exists and points to a valid type key, default to 'None'
                         const currentCoefTypeKey = config.coefficientType;
                          const validCoefTypeKeys = Object.keys(loadedState.settings.coefficientTypes || {});
                         if (currentCoefTypeKey === undefined || !validCoefTypeKeys.includes(currentCoefTypeKey)) {
                              if (currentCoefTypeKey !== undefined) console.warn(`CoefficientType "${currentCoefTypeKey}" for "${rubroKey}" is invalid or missing. Setting to 'None'.`);
                                config.coefficientType = 'None';
                                changed = true;
                         }
                     }
                  });
             });
            // Also prune rubroConfig entries if the rubro is no longer in the settings.rubros list
             Object.keys(loadedState.settings.rubroConfig).forEach(rubroKey => {
                 const isGasto = (loadedState.settings.rubros?.gastos || []).includes(rubroKey);
                 const isIngreso = (loadedState.settings.rubros?.ingresos || []).includes(rubroKey);
                 if (!isGasto && !isIngreso) {
                      console.log(`Rubro "${rubroKey}" not found in global settings. Removing its rubroConfig.`);
                      delete loadedState.settings.rubroConfig[rubroKey];
                     changed = true;
                 }
             });


             return changed; // Return whether any changes were made during migration/cleanup
         }

        // --- Validation and setting Active Scenario ---
        function validateAndSetActiveScenario() {
             // Use Object.keys on a potentially missing object defensively
             const scenarioKeys = Object.keys(appState.scenarios || {});
             let activeKeyIsValid = false;

             // Check if the stored active key points to a valid scenario entry
             if (appState.activeScenarioKey && appState.scenarios && appState.scenarios[appState.activeScenarioKey]) {
                const activeScenarioData = appState.scenarios[appState.activeScenarioKey];
                // Check if the year in the key matches the stored year property
                const activeYearFromKey = parseInt(appState.activeScenarioKey.split('_')[0]);

                 // Sync appState.currentYear to the year of the active scenario
                 if (!isNaN(activeYearFromKey)) {
                    if (appState.currentYear !== activeYearFromKey) {
                        console.warn(`Current year mismatch detected: State has ${appState.currentYear}, Active Key ${appState.activeScenarioKey} implies ${activeYearFromKey}. Syncing appState.currentYear.`);
                         appState.currentYear = activeYearFromKey;
                         // This might imply a need to auto-select a scenario for the *new* currentYear if the activeKey was from a different year
                         // This case should be handled by the fallback logic below
                    }
                     // If we reached here, the key exists, and its year is synced to appState.currentYear
                     activeKeyIsValid = true;
                 } else {
                      console.warn(`Invalid year part in activeScenarioKey: "${appState.activeScenarioKey}". Treating as invalid key.`);
                      // activeKeyIsValid remains false
                 }
             } else {
                 console.warn(`Active scenario key "${appState.activeScenarioKey}" is invalid or missing from state.`);
             }

             // --- Fallback Logic if the current active key is invalid or missing ---
             if (!activeKeyIsValid) {
                 console.log("Searching for a valid scenario...");

                 // Try finding 'Base' scenario for the current `appState.currentYear`
                 const currentYearBaseKey = `${appState.currentYear}_Base`;
                 if (appState.scenarios && appState.scenarios[currentYearBaseKey]) {
                     appState.activeScenarioKey = currentYearBaseKey;
                     activeKeyIsValid = true;
                     console.log(`Found and set fallback scenario: ${appState.activeScenarioKey} (Base for current year)`);
                 } else {
                      // If no 'Base' for current year, try finding ANY scenario for the current `appState.currentYear`
                      const firstKeyForCurrentYear = scenarioKeys.find(k => k.startsWith(`${appState.currentYear}_`));
                     if (firstKeyForCurrentYear) {
                         appState.activeScenarioKey = firstKeyForCurrentYear;
                         activeKeyIsValid = true;
                         console.log(`Found and set fallback scenario: ${appState.activeScenarioKey} (first for current year)`);
                     } else {
                         // If no scenarios for current year, try finding the very first scenario *globally*
                          if (scenarioKeys.length > 0) {
                               const firstGlobalKey = scenarioKeys.sort((a, b) => {
                                   // Sort first by year (ascending), then by scenario name (alphabetical)
                                   const yearA = parseInt(a.split('_')[0]);
                                   const yearB = parseInt(b.split('_')[0]);
                                   if (yearA !== yearB) return yearA - yearB;
                                   const nameA = appState.scenarios[a]?.scenarioName || '';
                                   const nameB = appState.scenarios[b]?.scenarioName || '';
                                   return nameA.localeCompare(nameB);
                               })[0]; // Get the chronologically/alphabetically first one
                             if (firstGlobalKey) {
                                   appState.activeScenarioKey = firstGlobalKey;
                                   activeKeyIsValid = true;
                                   appState.currentYear = parseInt(firstGlobalKey.split('_')[0]); // Sync currentYear to the newly selected global scenario's year
                                   console.log(`No scenarios for year ${new Date().getFullYear()}. Set fallback to global scenario: ${appState.activeScenarioKey}. Synced currentYear to ${appState.currentYear}`);
                             }
                          }
                     }
                 }
             }


             // --- Final State Check: If STILL no valid active key exists, create the initial default state ---
             if (!activeKeyIsValid) {
                console.log("No valid scenario found. Creating initial default scenario.");
                 // Reset appState to a minimal default and then initialize the Base scenario
                 appState = getDefaultAppState(); // Get base structure including default settings
                 appState.currentYear = new Date().getFullYear();
                 initScenarioData(appState.currentYear); // This also adds the Base scenario and initializes its structures based on appState.settings
                 appState.activeScenarioKey = `${appState.currentYear}_Base`; // Set the newly created Base as active
                 console.log(`Created initial scenario: ${appState.activeScenarioKey}`);
             }

             // At this point, appState.activeScenarioKey is guaranteed to point to an existing scenario in appState.scenarios,
             // and appState.currentYear is synced to the year of that scenario.

             // --- Ensure ALL scenario structures are complete and consistent with current GLOBAL settings ---
             // This is important after load, create, delete, or settings changes (though settings changes might trigger it directly).
             console.log("Ensuring consistency and completeness for all scenario structures...");
             Object.values(appState.scenarios || {}).forEach(scenario => {
                  // Skip initialization if scenario object itself is null/undefined
                 if(scenario) initializeScenarioDataForRubros(scenario);
                  else console.warn("Skipping initialization for a null/undefined scenario object in state.");
             });

            // State is now validated and corrected. Save it.
             saveState();
        }

        // --- Gestión de Datos del Escenario ---
        // Safely gets the data for the current active scenario from appState.
        function getCurrentScenarioData() {
            // Check if scenarios object and the active key itself exist in state before attempting access
            if (!appState.scenarios || !appState.activeScenarioKey || !appState.scenarios[appState.activeScenarioKey]) {
                console.error("Error getCurrentScenarioData: Cannot retrieve active scenario data. State invalid.", {
                    scenariosExist: !!appState.scenarios,
                    activeKey: appState.activeScenarioKey,
                    activeKeyExists: appState.scenarios ? appState.scenarios[appState.activeScenarioKey] !== undefined : 'N/A'
                });
                // Upstream validation (validateAndSetActiveScenario) should prevent this critical state on load/action.
                // If it happens runtime, returning null prevents crashes in downstream functions.
                return null;
            }
             // Return the actual scenario object reference
            return appState.scenarios[appState.activeScenarioKey];
        }


        // Function to initialize scenario specific structures based on global settings.
        // Ensures a given scenarioData object has all the necessary nested structures
        // for data, calculated, status, etc., based on the rubros and coefficient types defined *globally*
        function initializeScenarioDataForRubros(scenarioData) {
             if (!scenarioData) {
                console.warn("initializeScenarioDataForRubros called without scenario data.");
                return; // Cannot proceed without scenario data object
             }
             // Use getDefaultAppState to get the ideal *empty* structure pattern

             // Ensure top-level structures exist, using nullish coalescing assignment `??=`
             scenarioData.year ??= new Date().getFullYear(); // Ensure year property exists
             scenarioData.scenarioName ??= "Nuevo Escenario"; // Ensure name exists

             // Use JSON stringify/parse on the structure pattern from getDefaultAppState to ensure deep copy of objects/arrays if they are being defaulted.
             const defaultScenarioStructurePart = JSON.parse(JSON.stringify(getDefaultAppState().scenarios.BaseExample)); // Use the structure template


             scenarioData.rubroOrder ??= defaultScenarioStructurePart.rubroOrder;
             scenarioData.data ??= defaultScenarioStructurePart.data;
             scenarioData.monthStatus ??= defaultScenarioStructurePart.monthStatus;
             // For reserveFund, merge carefully to keep type/values if they exist, default if missing
             scenarioData.reserveFund = {
                 type: scenarioData.reserveFund?.type ?? 'percent',
                  values: Array.isArray(scenarioData.reserveFund?.values) && scenarioData.reserveFund.values.length === 12 && scenarioData.reserveFund.values.every(v => typeof v === 'number' && v >= 0) // Validate values array shape and contents (>=0)
                             ? scenarioData.reserveFund.values
                              : Array(12).fill(scenarioData.reserveFund?.type === 'fixed' ? 0 : 5) // Default based on the defaulted type
             };

             // Ensure calculated structure exists and fill default arrays/objects, preserving existing *valid* content
              // Merge calculated structure, potentially keeping existing numerical values
              const defaultCalcStructure = defaultScenarioStructurePart.calculated;
              scenarioData.calculated ??= {}; // Ensure calculated parent object exists

             for(const key in defaultCalcStructure) {
                 // If a calculated key is missing, deep copy its default structure
                 if(scenarioData.calculated[key] === undefined || scenarioData.calculated[key] === null) {
                      console.log(`Initializing missing calculated key "${key}" in scenario data.`);
                     scenarioData.calculated[key] = JSON.parse(JSON.stringify(defaultCalcStructure[key]));
                     continue; // Move to next key as structure is now set
                 }

                 // If the key exists, but its structure might be invalid (e.g., array vs object)
                 if (typeof scenarioData.calculated[key] !== typeof defaultCalcStructure[key]) {
                      console.warn(`Calculated key "${key}" has invalid type. Resetting.`);
                     scenarioData.calculated[key] = JSON.parse(JSON.stringify(defaultCalcStructure[key]));
                     continue; // Structure reset, move on
                 }


                  // Specific checks for complex nested structures (objects and arrays within calculated)
                 if (key === 'annualTotals') {
                      // Ensure annualTotals sub-objects exist
                      scenarioData.calculated.annualTotals.gastos ??= { __TOTAL__: 0 };
                      scenarioData.calculated.annualTotals.ingresos ??= { __TOTAL__: 0 };
                      // Annual totals per rubro/type don't need deep value preservation here; calculateAll computes them.
                 } else if (key === 'ipcManual') {
                      // ipcManual must be an array of 12 numbers
                     const sourceIPCValues = appState.settings.coefficientTypes?.[IPC_COEFFICIENT_KEY]?.values || Array(12).fill(0);
                      if (!Array.isArray(scenarioData.calculated.ipcManual) || scenarioData.calculated.ipcManual.length !== 12 || !scenarioData.calculated.ipcManual.every(v => typeof v === 'number')) {
                           console.warn(`Calculated IPC Manual array is missing or invalid. Copying from settings.`);
                          scenarioData.calculated.ipcManual = sourceIPCValues.slice(0, 12).map(v => typeof v === 'number' ? v : 0); // Copy valid numbers
                      } else {
                           // If it exists and is valid, potentially sync its contents from the IPC coefficient values in settings?
                           // No, calculated.ipcManual should be a *snapshot* when calculateAll runs.
                           // The next calculateAll will copy from the settings anyway.
                      }

                 } else if (Array.isArray(scenarioData.calculated[key]) && scenarioData.calculated[key].length === defaultCalcStructure[key].length) {
                     // This covers top-level calculated arrays like totalGastoProyectadoMes, fondoReservaMes etc.
                     // Ensure all elements are numbers
                     scenarioData.calculated[key] = scenarioData.calculated[key].map(v => typeof v === 'number' ? v : 0);

                 } else if (typeof scenarioData.calculated[key] === 'object' && !Array.isArray(scenarioData.calculated[key])) {
                     // This covers calculated objects like gastoAjustado, totalGastoRubroMes etc., which contain rubro keys.
                     // For these, ensure any rubro key present points to a valid structure (usually array of 12)
                      Object.keys(scenarioData.calculated[key]).forEach(rubroKey => {
                           // If the value is expected to be an array of 12
                           if (Array.isArray(defaultCalcStructure[key]?.[rubroKey]) && defaultCalcStructure[key][rubroKey].length === 12) {
                                const rubroValue = scenarioData.calculated[key][rubroKey];
                                if (!Array.isArray(rubroValue) || rubroValue.length !== 12 || !rubroValue.every(v => typeof v === 'number')) {
                                     console.warn(`Calculated sub-array "${key}.${rubroKey}" invalid. Resetting to 0s.`);
                                    scenarioData.calculated[key][rubroKey] = Array(12).fill(0);
                                    changed = true;
                                 }
                            }
                           // If value is expected to be an object (e.g. gastoAjustado's details) - This requires more complex recursive checking if needed.
                           // For now, gastoAjustado just holds arrays of 12 for details after projection. This case isn't covered here yet.
                       });
                 }
             }

              // Initialize or validate rubro-specific data structures based on GLOBAL settings rubro lists
              // This ensures any rubro defined in settings *has* an entry in scenarioData.data, .monthStatus, .calculated even if it came from a scenario without that data
             ['gastos', 'ingresos'].forEach(type => {
                 const globalRubrosForType = appState.settings.rubros?.[type] || [];
                  const scenarioDataForType = scenarioData.data?.[type] ?? {}; // Get reference, defaulting to empty object

                  // Ensure scenarioData.rubroOrder reflects all global rubros + any additional in scenarioData (from old loads?)
                  // Best approach: start scenario.rubroOrder for this type from scratch with global rubros, then add any unique rubros found in scenarioData.
                  const rubrosInScenarioData = Object.keys(scenarioDataForType);
                   scenarioData.rubroOrder[type] = [];
                   const addedToOrder = new Set();

                  // Add global rubros first to maintain settings order preference
                  globalRubrosForType.forEach(rubro => {
                      if (!addedToOrder.has(rubro)) {
                           scenarioData.rubroOrder[type].push(rubro);
                           addedToOrder.add(rubro);
                      }
                       // Also ensure structures exist for this global rubro in scenarioData
                       scenarioDataForType[rubro] ??= { detailOrder: [], detailsData: {} };
                       scenarioData.monthStatus[type] ??= {}; // Ensure type exists in monthStatus
                       scenarioData.monthStatus[type][rubro] ??= {}; // Ensure rubro exists in monthStatus (object)
                       // Calculated structures will be handled later during calculateAll or in main loops if needed.
                   });

                 // Then add any rubros found in scenarioData but *not* in global settings (might be remnants of deleted rubros)
                  rubrosInScenarioData.forEach(rubro => {
                      if (!addedToOrder.has(rubro)) {
                           // Rubro exists in data but not global settings. Maybe clean it up?
                           // For now, just log a warning and maybe add it to the order? Let's add it to order for old data visibility.
                            console.warn(`Rubro "${rubro}" (${type}) found in scenario data but not in global settings. Added to scenario's order.`);
                           scenarioData.rubroOrder[type].push(rubro);
                           // Do NOT add to addedToOrder set, it might conflict if a global rubro was accidentally deleted but exists in data.
                            // Or simply skip processing rubros NOT in global settings entirely during calculateAll/updateCollapsibleTable loops? Yes, filter those loops by global rubros.
                           // So, here, just ensure the structure for it exists if it came from data, but filter it out of loops. Let's add to order for robustness? Or just data struct?
                           // Decision: RubroOrder in scenario should ideally only contain rubros from settings. Let's filter it by global rubros.

                      }
                      // Ensure detailOrder and detailsData exist for this rubro in data structure
                       scenarioDataForType[rubro].detailOrder ??= [];
                       scenarioDataForType[rubro].detailsData ??= {};

                        // Ensure structure inside monthStatus exists for the rubro if type is 'gastos'
                        if (type === 'gastos') {
                           scenarioData.monthStatus[type][rubro] ??= {};
                        }
                       // Ensure detail data arrays within detailsData are 12 numbers and detail status arrays are 12 strings (for gastos)
                        Object.keys(scenarioDataForType[rubro].detailsData).forEach(detailKey => {
                           const currentDetailData = scenarioDataForType[rubro].detailsData[detailKey];
                            scenarioDataForType[rubro].detailsData[detailKey] = Array.isArray(currentDetailData) && currentDetailData.length === 12
                                ? currentDetailData.map(v => typeof v === 'number' ? v : 0) // Ensure numbers
                                 : Array(12).fill(0); // Re-initialize if corrupted

                            if (type === 'gastos') {
                                 const currentStatus = scenarioData.monthStatus[type][rubro]?.[detailKey];
                                 scenarioData.monthStatus[type][rubro][detailKey] = Array.isArray(currentStatus) && currentStatus.length === 12 && currentStatus.every(s => typeof s === 'string')
                                    ? currentStatus
                                     : Array(12).fill('Estimado'); // Re-initialize if corrupted
                            }
                             // If detail was in data but not in detailOrder, add it
                            if(!scenarioDataForType[rubro].detailOrder.includes(detailKey)) {
                                 // console.warn(`Detail "${detailKey}" for rubro "${rubro}" found in data but not in detailOrder. Adding to order.`);
                                 scenarioDataForType[rubro].detailOrder.push(detailKey);
                            }
                        });

                  });
                  // FINAL rubroOrder should ONLY contain rubros that are in the GLOBAL settings list AND have data in this scenario OR just came from settings (empty data is ok initially)
                   // Let's simplify: rubroOrder will match global settings order + any additional from data during load (handled by processSheetData).
                   // BUT during calculations/display, filter loops by global rubros list. This requires filtering in calculateAll and updateCollapsibleTable.
                   // The initial logic in calculateAll/updateCollapsibleTable filtering by global settings list AND checking data presence is the correct approach.
                   // Let's ensure scenario.rubroOrder doesn't contain deleted global rubros. It gets built from Excel first. Then merged.
                   // Simpler: after sheet processing or state loading, rebuild scenarioData.rubroOrder from scratch based *only* on appState.settings.rubros lists.
                    scenarioData.rubroOrder[type] = appState.settings.rubros?.[type]?.slice() || [];

             });

              // Re-calculate everything if initialization/validation found significant inconsistencies
              // (e.g., values turned NaN -> 0, structure was added) that calculateAll would need.
              // Maybe return a flag if `changed = true`? For now, rely on the standard flow of saveState() followed by calculateAll()
              // or updateUI() which calls updateDashboardTables(), which calls calculateAll if necessary.

         }


        // --- Lógica de Negocio y Cálculos ---
        function calculateAll(scenarioData) {
             console.log(`Recalculando TODO para: ${scenarioData?.year} - ${scenarioData?.scenarioName}`);
             if (!scenarioData) { console.error("CalculateAll: No scenario data provided."); renderEmptyState(); return; }

             // Ensure structures are complete before calculating (safe, idempotent call)
             initializeScenarioDataForRubros(scenarioData); // This also ensures calculate.ipcManual is sourced from settings.coefficientTypes.IPC

             const { data, monthStatus, reserveFund, rubroOrder } = scenarioData;
             const { settings } = appState;
             // Use 'quantityUnits' consistently based on v2.6+ variable name
             const { rubros, rubroConfig, quantityUnits, coefficientTypes } = settings;

             const calculated = scenarioData.calculated; // Direct reference

             // --- Reset Calculated Values ---
             // Preserve object structure but clear numeric arrays/totals
             calculated.totalGastoProyectadoMes = Array(12).fill(0);
             calculated.totalIngresoProyectadoMes = Array(12).fill(0);
             calculated.fondoReservaMes = Array(12).fill(0);
             calculated.cuotaSobreGastosMes = Array(12).fill(0);
             calculated.cuotaIpcMes = Array(12).fill(0);
             calculated.cuotaRealBaseMes = Array(12).fill(0);

              // Reset specific internal calculated objects by re-initializing keys based on *current* global rubros list
             calculated.gastoAjustado = {}; // Clear and rebuild below
             calculated.totalGastoRubroMes = {}; // Clear and rebuild below
             calculated.ingresoAjustado = {}; // Clear and rebuild below
             calculated.totalIngresoRubroMes = {}; // Clear and rebuild below

              calculated.annualTotals = { gastos: { __TOTAL__: 0 }, ingresos: { __TOTAL__: 0 }, fondoReserva: 0, cuotaSobreGastos: 0, cuotaIpc: 0, cuotaRealBase: 0 };


             // --- Synchronize ipcManual snapshot with current settings BEFORE calculation ---
             // This snapshot is used for the 'Cuota IPC' calculation and displayed in the summary table
             const ipcCoefficientType = coefficientTypes[IPC_COEFFICIENT_KEY] || { values: Array(12).fill(0) };
             // Copy percentage values, ensuring array has 12 valid numbers
             calculated.ipcManual = Array.isArray(ipcCoefficientType.values) && ipcCoefficientType.values.length === 12
                                    ? ipcCoefficientType.values.map(v => typeof v === 'number' ? v : 0)
                                    : Array(12).fill(0);


             // 1. Gastos Ajustados and Totals
             // Process only rubros that are defined in GLOBAL settings AND have data in this scenario AND are marked as GASTOS in settings.
             const gastoRubrosToProcess = (settings.rubros?.gastos || [])
                                          .filter(rubro => data.gastos?.[rubro] && data.gastos[rubro].detailsData && Object.keys(data.gastos[rubro].detailsData).length > 0); // Rubro exists & has detail data


             gastoRubrosToProcess.forEach(rubro => {
                 // Ensure calculated structures for this rubro exist and are cleared (if not already by the main reset)
                 calculated.gastoAjustado[rubro] = {};
                 calculated.totalGastoRubroMes[rubro] = Array(12).fill(0); // Array for monthly sums of adjusted values
                 calculated.annualTotals.gastos[rubro] = 0; // Annual total for this specific rubro


                 const detailOrder = data.gastos[rubro]?.detailOrder || [];

                 detailOrder.forEach(detail => {
                      const baseValues = data.gastos[rubro].detailsData?.[detail]; // Raw values loaded from file or last projection
                      // Ensure values array exists and is 12 numbers (done by initialize)
                      if (!Array.isArray(baseValues) || baseValues.length !== 12 || !baseValues.every(v => typeof v === 'number')) {
                           console.warn(`Gasto detail "${rubro}/${detail}" data array is corrupted/missing during calc. Skipping.`);
                           return;
                      }

                     calculated.gastoAjustado[rubro][detail] = Array(12).fill(0); // This will store the *final* calculated value for the detail

                     for (let i = 0; i < 12; i++) {
                         const value = baseValues[i] || 0; // Value stored in data (could be REAL or ESTIMADO)
                         // Store the value directly into gastoAjustado; it already contains the post-projection value if the month was ESTIMADO
                         calculated.gastoAjustado[rubro][detail][i] = value;

                         // Add this value to the monthly total for the rubro
                         calculated.totalGastoRubroMes[rubro][i] += value;
                     }
                 });

                 // Sum monthly totals for the rubro to overall monthly/annual totals
                 for (let i = 0; i < 12; i++) {
                     const monthTotalRubro = calculated.totalGastoRubroMes[rubro]?.[i] || 0;
                     calculated.totalGastoProyectadoMes[i] += monthTotalRubro;
                     calculated.annualTotals.gastos[rubro] += monthTotalRubro;
                 }
             });
             // Calculate the overall annual total for gastos
             calculated.annualTotals.gastos.__TOTAL__ = calculated.totalGastoProyectadoMes.reduce((a, b) => a + (b||0), 0);


             // 2. Ingresos Ajustados (Base) & Totales (Final incl. UF mult) & Expensa Real Base Extraction
              // Process only rubros that are defined in GLOBAL settings AND have data in this scenario AND are marked as INGRESOS in settings.
             const ingresoRubrosToProcess = (settings.rubros?.ingresos || [])
                                          .filter(rubro => data.ingresos?.[rubro] && data.ingresos[rubro].detailsData && Object.keys(data.ingresos[rubro].detailsData).length > 0);


             ingresoRubrosToProcess.forEach(rubro => {
                  // Ensure calculated structures for this rubro exist and are cleared
                  calculated.ingresoAjustado[rubro] = {}; // Stores BASE values (from Excel input)
                  calculated.totalIngresoRubroMes[rubro] = Array(12).fill(0); // Stores FINAL calculated value (incl. UF mult)
                  calculated.annualTotals.ingresos[rubro] = 0;


                 const detailOrder = data.ingresos[rubro]?.detailOrder || [];

                 detailOrder.forEach(detail => {
                      const baseValues = data.ingresos[rubro].detailsData?.[detail]; // Raw values from Excel file
                      // Ensure values array exists and is 12 numbers (done by initialize)
                      if (!Array.isArray(baseValues) || baseValues.length !== 12 || !baseValues.every(v => typeof v === 'number')) {
                           console.warn(`Ingreso detail "${rubro}/${detail}" data array is corrupted/missing during calc. Skipping.`);
                           return;
                      }

                     // Store BASE values in 'ingresoAjustado' for the detail table display
                     calculated.ingresoAjustado[rubro][detail] = baseValues.map(v => v || 0); // Ensure numbers or 0


                     // Sum monthly totals for the rubro based on DETAIL BASE values (before UF mult)
                     for (let i = 0; i < 12; i++) {
                         calculated.totalIngresoRubroMes[rubro][i] += (baseValues[i] || 0); // Summing base values initially
                     }
                 });

                 // After summing all details BASE values for the rubro, apply multiplication if it's a special rubro
                 // This updates totalIngresoRubroMes to hold the FINAL calculated value for this rubro (incl. UF mult if applicable)
                 if (SPECIAL_INGRESO_RUBROS.includes(rubro) && unidades > 0) {
                     for (let i = 0; i < 12; i++) {
                         calculated.totalIngresoRubroMes[rubro][i] *= unidades;
                     }
                 } else if (SPECIAL_INGRESO_RUBROS.includes(rubro) && unidades <= 0) {
                      console.warn(`Cantidad de UF (${unidades}) es <= 0. Rubro "${rubro}" (tipo ingreso especial) no se multiplicará por UF.`);
                 }


                 // Sum the final calculated monthly totals for this rubro to the overall ingreso totals and annuals
                 for (let i = 0; i < 12; i++) {
                     const monthTotalRubroFinal = calculated.totalIngresoRubroMes[rubro]?.[i] || 0;
                     calculated.totalIngresoProyectadoMes[i] += monthTotalRubroFinal;
                     calculated.annualTotals.ingresos[rubro] += monthTotalRubroFinal;
                 }
             });
             // Calculate the overall annual total for ingresos
             calculated.annualTotals.ingresos.__TOTAL__ = calculated.totalIngresoProyectadoMes.reduce((a, b) => a + (b||0), 0);


             // --- Calculate Expensa Real ($/UF) ---
             // This uses the FINAL total calculated for the main CUOTA_RUBRO_NAME (Ord Expensa) and divides by UF count
             const unidadesParaExpensaReal = parseInt(settings.quantityUnits) || 1;

             if (unidadesParaExpensaReal <= 0) {
                  console.warn("Cantidad de Unidades Funcionales es cero o inválida. No se puede calcular Cuota Real Base por UF.");
                 calculated.cuotaRealBaseMes = Array(12).fill(0);
             } else {
                  // Get the FINAL monthly totals for the main CUOTA_RUBRO_NAME rubro (these *already* include UF mult if rubro is special)
                  const cuotaRubroFinalMonthlyTotals = Array.isArray(calculated.totalIngresoRubroMes?.[CUOTA_RUBRO_NAME]) && calculated.totalIngresoRubroMes[CUOTA_RUBRO_NAME].length === 12
                                                         ? calculated.totalIngresoRubroMes[CUOTA_RUBRO_NAME]
                                                          : Array(12).fill(0);

                 calculated.cuotaRealBaseMes = Array(12);
                 for (let i = 0; i < 12; i++) {
                     const totalRubroMesFinal = cuotaRubroFinalMonthlyTotals[i] || 0;
                      // Divide by UF count. Since totalRubroMesFinal was already mult by UF for special rubros, this division cancels that out.
                      // For non-special income rubros (if somehow CUOTA_RUBRO_NAME changed logic or assigned elsewhere), this division would be wrong.
                      // ASSUMPTION: CUOTA_RUBRO_NAME is always special and its monthly total is the sum of its details BASE values MULTIPLIED BY UF.
                     calculated.cuotaRealBaseMes[i] = totalRubroMesFinal / unidadesParaExpensaReal; // Value PER UF
                 }
             }
             // Annual total for Expensa Real per UF
             calculated.annualTotals.cuotaRealBase = calculated.cuotaRealBaseMes.reduce((a,b)=>a+(b||0),0);


             // 3. Fondo Reserva
             const reserveFundValues = Array.isArray(reserveFund?.values) && reserveFund.values.length === 12 && reserveFund.values.every(v => typeof v === 'number' && v >= 0)
                                    ? reserveFund.values
                                     : Array(12).fill(reserveFund?.type === 'fixed' ? 0 : 5); // Use default 0 or 5% if missing/corrupt. Use type from state for default.


             for (let i = 0; i < 12; i++) {
                 const reserveValueInput = reserveFundValues[i] || 0;

                 calculated.fondoReservaMes[i] = reserveFund?.type === 'percent'
                     ? (calculated.totalGastoProyectadoMes[i] || 0) * (reserveValueInput / 100) // Apply percentage on total monthly gasto
                     : reserveValueInput; // Use fixed value directly
             }
             calculated.annualTotals.fondoReserva = calculated.fondoReservaMes.reduce((a, b) => a + (b||0), 0);


             // 4. Cuota Sobre Gastos (Gasto + Fondo / UF)
             const unidadesParaCuotaSobreGastos = parseInt(settings.quantityUnits) || 1;
             for (let i = 0; i < 12; i++) {
                 const totalGastoYFondo = (calculated.totalGastoProyectadoMes[i] || 0) + (calculated.fondoReservaMes[i] || 0);
                 calculated.cuotaSobreGastosMes[i] = unidadesParaCuotaSobreGastos > 0 ? totalGastoYFondo / unidadesParaCuotaSobreGastos : 0;
             }
             calculated.annualTotals.cuotaSobreGastos = calculated.cuotaSobreGastosMes.reduce((a, b) => a + (b||0), 0);


             // 5. Cuota IPC using Expensa Real ($/UF) of January as base and accumulating IPC ref month by month
             // This block uses calculated.cuotaRealBaseMes which now contains the value per UF from the Ord Rubro.
             // It uses calculated.ipcManual which is the snapshot of percentages from settings.coefficientTypes.IPC.values.
             {
                 const ipcRefPercentages = calculated.ipcManual || Array(12).fill(0); // Get IPC snapshot percentages

                 // Use the calculated Expensa Real ($/UF) value from Enero as the base
                 const baseEneroPerUF = (calculated.cuotaRealBaseMes?.[0] || 0);

                 // January calculation: Apply Enero IPC percentage increase to the Enero Expensa Real ($/UF) base
                 const ipcEneroPercentage = parseFloat(ipcRefPercentages?.[0] || 0);
                 const ipcEneroMultiplier = 1 + (ipcEneroPercentage / 100);
                 calculated.cuotaIpcMes[0] = baseEneroPerUF * ipcEneroMultiplier; // Value PER UF


                 // Subsequent months (accumulative)
                 for (let i = 1; i < 12; i++) {
                     const ipcMonthPercentage = parseFloat(ipcRefPercentages?.[i] || 0); // Get percentage for current month
                     // Ensure valid percentage, default multiplier to 1 if not a number
                      const safeIpcMultiplier = 1 + ((typeof ipcMonthPercentage === 'number' && !isNaN(ipcMonthPercentage) && ipcMonthPercentage >= 0) ? ipcMonthPercentage / 100 : 0);
                      // Calculate based on the previous month's calculated Cuota IPC value
                     calculated.cuotaIpcMes[i] = (calculated.cuotaIpcMes[i - 1] || 0) * safeIpcMultiplier; // Value PER UF
                 }
             }
            calculated.annualTotals.cuotaIpc = calculated.cuotaIpcMes.reduce((a, b) => a + (b||0), 0); // Sum calculated IPC cuotas PER UF


             console.log("Recálculo Finalizado.", calculated);
             saveState(); // Save state after successful calculation
             updateUI(); // Update the display
             showSnackbar("Cálculos actualizados correctamente.", false, 'success');
        }

        // --- Recalcular Estimados (ACUMULATIVO) - Modified to use Percentage Coefficients ---
        function recalculateEstimates() {
            const scenarioData = getCurrentScenarioData();
            if (!scenarioData) { showSnackbar("No hay escenario activo para calcular estimados.", true, 'error'); return; }
            console.log(`Calculando estimados (Acumulativo) para: ${scenarioData.scenarioName}`);

            const { data, monthStatus, rubroOrder } = scenarioData; // Need monthStatus here to check REAL vs ESTIMADO
            const { settings } = appState;
            const { rubroConfig, coefficientTypes } = settings;
            let changesMade = false;

             // Process only expense rubros defined in GLOBAL settings and present in this scenario data/order
             const gastoRubrosToProcess = (appState.settings.rubros?.gastos || [])
                                         .filter(rubro => scenarioData.data.gastos?.[rubro] && scenarioData.data.gastos[rubro].detailsData); // Rubro exists & has detailsData object


            gastoRubrosToProcess.forEach(rubro => {
                const rubroData = data.gastos[rubro];
                 const rubroStatus = monthStatus.gastos?.[rubro] ?? {}; // Use ?? {} for safety

                // Use scenario-specific detail order
                const detailOrder = rubroData.detailOrder || [];

                // Get the assigned coefficient type key for this rubro, default to 'None' if missing config
                const rubroCoefConfig = rubroConfig[rubro] || {};
                const coefTypeKey = rubroCoefConfig.coefficientType || 'None';

                 // Get the percentage values array for the assigned coefficient type from GLOBAL settings
                 // Default to an array of 0s (representing 0% change, i.e., multiplier of 1) if the type or values are missing/corrupted
                const coefPercentageValues = (coefficientTypes[coefTypeKey]?.values || Array(12).fill(0))
                                               .slice(0, 12) // Ensure 12 months
                                               .map(v => typeof v === 'number' ? v : 0); // Ensure numbers or 0

                detailOrder.forEach(detail => {
                     // Ensure detail data array and status array exist and have 12 elements
                      const currentData = rubroData.detailsData?.[detail]; // Raw values loaded or previously projected
                       const currentStatuses = rubroStatus?.[detail]; // Status array

                       if (!Array.isArray(currentData) || currentData.length !== 12 || !currentData.every(v => typeof v === 'number')) {
                            console.warn(`Gasto detail data "${rubro}/${detail}" corrupted. Cannot project estimates.`);
                            return;
                       }
                       if (!Array.isArray(currentStatuses) || currentStatuses.length !== 12 || !currentStatuses.every(s => typeof s === 'string')) {
                            console.warn(`Gasto detail status "${rubro}/${detail}" corrupted. Cannot project estimates based on status.`);
                            // Cannot project reliably if status is bad. Could re-initialize status?
                            // Let's proceed but projection might not happen as expected if statuses aren't 'REAL'/'Estimado'
                            return;
                       }


                    let lastRealMonthIndex = -1;
                    // Iterate backwards from the end (month 11 - Dec) to find the index of the last 'REAL' status
                    for (let i = currentStatuses.length - 1; i >= 0; i--) {
                        if (currentStatuses[i] === 'REAL') {
                            lastRealMonthIndex = i;
                            break;
                        }
                    }

                    if (lastRealMonthIndex === -1) {
                         // console.log(`   - ${rubro}/${detail}: Sin mes REAL encontrado para proyección.`);
                         return; // Skip projection if no REAL month found for this detail line
                    }

                    // The starting point for the cumulative calculation is the *value* from the last month marked as 'REAL'.
                    let previousMonthValue = parseFloat(currentData[lastRealMonthIndex] || 0);


                    // --- Project Forward from the Month *After* the Last REAL Month ---
                    for (let j = lastRealMonthIndex + 1; j < 12; j++) {

                         // If we encounter a month index `j` that is CURRENTLY marked as 'REAL' (could happen if Excel data is non-contiguous)
                         // We should stop projecting for this segment and continue the next loop iteration from this new REAL month as base.
                          // This means projection for this *detail line* is broken into segments by REAL data points.
                         if (currentStatuses[j] === 'REAL') {
                             previousMonthValue = parseFloat(currentData[j] || 0); // Update the base for future estimated months
                            continue; // Skip calculation for this specific REAL month
                         }

                        // If the month `j` is marked as 'Estimado', apply the coefficient.
                        const percentage = parseFloat(coefPercentageValues[j] || 0); // Get percentage for the current month j (default to 0 if NaN/null)
                        // Calculate multiplier from percentage: 0% -> 1, 2.5% -> 1.025
                         const multiplier = 1 + (percentage / 100); // Ensure percentage is number >= 0 handled by settings saving

                         // Accumulative calculation: multiply the PREVIOUS month's value by the CURRENT month's calculated multiplier.
                         // Use the *already calculated* value from month j-1 (which could be REAL or a prior EST)
                          let baseValueForProjection = (j - 1 >= 0) ? (data.gastos[rubro].detailsData[detail][j-1] || 0) : previousMonthValue; // Use value from previous month index if available, else use the last REAL value as starting point (only for first month after last REAL)

                         // Correction based on previous implementation and request logic: Use the last *known* value (which is previousMonthValue set from last REAL or previous EST)
                         baseValueForProjection = previousMonthValue;


                         const projectedValue = baseValueForProjection * multiplier;

                         // Get the current value stored in data for this month, default to 0 if undefined
                         const currentMonthStoredValue = currentData[j] ?? 0;

                         // Check if the newly projected value is significantly different OR if the status needs to be explicitly set to 'Estimado'
                         // Use a small epsilon for floating point comparison robustness
                          const epsilon = 0.001; // Tolerance for value comparison
                          if (Math.abs(currentMonthStoredValue - projectedValue) > epsilon || currentStatuses[j] !== 'Estimado') {

                            // Update the data value with the new projected value
                            data.gastos[rubro].detailsData[detail][j] = projectedValue;

                            // Explicitly set the status for this month to 'Estimado'.
                            // This is important because the calculation flow depends on this status.
                            monthStatus.gastos[rubro][detail][j] = 'Estimado';

                            changesMade = true;
                            // console.log(`     * Projected ${rubro}/${detail} - ${FULL_MONTHS[j]}: ${projectedValue.toFixed(2)} (Base: ${baseValueForProjection.toFixed(2)} * Multiplier: ${multiplier.toFixed(3)} derived from ${percentage}%)`);
                         }

                         // --- IMPORTANT FOR ACCUMULATION ---
                         // Update `previousMonthValue` using the *newly calculated* `projectedValue` for the *next* iteration (month j+1).
                         previousMonthValue = projectedValue;
                    }
                });
            });

            if (changesMade) {
                console.log("Se realizaron cambios en los estimados de gastos, recalculando todo el escenario...");
                showSnackbar("Meses estimados de gastos recalculados (acumulativo). Actualizando dashboard...", false, 'info', 4000);
                calculateAll(scenarioData); // Recalculate everything after projections
            } else {
                console.log("No se necesitaron cambios en los estimados de gastos.");
                showSnackbar("No se encontraron meses estimados que requieran recalcular en gastos.", false, 'info');
            }
        }


        // --- Actualización de la Interfaz (UI) ---
        function initUI() {
             // Set current year in upload tab input
             document.getElementById('exercise-year')?.setAttribute('value', appState.currentYear);
             // Set footer year
             document.getElementById('footer-year').textContent = new Date().getFullYear();
             // Populate scenario selector based on loaded state
             updateScenarioSelector();
             // Set initial dashboard/tab titles based on active scenario/year state
             updateCurrentYearAndScenarioInUI();

             // The coefficient editor area starts empty until a type is selected.
             // Add a default message to the editor div.
            const coefEditorDiv = document.getElementById('coefficient-values-editor');
             if (coefEditorDiv) {
                 coefEditorDiv.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente de la lista (que no sea "Sin Coeficiente") para editar sus valores (en porcentaje %).</p>';
                  // Ensure it doesn't have the grid class initially
                 coefEditorDiv.classList.remove('monthly-inputs-grid');
             }
        }

        // Updates the entire UI based on the current state and scenarioData
        function updateUI() {
             console.log("Actualizando UI completa...");
             const scenarioData = getCurrentScenarioData(); // Get current data

             if (!scenarioData) {
                 console.error("updateUI: No hay escenario activo o datos disponibles. Renderizando estado vacío.");
                 // Clear/Reset all UI elements that depend on scenario data
                 renderEmptyState();
                 // Update elements that only depend on year/scenario *name* (might show "Ninguno")
                 updateCurrentYearAndScenarioInUI();
                 // Update scenario selector based on whatever scenarios are available (might be none)
                 updateScenarioSelector();
                 // Update other panels that might need disabling or default messages
                 updateReportsPanel(); // Disable report buttons
                 updateSettingsPanel(); // Show empty lists/defaults if state is bad


                 showSnackbar("No se pudo cargar o encontrar un escenario válido.", true, 'error', 8000);
                 return; // Stop further UI updates
             }

             // If we have scenarioData, ensure its internal structure is complete
             initializeScenarioDataForRubros(scenarioData); // Idempotent

             // Update all relevant UI sections sequentially
             updateCurrentYearAndScenarioInUI(); // Sync titles to active scenario's year/name
             updateScenarioSelector(); // Ensure selector shows correct active scenario and options
             updateDashboardTables(scenarioData); // Update summary and detail tables
             updateCharts(scenarioData); // Update all charts
             updateReserveFundPanel(scenarioData); // Update reserve fund inputs UI based on scenario state
             updateSettingsPanel(); // Update settings lists and inputs based on global settings
             updateReportsPanel(); // Enable/disable report buttons based on calculated data presence
             console.log("UI Actualizada.");
        }


        // Renders placeholder text in tables and hides charts when no data
        function renderEmptyState() {
            console.log("Renderizando estado vacío...");
            // Find tables
            const summaryTable = document.getElementById('dashboard-summary');
            const gastosTable = document.getElementById('gastos-detail-table');
            const ingresosTable = document.getElementById('ingresos-detail-table');

             // Determine the correct colspan based on existing headers if tables exist, fallback to generous number
             const summaryHeaderCols = summaryTable?.querySelector('thead tr')?.cells?.length || 8;
             const gastosHeaderCols = gastosTable?.querySelector('thead tr')?.cells?.length || 15; // Rubro, Coef, 12 Months, Total
             const ingresosHeaderCols = ingresosTable?.querySelector('thead tr')?.cells?.length || 14; // Rubro, 12 Months, Total

            // Clear and add empty message to tables
            const tables = [
                { id: 'dashboard-summary', cols: summaryHeaderCols },
                { id: 'gastos-detail-table', cols: gastosHeaderCols },
                { id: 'ingresos-detail-table', cols: ingresosHeaderCols }
             ];

            tables.forEach(({ id, cols }) => {
                 const table = document.getElementById(id);
                 if (table) {
                      const tbody = table.querySelector('tbody');
                      const tfoot = table.querySelector('tfoot');
                       if (tbody) tbody.innerHTML = `<tr><td colspan="${cols}" class="text-muted" style="text-align: center; padding: 20px;">${id === 'dashboard-summary' ? 'No hay datos calculados para este escenario.' : `No hay datos ${id === 'gastos-detail-table' ? 'de gastos' : 'de ingresos'} para mostrar.`} Carga datos o usa los de ejemplo y luego ejecuta Calcular Estimados.</td></tr>`;
                      if (tfoot) tfoot.innerHTML = ''; // Ensure footer is clear
                 }
            });


            // Destroy and hide charts
            destroyChart('evolutivoCuotaChart');
            destroyChart('participacionGastosChart');
            destroyChart('participacionIngresosChart');
             // Show no-data messages and hide canvases
             displayChartNoData('evolutivoCuotaChart', true);
             displayChartNoData('participacionGastosChart', true);
             displayChartNoData('participacionIngresosChart', true);


            // Clear coefficient editor content and state
            const coefEditorDiv = document.getElementById('coefficient-values-editor');
            const coefNameSpan = document.getElementById('editing-coefficient-name');
            if(coefEditorDiv) {
                 coefEditorDiv.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente de la lista (que no sea "Sin Coeficiente") para editar sus valores (en porcentaje %).</p>';
                 coefEditorDiv.classList.remove('monthly-inputs-grid'); // Ensure grid class is removed
            }
            if(coefNameSpan) coefNameSpan.textContent = 'Ninguno';
             // Update UI state flag
            if(appState.uiState) appState.uiState.editingCoefficientType = null;

             // Update the coefficient type list styling after clearing selection
            updateCoefficientTypeList();
        }


        function destroyChart(canvasId) {
             const chart = window[`${canvasId}_instance`];
             const canvasElement = document.getElementById(canvasId);

             // Ensure the container element exists to apply 'no-data' class
             const container = canvasElement?.parentElement;


             if (chart) {
                chart.destroy();
                window[`${canvasId}_instance`] = null; // Nullify the instance reference
                // console.log(`Chart ${canvasId} destroyed.`);
             }

              // Ensure canvas is display: block when data is expected, display: none otherwise (handled by displayChartNoData)
             if (canvasElement) canvasElement.style.display = 'block';

              // Remove 'no-data' class from container by default when destroying (it will be re-added by displayChartNoData if needed)
             if (container) container.classList.remove('no-data');

         }


         // Shows/Hides the "No Data" message for a chart and toggles container/canvas display.
        function displayChartNoData(canvasId, show) {
            const canvasElement = document.getElementById(canvasId);
            if (!canvasElement) {
                console.warn(`Canvas element not found for ${canvasId}. Cannot toggle no-data message.`);
                return;
            }
            const container = canvasElement.parentElement; // Get the parent container element

            if (container) {
                // Use class on container to manage display of both canvas and message
                container.classList.toggle('no-data', show);
            } else {
                 console.warn(`Chart container not found for ${canvasId}. Cannot toggle no-data container class.`);
                 // Fallback: just manage canvas display directly
                 canvasElement.style.display = show ? 'none' : 'block';
                 const noDataElement = canvasElement.nextElementSibling; // Assuming message is the next sibling
                 if(noDataElement && noDataElement.classList.contains('chart-no-data')) {
                    noDataElement.style.display = show ? 'block' : 'none';
                 }
            }
         }

        // Update Reserve Fund panel monthly inputs UI based on the selected type
        function updateReserveUI() {
             // This function is called when the radio button changes type.
             // It needs to read the currently selected type directly from the DOM.
             const uiSelectedType = document.getElementById('reserve-type-percent')?.checked ? 'percent' : 'fixed';

             const panel = document.getElementById('reserve-fund-panel');
             if (!panel) return;

             // Determine UI labels, step, placeholder, and title based on the SELECTED type
             const unitLabel = uiSelectedType === 'percent' ? '%' : '$';
             // Step is arbitrary but useful for number input ux
             const currentStep = uiSelectedType === 'percent' ? '0.1' : '100';
             const inputPlaceholder = uiSelectedType === 'percent' ? 'Ej: 5' : 'Ej: 10000';
             const inputTitlePrefix = uiSelectedType === 'percent' ? 'Porcentaje (%) para ' : 'Valor fijo ($) para ';

             panel.querySelectorAll('input[type="number"]').forEach(input => {
                 input.step = currentStep;
                 input.placeholder = inputPlaceholder;

                 const monthIndex = parseInt(input.dataset.month); // Get month index from data attribute
                 // Update title with selected type
                 if (!isNaN(monthIndex)) { // Ensure monthIndex is valid
                      input.title = `${inputTitlePrefix}${FULL_MONTHS[monthIndex]}`;
                 }

                 // NOTE: The *value* displayed in the input field should reflect the value
                 // currently stored in the scenario data's `reserveFund.values` array.
                 // This is populated by `updateReserveFundPanel` when the dashboard or
                 // reserve tab is rendered or calculation runs.
                 // When the *type* is switched, the numerical values in the input fields
                 // are NOT automatically converted (e.g. 5000 fixed vs 5 percent).
                 // The user manually changes them and clicks "Guardar".
             });
             // Update unit text next to inputs
             panel.querySelectorAll('.month-config span, .input-with-unit span').forEach(span => span.textContent = unitLabel);

             console.log(`UI fondo reserva updated for display type: ${uiSelectedType}. User input values are not automatically converted.`);
        }


        // Update settings UI elements
        function updateSettingsPanel() {
            // Update UF input
            const ufInput = document.getElementById('cantidad-unidades');
             // Use quantityUnits consistently
            if (ufInput) ufInput.value = appState.settings.quantityUnits;

            // Update rubro lists for Gastos and Ingresos
            updateRubroList('gastos', 'gasto-rubro-list');
            updateRubroList('ingresos', 'ingreso-rubro-list');

            // Update the list of coefficient types available
            updateCoefficientTypeList();

             // Check which coefficient type is currently selected for editing in the UI state
            const currentEditingTypeKey = appState.uiState.editingCoefficientType;

             // Render the monthly value inputs area based on the current selection
             // Pass null if nothing is selected, which renderCoefficientValuesEditor handles by showing a default message
             renderCoefficientValuesEditor(currentEditingTypeKey);
        }


         // Render monthly inputs for a specific coefficient type (in Settings)
        function renderCoefficientValuesEditor(typeKey) {
             const editorDiv = document.getElementById('coefficient-values-editor');
             const nameSpan = document.getElementById('editing-coefficient-name'); // Span displaying the name of the edited type
             if (!editorDiv || !nameSpan) return;

            editorDiv.innerHTML = ''; // Clear previous content inside the editor div
            editorDiv.classList.remove('monthly-inputs-grid'); // Remove grid class by default when clearing


            // --- Logic to handle no type selected or invalid type ---
             // Check if the typeKey is null, undefined, or points to a non-existent type in state
             const typeData = typeKey ? appState.settings.coefficientTypes?.[typeKey] : null;

             if (!typeKey || !typeData) {
                 // If no valid type key provided or type not found in state, show default message
                 editorDiv.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente de la lista (que no sea "Sin Coeficiente") para editar sus valores (en porcentaje %).</p>';
                 nameSpan.textContent = 'Ninguno';
                  appState.uiState.editingCoefficientType = null; // Ensure state reflects no active editing type
                 // Do NOT return here, the remaining logic ensures lists/buttons are updated. No, the logic *is* supposed to stop here for rendering the inputs.
                 return; // Stop rendering inputs if no type is selected
             }
            // --- End Handle no type selected ---


             // If a valid typeKey is provided, display its name
             nameSpan.textContent = typeData.name;

            // Apply the grid layout class to the container holding the monthly inputs
            editorDiv.classList.add('monthly-inputs-grid');


             // Get the monthly values for the selected type.
             // Ensure the values array exists, has 12 elements, and all are numbers >= 0 (as percentages should be)
             const values = Array.isArray(typeData.values) && typeData.values.length === 12 && typeData.values.every(v => typeof v === 'number' && v >= 0)
                             ? typeData.values.map(v => v) // Copy valid non-negative numbers
                             : Array(12).fill(0); // Default to 0% if corrupted/missing


             // Determine if the inputs should be editable (only for non-default types)
             const isEditable = !typeData.isDefault;


             // Create monthly inputs grid
             for (let i = 0; i < 12; i++) {
                 const formGroup = document.createElement('div');
                 formGroup.classList.add('form-group'); // Use this class for styling within the grid

                 const label = document.createElement('label');
                 label.textContent = FULL_MONTHS[i]; // Full month names as labels
                 label.htmlFor = `coef-month-${typeKey}-${i}`; // Unique ID including type key and month index

                 const inputGroup = document.createElement('div');
                 inputGroup.classList.add('input-with-unit'); // Utility class for input+unit styling

                 const input = document.createElement('input');
                 input.type = 'number';
                 input.id = `coef-month-${typeKey}-${i}`;
                 input.dataset.month = i; // Store month index
                 input.dataset.typeKey = typeKey; // Store the key of the coefficient type
                 input.value = values[i]; // Display the percentage value directly from state
                 input.step = '0.1'; // Allow decimal percentages (e.g., 2.5)
                 input.min = '0'; // Percentages should be >= 0 (a multiplier < 1 like 0.9 for -10% comes from positive percentage < 100 like 90%)
                 input.disabled = !isEditable; // Disable input for default types

                 // Placeholder indicates expected format (percentage)
                 input.placeholder = 'Ej: 2.5'; // Percentage
                 input.title = `Porcentaje de ajuste para ${FULL_MONTHS[i]} (%)`;


                 const unitSpan = document.createElement('span');
                 unitSpan.textContent = '%';
                 unitSpan.style.fontWeight = "normal"; // Ensure unit text is normal weight

                 // Assemble input group and form group
                 inputGroup.appendChild(input);
                 inputGroup.appendChild(unitSpan);
                 formGroup.appendChild(label);
                 formGroup.appendChild(inputGroup);
                 editorDiv.appendChild(formGroup); // Add the form group (which is the grid cell content) to the editor div

                  // Add event listener only if the inputs are editable
                 if (isEditable) {
                     input.onchange = handleCoefficientValueChange; // Event handled when input value changes
                 }
             } // End loop for months
        }


        // Handle change for Percentage Coefficient Values
        // This function is called when the value in a monthly input field for a coefficient type changes.
        // It updates the state but does NOT trigger a recalculation immediately (saveSettings does that).
        function handleCoefficientValueChange(event) {
             const input = event.target; // The input element that changed
             const monthIndex = parseInt(input.dataset.month); // Get month index from data attribute
             const typeKey = input.dataset.typeKey; // Get coefficient type key from data attribute
             const value = parseFloat(input.value); // Read the percentage value entered by the user

            // --- Validation ---
            // Ensure monthIndex and typeKey are valid
             if (isNaN(monthIndex) || monthIndex < 0 || monthIndex > 11 || !typeKey || !appState.settings.coefficientTypes || !appState.settings.coefficientTypes[typeKey]) {
                 console.error("Error interno: Atributos data-month o data-type-key inválidos o tipo no encontrado en state.");
                  showSnackbar("Error interno al procesar el cambio de valor.", true, 'error');
                 // Attempt to revert the input display if the state lookup fails
                 if (appState.settings.coefficientTypes?.[typeKey]?.values && appState.settings.coefficientTypes[typeKey].values.length > monthIndex && !isNaN(monthIndex)) {
                      input.value = appState.settings.coefficientTypes[typeKey].values[monthIndex] || 0;
                 } else {
                      input.value = 0; // Revert to 0 if cannot find previous state value
                 }
                 return; // Stop processing invalid change
             }

            // Ensure the entered value is a non-negative number
             if (isNaN(value) || value < 0) {
                 showSnackbar(`Valor inválido (${input.value}). Debe ser un número mayor o igual a 0.`, true, 'error');
                  // Revert the input display to the last saved valid value
                  input.value = appState.settings.coefficientTypes[typeKey].values[monthIndex] || 0; // Use 0 as fallback
                 return; // Stop processing invalid input value
             }
            // --- End Validation ---


            // If input is valid, update the corresponding value in the global state
            // Ensure the values array for the type exists and is correct size before updating
             const typeData = appState.settings.coefficientTypes[typeKey]; // Get reference
             if (!Array.isArray(typeData.values) || typeData.values.length !== 12) {
                 // This shouldn't happen if initializeSettingsDataForCoefficientTypes worked on load,
                 // but handle defensively by logging and correcting.
                 console.warn(`Values array for "${typeKey}" corrupted. Reinitializing to 0s.`);
                  typeData.values = Array(12).fill(0); // Reset if structure is bad
                  // Recalculate flag would be true if state was invalid.
             }

             // Update the stored value (which is the percentage)
             typeData.values[monthIndex] = value;

             console.log(`Valor porcentaje mes ${MONTHS[monthIndex]} para "${typeData.name}" (${typeKey}) actualizado a ${value}%.`);

             saveState(); // Save state immediately after a change is made.
             // Recalculation is triggered by the main "Guardar Toda la Configuración" button click.
             // This ensures that the projection only runs *after* all coefficient values (and rubro assignments etc) are confirmed by the user clicking Save.

             showSnackbar(`Valor ${formatPercentage(value)} para ${FULL_MONTHS[monthIndex]} actualizado (guarda configuración para aplicar)`, false, 'info', 3000); // Show info snackbar indicating change, but pending save
         }


        // --- Funciones de Acción (Botones, etc.) ---

        // Clears scenario-specific data (Excel loaded/projected values and status),
        // but keeps the scenario's reserve fund config and global settings unchanged.
        // Recalculates the scenario (totals will go to zero, unless reserve fund type is fixed) and updates UI.
        function clearScenarioData() {
             const key = appState.activeScenarioKey;
             // Check if scenarios object exists and the key is valid
             const scenario = appState.scenarios?.[key];
             if (!scenario) { showSnackbar('No hay escenario activo.', true, 'error'); return; }

             if (!confirm(`¿Borrar TODOS los datos cargados (gastos, ingresos) y estados de meses ("REAL"/"Estimado") del escenario "${scenario.scenarioName}" del año ${scenario.year}?\n\nLa Configuración de Fondo de Reserva, Rubros, y Coeficientes NO se borrarán.\n¡No se puede deshacer esta parte de los datos!`)) {
                 showSnackbar("Operación cancelada.", false, 'info'); return;
             }

             console.log(`Borrando datos de detalle (Excel y Proyecciones) y estados para escenario: ${key}`);

             // Reset scenario's source data and month status. Keep rubroOrder for potentially adding data again.
             scenario.data = { gastos: {}, ingresos: {} }; // Replace with empty objects
             scenario.monthStatus = { gastos: {}, ingresos: {} }; // Replace with empty objects
             // Keep scenario.rubroOrder and scenario.reserveFund and global appState.settings


             // Ensure necessary basic structures exist in the newly reset data objects based on global settings
              initializeScenarioDataForRubros(scenario); // Re-initializes structures *within* the scenario data/monthStatus objects

             saveState(); // Save the state with cleared data structures


             // Trigger recalculation to update dashboard/tables with zeros and refresh UI state
             calculateAll(scenario); // Handles success message inside


             showSnackbar(`Datos cargados y estados de meses borrados para el escenario "${scenario.scenarioName}".`, false, 'success', 5000); // Separate snackbar for clearing data
        }


        // --- Reports ---
        function updateReportsPanel() {
             // Get current scenario data
             const scenarioData = getCurrentScenarioData();
             // Determine if there is enough calculated data to justify enabling reports.
             // Check key calculated arrays/totals for having any non-zero value.
             const hasMeaningfulCalculatedData = scenarioData?.calculated && (
                (scenarioData.calculated.totalGastoProyectadoMes?.some(v => v !== 0) ?? false) ||
                (scenarioData.calculated.totalIngresoProyectadoMes?.some(v => v !== 0) ?? false) ||
                (scenarioData.calculated.cuotaRealBaseMes?.some(v => v !== 0) ?? false) || // Check Expensa Real data
                 (scenarioData.calculated.cuotaIpcMes?.some(v => v !== 0) ?? false) || // Check Cuota IPC
                (scenarioData.calculated.fondoReservaMes?.some(v => v !== 0) ?? false) // Check Fondo Reserva
             );

             // Disable report buttons if no scenario is active OR if calculated data is all zeros
             const disableButtons = !scenarioData || !hasMeaningfulCalculatedData;

             // Select all buttons within the #reports section and set their disabled state
             document.querySelectorAll('#reports button').forEach(btn => { btn.disabled = disableButtons; });

              if (disableButtons && document.getElementById('reports').classList.contains('active')) {
                  // Optional: Show a temporary message in the reports panel if it's the active tab and buttons are disabled
                  // Might be cleaner to leave the buttons disabled but add a text below them.
             }
        }

        // Exports current scenario data to an Excel file
        function exportToExcel() {
             console.log("Iniciando exportación Excel...");
             const scenarioData = getCurrentScenarioData();
             // Check if there is an active scenario and if calculated data exists (meaning calculateAll ran successfully)
             if (!scenarioData || !scenarioData.calculated || !scenarioData.calculated.annualTotals || !scenarioData.calculated.totalGastoProyectadoMes || !scenarioData.calculated.totalIngresoProyectadoMes || !scenarioData.calculated.cuotaRealBaseMes || !scenarioData.calculated.ipcManual) {
                 showSnackbar("No hay datos calculados válidos para exportar.", true, 'error'); return;
             }

             const { year, scenarioName, data, calculated, reserveFund } = scenarioData; // No longer need rubroOrder explicitly, iterate global rubros filtered by data presence.
             const { settings } = appState;
             const { rubros, rubroConfig, quantityUnits, coefficientTypes } = settings;


             try {
                 const wb = XLSX.utils.book_new();

                 // --- Cell Formatting Definitions (Basic) ---
                 const currencyFormat = "$ #,##0.00"; // Format for monetary values
                 const percentageFormat = "0.00%"; // Format for percentage values (stored as fractions in XLSX cell.v if .z is set to %)
                 const rawPercentageFormat = "0.0"; // Format for percentage values stored AS percentages (like the IPC or coef inputs)
                 const numberFormat = "#,##0"; // Format for integers like UF count

                  // Map month indices to column headers for output (use short names)
                 const monthColumnHeaders = MONTHS; // ["Ene", "Feb", ...]

                 // --- Helper to create array data for a sheet ---
                 const createSheetArrayData = (title, headers, dataRows) => {
                      // Filter out any invalid or empty rows from the raw dataRows array
                     const validDataRows = dataRows.filter(row => Array.isArray(row) && row.length > 0 && row.some(cell => cell !== null && cell !== undefined && String(cell).trim() !== ''));
                     return [[title], [], headers, ...validDataRows]; // Title row, spacer, header row, data rows
                 };


                 // --- 1. Detalle Gastos Sheet ---
                 // Columns: Rubro, Detalle, Coef. Aplicado, Ene, ..., Dic, Total Anual
                 const gastosHeaders = ["Rubro", "Detalle", "Coef. Aplicado", ...monthColumnHeaders, "Total Anual"];
                 const gastosRows = [];

                  // Iterate through rubros defined in GLOBAL settings, filtering to include only those that have data in THIS scenario
                  (settings.rubros?.gastos || [])
                      .filter(rubro => data.gastos?.[rubro] && data.gastos[rubro].detailsData)
                      .forEach(rubro => {
                           const rubroData = data.gastos[rubro]; // Data for this rubro in the scenario
                           // Get the assigned coefficient type key and its name for this rubro
                          const rubroConfigForCoef = rubroConfig[rubro] || {};
                           const coefTypeKey = rubroConfigForCoef.coefficientType || 'None';
                           const coefTypeName = coefficientTypes[coefTypeKey]?.name || 'N/A';


                           // Iterate through details defined in the scenario's data order for this rubro
                          const detailOrder = rubroData.detailOrder || [];
                           detailOrder.forEach(detail => {
                               // Use the 'gastoAjustado' calculated data for the monthly values (contains the final Real/Projected value)
                                const monthlyValues = calculated.gastoAjustado?.[rubro]?.[detail];
                                // Ensure values array exists, is correct size, and contains numbers
                                if (!Array.isArray(monthlyValues) || monthlyValues.length !== 12 || !monthlyValues.every(v => typeof v === 'number')) {
                                     console.warn(`Corrupted monthly data for gasto detail "${rubro}/${detail}". Skipping export row.`);
                                    return; // Skip row if data is bad
                                }

                               // Calculate the annual total for this detail based on the monthly values
                                const annualDetailTotal = monthlyValues.reduce((a, b) => a + (b || 0), 0); // Use 0 for null/undefined


                                // Add the detail row to the export data array
                                // Monthly values and annual total should be included
                                gastosRows.push([
                                    rubro,
                                    detail,
                                    coefTypeName, // Coef type name
                                    ...monthlyValues, // Array of 12 numbers
                                    annualDetailTotal // Number
                                ]);
                           });
                  });

                 // Create worksheet from array data
                 const ws_gastos_array = createSheetArrayData(`DETALLE GASTOS ${year} - ${scenarioName}`, gastosHeaders, gastosRows);
                 const ws_gastos = XLSX.utils.aoa_to_sheet(ws_gastos_array);

                 // Set column widths
                 ws_gastos['!cols'] = [ {wch:20}, {wch:25}, {wch:18}, ...Array(12).fill({wch:12}), {wch:14} ];

                 // Apply number formatting to monetary columns (Ene to Dec, and Total Anual)
                 // Data rows start at row index 3 (0-based)
                 const dataStartRowGastos = ws_gastos_array.findIndex(row => Array.isArray(row) && row[0] === gastosHeaders[0]) + 1; // Find the header row, add 1
                 if (dataStartRowGastos > 0) { // Ensure header was found (index > 0)
                      for (let rowIndex = dataStartRowGastos; rowIndex < ws_gastos_array.length; rowIndex++) {
                          // Columns for monthly values are 3 to 14 (indices 3-14). Total column is 15 (index 15).
                           // Iterate through relevant columns (indices 3 through 3 + 12 = 15)
                          for (let colIndex = 3; colIndex < 16; colIndex++) { // Correct indices for Ene..Dic + Total Anual
                              const cellRef = XLSX.utils.encode_cell({r: rowIndex, c: colIndex});
                               // Check if cell exists and its value is a number before applying format
                               if (ws_gastos[cellRef] && typeof ws_gastos[cellRef].v === 'number') {
                                   ws_gastos[cellRef].z = currencyFormat;
                                    // Ensure cell type is 'n' (number)
                                   ws_gastos[cellRef].t = 'n';
                               }
                          }
                      }
                 }


                 XLSX.utils.book_append_sheet(wb, ws_gastos, "Detalle Gastos");


                 // --- 2. Detalle Ingresos Sheet (Shows BASE values from Excel) ---
                 // Columns: Rubro, Detalle, Ene, ..., Dic, Total Anual
                 const ingresosHeaders = ["Rubro", "Detalle", ...monthColumnHeaders, "Total Anual"];
                 const ingresosRows = [];

                 // Iterate through rubros defined in GLOBAL settings, filtering to include only those that have data in THIS scenario
                 (settings.rubros?.ingresos || [])
                     .filter(rubro => data.ingresos?.[rubro] && data.ingresos[rubro].detailsData)
                      .forEach(rubro => {
                           const rubroData = data.ingresos[rubro]; // Data for this rubro in the scenario

                           // Iterate through details defined in the scenario's data order for this rubro
                           const detailOrder = rubroData.detailOrder || [];
                           detailOrder.forEach(detail => {
                                // Use the 'ingresoAjustado' calculated data for the monthly values (contains the BASE values from Excel input)
                                const monthlyValues = calculated.ingresoAjustado?.[rubro]?.[detail];
                                // Ensure values array exists, is correct size, and contains numbers
                                if (!Array.isArray(monthlyValues) || monthlyValues.length !== 12 || !monthlyValues.every(v => typeof v === 'number')) {
                                     console.warn(`Corrupted monthly data for ingreso detail "${rubro}/${detail}". Skipping export row.`);
                                    return; // Skip row if data is bad
                                }


                               // Calculate the annual total for this detail based on the BASE monthly values
                                const annualDetailTotal = monthlyValues.reduce((a, b) => a + (b || 0), 0); // Use 0 for null/undefined


                                // Add a note to the rubro label if it's one of the special types multiplied by UF in the total sum
                                const rubroLabel = SPECIAL_INGRESO_RUBROS.includes(rubro) ? `${rubro} (Valor Base x UF)` : rubro;

                                ingresosRows.push([
                                     rubroLabel, // Label might have a note
                                     detail,
                                    ...monthlyValues, // Array of 12 numbers (Base Values)
                                     annualDetailTotal // Number (Sum of Base Values)
                                ]);
                           });
                  });

                 // Create worksheet from array data
                 const ws_ingresos_array = createSheetArrayData(`DETALLE INGRESOS (Valores Base) ${year} - ${scenarioName}`, ingresosHeaders, ingresosRows);
                 const ws_ingresos = XLSX.utils.aoa_to_sheet(ws_ingresos_array);

                 // Set column widths
                 ws_ingresos['!cols'] = [{wch:25},{wch:25}, ...Array(12).fill({wch:12}), {wch:14}];

                 // Apply number formatting to monetary columns (Ene to Dic, and Total Anual)
                 // Data rows start at row index 3 (0-based)
                 const dataStartRowIngresos = ws_ingresos_array.findIndex(row => Array.isArray(row) && row[0] === ingresosHeaders[0]) + 1; // Find the header row, add 1
                 if (dataStartRowIngresos > 0) { // Ensure header was found (index > 0)
                      for (let rowIndex = dataStartRowIngresos; rowIndex < ws_ingresos_array.length; rowIndex++) {
                          // Columns for monthly values are 2 to 13 (indices 2-13). Total column is 14 (index 14).
                           // Iterate through relevant columns (indices 2 through 2 + 12 = 14)
                          for (let colIndex = 2; colIndex < 15; colIndex++) { // Correct indices for Ene..Dic + Total Anual
                              const cellRef = XLSX.utils.encode_cell({r: rowIndex, c: colIndex});
                               // Check if cell exists and its value is a number before applying format
                               if (ws_ingresos[cellRef] && typeof ws_ingresos[cellRef].v === 'number') {
                                   ws_ingresos[cellRef].z = currencyFormat;
                                    // Ensure cell type is 'n' (number)
                                   ws_ingresos[cellRef].t = 'n';
                               }
                          }
                      }
                 }
                 XLSX.utils.book_append_sheet(wb, ws_ingresos, "Detalle Ingresos (Base)");


                  // --- 3. Tipos de Coeficientes Sheet (shows monthly percentage values) ---
                 const coefTypesHeaders = ["Tipo Coeficiente", ...monthColumnHeaders]; // No Total column needed here
                 const coefTypesRows = [];

                  // Iterate through all coefficient types defined in GLOBAL settings
                 Object.keys(coefficientTypes || {})
                     .sort((a, b) => (coefficientTypes[a]?.name || '').localeCompare(coefficientTypes[b]?.name || '')) // Sort alphabetically by name
                     .forEach(typeKey => {
                          const typeData = coefficientTypes[typeKey];
                           if (!typeData) return; // Skip if type data is missing

                           // Get percentage values array for this type
                           const monthlyPercentages = Array.isArray(typeData.values) && typeData.values.length === 12 && typeData.values.every(v => typeof v === 'number')
                                                     ? typeData.values.map(v => v >= 0 ? v : 0) // Use non-negative values
                                                      : Array(12).fill(0); // Default to 0% if corrupted/missing

                          // Add the row (Name + monthly percentages)
                           coefTypesRows.push([typeData.name, ...monthlyPercentages]);
                  });

                 const ws_coefTypes_array = createSheetArrayData(`COEFICIENTES DE AJUSTE (${year})`, coefTypesHeaders, coefTypesRows);
                 const ws_coefTypes = XLSX.utils.aoa_to_sheet(ws_coefTypes_array);

                 // Set column widths
                  ws_coefTypes['!cols'] = [ {wch:25}, ...Array(12).fill({wch:10}) ]; // Column widths for Name + 12 months

                 // Apply number/percentage formatting to value columns
                  // Data rows start at row index 3 (0-based)
                  const dataStartRowCoefTypes = ws_coefTypes_array.findIndex(row => Array.isArray(row) && row[0] === coefTypesHeaders[0]) + 1; // Find the header row, add 1
                 if (dataStartRowCoefTypes > 0) { // Ensure header was found
                      for (let rowIndex = dataStartRowCoefTypes; rowIndex < ws_coefTypes_array.length; rowIndex++) {
                          // Columns for monthly percentage values are 1 to 12 (indices 1-12)
                          for (let colIndex = 1; colIndex < 13; colIndex++) {
                              const cellRef = XLSX.utils.encode_cell({r: rowIndex, c: colIndex});
                               if (ws_coefTypes[cellRef] && typeof ws_coefTypes[cellRef].v === 'number') {
                                    // Store the percentage value directly, and use the rawPercentageFormat
                                    ws_coefTypes[cellRef].z = rawPercentageFormat;
                                    ws_coefTypes[cellRef].t = 'n';
                                    // NO division by 100 needed for rawPercentageFormat, just the format string
                                }
                          }
                      }
                 }
                 XLSX.utils.book_append_sheet(wb, ws_coefTypes, "Coeficientes (%)");


                 // --- 4. Resumen General Sheet ---
                 const resumenHeaders = ["Concepto", ...monthColumnHeaders, "Total Anual"]; // Use short month headers here too
                 const resumenRows = [];

                 // Helper function to safely add a row with its monthly values and total, storing format info
                 const addResumenRow = (label, values, format = currencyFormat, totalIsSum = true) => {
                     // Ensure values is an array of 12 numbers or default to 0s
                     const monthlyValues = Array.isArray(values) && values.length === 12 && values.every(v => typeof v === 'number')
                                         ? values.map(v => v)
                                          : Array(12).fill(0); // Default to 0s if missing/corrupted


                      // Calculate the annual total. For most rows (costs, funds), it's the sum. For rates per UF, it's often also sum, but sometimes misleading (better shown as avg maybe?). Summing is consistent with table footer.
                      // Exception: UF count - the total is just the single value repeated, not the sum. Handle this manually outside the loop or check label.
                      const annualTotal = totalIsSum ? monthlyValues.reduce((a, b) => a + (b||0), 0) : (monthlyValues[0] || 0); // Sum monthly values

                     const rowData = [label, ...monthlyValues, annualTotal];
                     rowData.formatInfo = { format: format, totalIsSum: totalIsSum, isUFRow: (label === `Unidades Funcionales (UF)`) }; // Store formatting details
                     resumenRows.push(rowData);
                 };

                 // GASTOS Summary (Summed adjusted values per month/rubro)
                 addResumenRow("--- GASTOS ---", []); // Header row
                 // Add rows for each expense rubro total (monthly sums of details)
                  (settings.rubros?.gastos || [])
                      .filter(rubro => calculated.totalGastoRubroMes?.[rubro]) // Rubro total calculation exists
                      .sort((a, b) => a.localeCompare(b)) // Sort rubros alphabetically for summary
                      .forEach(rubro => {
                           addResumenRow(`Gasto - ${rubro}`, calculated.totalGastoRubroMes[rubro], currencyFormat);
                  });
                 // Add overall total gastos row
                 addResumenRow("TOTAL GASTOS ($)", calculated.totalGastoProyectadoMes, currencyFormat);
                 resumenRows.push([]); // Spacer


                 // INGRESOS Summary (Summed FINAL values incl. UF mult)
                 addResumenRow("--- INGRESOS (Calculados) ---", []); // Header row
                  // Add rows for each income rubro total (monthly sums of final calculated values)
                  (settings.rubros?.ingresos || [])
                      .filter(rubro => calculated.totalIngresoRubroMes?.[rubro]) // Rubro total calculation exists
                       .sort((a, b) => a.localeCompare(b)) // Sort rubros alphabetically for summary
                      .forEach(rubro => {
                           // Add a note to the label if the rubro total was multiplied by UF
                           const rubroLabel = SPECIAL_INGRESO_RUBROS.includes(rubro) ? `${rubro} (Total x UF)` : rubro;
                          addResumenRow(`Ingreso - ${rubroLabel}`, calculated.totalIngresoRubroMes[rubro], currencyFormat);
                   });
                 // Add overall total ingresos row
                 addResumenRow("TOTAL INGRESOS ($)", calculated.totalIngresoProyectadoMes, currencyFormat);
                 resumenRows.push([]); // Spacer


                 // FONDO RESERVA Summary
                 addResumenRow("--- FONDO RESERVA ---", []); // Header row
                  // Add the reserve fund config row (Percentage or Fixed Value inputs)
                   const reserveType = reserveFund?.type === 'fixed' ? 'fixed' : 'percent'; // Default to percent
                   const reserveLabel = `Fondo Reserva Config (${reserveType === 'percent' ? '%' : '$'})`;
                   // Get configured reserve values from state (could be % or $)
                  const configuredReserveValues = Array.isArray(reserveFund?.values) && reserveFund.values.length === 12 && reserveFund.values.every(v => typeof v === 'number' && v >= 0)
                                                     ? reserveFund.values
                                                     : Array(12).fill(reserveType === 'fixed' ? 0 : 5); // Default values

                   // Add the config row, format depends on type. Total is sum of config values.
                  addResumenRow(reserveLabel, configuredReserveValues, reserveType === 'percent' ? rawPercentageFormat : currencyFormat, true); // Use raw % format


                 // Add the calculated reserve fund amounts row (always currency)
                 addResumenRow("Fondo Reserva Calculado ($)", calculated.fondoReservaMes, currencyFormat);
                 resumenRows.push([]); // Spacer


                 // CUOTAS Y REFERENCIAS Summary
                 addResumenRow("--- CUOTAS Y REFERENCIAS ---", []); // Header row
                 // Add Unidades Funcionales count row (only in first month column, Total is just the count)
                 const ufValues = Array(12).fill(null); // Array of 12, most are null
                 ufValues[0] = quantityUnits; // Put UF count in the first month column
                  addResumenRow(`Unidades Funcionales (UF)`, ufValues, numberFormat, false); // formatInfo indicates it's UF row

                 // Add calculated Cuota Sobre Gastos per UF row (monthly sums of $/UF)
                 addResumenRow("Cuota s/Gtos Calculada ($/UF)", calculated.cuotaSobreGastosMes, currencyFormat);

                 // Add IPC Reference (%) row (percentages from calculated snapshot)
                 addResumenRow("IPC Referencia (%)", calculated.ipcManual, rawPercentageFormat); // Use raw % format


                 // Add calculated Cuota IPC per UF row (monthly $/UF based on IPC accumulation)
                 addResumenRow("Cuota IPC Calculada ($/UF)", calculated.cuotaIpcMes, currencyFormat);

                 // Add calculated Expensa Real per UF row (monthly $/UF from Ord Expensa Rubro)
                 addResumenRow("Expensa Real ($/UF)", calculated.cuotaRealBaseMes, currencyFormat);


                 // Create worksheet from array data
                 const ws_resumen_array = createSheetArrayData(`RESUMEN GENERAL ${year} - ${scenarioName}`, resumenHeaders, resumenRows);
                 const ws_resumen = XLSX.utils.aoa_to_sheet(ws_resumen_array);


                  // Apply Formatting to Resumen sheet based on stored row formatInfo
                  // Find the actual start row index for data rows in the sheet
                  const dataStartRowResumen = ws_resumen_array.findIndex(row => Array.isArray(row) && row[0] === resumenHeaders[0]) + 1; // Find the header row, add 1

                 if (dataStartRowResumen > 0) { // Ensure header was found
                     // Iterate through the rows added via addResumenRow helper, NOT raw sheet rows
                     for (let i = 0; i < resumenRows.length; i++) {
                          const rowData = resumenRows[i]; // Row array containing [label, val1, val2, ..., total]
                          const rowInfo = rowData.formatInfo; // Get format info stored by the helper

                           if (rowInfo) { // Proceed only if format info exists for the row
                                // Calculate the corresponding row index in the actual worksheet
                               const sheetRowIndex = dataStartRowResumen + i;

                               // --- Apply format to Monthly Value columns (indices 1 to 12) ---
                                for (let colIndex = 1; colIndex <= 12; colIndex++) {
                                    const cellRef = XLSX.utils.encode_cell({r: sheetRowIndex, c: colIndex}); // Get cell reference (Ene...Dic)
                                     const cell = ws_resumen[cellRef]; // Get cell object


                                    // Only apply format if cell exists AND has a number value
                                    // Also handle nulls being 0 without value appearing
                                    if (cell && typeof cell.v === 'number') {
                                        // Format value based on the rowInfo format
                                         cell.z = rowInfo.format; // Set number format

                                        // Special handling for Percentage format if needed? (raw percentage format doesn't need * 100)
                                        // If rowInfo.format was '0.00%', cell.v would ideally be like 0.05 for 5%.
                                        // Since we are using 'rawPercentageFormat' (e.g. "0.0"), cell.v stores the literal 5.0. This is simpler.

                                        // Ensure cell type is number 'n'
                                         cell.t = 'n';
                                     } else if (cell && cell.v === null && rowInfo.isUFRow) {
                                         // Handle explicit null for UF row where value is only in Jan cell
                                         // No format needed, ensure it's 'z' type stub if desired? Or just leave? Leave as is.
                                     } else if (cell === undefined && rowData[colIndex] !== undefined) {
                                          // Safety check: if cell is undefined but we expected a value based on the array... unlikely.
                                           console.warn(`Expected cell value at R${sheetRowIndex+1}C${colIndex+1} for ${rowData[0]}, but cell object missing.`);
                                     }
                               }

                               // --- Apply format to Annual Total column (index 13) ---
                                // Total column is always at index 1 + 12 = 13 in a 1 + 12 + 1 layout
                              const totalColIndex = 13;
                              const totalCellRef = XLSX.utils.encode_cell({r: sheetRowIndex, c: totalColIndex}); // Get total cell reference
                               const totalCell = ws_resumen[totalCellRef]; // Get total cell object

                              if (totalCell && typeof totalCell.v === 'number') {
                                   totalCell.z = rowInfo.format; // Apply the same format as monthly values (or a specific total format)
                                   // Check if it's a percentage row config, then total needs similar logic (raw%)
                                    if (rowInfo.format === rawPercentageFormat && totalCell.v !== 0) { // Apply raw percentage format
                                         totalCell.z = rawPercentageFormat;
                                    } else {
                                         // Default to currency for other calculated rows, even if config line was percentage.
                                          // e.g., Fondo Reserva Config is %, but Fondo Reserva Calculated Total is $.
                                         if (rowData[0].includes("Calculado ($)") || rowData[0].includes("TOTAL ") || rowData[0].includes("Cuota ") || rowData[0].includes("Fondo Reserva Calculado ($)")) {
                                              totalCell.z = currencyFormat; // Ensure calculated totals are currency
                                          } else if (rowData[0].includes("Unidades Funcionales")) {
                                               totalCell.z = numberFormat; // Ensure UF total is number
                                          } else {
                                             totalCell.z = currencyFormat; // Default to currency if unsure
                                          }
                                    }

                                   totalCell.t = 'n'; // Ensure cell type is number
                               } else if (rowInfo.isUFRow && totalCell && typeof totalCell.v === 'number') {
                                   // Special handling for the UF row's annual total cell
                                    totalCell.z = numberFormat; // Ensure number format
                                    totalCell.t = 'n';
                               }

                          }
                     }
                 }

                 // Set column widths for the Resumen sheet (Rubro/Concepto col wider)
                 ws_resumen['!cols'] = [{wch:30}, ...Array(12).fill({wch:12}), {wch:14}];

                 XLSX.utils.book_append_sheet(wb, ws_resumen, "Resumen General");


                  // --- Write File ---
                 const filename = `Reporte_Expensas_${year}_${scenarioName.replace(/\s+/g, '_')}.xlsx`;
                 XLSX.writeFile(wb, filename); // Use XLSX.writeFile to trigger download
                 showSnackbar("Reporte Excel generado.", false, 'success');

             } catch (error) {
                  console.error("Error exportando a Excel:", error);
                  showSnackbar(`Error al generar Excel: ${error.message}`, true, 'error');
             }
        }


        // Exports a chart to a PNG image file
        function exportChart(canvasId, filename) {
             const canvas = document.getElementById(canvasId);
             // Check if canvas exists and has getContext method (basic canvas check)
             if (!canvas || typeof canvas.getContext !== 'function') {
                  showSnackbar(`Elemento de gráfico "${canvasId}" no encontrado.`, true, 'warning');
                 return;
             }
             const chartInstance = window[`${canvasId}_instance`];
             // Check if Chart.js instance exists and has data. Also check if data is non-empty.
              const hasData = chartInstance && chartInstance.data && chartInstance.data.datasets?.length > 0 && chartInstance.data.datasets[0].data?.some(v => v !== null && v !== undefined && v !== 0);

             if (!hasData) {
                  showSnackbar(`Gráfico "${canvasId}" no tiene datos para exportar.`, true, 'warning');
                 return;
             }
             try {
                 // Force a re-render *without* animation for cleaner export image
                 if(chartInstance) chartInstance.update('none');

                 // Allow a small delay for the canvas to potentially update internally
                 requestAnimationFrame(() => {
                     // Use a second requestAnimationFrame for robustness across different browsers/Chart.js versions
                    requestAnimationFrame(() => {
                         const imageURL = canvas.toDataURL('image/png'); // Get data URL as PNG

                         const link = document.createElement('a'); // Create a temporary link element
                         link.href = imageURL; // Set the href to the image data URL
                         link.download = filename; // Set the download filename

                         // Programmatically click the link to trigger download
                         document.body.appendChild(link); // Append to body needed for Firefox
                         link.click(); // Simulate click
                         document.body.removeChild(link); // Clean up the temporary element

                         showSnackbar(`Gráfico "${filename}" exportado como PNG.`, false, 'success');
                     });
                 });

             } catch (e) {
                 console.error(`Error exporting chart "${canvasId}":`, e);
                 showSnackbar(`Error al exportar gráfico: ${e.message}`, true, 'error');
             }
        }


        // --- Utilidades ---

        // Formats a number as currency ($ 0.00)
        function formatCurrency(value) {
             const num = Number(value); // Ensure value is treated as a number
             if (isNaN(num)) return "$ 0,00"; // Return default string for invalid numbers
             // Use 'es-AR' locale for Argentinian Peso formatting (includes $ and commas/dots)
             // Specify currency 'ARS' to ensure correct symbol behavior
             return num.toLocaleString('es-AR', { style: 'currency', currency: 'ARS', minimumFractionDigits: 2, maximumFractionDigits: 2 });
        }

         // Formats a number as a percentage (0.0%)
         function formatPercentage(value) {
             const num = Number(value); // Ensure value is treated as a number
             if (isNaN(num)) return "0,0%"; // Return default string for invalid numbers
              // Format as a percentage, use 'es-AR' for locale decimal/thousands separators if any, though not typically for percentage display
             // Ensure at least one decimal place as per example
             return `${num.toLocaleString('es-AR', { minimumFractionDigits: 1, maximumFractionDigits: 1 })}%`;
         }


         // Converts a hex color string to an RGBA string
        function hexToRgba(hex, alpha) {
            const sanitizeHex = String(hex).trim().replace('#', '');
            // Validate hex format (3 or 6 characters, 0-9a-f)
            if (!/^[0-9a-f]{3}([0-9a-f]{3})?$/i.test(sanitizeHex)) {
                 console.warn(`Invalid hex color format: "${hex}". Using fallback black with alpha.`);
                return `rgba(0,0,0,${alpha})`; // Fallback black
            }
             let fullHex = sanitizeHex;
            // Expand shorthand hex (e.g., "03F" -> "0033FF")
            if (fullHex.length === 3) {
                 fullHex = fullHex[0]+fullHex[0] + fullHex[1]+fullHex[1] + fullHex[2]+fullHex[2];
             }

            // Parse hex segments into RGB integers
            const r = parseInt(fullHex.substring(0,2), 16);
            const g = parseInt(fullHex.substring(2,4), 16);
            const b = parseInt(fullHex.substring(4,6), 16);

            // Return RGBA string
            // Check if parsed components are valid numbers (should be if hex was valid)
            return (isNaN(r) || isNaN(g) || isNaN(b)) ? `rgba(0,0,0,${alpha})` : `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }


         // Utility function to safely toggle tab content and highlight tab links.
         // Also handles specific actions needed when showing certain tabs (like resizing charts).
        function openTab(evt, tabName) {
            // Hide all tab content
             document.querySelectorAll(".tab-content").forEach(content => {
                content.classList.remove("active"); // Remove active class
                 content.style.display = "none"; // Hide element
            });

            // Remove active class from all tab links
            document.querySelectorAll(".tab-link").forEach(link => {
                link.classList.remove("active");
            });

            // Show the selected tab content
            const tabToShow = document.getElementById(tabName);
            if(tabToShow) {
                 tabToShow.style.display = "block";
                 // Force a reflow (recalculation of styles and layout) before animation
                  void tabToShow.offsetWidth;
                 tabToShow.classList.add("active"); // Add active class (triggers fadeIn animation if defined)
            } else {
                console.error(`Tab content element not found for tab name: ${tabName}`);
            }

            // Add active class to the clicked tab link
            if(evt?.currentTarget) { // Check if event and target exist
                evt.currentTarget.classList.add("active");
            } else {
                 console.warn(`Event or currentTarget missing for openTab(${tabName}). Could not highlight tab link.`);
                 // Fallback: Find the link by tabName if possible (assuming naming convention)
                 const fallbackLink = document.querySelector(`.tab-link[onclick*="'${tabName}'"]`);
                  if (fallbackLink) fallbackLink.classList.add('active');
            }


            // Special handling for specific tabs upon opening
            if (tabName === 'dashboard') { // If showing the dashboard tab (charts)
                // Use requestAnimationFrame for slightly deferred chart updates/resizes.
                // This allows the browser to finish displaying the tab content.
                 requestAnimationFrame(() => {
                     // Use a second rAF for better reliability
                     requestAnimationFrame(() => {
                         // Resize and potentially update each chart instance if it exists
                       ['evolutivoCuotaChart', 'participacionGastosChart', 'participacionIngresosChart'].forEach(id => {
                           const chart = window[`${id}_instance`]; // Get chart instance reference
                           if (chart && typeof chart.resize === 'function') {
                                // Resize chart to fit its container
                                chart.resize();

                                // After resizing, trigger an update to ensure rendering correctness (e.g., legend position, tooltip placement)
                                // Check if the chart actually has data before calling update (empty charts shouldn't need update?)
                                 const hasChartData = chart.data?.datasets?.length > 0 && chart.data.datasets[0].data?.some(v => v !== null && v !== undefined && v !== 0);
                                 if(hasChartData) {
                                      chart.update('none'); // Use 'none' animation for updates triggered by UI state changes
                                 }
                                // The 'no-data' message visibility is handled by updateCharts initially,
                                // and potentially re-checked after resize by updateCharts being called after calculation.

                           } else {
                              // If chart instance doesn't exist, ensure the no-data message is displayed.
                              displayChartNoData(id, true); // explicit true to show
                              // Ensure the container doesn't have the 'no-data' class *while data exists* - redundant if updateCharts always runs after calculateAll?
                           }
                       }); // End forEach chart id
                   }); // End second rAF
                 }); // End first rAF

            } else if (tabName === 'settings') {
                 // When navigating TO settings, ensure the coefficient editor is displayed for the currently selected type.
                 // This is handled by updateSettingsPanel(), which runs whenever state/UI updates.
                 // Explicitly calling updateSettingsPanel here might be redundant if calculateAll (or updateUI which calls it) just finished,
                 // but is safer if tab is opened directly without state changes. Let's rely on updateUI on page load/data load.
                 // No extra action needed here just for opening settings.
            } else {
                 // For other tabs, no special resize/update needed.
            }
        }


        // Shows a temporary notification bar at the bottom
        function showSnackbar(message, isError = false, level = null, duration = 4000) {
             const snackbar = document.getElementById('snackbar');
             if (!snackbar) return; // Cannot show snackbar if element not found

             // Determine the color/style level of the snackbar
             let effectiveLevel = level; // Start with explicit level if provided
              if (effectiveLevel === null) { // If no explicit level, use error/success based on isError flag
                   effectiveLevel = isError ? 'error' : 'success';
              }
             // If still null (e.g., isError is false and level was null), default to 'info' or 'success'
              effectiveLevel = effectiveLevel ?? 'success';


             snackbar.textContent = message; // Set message text

             // Remove all level classes to reset appearance
             snackbar.classList.remove('show', 'error', 'warning', 'info', 'success'); // List all possible levels


             // Add the determined level class and the base 'show' class to make it visible
             snackbar.classList.add('show', effectiveLevel);


             // Clear any previously set timer to avoid multiple overlapping snackbars
             if (snackbar.timer) clearTimeout(snackbar.timer);

             // Set a new timer to automatically hide the snackbar after the duration
             snackbar.timer = setTimeout(() => {
                 snackbar.classList.remove('show'); // Remove 'show' class to hide the snackbar
                 snackbar.timer = null; // Clear the timer reference
             }, duration);
        }


        // --- Theme Toggle Logic ---
        function initTheme() {
            // Read theme preference from localStorage
            const savedTheme = localStorage.getItem('theme');
            // Check user's system preference for dark mode
            const prefersDark = window.matchMedia?.('(prefers-color-scheme: dark)').matches ?? false; // Default to false if matchMedia is not supported

            // Determine initial darkMode state:
            // 1. Explicitly 'dark' saved in localStorage.
            // 2. No saved theme, and system preference is dark.
            // 3. Otherwise, default to light.
            appState.darkMode = (savedTheme === 'dark') || (!savedTheme && prefersDark);

            console.log(`Initializing theme. Saved: "${savedTheme}", SystemPref: ${prefersDark}, Setting darkMode: ${appState.darkMode}`);

            // Apply the determined theme to the document body immediately, without animation
            applyTheme(false);


            // Add a listener for system theme preference changes
            window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                 // ONLY follow system preference if no explicit theme is saved in localStorage.
                 // If a theme is saved, the user has explicitly chosen, and we stick to that choice.
                 const currentSavedTheme = localStorage.getItem('theme'); // Re-read in case it changed since init
                 if (!currentSavedTheme) {
                    console.log(`System theme preference changed (no saved preference). Applying theme accordingly.`);
                    appState.darkMode = event.matches; // event.matches is true if dark mode is preferred
                    applyTheme(); // Apply the new theme (triggers update, including chart colors)
                    saveState(); // Save the updated (implicit) preference to state (though localStorage isn't updated here as there's no explicit choice)
                 } else {
                     console.log(`System theme preference changed, but explicit theme "${currentSavedTheme}" is saved. Ignoring system preference.`);
                 }
            });
        }

        // Toggles the theme state between dark and light
        function toggleTheme() {
             // Flip the boolean state
            appState.darkMode = !appState.darkMode;

            // Save the new explicit preference to localStorage
            localStorage.setItem('theme', appState.darkMode ? 'dark' : 'light');
             console.log(`Toggled theme to ${appState.darkMode ? 'dark' : 'light'}. Saved to localStorage.`);

            // Apply the new theme to the UI and update charts
            applyTheme();

            // Save the updated theme state in the application's overall state
            saveState();
        }

        // Applies the current theme from appState.darkMode to the UI
        function applyTheme(updateCharts = true){
             const body = document.body;
             const toggleButton = document.getElementById('theme-toggle'); // The button that changes icon

            // Toggle the 'dark-mode' class on the body based on the state
            body.classList.toggle('dark-mode', appState.darkMode);


            // Update the toggle button icon and title based on the state
             if (toggleButton) {
                 toggleButton.innerHTML = appState.darkMode ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>'; // Sun for dark mode, Moon for light
                 toggleButton.title = appState.darkMode ? 'Cambiar a tema claro' : 'Cambiar a tema oscuro';
            } else {
                 console.warn("Theme toggle button not found.");
             }

            // Update chart colors IF charts exist and are rendered (not on initial page load before they are created)
             if (updateCharts) {
                  console.log("Applying theme updates to charts...");
                 // Use requestAnimationFrame to ensure DOM update is potentially painted before chart re-rendering
                 requestAnimationFrame(() => {
                    // Use another rAF for robustness with chart repaints
                    requestAnimationFrame(() => {
                         // Get dynamic colors after dark/light class is applied to body
                        const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
                        const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();

                        // Update Chart.js default global colors
                        Chart.defaults.color = textColor;
                        Chart.defaults.borderColor = borderColor;

                         // Update existing chart instances individually
                       ['evolutivoCuotaChart', 'participacionGastosChart', 'participacionIngresosChart'].forEach(id => {
                            const chart = window[`${id}_instance`];
                             // Check if the chart instance exists
                            if (chart) {
                                 // Trigger a chart update without animation to pick up new colors and redrawn elements
                                chart.update('none'); // Use 'none' animation
                            }
                       }); // End forEach chart id
                    }); // End second rAF
                 }); // End first rAF
            }
        }


        // --- Persistencia (localStorage) ---

        // Saves the relevant application state to localStorage.
        function saveState() {
             try {
                 // Create a state object containing data structure that should be persisted
                 // Exclude transient UI state (like which coefficient is being edited)
                 const stateToSave = {
                     currentYear: appState.currentYear,
                     scenarios: appState.scenarios,
                     activeScenarioKey: appState.activeScenarioKey,
                     settings: appState.settings, // Global settings including rubros, configs, coefficient types
                     darkMode: appState.darkMode, // Dark mode preference
                     // Add other top-level persistent state properties here if needed in future
                 };
                 // Convert the state object to a JSON string and store it using the unique STORAGE_KEY
                 localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
                 // console.log("Estado guardado exitosamente.");
             } catch (e) {
                 // Log any errors during the saving process
                 console.error("Error guardando estado:", e);
                 showSnackbar("Error al guardar estado en el navegador.", true, 'error');
             }
         }

        // Loads state from localStorage based on the current STORAGE_KEY.
        // Performs data migration and structure validation.
        function loadState() {
             try {
                 const savedStateJson = localStorage.getItem(STORAGE_KEY); // Get JSON string from localStorage

                 if (savedStateJson) {
                     // If data found, parse it into an object
                     const loadedState = JSON.parse(savedStateJson);
                     console.log(`Estado ${STORAGE_KEY} cargado. Validando y migrando si es necesario...`, loadedState);

                      // --- Perform Migration and Validation ---
                      // This function modifies the loadedState object directly if inconsistencies or old formats are found
                      // It also adds default structures (like Coefficient Types or Base Scenario) if they are missing entirely
                      const stateChangedDuringMigrationOrValidation = migrateState(loadedState);
                       // validateAndSetActiveScenario handles ensuring activeKey is valid and syncs currentYear after load/migration

                     // --- Apply Loaded/Migrated State ---
                     // Merge the (potentially migrated/corrected) loaded state into the current default appState.
                     // Use deepMerge to handle nested objects and arrays correctly.
                      // Start with a fresh default state pattern for any properties *not* covered by migration.
                     appState = deepMerge(getDefaultAppState(), loadedState);
                     console.log("Estado cargado y migrado (si aplicó). AppState final:", appState);

                      // validateAndSetActiveScenario needs to run *after* deepMerge assigns scenarios object
                      // This is called later in DOMContentLoaded initialization sequence

                      // Re-save if any changes were made during migration/validation itself
                       // validateAndSetActiveScenario saves state at the end of its process.
                       // No explicit save here unless strictly necessary before validate runs.

                 } else {
                     // If no saved state found for this key, use the default application state structure
                     console.log(`No hay estado guardado para ${STORAGE_KEY}. Usando estado por defecto.`);
                     appState = getDefaultAppState(); // Use default state structure (already includes default settings)

                     // The subsequent validateAndSetActiveScenario call will handle creating the initial Base scenario and setting activeKey/currentYear.
                 }

             } catch (e) {
                 // Handle errors during loading or initial parsing/migration
                 console.error("Error cargando estado:", e);
                 showSnackbar("Error al cargar estado guardado. Se usará configuración por defecto.", true, 'error', 8000);

                 // If loading fails, reset to default state
                 appState = getDefaultAppState(); // Reset to clean default state
                 // The subsequent validateAndSetActiveScenario call will create a Base scenario.
             }
             // At the end of loadState, appState holds either the loaded/migrated state or the default state.
             // validation/scenario selection happens NEXT in the DOMContentLoaded chain.
         }

        // Recursive helper function for deep merging objects. Used during state loading.
         // Merges properties from `source` into `target`. Creates copies of arrays.
        function deepMerge(target, source) {
             // Ensure both target and source are objects, otherwise return a copy of source (or source itself if non-object)
             if (!isObject(target) || !isObject(source)) {
                 // If source is an object or array, make a deep copy. Otherwise return the primitive value directly.
                  if (isObject(source) || Array.isArray(source)) {
                       try { return JSON.parse(JSON.stringify(source)); }
                       catch (e) { console.error("DeepMerge failed to deep copy non-object/array:", source, e); return source; } // Return source if cloning fails
                  }
                 return source !== undefined ? source : target; // If source is a primitive, prefer source if it's not undefined, else use target.
             }

             const output = { ...target }; // Start with a shallow copy of the target object

             // Iterate over keys in the source object
             Object.keys(source).forEach(key => {
                 const targetValue = target[key]; // Value in the target object
                 const sourceValue = source[key]; // Value in the source object

                 if (key === 'uiState') {
                      // Special case: uiState should NOT be deep merged, source simply overwrites (or prefer default parts?)
                      // Let's handle uiState defaulting in getDefaultAppState. Merging risks keeping stale UI state.
                      // Just assign the source value if it exists, otherwise leave the target value.
                       output[key] = sourceValue !== undefined ? sourceValue : targetValue;
                       return; // Skip recursive merge for uiState
                 }


                 // Check if both source and target values are objects (and not arrays)
                 if (isObject(sourceValue) && isObject(targetValue)) {
                     // If both are objects, recursively deep merge them
                     output[key] = deepMerge(targetValue, sourceValue);
                 }
                 // Check if both source and target values are arrays
                 else if (Array.isArray(sourceValue) && Array.isArray(targetValue)) {
                      // Array merge: Use a deep copy of the source array to replace the target array.
                     // This avoids modifying the source array and prevents target elements being left if source is shorter.
                       try { output[key] = JSON.parse(JSON.stringify(sourceValue)); }
                       catch (e) { console.error(`DeepMerge failed to copy array for key "${key}".`, sourceValue, e); output[key] = targetValue; } // Keep target array if source array copy fails
                 }
                 // Check if source value is an array while target is not (or vice versa)
                  else if (Array.isArray(sourceValue) && !Array.isArray(targetValue) || !Array.isArray(sourceValue) && Array.isArray(targetValue)) {
                       // If types are incompatible, log a warning and replace the target value with a deep copy of the source value (if source is object/array) or the source value itself
                       console.warn(`DeepMerge: Incompatible types for key "${key}". Overwriting.`);
                       try {
                            if (isObject(sourceValue) || Array.isArray(sourceValue)) output[key] = JSON.parse(JSON.stringify(sourceValue));
                           else output[key] = sourceValue;
                       } catch(e) {
                            console.error(`DeepMerge failed to copy value for key "${key}".`, sourceValue, e);
                             output[key] = targetValue; // Keep target value if source copy fails
                       }
                 }
                 // If source value is null or undefined, and target value exists, prefer target
                  else if (sourceValue === null && targetValue !== undefined && targetValue !== null) {
                      // console.log(`DeepMerge: Preferring target's non-null/undefined value for key "${key}"`);
                      output[key] = targetValue;
                  }
                 // If none of the above, simply assign the source value to the output
                 // This handles primitives, null/undefined source replacing undefined target, and source replacing null target.
                 else {
                      // Prefer source value UNLESS it's undefined and target is defined.
                       // The spread syntax {...target} already handled leaving target values where source is undefined.
                       // So this final case is really just `output[key] = sourceValue;`
                       output[key] = sourceValue; // Direct assignment handles primitives and null/undefined correctly
                 }
             });

             return output; // Return the merged object
         }

         // Helper function to check if a value is an object (and not null or an array)
        function isObject(item) {
             return (item && typeof item === 'object' && !Array.isArray(item));
        }

        // Provides the initial structure of the appState, including default settings.
        // This is the "clean slate".
        function getDefaultAppState() {
            const defaultYear = new Date().getFullYear();
            // Define the structure here. Use JSON stringify/parse later if a deep copy is needed from this template.
            const defaultStateTemplate = {
                 // General State
                 currentYear: defaultYear,
                 activeScenarioKey: null, // Will be set by validation logic after load
                 darkMode: false, // Default theme

                 // All Scenarios data keyed by `${year}_${scenarioName}`
                 scenarios: {
                     // Example scenario structure (will be deleted/replaced on load if data exists, but provides template)
                     BaseExample: { // This key is just a template, not meant to be in the final scenarios object initially
                        year: defaultYear,
                        scenarioName: 'Base Example', // Placeholder name
                        rubroOrder: { gastos: [], ingresos: [] }, // Array of rubro keys for display order
                        data: { // Raw/Input/Projected monthly data by rubro and detail
                             gastos: {}, // Keyed by rubro name -> { detailOrder: [], detailsData: { detailName: [val, val, ...12], ... } }
                             ingresos: {}, // Keyed by rubro name -> { detailOrder: [], detailsData: { detailName: [val, val, ...12], ... } }
                        },
                        monthStatus: { // Status flags for expense details ('REAL' or 'Estimado')
                            gastos: {}, // Keyed by rubro name -> { detailName: ['REAL', 'Estimado', ...12], ... }
                             ingresos: {}, // Month status currently not used/populated for ingresos details
                        },
                        reserveFund: { type: 'percent', values: Array(12).fill(5) }, // Fondo reserva config (percent or fixed, monthly values)

                        calculated: { // Monthly/Annual calculated results
                             gastoAjustado: {}, // Stores final values used for summing totals after projection (should be same as data.gastos after recalculateEstimates)
                            totalGastoRubroMes: {}, // Sum of gastoAjustado details per rubro per month
                            totalGastoProyectadoMes: Array(12).fill(0), // Sum of all totalGastoRubroMes

                             ingresoAjustado: {}, // Stores BASE income values from Excel for detail table display
                            totalIngresoRubroMes: {}, // Stores FINAL calculated income value (base value sums + UF multiplication for special rubros)
                            totalIngresoProyectadoMes: Array(12).fill(0), // Sum of all totalIngresoRubroMes

                            fondoReservaMes: Array(12).fill(0), // Monthly calculated reserve amount

                            cuotaSobreGastosMes: Array(12).fill(0), // Monthly (Total Gasto + Fondo) / UF

                            ipcManual: Array(12).fill(0), // Snapshot of IPC % values from settings *when calculateAll ran*

                            cuotaIpcMes: Array(12).fill(0), // Monthly (Expensa Real Enero / UF) * cumulative IPC ref

                            cuotaRealBaseMes: Array(12).fill(0), // Monthly (Expensa Ordinaria Rubro Total Final) / UF

                             annualTotals: { // Sum of calculated monthly values
                                 gastos: {__TOTAL__:0}, // Total of totalGastoProyectadoMes
                                 ingresos: {__TOTAL__:0}, // Total of totalIngresoProyectadoMes
                                 fondoReserva: 0, // Total of fondoReservaMes
                                 cuotaSobreGastos: 0, // Total of cuotaSobreGastosMes
                                 cuotaIpc: 0, // Total of cuotaIpcMes
                                 cuotaRealBase: 0 // Total of cuotaRealBaseMes
                             }
                        }
                     }
                 },

                 settings: { // Global settings, apply to all scenarios (quantityUnits, rubros, coef types, rubro config)
                     quantityUnits: 100, // Total number of Functional Units (UF)

                     // List of defined rubro names by type (used for display order in config/dropdowns, filter calc/tables)
                     rubros: { gastos: [], ingresos: [] },

                      // Configuration specific to each rubro (assigned coefficient, collapsed state)
                     rubroConfig: {
                         // Keyed by rubro name -> { coefficientType: 'CoefKey', detailsCollapsed: boolean }
                         // Example: "Seguridad": { coefficientType: "IPC", detailsCollapsed: true }
                     },

                      // Definitions of coefficient types and their monthly percentage values
                     coefficientTypes: {
                         "None": { name: "Sin Coeficiente", values: Array(12).fill(0), isDefault: true }, // Multiplier is 1 (1 + 0/100)
                         "IPC": { name: "IPC", values: [5, 4, 6, 3, 4, 5, 3, 4, 5, 6, 4, 5], isDefault: true }, // Example monthly percentages (%)
                         "UTEDYC": { name: "UTEDYC (Ejemplo)", values: [0, 0, 10, 0, 0, 8, 0, 0, 7, 0, 0, 5], isDefault: true }, // Example percentage increases for some months
                         "Sueldos": { name: "Sueldos Generales (Ejemplo)", values: [0, 0, 8, 0, 0, 6, 0, 0, 5, 0, 0, 4], isDefault: false } // Custom type, percentage example
                     },

                     // Old: ipcManual: [5, 4, 6, 3, 4, 5, 3, 4, 5, 6, 4, 5] // Default IPC ref values (%)
                     // This is now part of the "IPC" coefficient type definition
                 },

                 uiState: { // Transient state, not intended for long-term persistence (cleared on reload unless added to saveState)
                    editingCoefficientType: null // Key of the coefficient type currently being edited
                 }
             };

             // Return a deep copy of the template to ensure clean default state
             try { return JSON.parse(JSON.stringify(defaultStateTemplate)); }
             catch (e) {
                  console.error("Failed to deep copy default app state template. Returning potentially unsafe object.", e);
                  return defaultStateTemplate; // Return original object if deep copy fails
             }

        }


    </script>

<!-- Keeping old commented blocks just in case for reference during development, but these are likely obsolete -->
<!-- Toggle Rubros -->
<script>
// Old Toggle Rubros script - The main script now uses event delegation for this
// This block is likely vestigial.
/*
// Note: This section seems to be remnants of an older toggle implementation.
// The current toggle logic uses event delegation on the table rows themselves
// via addCollapsibleListeners and toggleRubroDetails. Keeping it here
// for now just in case, but it might not be actively used by the main script.
// Consider removing if testing confirms it's unused.
function initRubrosToggle(){
  document.querySelectorAll('.rubro-header').forEach(h=>{
    h.addEventListener('click', ()=> toggleDetail(h));
  });
}
function toggleDetail(header){
  const detail = header.nextElementSibling;
  if(detail){
    detail.classList.toggle('collapsed');
    const icon = header.querySelector('.arrow');
    if(icon) icon.textContent = detail.classList.contains('collapsed') ? '▼' : '▲';
  }
}
// Botones globales
function toggleSection(sectionId, collapse){
  document.querySelectorAll('#'+sectionId+' .rubro-detail').forEach(d=>{
     if(collapse===undefined){
        d.classList.toggle('collapsed');
     }else{
        d.classList.toggle('collapsed', collapse);
     }
  });
  // actualizar iconos
  document.querySelectorAll('#'+sectionId+' .rubro-header .arrow').forEach(i=>{
     const header=i.closest('.rubro-header');
     const det=header.nextElementSibling;
     i.textContent = det.classList.contains('collapsed') ? '▼':'▲';
  });
}
// document.addEventListener('DOMContentLoaded', initRubrosToggle); // This line is likely commented out or should be if not used.
*/
</script>
<!-- End Toggle Rubros -->


<!-- Expensa Real Auto‑Fill v4 -->
<script>
// Old Auto-Fill script for Expensa Real - This functionality is now fully
// integrated into the calculateAll function which computes the value directly
// from the main Ord Expensa rubro and UF count. This block is vestigial and
// could potentially cause issues if uncommented. Keeping it commented out.
/*
// Note: This script seems to be an old attempt to auto-fill the "Expensa Real"
// column based on an old data structure (appState.ingresos).
// The main script now calculates calculated.cuotaRealBaseMes directly from
// scenarioData.data.ingresos[CUOTA_RUBRO_NAME].detailsData, which is more robust.
// This script is likely obsolete and could be removed. It might interfere or
// be redundant. Let's keep it commented out or remove it entirely to avoid confusion.
// The patching part commented out in the previous version reinforces its obsolescence.
// Leave this block commented entirely.
(function(){
  const FULL = ['enero','febrero','marzo','abril','mayo','junio','julio','agosto','septiembre','octubre','noviembre','diciembre'];
  const ABBR = ['ene','feb','mar','abr','may','jun','jul','ago','sep','oct','nov','dic'];

  function findMonthIndex(key){
     key = key.toLowerCase().trim();
     if(key.match(/^m\d+$/)) return parseInt(key.slice(1))-1;
     let idx = FULL.indexOf(key);
     if(idx>-1) return idx;
     idx = ABBR.indexOf(key.slice(0,3));
     return idx;
  }

  function getExpensasRow(){
     // This structure appState.ingresos no longer exists in the current state structure
     // It was likely from a previous version
     if(!window.appState || !appState.ingresos) return null;
     return appState.ingresos.find(r=>{
       const rub=(r.rubro||'').toString().toLowerCase().trim();
       const det=(r.detalle||'').toString().toLowerCase().trim();
       return rub==='expensas' && det==='expensas ordinarias';
     });
  }

  function getMonthlyArray(row){
     const arr = new Array(12).fill(0);
     if(!row) return arr;
     Object.entries(row).forEach(([k,v])=>{
        const idx = findMonthIndex(k);
        if(idx>=0 && idx<12) arr[idx]=Number(v)||0;
     });
     return arr;
  }

  function writeToTable(){
     const table=document.querySelector('#dashboard-summary');
     if(!table) return false;
     // Search for the column index
     let colIdx = -1;
     const headers = table.querySelectorAll('thead th');
     for(let i=0; i < headers.length; i++){
        if (headers[i].textContent.toLowerCase().includes('expensa real ($/uf)')) {
           colIdx = i;
           break;
        }
        if (headers[i].textContent.toLowerCase().includes('expensa real ($)')) { // Fallback to older name
            colIdx = i;
            break;
        }
     }

     if(colIdx === -1) {
         // console.warn("Expensa Real column not found in summary table header.");
         return false; // Column not found
     }


     const rows=table.querySelectorAll('tbody tr');
     if(rows.length < 12) {
         // console.warn("Summary table tbody doesn't have 12 rows yet.");
         return false; // Table not fully populated yet
     }

     // This part relies on the old data structure and function, which is no longer used.
     // The main calculateAll already populates the cuotaRealBaseMes and updates the summary table correctly.
     // So, the data obtained here would likely be from the old, defunct structure.
     // Calling this part would try to write potentially incorrect/stale data.
     // const data=getMonthlyArray(getExpensasRow());
     // if(data.every(v => v === 0)){
         // console.log("Old Expensa Real data is all zeros, likely not populated in old structure.");
         // return true; // Found column, but no data in old structure, assume modern code will handle
     // }

     // const fmt=new Intl.NumberFormat('es-AR',{style:'currency',currency:'ARS',minimumFractionDigits:2});
     // data.forEach((val,i)=>{
         // If the cell *already* has content (meaning the main script populated it), don't overwrite.
     //    if(i < rows.length && rows[i].children[colIdx].textContent.trim() === formatCurrency(0).trim()){ // Only overwrite if cell is effectively $0.00
     //       rows[i].children[colIdx].textContent=fmt.format(val);
     //    }
     // });

     return true; // Indicate that the column was found
  }

  // function waitAndWrite(attempt=0){
  //    if(writeToTable()) return; // Stop waiting once column is found
  //    if(attempt<20) setTimeout(()=>waitAndWrite(attempt+1),300); // Retry for a few seconds
  // }

  // The patching functions (patching handleFileUpload, cargarEscenario) are also obsolete
  // as they rely on the old flow. Remove or leave commented. Keeping commented for history.

  // Instead of patching or trying to run writeToTable manually, this entire block
  // related to auto-filling the old Expensa Real from an old structure should be removed.
  // The functionality is replaced by calculateAll populating calculated.cuotaRealBaseMes
  // which is then displayed correctly by updateDashboardTables.
  // If the column is still not colored correctly after this v2.7 update, the CSS or
  // updateDashboardTables logic for colors might need refinement, NOT adding back old auto-fill.
})();
*/
</script>

</body>
</html>