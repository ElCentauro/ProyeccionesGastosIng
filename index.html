
No puedo generar un link de descarga directa para un archivo local desde aquí, ya que mi función es proporcionarte el código en formato de texto.

La forma en que puedes "bajar" el archivo con todo el código corregido es **copiar el código completo** que te he proporcionado y **pegarlo** en un editor de texto simple (como el Bloc de Notas en Windows, TextEdit en macOS, o cualquier editor de código como VS Code, Sublime Text, Notepad++, etc.).

Luego, debes **guardar el archivo con el nombre `index14.html`**. Asegúrate de que el editor no le agregue una extensión adicional como `.txt` (si usas Bloc de Notas, selecciona "Todos los archivos" como tipo de archivo y escribe `index14.html` entre comillas `""`).

Así, tendrás el archivo HTML listo para abrirlo directamente en tu navegador web.

Te proporciono el código completo nuevamente para que puedas copiarlo fácilmente:

--- START OF FILE index14.html ---

```html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="favicon.png">
    <title>Proyección Expensas - Barrio El Centauro</title>
    <!-- Librería SheetJS (js-xlsx) para leer/escribir Excel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Librería Chart.js para gráficos -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- Plugin doughnut 3D shadow -->
<script>
/* Plugin: doughnutShadow3D
   Añade una sombra suave debajo de cada porción para simular profundidad 3 D.
   Seguro para todos los datasets (evita NaN en createRadialGradient). */
const doughnutShadow3D = {
  id: 'doughnutShadow3D',
  afterDatasetDraw(chart, args, opts) {
    const {ctx} = chart;
    if (args.meta.type !== 'doughnut') return;

    args.meta.data.forEach(segment => {
      const {x, y, startAngle, endAngle, innerRadius, outerRadius} = segment;
      // Ensure numeric validity before attempting to draw
      if (!isFinite(x) || !isFinite(y) || !isFinite(startAngle) || !isFinite(endAngle) || !isFinite(innerRadius) || !isFinite(outerRadius)) {
          console.warn("Skipping shadow for segment due to invalid dimensions:", segment);
          return;
      }

      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.15)';      // shadow color
      ctx.translate(0, 4);                     // vertical offset
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.arc(x, y, outerRadius, startAngle, endAngle);
      ctx.arc(x, y, innerRadius, endAngle, startAngle, true);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    });
  }
};
// Registrar plugin globalmente
if (window.Chart && !Chart.registry.plugins.get('doughnutShadow3D')) {
  Chart.register(doughnutShadow3D);
}
</script>

    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts (Inter) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- Reset Básico y Fuentes --- */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        *{ /* Add a smoother color transition to elements not covered by explicit transitions */
            transition-property: background-color, color, border-color, box-shadow, fill, stroke, transform, opacity; /* Added opacity and transform */
            transition-duration: 0.3s;
            transition-timing-function: ease-in-out;
        }
        html { scroll-behavior: smooth; font-size: 16px; /* Base font size */ }
        body {
            font-family: 'Inter', 'Segoe UI', sans-serif;
            line-height: 1.7; /* Improved readability */
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* --- Variables de Color (Paleta Refinada) --- */
        :root {
            --bg-color: #f8f9fa;              /* Slightly off-white */
            --text-color: #343a40;            /* Darker gray */
            --primary-color: #007bff;          /* Classic blue */
            --primary-color-darker: #0056b3;   /* Darker blue for hover */
            --secondary-color: #6c757d;        /* Standard gray */
            --secondary-color-darker: #5a6268; /* Darker gray for hover */
            --accent-color: #28a745;           /* Vibrant green */
            --accent-color-darker: #218838;    /* Darker green for hover */
            --danger-color: #dc3545;           /* Red */
            --danger-color-darker: #c82333;    /* Darker red */
            --warning-color: #ffc107;           /* Yellow */
            --warning-color-darker: #e0a800;   /* Darker yellow */
            --info-color: #17a2b8;             /* Teal */
            --info-color-darker: #138496;      /* Darker teal */
            --success-color: var(--accent-color); /* Alias for consistency */
            --success-color-darker: var(--accent-color-darker); /* Alias */

            --border-color: #dee2e6;           /* Light gray border */
            --header-bg: #ffffff;              /* White header */
            --card-bg: #ffffff;                /* White cards */
            --shadow-color: rgba(0, 0, 0, 0.08); /* Softer shadow */
            --input-bg: #ffffff;
            --input-border: #ced4da;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(0, 123, 255, 0.25);
            --button-text: #ffffff;
            --button-warning-text: #212529; /* Dark text for yellow button */
            --table-header-bg: #eef2f7;        /* Lighter table header */
            --table-row-hover: #f1f3f5;        /* Subtle hover */
            --expandable-row-bg: #f8f9fa;      /* Same as body bg for subtle diff */
            --clickable-row-hover: #e9ecef;    /* Slightly darker hover for clickable rows */
            --disabled-bg: #e9ecef;
            --disabled-text: #6c757d;
            --disabled-border: #ced4da;

            /* >>> COLORES REAL/ESTIMADO OSCURO <<< */
            --real-month-bg: #1c4a2b; /* Darker Green */
            --estimated-month-bg: #5a4a1d; /* Dark Yellow/Brown */
        }

        body.dark-mode {
            --bg-color: #1a1a1a;              /* Very dark gray */
            --text-color: #e0e0e0;            /* Light gray text */
            --primary-color: #58a6ff;          /* Brighter blue */
            --primary-color-darker: #79b8ff;   /* Lighter blue for hover */
            --secondary-color: #8b949e;        /* Lighter gray */
            --secondary-color-darker: #a0a8b0; /* Lighter gray hover */
            --accent-color: #56d364;           /* Brighter green */
            --accent-color-darker: #6bde7a;    /* Lighter green hover */
            --danger-color: #f85149;           /* Bright red */
            --danger-color-darker: #fa6a61;    /* Lighter red */
            --warning-color: #f0b41e;          /* Bright yellow */
            --warning-color-darker: #f2c037;   /* Lighter yellow */
            --info-color: #6cb6f1;             /* Bright teal */
            --info-color-darker: #85c3f4;      /* Lighter teal */
            --success-color: var(--accent-color);
            --success-color-darker: var(--accent-color-darker);

            --border-color: #444c56;           /* Darker border */
            --header-bg: #2c2c2c;              /* Dark card background */
            --card-bg: #2c2c2c;                /* Dark card background */
            --shadow-color: rgba(255, 255, 255, 0.05); /* Subtle white shadow */
            --input-bg: #3a3f44;
            --input-border: #5a6268;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(88, 166, 255, 0.25);
            --button-text: #1a1a1a; /* Dark text on bright buttons */
            --button-warning-text: #1a1a1a;
            --table-header-bg: #343a40;        /* Darker header */
            --table-row-hover: #3e444a;        /* Subtle dark hover */
            --expandable-row-bg: #343a40;      /* Darker expandable row bg */
            --clickable-row-hover: #495057;    /* Darker hover for clickable */
            --disabled-bg: #495057;
            --disabled-text: #adb5bd;
            --disabled-border: #5a6268;

            /* >>> COLORES REAL/ESTIMADO OSCURO <<< */
            --real-month-bg: #1c4a2b; /* Darker Green */
            --estimated-month-bg: #5a4a1d; /* Dark Yellow/Brown */
        }

        /* --- Estilos Generales --- */


        h1, h2, h3, h4 { color: var(--primary-color); margin-bottom: 1em; font-weight: 600; }
        h1 { font-size: 2.2rem; text-align: center; }
        h2 { font-size: 1.8rem; border-bottom: 2px solid var(--accent-color); padding-bottom: 0.4em; }
        h3 { font-size: 1.4rem; margin-top: 1.8em; }
        h4 { font-size: 1.15rem; color: var(--secondary-color); margin-top: 1.2em; margin-bottom: 0.6em; }
        a { color: var(--primary-color); text-decoration: none; transition: color 0.2s ease; }
        a:hover { color: var(--primary-color-darker); text-decoration: underline; }

        button {
            padding: 12px 22px;
            border: 1px solid transparent; /* Added border for consistency */
            border-radius: 6px;
            background-color: var(--primary-color);
            color: var(--button-text);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition-property: background-color, border-color, transform, box-shadow, opacity; /* Added transition property explicitly */
            transition-duration: 0.2s;
            transition-timing-function: ease-in-out;
            display: inline-flex;
            align-items: center;
            justify-content: center; /* Center content */
            gap: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            line-height: 1.5; /* Ensure consistent height */
            text-align: center; /* Ensure text aligns center */
        }
        button:hover {
            background-color: var(--primary-color-darker);
            border-color: var(--primary-color-darker);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        button:focus {
            outline: none;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        button:disabled {
            background-color: var(--disabled-bg);
            color: var(--disabled-text);
            border-color: var(--disabled-border);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
            opacity: 0.7; /* Visually indicate disabled state */
        }
        button i { margin-right: 2px; /* Keep small margin */ }

        /* Button variants */
        .button-primary { background-color: var(--primary-color); border-color: var(--primary-color); color: var(--button-text); }
        .button-primary:hover { background-color: var(--primary-color-darker); border-color: var(--primary-color-darker); }
        .button-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: var(--button-text); }
        .button-secondary:hover { background-color: var(--secondary-color-darker); border-color: var(--secondary-color-darker); }
        .button-success { background-color: var(--success-color); border-color: var(--success-color); color: var(--button-text); }
        .button-success:hover { background-color: var(--success-color-darker); border-color: var(--success-color-darker); }
        .button-danger { background-color: var(--danger-color); border-color: var(--danger-color); color: var(--button-text); }
        .button-danger:hover { background-color: var(--danger-color-darker); border-color: var(--danger-color-darker); }
        .button-warning { background-color: var(--warning-color); border-color: var(--warning-color); color: var(--button-warning-text); }
        .button-warning:hover { background-color: var(--warning-color-darker); border-color: var(--warning-color-darker); }
        .button-info { background-color: var(--info-color); border-color: var(--info-color); color: var(--button-text); }
        .button-info:hover { background-color: var(--info-color-darker); border-color: var(--info-color-darker); }
        .button-sm { padding: 6px 12px; font-size: 0.85rem; gap: 6px;}
        .button-lg { padding: 15px 30px; font-size: 1.1rem; }


        /* --- Header --- */
        header {
            background-color: var(--header-bg);
            padding: 15px 0;
            box-shadow: 0 2px 5px var(--shadow-color);
            position: sticky; top: 0; z-index: 1000;
            border-bottom: 1px solid var(--border-color);
        }
        header .container { display: flex; justify-content: space-between; align-items: center; padding-top: 0; padding-bottom: 0; }
        .app-title { font-size: 1.6rem; font-weight: 700; color: var(--primary-color); }
        /* Removed transition as '*' covers it */
        #theme-toggle { font-size: 1.3rem; background: none; border: none; color: var(--text-color); cursor: pointer; padding: 5px; border-radius: 50%;}
        #theme-toggle:hover { background-color: var(--table-row-hover); }

        /* --- Navegación / Pestañas --- */
        .tabs {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 5px;
        }
        /* Removed transition from tab-link as '*' covers it */
        .tab-link {
            padding: 12px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-bottom: -1px; /* Overlap bottom border */
            background-color: transparent;
            color: var(--secondary-color);
            font-size: 1rem;
            font-weight: 600;
            border-radius: 6px 6px 0 0;
            display: inline-flex; /* Align icon and text */
            align-items: center;
            gap: 8px;
        }
        .tab-link:hover {
             color: var(--primary-color);
             background-color: var(--table-row-hover);
        }
        .tab-link.active {
            background-color: var(--card-bg);
            border-color: var(--border-color);
            border-bottom-color: var(--card-bg); /* Hide bottom border part */
            color: var(--primary-color);
            font-weight: 700;
        }
        .tab-content {
            display: none;
            padding: 30px;
            border: 1px solid var(--border-color);
            border-top: none;
            background-color: var(--card-bg);
            border-radius: 0 0 6px 6px;
            box-shadow: 0 5px 15px var(--shadow-color);
        }
        .tab-content.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Formularios y Entradas --- */
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-color); font-size: 0.95rem;}
        input[type="text"], input[type="number"], input[type="file"], select, textarea {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid var(--input-border);
            border-radius: 6px;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1rem;
             /* Removed transition as '*' covers it */
        }
        input:focus, select:focus, textarea:focus {
            border-color: var(--input-focus-border);
            outline: 0;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        input:disabled, select:disabled, textarea:disabled {
             background-color: var(--disabled-bg);
             color: var(--disabled-text);
             border-color: var(--disabled-border);
             cursor: not-allowed;
        }
        input[type="number"] { text-align: right; -moz-appearance: textfield; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { margin: 0; }
        input[type="file"] { padding: 8px; line-height: 1.5; } /* Adjust file input padding */
        .input-group { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
        .input-group label { margin-bottom: 0; font-weight: normal;}
        .input-group input[type="radio"] { width: auto; margin-right: 5px; }
        .input-small { width: 150px; display: inline-block; margin-left: 10px; }

        /* --- Tablas --- */
        .table-container { overflow-x: auto; margin-top: 25px; border: 1px solid var(--border-color); border-radius: 6px; }
        table { width: 100%; border-collapse: collapse; background-color: var(--card-bg); font-size: 0.9rem; }
        th, td {
            padding: 12px 15px;
            border: none;
            border-bottom: 1px solid var(--border-color);
            text-align: left;
            vertical-align: middle;
            white-space: nowrap;
        }
        th {
            background-color: var(--table-header-bg);
            font-weight: 600;
            position: sticky; top: 0; z-index: 10;
            border-bottom-width: 2px;
        }
        tbody tr:last-child td { border-bottom: none; }
        /* Use a more specific selector for hover not overriding background colors below */
        tbody tr:hover td { background-color: var(--table-row-hover); }


        /* Cell specific styles */
        /* Target only cells within .collapsible-table .detail-row for coloring */
        .collapsible-table tbody tr.detail-row td.real-month-cell { background-color: var(--real-month-bg); }
        .collapsible-table tbody tr.detail-row td.estimated-month-cell { background-color: var(--estimated-month-bg); }

         /* Handle hover for colored cells more explicitly for detail rows */
        .collapsible-table tbody tr.detail-row:hover td.real-month-cell { background-color: color-mix(in srgb, var(--real-month-bg), var(--table-row-hover) 30%); }
        .collapsible-table tbody tr.detail-row:hover td.estimated-month-cell { background-color: color-mix(in srgb, var(--estimated-month-bg), var(--table-row-hover) 30%); }


        td.number-cell { text-align: right; font-variant-numeric: tabular-nums; }
        /*td.input-cell input { width: 100px; padding: 6px; font-size: 0.9rem; text-align: right; }*/ /* Now using monthly-inputs-grid styles */
        /*td.input-cell input:disabled { background-color: transparent; border: none; color: var(--disabled-text);}*/ /* Now using monthly-inputs-grid styles */
        .text-muted { color: var(--secondary-color); font-style: italic; font-size: 0.9em;}

        /* --- Tablas Desplegables --- */
        /* Removed transition as '*' covers it */
        .collapsible-table tbody tr.rubro-total-row { font-weight: bold; cursor: pointer; background-color: var(--expandable-row-bg); }
        .collapsible-table tbody tr.rubro-total-row:hover { background-color: var(--clickable-row-hover); }
        .collapsible-table tbody tr.rubro-total-row td:first-child::before {
            content: '\f078'; /* fa-chevron-down */
            font-family: 'Font Awesome 6 Free'; font-weight: 900; margin-right: 12px; display: inline-block; transition: transform 0.2s ease-in-out; color: var(--primary-color);
        }
        .collapsible-table tbody tr.rubro-total-row.collapsed td:first-child::before { transform: rotate(-90deg); }
        /* Removed transition as '*' covers it */
        .collapsible-table tbody tr.detail-row { display: table-row; background-color: var(--card-bg); }
        .collapsible-table tbody tr.detail-row.hidden { display: none; }
        .collapsible-table tbody tr.detail-row td { font-size: 0.85rem; color: var(--secondary-color); border-color: var(--border-color); }
        .collapsible-table tbody tr.detail-row td:first-child { padding-left: 40px; /* Indent details more */ }
        body.dark-mode .collapsible-table tbody tr.detail-row { background-color: #353535; }
        .collapsible-table tfoot tr { font-weight: bold; background-color: var(--table-header-bg); border-top: 2px solid var(--border-color); }

         /* Styles for Group/Ungroup All buttons */
        .table-actions {
            margin-bottom: 15px;
             display: flex;
             justify-content: flex-end; /* Align buttons to the right */
             gap: 10px;
             flex-wrap: wrap;
        }


        /* --- Componentes UI Específicos --- */
        #dashboard-summary { border-collapse: separate; border-spacing: 0; }
        #dashboard-summary th, #dashboard-summary td { text-align: center; white-space: normal; }
        #dashboard-summary tbody td, #dashboard-summary tfoot td { padding: 10px 8px; }
        #dashboard-summary .month-header { font-weight: bold; }

        .chart-container {
            margin-top: 35px; padding: 30px;
            background-color: var(--card-bg); border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-color);
            position: relative; min-height: 200px; /* Adjusted min height */
        }
        /* Fixed height needed for chart.js responsive container logic */
        .chart-container canvas { max-width: 100%; height: 380px; display: block;}
        /* Added class to manage canvas display when no data */
        .chart-container.no-data canvas { display: none; }


        .chart-no-data {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--secondary-color);
            font-style: italic; font-size: 1.1rem; text-align: center;
             display: none; /* Hidden by default */
        }
         /* Show no-data message when the container has the 'no-data' class */
         .chart-container.no-data .chart-no-data {
             display: block;
         }


        #file-upload-area {
            border: 2px dashed var(--primary-color);
            padding: 45px; text-align: center; background-color: var(--bg-color);
            border-radius: 8px; margin-bottom: 25px; cursor: pointer; /* Removed transition as '*' covers it */
        }
        #file-upload-area:hover { background-color: var(--table-row-hover); border-color: var(--primary-color-darker); }
        #file-upload-area p { margin-bottom: 15px; font-size: 1.1rem; color: var(--secondary-color); }
        #file-upload-area i.fa-file-excel { font-size: 3rem; margin-bottom: 10px; color: var(--accent-color); }
        #file-upload-feedback { margin-top: 15px; font-weight: bold; white-space: pre-wrap; font-size: 0.95rem; min-height: 2em; }

        #reserve-fund-panel { /* This div is now a monthly-inputs-grid */
            margin-top: 20px;
        }


        .config-section {
            border: 1px solid var(--border-color); border-radius: 8px; padding: 25px;
            margin-bottom: 30px; background-color: var(--card-bg);
            box-shadow: 0 3px 7px var(--shadow-color);
        }
        .config-section h4 { border-bottom: 1px solid var(--border-color); padding-bottom: 0.6em; margin-bottom: 1.2em;}
        .management-list { list-style: none; padding: 0; max-height: 350px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 6px; padding: 10px; background-color: var(--bg-color); }
        body.dark-mode .management-list { background-color: #3a3f44; }
        /* Removed transition from li as '*' covers it */
        .management-list li { display: flex; justify-content: space-between; align-items: center; padding: 10px 8px; border-bottom: 1px solid var(--border-color); }
        .management-list li:last-child { border-bottom: none;}
        .management-list li:hover { background-color: var(--table-row-hover); }
        .management-list li span { flex-grow: 1; margin-right: 15px; font-weight: 500; }
        .management-list li select { width: 200px; font-size: 0.88rem; padding: 6px 8px; flex-shrink: 0; }
        .management-list li button { flex-shrink: 0; }
        #coefficient-editor { margin-top: 25px; }
        #coefficient-editor h4 { margin-bottom: 15px;}
        /* #coefficient-editor .table-container { max-height: 450px; overflow-y: auto;} No longer a table-container directly */

        /* Monthly inputs grid style - Applied to #reserve-fund-panel and #coefficient-values-editor */
        .monthly-inputs-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); /* Adjusted min-width */
            gap: 15px; /* Slightly reduced gap */
            margin-top: 20px;
            padding: 15px; /* Added padding */
            border: 1px solid var(--border-color); /* Added border */
            border-radius: 6px; /* Added border-radius */
            background-color: var(--bg-color); /* Match management list bg */
             /* Removed transition as '*' covers it */
        }
        body.dark-mode .monthly-inputs-grid { background-color: #3a3f44; }

        .monthly-inputs-grid .form-group {
            margin-bottom: 0; /* Remove default form-group margin */
        }
         .monthly-inputs-grid .form-group label {
             margin-bottom: 5px; /* Smaller margin below label */
             font-weight: normal; /* Normal weight label */
         }
        .monthly-inputs-grid .form-group input {
             width: 100%; /* Make input fill grid cell */
             padding: 8px 10px; /* Adjusted padding */
             font-size: 0.9rem; /* Smaller font size */
             text-align: right; /* Align numbers right */
         }
         .monthly-inputs-grid .input-with-unit {
             display: flex;
             align-items: center;
             gap: 5px; /* Gap between input and unit */
         }
         .monthly-inputs-grid .input-with-unit input {
             flex-grow: 1; /* Input takes available space */
         }
         .monthly-inputs-grid .input-with-unit span {
              flex-shrink: 0; /* Unit doesn't shrink */
              font-weight: normal; /* Unit text normal */
         }


        /* --- Snackbar --- */
        #snackbar {
            visibility: hidden; min-width: 300px; max-width: 90%;
            background-color: var(--success-color); /* Default to success */
            color: var(--button-text); text-align: center;
            border-radius: 6px; padding: 18px 25px; position: fixed; z-index: 1001;
            left: 50%; transform: translateX(-50%); bottom: 30px;
            font-size: 1.05rem; font-weight: 500;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            opacity: 0; transition: visibility 0s 0.5s, opacity 0.5s ease-out, bottom 0.5s ease-out, background-color 0.3s; /* Added bg color transition */
        }
        #snackbar.show {
            visibility: visible; opacity: 1; bottom: 60px;
            transition: opacity 0.5s ease-in, bottom 0.5s ease-in, background-color 0.3s;
        }
        #snackbar.error { background-color: var(--danger-color); color: var(--button-text); }
        #snackbar.warning { background-color: var(--warning-color); color: var(--button-warning-text); }
        #snackbar.info { background-color: var(--info-color); color: var(--button-text); }
        #snackbar.success { background-color: var(--success-color); color: var(--button-text); } /* Ensure success explicit */


        /* --- Footer --- */
        footer {
            margin-top: auto; padding: 20px 0; text-align: center; font-size: 0.95em;
            color: var(--secondary-color); background-color: var(--header-bg);
            border-top: 1px solid var(--border-color);
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 1200px) { .container { width: 98%; } .chart-container canvas { height: 320px; } }
        @media (max-width: 992px) {
             h1 { font-size: 2rem; } h2 { font-size: 1.6rem; } h3 { font-size: 1.3rem; }
             .tabs { justify-content: flex-start; }
             .tab-link { padding: 10px 18px; font-size: 0.95rem;}
             table { font-size: 0.88rem; } th,td {padding: 10px 12px;}
             .management-list li select { width: 150px; } /* Reduce select width */
             /* Allow wrapping text in narrow tables */
            th, td { white-space: normal; }
             /* Adjusting cell padding slightly for smaller screens */
             th:first-child, td:first-child { padding-left: 15px; }
             th:last-child, td:last-child { padding-right: 15px; }
             .monthly-inputs-grid { grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; }
             /*td.input-cell input { width: 90%; /* Make input wider inside td */ }
        }
        @media (max-width: 768px) {
            body { line-height: 1.6; }
            .app-title { font-size: 1.3rem;} #theme-toggle { font-size: 1.1rem;}
            .chart-container { padding: 20px;} .chart-container canvas { height: 280px; }
            .input-group { flex-direction: column; align-items: stretch; gap: 10px;}
            .input-small { margin-left: 0; margin-top: 8px; width: 100%; }
            #reserve-fund-panel .month-config { flex-direction: column; align-items: stretch; }
            #reserve-fund-panel .month-config label { width: 100%; text-align: left; margin-bottom: 5px; }
            #reserve-fund-panel .month-config input { width: 100%; }
            table { font-size: 0.85rem; } /*th, td { padding: 9px 8px; white-space: normal; }*/
            th:first_child, td:first_child { padding-left: 15px; }
            th:last_child, td:last_child { padding_right: 15px; }
            /*td.input_cell input { width: 90%; /* Make input wider inside td */ }
            .management_list li { flex-wrap: wrap; gap: 8px; }
            .management_list li span { flex-basis: 100%; margin-right: 0; } /* Name takes full width */
            .management_list li select { width: calc(100% - 50px); margin-top: 5px; } /* Select almost full width */
            .management_list li button { margin-left: auto; } /* Push button right */
            button { font-size: 0.95rem; padding: 10px 18px;}
            .tabs { gap: 2px; }
            .tab_link { padding: 8px 10px; font_size: 0.85rem;}
             .table_actions { justify_content: center; }
             .monthly_inputs_grid { grid_template_columns: repeat(auto_fit, minmax(80px, 1fr)); gap: 8px; padding: 10px; }
              .monthly_inputs_grid .form_group label { margin_bottom: 3px; font_size: 0.9em;}
              .monthly_inputs_grid .form_group input { padding: 6px 8px; font_size: 0.85em;}
        }
        @media (max_width: 576px) {
            h1 { font_size: 1.7rem; } .app_title { display: none; } header .container { justify_content: flex_end; }
            .tab_link { padding: 8px 10px; font_size: 0.85rem;}
            th, td { padding: 8px 6px; }
            th:first_child, td:first_child { padding_left: 10px; }
            th:last_child, td:last_child { padding_right: 10px; }
            .chart_container canvas { height: 220px; }
            #snackbar { min_width: 90%; bottom: 20px; font_size: 1rem; padding: 15px 20px; }
            #snackbar.show { bottom: 40px; }
            #file_upload_area { padding: 30px; }
            .management_list li select { width: 100%; } /* Select full width on smallest screens */
             /* Fix columns on small devices to prevent extreme squeezing */
             .monthly_inputs_grid { grid_template_columns: repeat(3, 1fr); /* Fixed 3 columns */ }
             .monthly_inputs_grid .form_group { width: 100%; /* Ensure form group takes full cell width */ }
             .monthly_inputs_grid .input_with_unit { width: 100%; /* Ensure input group takes full form group width */ }

        }
         @media (max_width: 380px) {
              .monthly_inputs_grid { grid_template_columns: repeat(2, 1fr); /* Fixed 2 columns on very small screens */ }
         }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <span class="app-title">Proyección Expensas - El Centauro</span>
            <button id="theme-toggle" title="Cambiar tema"><i class="fas fa-moon"></i></button>
        </div>
    </header>

    <div class="container">
        <!-- REMOVED onclick attributes from buttons and handle them via JS event listeners -->
        <div class="tabs">
            <!-- Added data-tab-name to identify target tab, handled by delegated click listener in addEventListeners -->
            <button class="tab-link active" data-tab-name="dashboard"><i class="fas fa-tachometer-alt"></i> Dashboard</button>
            <button class="tab-link" data-tab-name="upload"><i class="fas fa-upload"></i> Cargar Datos</button>
            <button class="tab-link" data-tab-name="reserve"><i class="fas fa-piggy-bank"></i> Fondo Reserva</button>
            <button class="tab-link" data-tab-name="settings"><i class="fas fa-cog"></i> Configuración</button>
            <button class="tab-link" data-tab-name="reports"><i class="fas fa-download"></i> Reportes</button>
        </div>

        <!-- ==================== DASHBOARD ==================== -->
        <div id="dashboard" class="tab-content active">
            <h2><i class="fas fa-tachometer-alt"></i> Dashboard Anual - <span id="dashboard-year"></span> (<span id="dashboard-scenario">Base</span>)</h2>
            <div class="form-group input-group">
                <label for="scenario-selector" style="flex-shrink: 0;">Escenario:</label>
                <!-- scenario-selector change handler is added via JS addEventListener -->
                <select id="scenario-selector" style="flex-grow: 1;"></select>
                <!-- REMOVED onclick attributes and added data-action attributes for clarity, handled by JS delegated listener -->
                <button data-action="createScenario" class="button-primary button-sm" title="Crear Escenario Nuevo"><i class="fas fa-plus"></i> Crear</button>
                <button data-action="cloneScenario" class="button-secondary button-sm" title="Clonar Escenario Actual"><i class="fas fa-clone"></i> Clonar</button>
                <button data-action="deleteScenario" class="button-danger button-sm" title="Eliminar Escenario Actual"><i class="fas fa-trash"></i> Eliminar</button>
                <button id="btnBorrarDatos" data-action="clearScenarioData" class="button-warning button-sm" title="Borrar Datos del Escenario Actual (Gastos, Ingresos, Status)"><i class="fas fa-broom"></i> Borrar Datos</button>
                <button data-action="recalculateEstimates" class="button-info button-sm" title="Proyectar meses estimados de gastos basados en último mes real y coeficientes (acumulativo)"><i class="fas fa-calculator"></i> Calcular Estimados</button>
            </div>

            <h4>Resumen Mensual General</h4>
            <div class="table-container">
                <table id="dashboard-summary">
                    <thead>
                        <tr>
                            <th>Mes</th>
                            <th>Gasto ($)</th>
                            <th>Fondo ($)</th>
                            <th>Cuota s/Gs ($/UF)</th> <!-- Basado en Gasto+Fondo / UF -->
                            <th>IPC Ref (%)</th> <!-- Referencia, now from settings.coefficientTypes.IPC snapshot-->
                            <th>Cuota IPC ($/UF)</th>   <!-- Cuota s/Gs base Enero + IPC acumulado -->
                            <th>Expensa Real ($/UF)</th> <!-- Muestra el valor del rubro Expensas Ordinarias / UF -->
                        </tr>
                    </thead>
                    <tbody><!-- Contenido generado por JS --></tbody>
                    <tfoot><!-- Contenido generado por JS --></tfoot>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Detalle de Gastos Proyectados ($)</h4>
             <p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar los detalles. Las celdas mensuales de detalle se colorean según su origen: <span style="background-color: var(--real-month-bg); padding: 1px 4px; border-radius: 3px; border: 1px solid var(--border-color);">REAL</span> (cargado) o <span style="background-color: var(--estimated-month-bg); padding: 1px 4px; border-radius: 3px; border: 1px solid var(--border-color);">ESTIMADO</span> (proyectado/calculado).</p>

            <!-- Added Group/Ungroup Buttons for Gastos, handled by JS data-action -->
            <div class="table-actions">
                 <button data-action="toggleAllGastosDetails" data-collapse="false" class="button-secondary button-sm" title="Expandir todos los detalles de gastos"><i class="fas fa-expand"></i> Expandir Todo</button>
                 <button data-action="toggleAllGastosDetails" data-collapse="true" class="button-secondary button-sm" title="Colapsar todos los detalles de gastos"><i class="fas fa-compress"></i> Colapsar Todo</button>
            </div>

            <div class="table-container">
                <table id="gastos-detail-table" class="collapsible-table">
                     <thead>
                        <tr>
                            <th>Rubro / Detalle</th>
                            <th>Coef. Aplicado</th> <!-- Added Coef Aplicado Header -->
                            <!-- Meses y Total Anual generados por JS -->
                         </tr>
                     </thead>
                     <tbody><!-- Contenido generado por JS --></tbody>
                     <tfoot><!-- Contenido generado por JS --></tfoot>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Detalle de Ingresos Proyectados (Valores Base $)</h4>
             <p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar. Los valores aquí son la base de cálculo (valor individual o por UF) como fueron cargados. El Total de Ingresos en el Resumen General incluye la multiplicación por la Cantidad de UF (definida en Configuración) para los rubros específicos.</p>

             <!-- Added Group/Ungroup Buttons for Ingresos, handled by JS data-action -->
             <div class="table-actions">
                 <button data-action="toggleAllIngresosDetails" data-collapse="false" class="button-secondary button-sm" title="Expandir todos los detalles de ingresos"><i class="fas fa-expand"></i> Expandir Todo</button>
                 <button data-action="toggleAllIngresosDetails" data-collapse="true" class="button-secondary button-sm" title="Colapsar todos los detalles de ingresos"><i class="fas fa-compress"></i> Colapsar Todo</button>
            </div>

            <div class="table-container">
                 <table id="ingresos-detail-table" class="collapsible-table">
                      <thead>
                         <tr>
                            <th>Rubro / Detalle</th>
                             <!-- Meses y Total Anual generados por JS -->
                         </tr>
                       </thead>
                      <tbody><!-- Contenido generado por JS --></tbody>
                      <tfoot><!-- Contenido generado por JS --></tfoot>
                 </table>
            </div>

            <div class="chart-container">
                 <h3>Evolutivo Expensa Mensual ($/UF)</h3>
                 <canvas id="evolutivoCuotaChart"></canvas>
                 <div class="chart-no-data">No hay datos suficientes para graficar.</div>
            </div>

            <div style="display: flex; gap: 25px; flex-wrap: wrap; margin-top: 35px;">
                <div class="chart-container" style="flex: 1; min-width: 320px;">
                    <h3>Participación Gastos (%)</h3>
                    <canvas id="participacionGastosChart"></canvas>
                    <div class="chart-no-data">No hay datos de gastos<br>para mostrar el gráfico.</div>
                </div>
                <div class="chart-container" style="flex: 1; min-width: 320px;">
                    <h3>Participación Ingresos (%)</h3>
                    <canvas id="participacionIngresosChart"></canvas>
                    <div class="chart-no-data">No hay datos de ingresos<br>para mostrar el gráfico.</div>
                </div>
            </div>
        </div>

        <!-- ==================== UPLOAD ==================== -->
        <div id="upload" class="tab-content">
            <h2><i class="fas fa-upload"></i> Cargar Datos Reales / Base</h2>
            <div class="form-group input-group">
                <label for="exercise-year">Año del Ejercicio:</label>
                <!-- Input change handled by addEventListeners on 'change' event -->
                <input type="number" id="exercise-year" min="2000" max="2099" value="2024">
                <!-- REMOVED onclick and handled by JS data-action -->
                <button data-action="createNewExercise" class="button-success"><i class="fas fa-calendar-plus"></i> Crear/Seleccionar Año</button>
             </div>
            <p>Sube tu archivo Excel con las hojas <strong>"Gastos"</strong> e <strong>"Ingresos"</strong>. Los rubros y detalles nuevos encontrados se añadirán automáticamente a la sección de Configuración.</p>
            <p><strong>Importante:</strong>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>En la hoja "Gastos", las celdas con valores numéricos serán marcadas como 'REAL'. Las celdas vacías o con valores no numéricos se interpretarán como 'Estimado' y podrán ser proyectadas por la función "Calcular Estimados".</li>
                    <li>Los rubros de Ingreso llamados "<strong id="cuota-rubro-name-info">Expensas Ordinarias</strong>" y "<strong>Expensas Extraordinarias</strong>" tendrán sus valores base multiplicados por la cantidad de UF (definida en Configuración) al calcular el *total* de ingresos en el Resumen General. La columna "Expensa Real ($/UF)" en el resumen muestra el valor del rubro "<strong id="cuota-rubro-name-info2">Expensas Ordinarias</strong>" <strong style="color: var(--primary-color)">dividido por la cantidad de UF</strong>.</li>
                </ul>
            </p>
            <!-- Handled drag/drop listener on #file-upload-area div, and button clicks via data-action -->
            <div id="file-upload-area">
                 <p><i class="fas fa-file-excel"></i><br>Arrastra tu archivo Excel aquí (.xlsx, .xls) o haz clic para seleccionar</p>
                 <!-- REMOVED onchange attribute, handler is added via JS addEventListener -->
                 <input type="file" id="excel-file-input" accept=".xlsx, .xls" style="display: none;">
                 <!-- REMOVED onclick attribute, handled by JS data-action -->
                 <button type="button" data-action="selectFileInput" class="button-primary" style="pointer-events: auto;"><i class="fas fa-folder-open"></i> Seleccionar Archivo</button>
                 <!-- REMOVED onclick attribute, handled by JS data-action -->
                 <button type="button" data-action="loadSampleData" style="margin-left: 10px; pointer-events: auto;" class="button-secondary"><i class="fas fa-database"></i> Cargar Datos Ejemplo</button>
            </div>
            <div id="file-upload-feedback"></div>
            <!-- REMOVED onclick attribute, handler is added via JS addEventListener -->
            <a href="#" id="download-template-link" title="Descargar archivo Excel con estructura de ejemplo"><i class="fas fa-download"></i> Descargar Plantilla Ejemplo</a>
        </div>

        <!-- ==================== RESERVE FUND ==================== -->
        <div id="reserve" class="tab-content">
             <h2><i class="fas fa-piggy-bank"></i> Configurar Fondo de Reserva - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
             <div class="form-group">
                 <label>Método de Cálculo del Fondo:</label>
                 <div class="input-group">
                     <!-- REMOVED onchange attribute, handler is added via JS addEventListener -->
                     <input type="radio" id="reserve-type-percent" name="reserve-type" value="percent" checked>
                     <label for="reserve-type-percent">Porcentaje (%) sobre Gastos Mensuales</label>
                     <!-- REMOVED onchange attribute, handler is added via JS addEventListener -->
                     <input type="radio" id="reserve-type-fixed" name="reserve-type" value="fixed">
                     <label for="reserve-type-fixed">Valor Fijo Mensual ($)</label>
                 </div>
             </div>
              <h4>Valores Mensuales del Fondo</h4>
              <!-- Used the new monthly-inputs-grid class -->
             <div id="reserve-fund-panel" class="monthly-inputs-grid">
                 <!-- Monthly inputs for reserve fund are generated by JS updateReserveFundPanel -->
             </div>
             <!-- REMOVED onclick attribute, handler is added via JS data-action -->
             <button data-action="saveReserveFund" style="margin-top: 25px;" class="button-success" title="Guardar los valores mensuales y el tipo de cálculo del fondo"><i class="fas fa-save"></i> Guardar Configuración del Fondo y Recalcular</button>
        </div>

        <!-- ==================== SETTINGS ==================== -->
        <div id="settings" class="tab-content">
             <h2><i class="fas fa-cog"></i> Configuración General y de Cálculo</h2>

             <div class="config-section">
                 <h4><i class="fas fa-building"></i> Ajustes Generales del Barrio</h4>
                 <div class="form-group">
                     <label for="cantidad-unidades">Cantidad Total de Unidades Funcionales (UF):</label>
                     <!-- Input change handled when Save Settings button is clicked -->
                     <input type="number" id="cantidad-unidades" min="1" value="100" style="width: 180px;" title="Número total de UF para calcular cuotas base">
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-list-alt"></i> Gestión de Rubros (Categorías)</h4>
                 <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                     <div style="flex: 1; min-width: 320px;">
                         <h5><i class="fas fa-arrow-down" style="color:var(--danger-color)"></i> Rubros de GASTOS</h5>
                         <p class="text-muted">Asigna un coeficiente a cada rubro para proyectar sus gastos estimados.</p>
                         <div class="form-group input-group">
                             <input type="text" id="new-gasto-rubro-name" placeholder="Nombre nuevo rubro de gasto" style="flex-grow: 1;">
                             <!-- REMOVED onclick attribute, handled by JS data-action -->
                             <button data-action="addGastoRubro" class="button-sm button-success" title="Añadir este nuevo rubro a la lista de gastos"><i class="fas fa-plus"></i> Añadir</button>
                         </div>
                         <!-- Rubro list items are generated by JS, delete buttons' clicks are handled programmatically -->
                         <ul id="gasto-rubro-list" class="management-list"></ul>
                     </div>
                     <div style="flex: 1; min-width: 320px;">
                          <h5><i class="fas fa-arrow-up" style="color:var(--success-color)"></i> Rubros de INGRESOS</h5>
                          <p class="text-muted">Solo los rubros Expensa Ordinaria y Extraordinaria se multiplican por UF.</p>
                          <div class="form-group input-group">
                              <input type="text" id="new-ingreso-rubro-name" placeholder="Nombre nuevo rubro de ingreso" style="flex-grow: 1;">
                               <!-- REMOVED onclick attribute, handled by JS data-action -->
                              <button data-action="addIngresoRubro" class="button-sm button-success" title="Añadir este nuevo rubro a la lista de ingresos"><i class="fas fa-plus"></i> Añadir</button>
                          </div>
                          <!-- Rubro list items are generated by JS, delete buttons' clicks are handled programmatically -->
                          <ul id="ingreso-rubro-list" class="management-list"></ul>
                     </div>
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-percentage"></i> Gestión de Coeficientes de Ajuste (%)</h4>
                 <p class="text-muted" style="font-size: 0.9em;">Define tipos de coeficientes (ej. Inflación, Aumento Gremial). Edita sus valores mensuales en porcentaje. <strong style="color: var(--primary-color);">0 %</strong> implica un multiplicador de <strong style="color: var(--primary-color);">1</strong> (sin cambio). <strong style="color: var(--primary-color);">+2.5 %</strong> implica un multiplicador de <strong style="color: var(--primary-color);">1.025</strong>.</p>
                 <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                     <div style="flex: 1; min-width: 280px;">
                         <h5>Tipos de Coeficientes Disponibles</h5>
                         <div class="form-group input-group">
                             <input type="text" id="new-coefficient-type-name" placeholder="Nuevo tipo (ej: Aumento Sindicato)" style="flex-grow: 1;">
                              <!-- REMOVED onclick attribute, handled by JS data-action -->
                             <button data-action="addCoefficientType" class="button-sm button-success" title="Añadir este nuevo tipo de coeficiente a la lista"><i class="fas fa-plus"></i> Añadir Tipo</button>
                         </div>
                         <!-- Coefficient type list items generated by JS. Click handlers and delete buttons added programmatically. -->
                         <ul id="coefficient-type-list" class="management-list"></ul>
                     </div>
                     <div id="coefficient-editor" style="flex: 2; min-width: 450px;">
                          <h5><i class="fas fa-edit"></i> Editar Valores Mensuales (%) para: <span id="editing-coefficient-name" style="color: var(--primary-color); font-weight: bold;"></span></h5>
                          <!-- monthly-inputs-grid for coefficient values are generated by JS renderCoefficientValuesEditor -->
                          <!-- input change handlers are added programmatically by renderCoefficientValuesEditor -->
                          <div id="coefficient-values-editor">
                              <p class="text-muted">Selecciona un tipo de coeficiente de la lista (que no sea "Sin Coeficiente") para editar sus valores (en porcentaje %).</p>
                          </div>
                     </div>
                 </div>
             </div>
             <!-- REMOVED onclick attribute, handler is added via JS data-action -->
             <button data-action="saveSettings" style="margin-top: 20px; width: 100%; padding: 15px;" class="button-success button-lg" title="Guardar todos los cambios realizados en esta pestaña (UF, Rubros, Coeficientes) y recalcular el escenario actual">
                 <i class="fas fa-save"></i> GUARDAR TODA LA CONFIGURACIÓN Y RECALCULAR
             </button>
        </div>

        <!-- ==================== REPORTS ==================== -->
        <div id="reports" class="tab-content">
             <h2><i class="fas fa-download"></i> Descargar Reportes - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
             <p>Genera y descarga los datos del ejercicio y escenario actual en formato Excel, incluyendo detalles y resumen.</p>
             <!-- REMOVED onclick attribute, handled by JS data-action -->
             <button data-action="exportToExcel" class="button-success" title="Descargar un archivo .xlsx con el detalle y resumen del escenario actual"><i class="fas fa-file-excel"></i> Descargar Reporte Completo (.xlsx)</button>

             <h3 style="margin-top: 35px;">Exportar Gráficos Individuales</h3>
             <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                 <!-- REMOVED onclick attributes and handled by JS data-action + data-chart-id/data-filename -->
                 <button data-action="exportChart" data-chart-id="evolutivoCuotaChart" data-filename="evolutivo_expensa_por_uf.png" class="button-secondary" title="Descargar el gráfico de evolución de expensas como imagen PNG"><i class="fas fa-chart-line"></i> Gráfico Evolutivo ($/UF PNG)</button>
                 <button data-action="exportChart" data-chart-id="participacionGastosChart" data-filename="participacion_gastos.png" class="button-secondary" title="Descargar el gráfico de torta de gastos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Gastos (PNG)</button>
                 <button data-action="exportChart" data-chart-id="participacionIngresosChart" data-filename="participacion_ingresos.png" class="button-secondary" title="Descargar el gráfico de torta de ingresos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Ingresos (PNG)</button>
             </div>
        </div>
    </div> <!-- /container -->

    <footer>
        <div class="container">
            &copy; <span id="footer-year"></span> Proyección Expensas El Centauro. v2.7 (PctCoef_IPCRubro_Style + BugFix3)
        </div>
    </footer>
    <div id="snackbar">Mensaje</div>

    <!-- ==================== SCRIPT PRINCIPAL ==================== -->
    <script>

        // --- Helper function to check if a value is an object (and not null or an array) ---
        // Defined early so getDefaultAppState can potentially use it (though not strictly necessary based on its simple use there)
        function isObject(item) {
            return (item && typeof item === 'object' && !Array.isArray(item));
        }

        // --- Provides the initial clean state structure of the application ---
        // Moved this definition higher so it's available when appState is declared using it.
        function getDefaultAppState() {
            const defaultYear = new Date().getFullYear();
            // Define the structure here. Use JSON stringify/parse later if a deep copy is needed from this template.
            const defaultStateTemplate = {
                 // General State
                 currentYear: defaultYear,
                 activeScenarioKey: null, // Will be set by validation logic after load
                 darkMode: false, // Default theme

                 // All Scenarios data keyed by `${year}_${scenarioName}`
                 scenarios: {
                     // Example scenario structure (will be deleted/replaced on load if data exists, but provides template)
                     // Used as a template in initializeScenarioDataForRubros for consistent structure across scenarios.
                     BaseExample: { // This key is just a template, not meant to be a real scenario in 'scenarios' initially
                        year: defaultYear,
                        scenarioName: 'Base Example Template', // Placeholder name
                        rubroOrder: { gastos: [], ingresos: [] }, // Array of rubro keys for display order
                        data: { // Raw/Input/Projected monthly data by rubro and detail
                             gastos: {}, // Keyed by rubro name -> { detailOrder: [], detailsData: { detailName: [val, val, ...12], ... } }
                             ingresos: {}, // Keyed by rubro name -> { detailOrder: [], detailsData: { detailName: [val, val, ...12], ... } }
                        },
                        monthStatus: { // Status flags for expense details ('REAL' or 'Estimado') - Used for coloring and projection logic
                            gastos: {}, // Keyed by rubro name -> { detailName: ['REAL', 'Estimado', ...12], ... }
                             ingresos: {}, // Month status currently not used/populated per detail for ingresos
                        },
                        reserveFund: { type: 'percent', values: Array(12).fill(5) }, // Fondo reserva config (percent or fixed, monthly values)

                        calculated: { // Monthly/Annual calculated results. Should NOT be manually edited.
                             gastoAjustado: {}, // Stores final values used for summing totals after projection (should be same as data.gastos after recalculateEstimates for estimated, or same as original real)
                            totalGastoRubroMes: {}, // Sum of gastoAjustado details per rubro per month
                            totalGastoProyectadoMes: Array(12).fill(0), // Sum of all totalGastoRubroMes (Overall monthly total expense)

                             ingresoAjustado: {}, // Stores BASE income values from Excel/input for detail table display (before UF mult)
                            totalIngresoRubroMes: {}, // Stores FINAL calculated income value (base value sums + UF multiplication for special rubros)
                            totalIngresoProyectadoMes: Array(12).fill(0), // Sum of all totalIngresoRubroMes (Overall monthly total income)

                            fondoReservaMes: Array(12).fill(0), // Monthly calculated reserve amount

                            cuotaSobreGastosMes: Array(12).fill(0), // Monthly (Total Gasto + Fondo) / UF (The cost PER UF to cover Gasto+Fondo)

                            ipcManual: Array(12).fill(0), // Snapshot of IPC % values from settings.coefficientTypes.IPC *when calculateAll ran*. Used for IPC reference display & Cuota IPC calc.

                            cuotaIpcMes: Array(12).fill(0), // Monthly calculated $/UF based on Enero Expensa Real / UF and cumulative IPC Ref snapshot. A reference line.

                            cuotaRealBaseMes: Array(12).fill(0), // Monthly (Expensa Ordinaria Rubro Total Final) / UF. Shows the actual calculated Expensa Ordinaria value per UF.

                             annualTotals: { // Annual totals calculated from monthly sums
                                 gastos: {__TOTAL__:0}, // Sum of totalGastoProyectadoMes (Overall Annual Total Expense)
                                 ingresos: {__TOTAL__:0}, // Sum of totalIngresoProyectadoMes (Overall Annual Total Income)
                                 fondoReserva: 0, // Sum of fondoReservaMes (Overall Annual Reserve Contribution)
                                 cuotaSobreGastos: 0, // Sum of cuotaSobreGastosMes (Sum of monthly Cost-per-UF for Gasto+Fondo)
                                 cuotaIpc: 0, // Sum of cuotaIpcMes (Sum of monthly IPC reference cuota per UF)
                                 cuotaRealBase: 0 // Sum of cuotaRealBaseMes (Sum of monthly Expensa Real per UF)
                             }
                        }
                     } // End BaseExample structure
                 }, // End scenarios object

                 settings: { // Global settings, affect all scenarios and how they are calculated/displayed
                     quantityUnits: 100, // Total number of Functional Units (UF) - Integer >= 1

                     // List of defined rubro names by type ('gastos', 'ingresos'). Determines what rubros appear in lists/tables and their order in config.
                     rubros: { gastos: [], ingresos: [] },

                      // Configuration specific to each rubro, keyed by rubro name.
                     rubroConfig: {
                         // Example entry for a 'gastos' rubro:
                         // "Nombre Rubro Gasto": { coefficientType: 'KEY_DE_COEFICIENTE', detailsCollapsed: boolean (default true) }
                         // Example entry for an 'ingresos' rubro (only collapsed state used):
                         // "Nombre Rubro Ingreso": { detailsCollapsed: boolean (default true) }
                         // coefficientType is only relevant and used for 'gastos' rubros.
                     },

                      // Definitions of coefficient types (e.g., IPC, Gremiales) and their monthly percentage values. Keyed by unique identifier.
                     coefficientTypes: {
                         "None": { name: "Sin Coeficiente", values: Array(12).fill(0), isDefault: true }, // Multiplier is 1 (1 + 0/100) for all months. Default type for unassigned rubros.
                         "IPC": { name: "IPC", values: [5, 4, 6, 3, 4, 5, 3, 4, 5, 6, 4, 5], isDefault: true }, // Example monthly percentages (%) for IPC. This specific type is also snapshotted for Cuota IPC calculation.
                         "UTEDYC": { name: "UTEDYC (Ejemplo)", values: [0, 0, 10, 0, 0, 8, 0, 0, 7, 0, 0, 5], isDefault: true }, // Example percentage increases for some months. Default example types are not deletable.
                         "Sueldos": { name: "Sueldos Generales (Ejemplo)", values: [0, 0, 8, 0, 0, 6, 0, 0, 5, 0, 0, 4], isDefault: false } // Example of a custom percentage type that is deletable.
                     },
                     // monthly values for coefficient types are PERCENTAGES (ej. 5 for 5%). >= 0%.
                 },

                 uiState: { // Transient UI state, NOT typically saved or loaded with saveState/loadState
                    editingCoefficientType: null // Key of the coefficient type currently being edited in the Settings tab
                     // Add other temporary UI flags here as needed.
                 }
             };

             // Return a deep copy of the template to ensure a clean and independent default state object.
             try { return JSON.parse(JSON.stringify(defaultStateTemplate)); }
             catch (e) {
                  console.error("Failed to deep copy default app state template. Returning potentially unsafe object.", e);
                  return defaultStateTemplate; // Fallback: return the original object if deep copy fails
             }
        }


        // --- Constantes y Estado Global ---
        const MONTHS = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
        const FULL_MONTHS = ["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"];
        const GASTOS_SHEET_NAME = "Gastos";
        const INGRESOS_SHEET_NAME = "Ingresos";
        // MODIFICACIÓN STORAGE KEY V2.7 - Introduce coeficientes en porcentaje, IPC como rubro coeficiente y estilos de tablas/graficos
        const STORAGE_KEY = 'expensasAppCentauroState_v2.7_PctCoef_IPCRubro_Style'; // Stay the same
        const CUOTA_RUBRO_NAME = "Expensas Ordinarias"; // Rubro principal para multiplicar x UF y base de Expensa Real
        const EXTRA_CUOTA_RUBRO_NAME = "Expensas Extraordinarias"; // Otro rubro a multiplicar x UF
        const SPECIAL_INGRESO_RUBROS = [CUOTA_RUBRO_NAME, EXTRA_CUOTA_RUBRO_NAME]; // Rubros that are multiplied by UF for total Ingresos
        const IPC_COEFFICIENT_KEY = "IPC"; // Key for the default IPC coefficient type in settings


        // Declare appState variable early (its value is assigned in DOMContentLoaded after loadState runs)
        // Assign a placeholder or a call to getDefaultAppState right away (as done previously).
        // Moving getDefaultAppState definition UP solves the ReferenceError here.
        let appState = getDefaultAppState();

        // Chart instances (declared at a scope accessible for Chart.js instances)
        let evolutivoCuotaChart_instance = null;
        let participacionGastosChart_instance = null;
        let participacionIngresosChart_instance = null;


        // --- DOMContentLoaded Initialization ---
        // This code runs AFTER the entire HTML document is loaded and parsed.
        document.addEventListener('DOMContentLoaded', () => {
            console.log(`DOM Cargado. Inicializando App ${STORAGE_KEY}...`);
            // Load application state from localStorage. This also performs data migration if needed.
            loadState();

            // Initialize theme (light/dark mode) based on loaded state and system preference.
            initTheme();

            // Ensure there is always a valid active scenario to work with, creating a default if none found.
            // This function also syncs the current year and ensures basic scenario data structures.
            validateAndSetActiveScenario();

            // --- Update UI elements that need current configuration names/references ---
            // Update UI text references for specific income rubro names.
            const cuotaInfoSpan = document.getElementById('cuota-rubro-name-info');
            if (cuotaInfoSpan) cuotaInfoSpan.textContent = CUOTA_RUBRO_NAME;
            const cuotaInfoSpan2 = document.getElementById('cuota-rubro-name-info2');
            if (cuotaInfoSpan2) cuotaInfoSpan2.textContent = CUOTA_RUBRO_NAME;

            // Perform initial UI setup and add core event listeners.
            // addEventListeners handles attaching event listeners programmatically.
            initUI();
            addEventListeners(); // Call addEventListeners *after* initUI and getting DOM elements

            // Perform the first full update of the UI, rendering data based on the loaded/initial state.
            updateUI(); // Calls calculateAll and all other update functions

            console.log(`App ${STORAGE_KEY} Inicializada.`);
        });


         // --- Data Migration & Structure Validation (during loadState) ---

         // Helper function called by loadState to handle data format migrations from older STORAGE_KEY versions
         // and validate the loaded state structure against the current getDefaultAppState template, correcting inconsistencies.
         // Modifies the `loadedState` object in place. Returns `true` if any structural changes were made that warrant re-saving.
         function migrateState(loadedState) {
            let changed = false; // Flag to indicate if state was modified

             // Check for necessary top-level properties; if missing, add defaults.
              loadedState.currentYear ??= new Date().getFullYear(); changed = true;
              loadedState.darkMode ??= false; changed = true;
              // scenarios, activeScenarioKey, settings are validated/initialized later/separately


             // Ensure settings object exists; if not, get defaults.
             loadedState.settings = loadedState.settings || getDefaultAppState().settings;
             // Mark as changed if settings object itself was missing
             if (loadedState.settings === getDefaultAppState().settings) changed = true;


             // --- Migration Step: Old ipcManual array -> New IPC Coefficient Type ---
             // Check if the old `settings.ipcManual` array exists in the loaded state.
             if (Array.isArray(loadedState.settings.ipcManual)) {
                 console.log("Migración: Detected old 'ipcManual' array in settings. Migrating to Coefficient Type 'IPC'.");
                  // Ensure the `coefficientTypes` object exists or initialize it from defaults
                  loadedState.settings.coefficientTypes = loadedState.settings.coefficientTypes || getDefaultAppState().settings.coefficientTypes;
                  // Get the default definition for the IPC coefficient type (from current defaults)
                 const defaultIpcCoefDef = getDefaultAppState().settings.coefficientTypes?.[IPC_COEFFICIENT_KEY];

                 // Ensure the IPC coefficient type exists in the loaded state's `coefficientTypes`
                 loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY] ??= defaultIpcCoefDef ? JSON.parse(JSON.stringify(defaultIpcCoefDef)) : { name: IPC_COEFFICIENT_KEY, values: Array(12).fill(0), isDefault: true };


                 // Overwrite the 'values' array of the existing IPC type with the migrated data
                 // Ensure copied values are numbers.
                  const migratedValues = loadedState.settings.ipcManual.slice(0, 12).map(v => typeof v === 'number' ? v : 0); // IPC % can be negative, but input is limited to >=0. Migrate raw loaded value? Let's limit to >=0 during migration for safety/consistency with current input method.
                   migratedValues.forEach((val, i) => migratedValues[i] = val >= 0 ? val : 0);

                  // Compare to existing values in the target type; if different, update.
                  if (JSON.stringify(loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].values) !== JSON.stringify(migratedValues)) {
                      console.log(`Migración: Updating IPC coefficient type values with data from old ipcManual.`);
                       loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].values = migratedValues;
                       changed = true;
                   } else {
                      console.log(`Migración: Values for "${IPC_COEFFICIENT_KEY}" from old ipcManual already match existing. No update needed.`);
                   }


                 // Ensure default properties (name, isDefault) for the IPC type are set according to current defaults
                 if (defaultIpcCoefDef) {
                       if (loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].name !== defaultIpcCoefDef.name || loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].isDefault !== defaultIpcCoefDef.isDefault) {
                             console.warn(`Migración: Correcting name/isDefault for IPC coefficient type.`);
                           loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].name = defaultIpcCoefDef.name;
                            loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].isDefault = defaultIpcCoefDef.isDefault;
                            changed = true;
                       }
                 } else {
                            console.warn(`Migración: Default definition for IPC coefficient type missing. Using hardcoded fallback.`);
                             loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].name = loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].name || IPC_COEFFICIENT_KEY;
                             loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].isDefault = loadedState.settings.coefficientTypes[IPC_COEFFICIENT_KEY].isDefault ?? true;
                             changed = true;
                 }

                 // Remove the old `ipcManual` property from settings
                 delete loadedState.settings.ipcManual;
                 changed = true; // State was changed by removing old prop
                 console.log("Migración de ipcManual a coefficientTypes.IPC completada.");
             }


             // Add any new default coefficient types defined in getDefaultAppState but missing in the loaded state.
              // Also validate/correct structure of existing default and custom types.
              const defaultCoefficientTypes = getDefaultAppState().settings.coefficientTypes;
              loadedState.settings.coefficientTypes ??= {}; // Ensure exists

              // Iterate through the DEFAULT types (from template) to ensure they exist in loaded state and have correct properties/values
              Object.keys(defaultCoefficientTypes).forEach(defaultKey => {
                  const defaultDef = defaultCoefficientTypes[defaultKey]; // The default definition template
                  const loadedType = loadedState.settings.coefficientTypes[defaultKey]; // The type definition from loaded state

                   // Check if the type exists in the loaded state
                  if (!loadedType) {
                      // If a default type is completely missing in loaded state, add it (deep copy from template)
                      console.log(`Migración: Adding missing default coefficient type "${defaultKey}".`);
                      loadedState.settings.coefficientTypes[defaultKey] = JSON.parse(JSON.stringify(defaultDef));
                      changed = true;
                  } else {
                       // If a default type EXISTS in loaded state, ensure its properties (`name`, `isDefault`)
                       // match the default template definition and correct them if needed.
                       if (loadedType.name !== defaultDef.name || loadedType.isDefault !== defaultDef.isDefault) {
                            console.warn(`Migración: Correcting default properties for coefficient type "${defaultKey}". Loaded: {name: "${loadedType.name}", isDefault: ${loadedType.isDefault}}, Default: {name: "${defaultDef.name}", isDefault: ${defaultDef.isDefault}}.`);
                           loadedType.name = defaultDef.name; // Force name from default template
                           loadedType.isDefault = defaultDef.isDefault; // Force isDefault from default template
                           changed = true;
                       }

                      // Validate the 'values' array structure for THIS specific default type: must be array of 12 numbers.
                       const isValidLoadedValues = Array.isArray(loadedType.values) && loadedType.values.length === 12 && loadedType.values.every(v => typeof v === 'number');

                       if (!isValidLoadedValues) {
                           console.warn(`Migración: Values array for default coefficient type "${defaultKey}" corrupted/invalid structure. Resetting to default values.`);
                          // If structure invalid, reset to default template values if valid, else set 0% fill.
                           loadedType.values = Array.isArray(defaultDef?.values) ? JSON.parse(JSON.stringify(defaultDef.values)) : Array(12).fill(defaultKey === 'None' ? 1 : 0); // Default value for 'None' is 1
                           changed = true;
                      } else {
                           // If structure is valid, ensure values are appropriate for the type:
                           // - For default 'None', all values MUST be exactly 1.
                           if (defaultKey === 'None' && !loadedType.values.every(v => v === 1)) {
                              console.warn(`Migración: Default "None" coefficient type values corrupted. Correcting to 1s.`);
                              loadedType.values = Array(12).fill(1);
                              changed = true;
                           }
                            // - For other default percentage types (like IPC, UTEDYC examples), values MUST be >= 0.
                            else if (defaultKey !== 'None') {
                               const correctedValues = loadedType.values.map(v => v >= 0 ? v : 0); // Ensure non-negative
                                // Check if correction was needed
                                if (JSON.stringify(correctedValues) !== JSON.stringify(loadedType.values)) {
                                    console.warn(`Migración: Found negative values in default percentage coefficient type "${defaultKey}". Correcting to 0s.`);
                                    loadedType.values = correctedValues;
                                    changed = true;
                               }
                            }
                      }
                  }
              }); // End iteration over default coefficient types


              // --- Validation & Correction Step: Ensure structure and validity of CUSTOM Coefficient Types ---
              // Iterate through ALL coefficient types present in the loaded state (including customs).
             Object.keys(loadedState.settings.coefficientTypes).forEach(loadedKey => {
                  const loadedType = loadedState.settings.coefficientTypes[loadedKey]; // Definition from loaded state (guaranteed valid object by filter/checks above)

                  // If THIS key does NOT match a key in the default template definitions (after template definitions were ensured above).
                  // This means it's a custom type that exists ONLY in the loaded state.
                   if (!defaultCoefficientTypes[loadedKey]) { // Check if key exists in the original default template
                       console.log(`Migración: Validating custom coefficient type "${loadedKey}".`);

                       // Ensure custom types have correct non-default properties (`name`, `isDefault: false`).
                       if (loadedType.isDefault !== false) { // It should NOT be true for customs
                            console.warn(`Migración: Custom coefficient type "${loadedKey}" was marked as default (${loadedType.isDefault}). Correcting to isDefault=false.`);
                            loadedType.isDefault = false; // Force to false
                            changed = true;
                       }
                        if (!loadedType.name || typeof loadedType.name !== 'string') { // Must have a string name
                           console.warn(`Migración: Custom coefficient type "${loadedKey}" missing or invalid name. Using key as name.`);
                           loadedType.name = String(loadedKey); // Fallback name to the key
                           changed = true;
                       }

                      // Validate the 'values' array structure for THIS CUSTOM type: must be array of 12 numbers >= 0%.
                       const isValidLoadedValuesStructure = Array.isArray(loadedType.values) && loadedType.values.length === 12 && loadedType.values.every(v => typeof v === 'number');
                       if (!isValidLoadedValuesStructure) {
                           console.warn(`Migración: Coefficient values array for custom type "${loadedKey}" corrupted/invalid structure. Resetting to 0%.`);
                          loadedType.values = Array(12).fill(0); // Reset custom corrupted values to 0%
                           changed = true;
                       } else {
                            // Ensure non-negative values for custom percentage types.
                           const correctedValues = loadedType.values.map(v => v >= 0 ? v : 0); // Ensure non-negative
                           if (JSON.stringify(correctedValues) !== JSON.stringify(loadedType.values)) {
                                console.warn(`Migración: Found negative values in custom percentage coefficient type "${loadedKey}". Correcting to 0s.`);
                                loadedType.values = correctedValues;
                                changed = true;
                           }
                       }
                   } // End if is a custom type

             }); // End iteration over all loaded coefficient types keys (handles defaults and customs)


             // --- Validation & Correction Step: Ensure rubroConfig structure ---
             loadedState.settings.rubroConfig ??= {}; // Ensure exists

             // Get a combined list of ALL rubro keys that are defined in the global settings lists.
             const allRubrosDefinedInSettings = [
                  ...(loadedState.settings.rubros?.gastos || []).map(r => String(r ?? '').trim()).filter(r => r),
                 ...(loadedState.settings.rubros?.ingresos || []).map(r => String(r ?? '').trim()).filter(r => r)
             ];
             // Use a Set to get unique keys, just in case there are duplicates or empty strings somehow got in the lists.
              const uniqueRubrosInSettings = new Set(allRubrosDefinedInSettings);


              // Iterate through ALL unique rubro keys defined in the global settings lists.
              uniqueRubrosInSettings.forEach(rubroKey => {
                   const rubroConfigEntry = loadedState.settings.rubroConfig[rubroKey]; // Config entry for this rubro


                   // If rubro config entry is missing or is not an object, create a default one.
                   if (!rubroConfigEntry || typeof rubroConfigEntry !== 'object' || Array.isArray(rubroConfigEntry)) { // Ensure it's an object, not array or null
                       console.warn(`Migración: Missing or invalid rubroConfig for "${rubroKey}". Creating default.`);
                       // Default config: coefficientType 'None', detailsCollapsed true.
                       loadedState.settings.rubroConfig[rubroKey] = { coefficientType: 'None', detailsCollapsed: true };
                       changed = true;
                       return; // Continue to next rubro key after fixing this one
                   }

                   // If config exists and is an object, validate/correct its properties.
                   // Validate `detailsCollapsed`: must be a boolean. Default to true if invalid.
                  if (typeof rubroConfigEntry.detailsCollapsed !== 'boolean') {
                       console.warn(`Migración: Invalid type for rubroConfig.detailsCollapsed for "${rubroKey}". Value: "${rubroConfigEntry.detailsCollapsed}" (${typeof rubroConfigEntry.detailsCollapsed}). Setting to default (true).`);
                       rubroConfigEntry.detailsCollapsed = true; // Default to true
                       changed = true;
                   }

                   // Validate `coefficientType`:
                   // 1. Ensure the `coefficientType` property exists for EXPENSE rubros if the type is 'gastos' in settings.
                   // 2. If it exists, ensure the key points to a type that exists in the (now corrected) `settings.coefficientTypes`.
                   // 3. Default to 'None' if property is missing for 'gastos', or if assigned key is invalid.

                   const rubroIsExpense = (loadedState.settings.rubros?.gastos || []).includes(rubroKey);

                    if (rubroIsExpense) { // Check coefType only for rubros explicitly listed in gastos settings
                        const assignedCoefTypeKey = rubroConfigEntry.coefficientType;
                        const validCoefTypeKeys = Object.keys(loadedState.settings.coefficientTypes); // Get keys from the corrected types list

                        if (assignedCoefTypeKey === undefined || assignedCoefTypeKey === null || !validCoefTypeKeys.includes(assignedCoefTypeKey)) {
                           // Only log warning if it's not undefined/null and doesn't exist among valid keys
                           if (assignedCoefTypeKey !== undefined && assignedCoefTypeKey !== null) console.warn(`Migración: Invalid or non-existent coefficientType "${assignedCoefTypeKey}" in rubroConfig for gasto rubro "${rubroKey}". Setting to 'None'.`);
                            rubroConfigEntry.coefficientType = 'None'; // Force to 'None'
                           changed = true;
                       }
                         // If it exists and is valid, great.
                   } else {
                       // If rubro is NOT listed as an expense rubro, the coefficientType property isn't used by current logic.
                       // Can optionally check if the property exists here and potentially remove it or ensure its null/undefined state
                       // if it shouldn't be there for an income rubro. For now, let it be if present unless problematic.
                       // console.log(`Migración: Skipping coefficientType check for non-gasto rubro "${rubroKey}".`);
                       // Potentially remove unexpected 'coefficientType' property from income rubro configs if present?
                       // This could be overzealous. Let's assume its presence on an income rubro doesn't break anything for now.
                   }


              }); // End iteration over rubros in settings

              // --- Clean up rubroConfig entries for rubros that are NO LONGER defined in the global settings lists ---
              // Get keys of all rubroConfig entries in the loaded state.
              Object.keys(loadedState.settings.rubroConfig).forEach(rubroConfigKey => {
                   // Check if this rubroConfigKey exists in EITHER the current corrected `settings.rubros.gastos` list OR the `settings.rubros.ingresos` list.
                  const isInGastosList = (loadedState.settings.rubros?.gastos || []).includes(rubroConfigKey);
                  const isInIngresosList = (loadedState.settings.rubros?.ingresos || []).includes(rubroConfigKey);

                   // If the rubro key is not found in ANY global rubro list...
                  if (!isInGastosList && !isInIngresosList) {
                       // It's a remnant config entry for a rubro that must have been deleted from global settings previously. Delete this orphaned config entry.
                       console.log(`Migración: Found rubroConfig entry for "${rubroConfigKey}", but rubro is not in settings lists. Removing the orphaned rubroConfig entry.`);
                      delete loadedState.settings.rubroConfig[rubroConfigKey];
                     changed = true;
                 }
             }); // End iteration over rubroConfig keys


             // --- Validation & Correction Step: Ensure consistency within Scenarios data structures ---
              loadedState.scenarios ??= getDefaultAppState().scenarios; // Ensure scenarios object exists

              // Iterate through each scenario object found in the loaded state.
              // Safely get values from the scenarios object, filtering out null/undefined/primitive entries.
              Object.values(loadedState.scenarios).forEach(scenario => {
                  // Check if the scenario object reference itself is a valid structure with a year property before processing.
                   if (scenario && typeof scenario === 'object' && scenario !== null && !Array.isArray(scenario) && scenario.year !== undefined) {
                       // Call the scenario-level initializer function for *each* valid scenario object.
                       // This function (`initializeScenarioDataForRubros`) ensures that the `scenario` object's internal
                       // structures (`data`, `monthStatus`, `calculated`, `rubroOrder` for each type/rubro/detail)
                       // are present and correctly structured (e.g., arrays are size 12, values are numeric, etc.)
                       // based on the (now corrected) global settings passed as the second argument.
                       // This call modifies the `scenario` object in place.
                        initializeScenarioDataForRubros(scenario, loadedState.settings); // Pass corrected settings
                        // This ensures that:
                        // - data, monthStatus, calculated objects for 'gastos'/'ingresos' types exist.
                        // - Nested objects for each rubro within data, monthStatus, calculated exist (even if rubro has no loaded data).
                        // - detailOrder and detailsData arrays within data objects exist.
                        // - monthly arrays ([val1, ..., val12]) within detailsData/calculated/etc. exist, are size 12, contain numbers, and are non-negative where applicable.
                        // - monthStatus arrays within monthStatus.gastos exist, are size 12, and contain strings.
                        // - annualTotals structures within calculated are initialized.
                        // - ipcManual snapshot within *this scenario's* calculated structure is updated from the global settings.coefficientTypes.IPC.values.
                       // This internal initialization itself modifies the scenario object, so `changed` becomes true here implicitly? No, function signature doesn't track that.
                        // Let's assume for simplicity that this validation step itself causes `changed = true` if anything significant happened within scenarios.
                       // This might lead to slightly more frequent saves on load if state isn't perfectly clean, but is safer.
                        changed = true; // Assume scenarios were initialized/validated
                   } else {
                       console.warn("Migración: Skipping validation/init for an invalid scenario entry found:", scenario);
                       // Should potentially clean up invalid entries FROM the scenarios object itself?
                       // The logic `Object.values(appState.scenarios || {})` in places like calculateAll etc., filters out bad references.
                       // A robust approach would identify the *key* pointing to this bad value and delete it. That's more complex for migration.
                       // For now, we rely on functions downstream to filter out bad scenario references if they exist.
                   }
              }); // End iteration over scenarios in state


            // --- Final Top-Level Setting Property Validations ---
             // Ensure main rubros list objects are valid arrays of trimmed strings
              loadedState.settings.rubros = loadedState.settings.rubros || { gastos: [], ingresos: [] };
              loadedState.settings.rubros.gastos = Array.isArray(loadedState.settings.rubros.gastos) ? loadedState.settings.rubros.gastos.map(r => String(r ?? '').trim()).filter(r => r) : []; // Ensure non-empty string arrays
              loadedState.settings.rubros.ingresos = Array.isArray(loadedState.settings.rubros.ingresos) ? loadedState.settings.rubros.rubros.ingresos.map(r => String(r ?? '').trim()).filter(r => r) : []; // Ensure non-empty string arrays


             loadedState.settings.coefficientTypes = loadedState.settings.coefficientTypes || {}; // Ensure exists and non-null/undefined entries are handled by prior loop

             loadedState.settings.rubroConfig = loadedState.settings.rubroConfig || {}; // Ensure exists and non-null/undefined entries are handled by prior loop

             loadedState.scenarios = loadedState.scenarios || {}; // Ensure exists


             console.log(`Migration and validation process finished for STORAGE_KEY "${STORAGE_KEY}". State was ${changed ? 'changed' : 'NOT changed'}. Final state sample:`, JSON.stringify(loadedState).substring(0, 500) + '...');
             // Return true if any significant structural or data changes were made during migration/validation process that might need re-saving the entire state.
             return changed;
         }


        // --- Validation and setting Active Scenario ---
         // This function is critical during application startup after loadState.
         // It ensures that `appState.activeScenarioKey` is set to a key that exists within `appState.scenarios`.
         // If the existing active key is invalid or missing, it finds a valid fallback.
         // If no scenarios exist at all, it creates the initial default 'Base' scenario for the current year.
         // It also synchronizes `appState.currentYear` to the year of the scenario identified as the active one.
         // It calls `initializeScenarioDataForRubros` on *all* scenarios to ensure their structure consistency *after* loading and potential migration.
         // It calls `saveState()` at the end if a valid scenario was determined or created.
        function validateAndSetActiveScenario() {
             console.log("Validation: Starting validateAndSetActiveScenario...");

             // Get the keys of all scenario entries present in the application state, safely handling if scenarios object is missing or null.
             const scenarioKeys = Object.keys(appState.scenarios || {}); // Use {] || to safely iterate empty scenarios if null


             let activeKeyIsCurrentlyValid = false; // Flag to track if the activeKey from state points to a good scenario

             // --- Step 1: Check if the stored `activeScenarioKey` from state is currently valid. ---
             // Check if `appState.activeScenarioKey` is not null/undefined and exists as a key in `appState.scenarios`.
             // Also validate the scenario entry itself (must be an object with a valid numeric `year` property).
             const currentActiveScenarioEntry = appState.scenarios?.[appState.activeScenarioKey]; // Safely attempt to get the scenario object

             if (appState.activeScenarioKey !== null && appState.activeScenarioKey !== undefined &&
                 currentActiveScenarioEntry && typeof currentActiveScenarioEntry === 'object' &&
                 !Array.isArray(currentActiveScenarioEntry) && typeof currentActiveScenarioEntry.year === 'number' && !isNaN(currentActiveScenarioEntry.year)) {

                 // The stored active key points to an existing, structurally valid scenario entry.
                 // Synchronize `appState.currentYear` to the year stored *within* this valid active scenario.
                        // Note: The year in the key itself (`key.split('_')[0]`) should theoretically match `scenario.year`, but use `scenario.year` as the source of truth if valid.
                       appState.currentYear = currentActiveScenarioEntry.year;

                       activeKeyIsCurrentlyValid = true; // Mark the current state as valid with the active key
                       console.log(`Validation: Stored active scenario key "${appState.activeScenarioKey}" is valid.`);
                   } else {
                        // The scenarios object is missing/null, OR the activeKey is null/undefined, OR the key does not point to an entry, OR the entry is corrupted.
                       console.warn(`Validation: Active scenario key "${appState.activeScenarioKey}" is invalid or missing, or scenario data corrupted. Searching for fallback.`, {
                    scenariosExists: !!appState.scenarios,
                    activeKey: appState.activeScenarioKey,
                    currentActiveScenarioEntryValid: !!(currentActiveScenarioEntry && typeof currentActiveScenarioEntry === 'object' && !Array.isArray(currentActiveScenarioEntry) && typeof currentActiveScenarioEntry.year === 'number' && !isNaN(currentActiveScenarioEntry.year)),
                    corruptedEntry: currentActiveScenarioEntry && !(typeof currentActiveScenarioEntry === 'object' && !Array.isArray(currentActiveScenarioEntry) && typeof currentActiveScenarioEntry.year === 'number' && !isNaN(currentActiveScenarioEntry.year))
                 });
                 appState.activeScenarioKey = null; // Explicitly set to null to clearly indicate no currently active key
             }


             // --- Step 2: Fallback Logic. If `activeKeyIsCurrentlyValid` is false, try to find a valid fallback key. ---
             let fallbackKeyFound = null; // Variable to store the key of the best fallback scenario found


             // This fallback search runs ONLY if `activeKeyIsCurrentlyValid` is false.
             if (!activeKeyIsCurrentlyValid) {
                 console.log("Validation: Searching for a valid fallback scenario...");

                 // --- Fallback Priority 1: Try finding the 'Base' scenario for the current `appState.currentYear`. ---
                 const currentYearBaseKey = `${appState.currentYear}_Base`;
                  // Check if the 'scenarios' object exists AND contains an entry for the currentYearBaseKey.
                  // Validate the candidate scenario entry (object with valid numeric year).
                 const baseScenarioCandidate = appState.scenarios?.[currentYearBaseKey]; // Access safely
                 if (baseScenarioCandidate && typeof baseScenarioCandidate === 'object' && !Array.isArray(baseScenarioCandidate) && typeof baseScenarioCandidate.year === 'number' && !isNaN(baseScenarioCandidate.year)) {
                      fallbackKeyFound = currentYearBaseKey; // Found a valid Base for the current year. This is the best fallback.
                       // Synchronize `appState.currentYear` to the year of this Base scenario.
                       // Note: this will usually be the same as the current appState.currentYear we used in the key search, but use the scenario data as source.
                       appState.currentYear = baseScenarioCandidate.year;
                       console.log(`Validation: Fallback found: Base scenario for current year: ${fallbackKeyFound}`);
                 } else {
                     // Base scenario for current year not found OR it's corrupted. Log if corrupted.
                      if(baseScenarioCandidate) console.warn(`Validation: Fallback candidate Base scenario "${currentYearBaseKey}" found but is corrupted. Skipping as fallback.`);
                      console.log(`Validation: Base scenario for current year (${currentYearBaseKey}) not available as fallback.`);
                 }

                 // --- Fallback Priority 2 (if no fallback yet): Try finding ANY scenario for the current `appState.currentYear`, sorted alphabetically by name. ---
                 // Only proceed if no fallback has been found in Step 1.
                  if (!fallbackKeyFound) {
                       // Filter scenario keys (from the start of the function, ensuring scenarios object exists)
                       // Must start with `${appState.currentYear}_` AND correspond to a valid scenario object entry.
                       const keysForCurrentYear = scenarioKeys.filter(key => {
                           const scenario = appState.scenarios?.[key]; // Access safely
                           return scenario && typeof scenario === 'object' && !Array.isArray(scenario) && typeof scenario.year === 'number' && !isNaN(scenario.year) && scenario.year === appState.currentYear;
                       });

                       if (keysForCurrentYear.length > 0) {
                           // Sort valid keys found for the current year alphabetically by scenario name. Access scenario data safely (`?.`)
                            const firstKeyAlphaForCurrentYear = keysForCurrentYear.sort((a, b) => {
                               // Safely access scenario name
                               const nameA = appState.scenarios?.[a]?.scenarioName || '';
                               const nameB = appState.scenarios?.[b]?.scenarioName || '';
                               return nameA.localeCompare(nameB);
                           })[0]; // Get the key of the first scenario alphabetically.

                           fallbackKeyFound = firstKeyAlphaForCurrentYear; // Set this as the fallback key.
                            // `appState.currentYear` is already correct (was used in the filter).
                            console.log(`Validation: Fallback found: First scenario for current year: ${fallbackKeyFound}`);

                       } else {
                           // No scenarios found AT ALL for the current `appState.currentYear` that are also valid entries.
                           console.log(`Validation: No valid scenarios found at all for current year ${appState.currentYear} as fallback.`);
                       }
                  }


                 // --- Fallback Priority 3 (if no fallback yet): If still no valid scenario for the `appState.currentYear`,
                 // try finding the chronologically first valid scenario GLOBALLY (earliest year, then alphabetically). ---
                 // This logic is the final search step if no valid scenario exists for the currently targeted year.
                 // Only proceed if no fallback has been found in Step 1 or 2.
                  if (!fallbackKeyFound && scenarioKeys.length > 0) {
                      // Sort ALL scenario keys (from the start of the function, ensuring scenarios object exists).
                      // Criteria: valid year ascending > invalid year ascending > alphabetical by name.
                       const validGlobalKeys = scenarioKeys.filter(key => {
                           const scenario = appState.scenarios?.[key]; // Access safely
                           return scenario && typeof scenario === 'object' && !Array.isArray(scenario) && typeof scenario.year === 'number'; // Check for object + numeric year
                       });

                       if (validGlobalKeys.length > 0) {
                            // Sort valid global keys chronologically.
                            const sortedGlobalKeys = validGlobalKeys.sort((a, b) => {
                                const scenarioA = appState.scenarios[a]; const scenarioB = appState.scenarios[b]; // Access is safe now as keys are valid global
                                // Sort by year (ascending)
                               const yearA = scenarioA.year; const yearB = scenarioB.year; // Years are guaranteed numbers now
                                if (yearA !== yearB) return yearA - yearB;

                               // If years are the same, sort alphabetically by name
                               const nameA = scenarioA.scenarioName || ''; const nameB = scenarioB.scenarioName || '';
                               return nameA.localeCompare(nameB);
                           });

                            const firstGlobalCandidate = sortedGlobalKeys[0]; // Get the key of the first sorted valid scenario globally.

                           fallbackKeyFound = firstGlobalCandidate; // Set this as the fallback key.
                            // Synchronize `appState.currentYear` to the year of this global fallback scenario.
                           appState.currentYear = appState.scenarios[fallbackKeyFound].year; // Year is guaranteed number
                           console.log(`Validation: Fallback found: First global scenario: ${fallbackKeyFound}. Synced currentYear to ${appState.currentYear}.`);

                       } else {
                           // No valid scenarios found AT ALL globally in the application state.
                           console.log("Validation: No valid global scenarios found as fallback.");
                       }
                  }


             } // End `if (!activeKeyIsCurrentlyValid)` block


             // --- Final Determination & Action: If STILL NO VALID KEY after all fallbacks, create initial state. ---
             // If `fallbackKeyFound` is not null, use it as the new active key. Otherwise, if the original `activeKeyIsCurrentlyValid` was true, the state is fine.
             // If neither, it means no valid scenario key was found after any search attempts, implying the `scenarios` object was initially empty or entirely corrupt.
              let finalActiveKey;

              if (fallbackKeyFound) {
                   finalActiveKey = fallbackKeyFound; // Use the best fallback key found
                   console.log(`Validation: Setting active scenario to fallback key: ${finalActiveKey}.`);
              } else if (activeKeyIsCurrentlyValid) {
                   finalActiveKey = appState.activeScenarioKey; // Use the original key (it was validated as valid)
                   console.log(`Validation: Original active scenario key "${finalActiveKey}" is valid. Keeping it.`);
              } else {
                   // If reached here, it means no valid key was found from the state or fallbacks.
                   console.log("Validation: No valid scenario found in state or fallbacks. Creating initial default scenario (Base for current year).");
                  // Create a NEW default 'Base' scenario for the current calendar year.
                   // `getDefaultAppState` initializes the state structure including `scenarios:{}`.
                   // `initScenarioData` creates the scenario object for "Base" of current year and adds it to `appState.scenarios`.
                  appState = getDefaultAppState(); // Reset appState to clean default template state
                  appState.currentYear = new Date().getFullYear(); // Ensure currentYear is current calendar year
                   initScenarioData(appState.currentYear); // Creates scenario '${appState.currentYear}_Base' and initializes it
                  finalActiveKey = `${appState.currentYear}_Base`; // The key of the newly created scenario
                   console.log(`Validation: Created initial scenario: ${finalActiveKey}.`);
              }


             // --- Set the FINAL Determined Active Scenario Key in App State ---
             appState.activeScenarioKey = finalActiveKey;


             // --- Synchronize appState.currentYear (again) to the Year of the FINAL Active Scenario ---
             // Get the scenario data object safely using the new key.
             const finalActiveScenarioData = appState.scenarios?.[appState.activeScenarioKey];
              // Ensure the scenario object exists and has a valid numeric year property.
             if (finalActiveScenarioData && typeof finalActiveScenarioData.year === 'number' && !isNaN(finalActiveScenarioData.year)) {
                  appState.currentYear = finalActiveScenarioData.year; // Sync currentYear using the definitive year from scenario data
             } else {
                 // This is a severe error case. The code should have ensured a valid scenario was set.
                  // If it still failed, log it. appState.currentYear might retain old bad value or default.
                  console.error(`Validation: Final active scenario "${appState.activeScenarioKey}" data corrupted or year invalid after validation. Cannot sync appState.currentYear correctly.`, finalActiveScenarioData);
                  // Fallback attempt for currentYear if necessary: try parsing key, then current year
                   // appState.currentYear = parseInt(appState.activeScenarioKey?.split('_')[0]) || new Date().getFullYear();
             }
             console.log(`Validation: Final active scenario key set to "${appState.activeScenarioKey}". appState.currentYear synchronized to ${appState.currentYear}.`);


             // --- Final Structure Consistency and Integrity Check on ALL Scenarios in state ---
             // After ensuring the scenarios object exists, an active key is set, and currentYear synced,
             // ensure ALL scenario data objects in `appState.scenarios` are structurally consistent and complete
             // with the current global settings (rubros, coefs, rubroConfig).
             // This is important after load, migration, validation, create, delete, or if settings were changed.
             // This call modifies scenarios in place and updates their `ipcManual` snapshots.
             console.log("Validation: Ensuring structural consistency for ALL scenarios in state based on current global settings...");
             Object.values(appState.scenarios || {}).forEach(scenario => {
                  // Process only if the scenario object itself is valid and not null/undefined/primitive
                 if(scenario && typeof scenario === 'object' && scenario !== null && !Array.isArray(scenario) && scenario.year !== undefined) {
                      // Pass the scenario object AND the current global settings for context
                     initializeScenarioDataForRubros(scenario, appState.settings);
                      // `initializeScenarioDataForRubros` also updates `scenario.calculated.ipcManual`
                   } else {
                     console.warn("Validation: Skipping structure initialization for an invalid scenario entry found in state.", scenario);
                     // Ideally, invalid scenario entries themselves would be cleaned from `appState.scenarios`.
                 }
             });


            // --- Save State ---
             // Save the entire application state, which now has a valid active scenario key,
             // potentially migrated/corrected settings, and consistent scenario structures.
             saveState();
             console.log("Validation complete. State saved. Proceeding to UI updates.");

            // UI will be updated based on this state by updateUI function which is called after this.
        }

        // Safely initializes/validates a single scenarioData object structure based on a provided settings object.
        // This is used by validateAndSetActiveScenario (to ensure consistency of all scenarios after load/changes)
        // and by initScenarioData (to structure a newly created empty scenario).
        // It ensures the presence and correct basic type/shape of nested data, monthStatus,
        // and calculated properties and sub-properties (like detail arrays being size 12)
        // based on the rubros and coefficient types defined in `currentSettings`.
        // It modifies the `scenarioData` object in place.
        // Returns true if the scenarioData structure was modified significantly (missing objects/arrays created, array size fixed etc).
        function initializeScenarioDataForRubros(scenarioData, currentSettings) {
            let structureChanged = false; // Flag to track if structure was modified

             // Input validation: Ensure `scenarioData` is a valid object/reference. `currentSettings` validity checked internally.
             if (!scenarioData || typeof scenarioData !== 'object') {
                console.warn("Structure initialization called without valid scenario data object.");
                return false; // Cannot proceed
             }

             // Ensure a valid settings object is available for structural definition lookup.
             // Use the provided currentSettings if valid, otherwise default to the template.
             const settingsForTemplate = (currentSettings && typeof currentSettings === 'object') ? currentSettings : getDefaultAppState().settings;
              if (settingsForTemplate !== currentSettings) console.warn("Structure init: Using default settings for template reference due to invalid currentSettings input.");


              // Get template parts from getDefaultAppState(). Use JSON parse/stringify for template consistency.
             const defaultTemplateParts = JSON.parse(JSON.stringify(getDefaultAppState().scenarios.BaseExample));


             // --- Ensure essential top-level structures within scenarioData exist ---
             // Ensure {gastos: [], ingresos: []} shape for rubroOrder if missing or invalid type.
             if (!isObject(scenarioData.rubroOrder)) { scenarioData.rubroOrder = { gastos: [], ingresos: [] }; structureChanged = true; console.warn("Structure init: Correcting rubroOrder structure."); }
             scenarioData.rubroOrder.gastos ??= []; // Ensure arrays exist
             scenarioData.rubroOrder.ingresos ??= [];

             // Ensure {gastos: {}, ingresos: {}} shape for data if missing or invalid type.
              if (!isObject(scenarioData.data)) { scenarioData.data = { gastos: {}, ingresos: {} }; structureChanged = true; console.warn("Structure init: Correcting data structure."); }
              scenarioData.data.gastos ??= {}; // Ensure objects exist
              scenarioData.data.ingresos ??= {};

             // Ensure {gastos: {}, ingresos: {}} shape for monthStatus if missing or invalid type.
              if (!isObject(scenarioData.monthStatus)) { scenarioData.monthStatus = { gastos: {}, ingresos: {} }; structureChanged = true; console.warn("Structure init: Correcting monthStatus structure."); }
              scenarioData.monthStatus.gastos ??= {}; // Ensure objects exist
              scenarioData.monthStatus.ingresos ??= {};

              // Ensure reserveFund structure. Preserve type if exists, default if not. Validate/correct values array.
             scenarioData.reserveFund = scenarioData.reserveFund ?? { type: 'percent', values: Array(12).fill(5) }; structureChanged = true; // Default if completely missing
              if (typeof scenarioData.reserveFund.type !== 'string' || (scenarioData.reserveFund.type !== 'percent' && scenarioData.reserveFund.type !== 'fixed')) {
                   console.warn(`Structure init: Reserve fund type invalid ("${scenarioData.reserveFund.type}"). Setting to default 'percent'.`);
                  scenarioData.reserveFund.type = 'percent';
                   structureChanged = true;
              }
             // Validate values array structure and content (12 numbers >= 0).
             if (!Array.isArray(scenarioData.reserveFund.values) || scenarioData.reserveFund.values.length !== 12 || !scenarioData.reserveFund.values.every(v => typeof v === 'number')) {
                  console.warn(`Structure init: Reserve fund values array for scenario year ${scenarioData.year} is missing/invalid structure. Resetting to default.`);
                  const defaultFillValue = scenarioData.reserveFund.type === 'fixed' ? 0 : 5; // Use the (now valid) scenario's type
                  scenarioData.reserveFund.values = Array(12).fill(defaultFillValue);
                   structureChanged = true;
             } else {
                 // Ensure values are non-negative (they represent percentages or amounts to add)
                 const correctedValues = scenarioData.reserveFund.values.map(v => v >= 0 ? v : 0);
                  if (JSON.stringify(correctedValues) !== JSON.stringify(scenarioData.reserveFund.values)) {
                       console.warn(`Structure init: Found negative reserve fund values. Correcting.`);
                       scenarioData.reserveFund.values = correctedValues;
                       structureChanged = true;
                  }
             }


             // Ensure calculated structure exists and has necessary top-level objects/arrays initialized correctly.
             // Use the default template structure. Keep existing properties, but fill missing arrays/objects.
              scenarioData.calculated ??= {}; structureChanged = true; // Ensure calculated object exists


              // Iterate through expected keys in default calculated template.
             Object.keys(defaultTemplateParts.calculated).forEach(calcKey => {
                 const defaultTemplateValue = defaultTemplateParts.calculated[calcKey]; // The value in the template (expected shape)
                 const scenarioValue = scenarioData.calculated[calcKey]; // The corresponding value in the scenario data


                  // Case 1: Key is missing or invalid in scenario data. Initialize it from the template.
                  // Check if missing (undefined/null) OR type mismatch vs template.
                  if (scenarioValue === undefined || scenarioValue === null || typeof scenarioValue !== typeof defaultTemplateValue) {
                       console.warn(`Structure init: Calculated key "${calcKey}" missing, null, or has wrong type. Resetting structure to template.`);
                      // Deep copy the template part using JSON to avoid reference issues.
                      scenarioData.calculated[calcKey] = JSON.parse(JSON.stringify(defaultTemplateValue));
                       structureChanged = true;
                   }
                  // Case 2: Key exists and type matches template, but it's a specific type that needs detailed structural validation (e.g. array of 12 numbers, object of objects).
                  else { // Key exists and typeof matches default template typeof

                       if (calcKey === 'annualTotals') {
                           // Ensure annualTotals itself is an object and its nested gastos/ingresos are objects with __TOTAL__
                           scenarioData.calculated.annualTotals ??= {__TOTAL__: 0}; if(!isObject(scenarioData.calculated.annualTotals)){ scenarioData.calculated.annualTotals = {__TOTAL__:0}; structureChanged=true;}
                           scenarioData.calculated.annualTotals.gastos ??= {__TOTAL__: 0}; if(!isObject(scenarioData.calculated.annualTotals.gastos)){ scenarioData.calculated.annualTotals.gastos={__TOTAL__:0}; structureChanged=true;}
                           scenarioData.calculated.annualTotals.ingresos ??= {__TOTAL__: 0}; if(!isObject(scenarioData.calculated.annualTotals.ingresos)){ scenarioData.calculated.annualTotals.ingresos={__TOTAL__:0}; structureChanged=true;}


                           // Check existing rubro-specific annual totals - if they exist, ensure they are numbers, default to 0 if not.
                           ['gastos', 'ingresos'].forEach(type => {
                               if (isObject(scenarioData.calculated.annualTotals[type])) { // Ensure parent is an object
                                    Object.keys(scenarioData.calculated.annualTotals[type]).forEach(rubroKey => {
                                         if (rubroKey === '__TOTAL__') return; // Skip __TOTAL__, handled above
                                         const annualTotalValue = scenarioData.calculated.annualTotals[type][rubroKey];
                                         if (typeof annualTotalValue !== 'number' || isNaN(annualTotalValue)) {
                                             console.warn(`Structure init: Annual total for rubro "${type}/${rubroKey}" is not a number (${annualTotalValue}). Resetting to 0.`);
                                            scenarioData.calculated.annualTotals[type][rubroKey] = 0;
                                            structureChanged = true;
                                         }
                                     });
                                } else {
                                     // Should not happen given nullish coalescing assignment above, but defensive log
                                     console.warn(`Structure init: calculated.annualTotals.${type} expected object but is not.`);
                                }
                           });
                            // Other top-level annualTotals (fondoReserva, cuotaSobreGastos etc) are single numbers - check if numeric
                           ['fondoReserva', 'cuotaSobreGastos', 'cuotaIpc', 'cuotaRealBase'].forEach(singleTotalKey => {
                                if (typeof scenarioData.calculated.annualTotals[singleTotalKey] !== 'number' || isNaN(scenarioData.calculated.annualTotals[singleTotalKey])) {
                                     console.warn(`Structure init: calculated.annualTotals.${singleTotalKey} is not a number (${scenarioData.calculated.annualTotals[singleTotalKey]}). Resetting to 0.`);
                                     scenarioData.calculated.annualTotals[singleTotalKey] = 0; structureChanged = true;
                                }
                           });

                       } else if (Array.isArray(defaultTemplateValue) && defaultTemplateValue.length > 0) { // Covers expected arrays like monthly totals or ipcManual (if default >0 length)
                           // Check if scenarioValue is an array of the same expected length and contains only numbers.
                           if (!Array.isArray(scenarioValue) || scenarioValue.length !== defaultTemplateValue.length || !scenarioValue.every(v => typeof v === 'number')) {
                                console.warn(`Structure init: Calculated array "${calcKey}" invalid size or contains non-numbers. Resetting to 0s.`);
                              // Reset to an array of zeros with the correct length from the template.
                              scenarioData.calculated[calcKey] = Array(defaultTemplateValue.length).fill(0);
                              structureChanged = true;
                           } else {
                                // If array exists and has correct shape/numeric content, just ensure values are non-negative for relevant ones (e.g. Cuota types)
                                // Most calculated monthly totals/rates can be positive or negative theoretically.
                                // But specifically Cuota IPC/Cuota Real Base/Cuota s/Gs should ideally be non-negative unless errors. Let's ensure 0 is min.
                                if (['cuotaIpcMes', 'cuotaRealBaseMes', 'cuotaSobreGastosMes', 'fondoReservaMes', 'totalGastoProyectadoMes', 'totalIngresoProyectadoMes'].includes(calcKey)) {
                                    const correctedValues = scenarioValue.map(v => v >= 0 ? v : 0);
                                     if (JSON.stringify(correctedValues) !== JSON.stringify(scenarioValue)) {
                                        console.warn(`Structure init: Found negative values in calculated array "${calcKey}". Correcting to >= 0.`);
                                         scenarioData.calculated[calcKey] = correctedValues; structureChanged = true;
                                     }
                                 } else if (calcKey === 'ipcManual') {
                                    // Ensure ipcManual values are non-negative (they represent percentage increase/stability).
                                     const correctedValues = scenarioValue.map(v => typeof v === 'number' && v >= 0 ? v : 0);
                                     if (JSON.stringify(correctedValues) !== JSON.stringify(scenarioValue)) {
                                        console.warn(`Structure init: Found invalid/negative values in calculated ipcManual array. Correcting to >= 0.`);
                                         scenarioData.calculated[calcKey] = correctedValues; structureChanged = true;
                                     }
                                 }
                               // Else array is fine, keep as is.
                            }

                       } else if (isObject(defaultTemplateValue)) { // Covers expected objects that contain rubro keys, like gastoAjustado, totalGastoRubroMes etc.
                           // Ensure scenarioValue itself is an object (already checked in parent if).
                           // For these, iterate through keys *currently present* in the scenario's calculated object
                           // for this key and validate their corresponding structures (usually array of 12 numbers).
                            Object.keys(scenarioValue).forEach(rubroKey => { // Iterate keys currently in the scenario's calculated object for calcKey (e.g., Object.keys(scenarioData.calculated.gastoAjustado))
                                const detailOrMonthlyArray = scenarioValue[rubroKey];

                                 // If checking totalGastoRubroMes/totalIngresoRubroMes (Expected: rubroKey -> [v1..v12] Array)
                                 if (['totalGastoRubroMes', 'totalIngresoRubroMes'].includes(calcKey)) {
                                      // Check if the value is an array of 12 numbers. If not, log and remove the entry.
                                     if (!Array.isArray(detailOrMonthlyArray) || detailOrMonthlyArray.length !== 12 || !detailOrMonthlyArray.every(v => typeof v === 'number')) {
                                         console.warn(`Structure init: Calculated monthly totals array for "${calcKey}.${rubroKey}" is invalid. Removing.`);
                                        delete scenarioValue[rubroKey]; // Remove corrupted entry
                                         structureChanged = true;
                                     }
                                }
                                // If checking gastoAjustado/ingresoAjustado (Expected: rubroKey -> {detailName: [v1..v12] Object})
                                else if (['gastoAjustado', 'ingresoAjustado'].includes(calcKey)) {
                                      // Check if the value is an object. If not, log and remove the entry.
                                     if (!isObject(detailOrMonthlyArray)) {
                                         console.warn(`Structure init: Calculated details object for "${calcKey}.${rubroKey}" is not an object. Removing.`);
                                         delete scenarioValue[rubroKey]; // Remove corrupted entry
                                         structureChanged = true;
                                         return; // Stop validating this rubro's calculated details object
                                    } else {
                                         // If it is an object, check each detail key *within* it.
                                         Object.keys(detailOrMonthlyArray).forEach(detailKey => {
                                             const detailArray = detailOrMonthlyArray[detailKey]; // Array for this detail

                                             // This detail array must be an array of 12 numbers. If not, log and remove the detail entry.
                                              if (!Array.isArray(detailArray) || detailArray.length !== 12 || !detailArray.every(v => typeof v === 'number')) {
                                                  console.warn(`Structure init: Calculated detail array "${calcKey}.${rubroKey}.${detailKey}" invalid. Removing.`);
                                                 delete detailOrMonthlyArray[detailKey]; // Remove corrupted detail array entry
                                                 structureChanged = true;
                                              }
                                         }); // End detailKey loop within rubro
                                          // If rubro object is now empty after cleaning corrupted details, consider removing it?
                                          // Decision: Only remove rubro keys from calculated objects if they are not defined in settings anymore. This is handled by cleanup logic below.
                                    }
                               } // End check for gastoAjustado/ingresoAjustado type objects


                            }); // End loop over rubro keys currently present in the calculated object


                           // --- Add missing rubro keys to calculated objects based on Settings lists ---
                           // For calculated objects (like totalGastoRubroMes, totalIngresoRubroMes, gastoAjustado, ingresoAjustado)
                           // ensure that entries corresponding to ANY rubro listed in the GLOBAL SETTINGS
                           // are present, adding them if they are missing. Initialize them with empty structures or zeros.
                           const relevantRubrosForCalcKey = (type === 'gastos' ? settingsForTemplate.rubros?.gastos : settingsForTemplate.rubros?.ingresos) || [];
                           const calcObjectType = defaultTemplateParts.calculated[calcKey]; // Expected type from template

                            relevantRubrosForCalcKey.forEach(rubroKey => {
                                 // If the rubro key from settings is missing in the scenarioValue object...
                                 if (scenarioValue[rubroKey] === undefined) { // Check for undefined, NOT null
                                      console.log(`Structure init: Adding missing calculated entry for settings rubro "${calcKey}.${rubroKey}".`);
                                      // Add the default structure based on the TEMPLATE for this calculated key's expected content.
                                      // If template expects an object ({}), add {}. If template expects array ([..]), add array of 0s.
                                      if (isObject(calcObjectType?.[rubroKey] ?? defaultTemplateValue?.[rubroKey] ?? defaultTemplateValue)) { // Is the expected value an object (e.g. details within gastoAjustado, or rubro total object if that's shape) or is the parent object itself expected? Check in template if template has a shape for this key or a nested shape. Use fallback to checking the template's own shape.
                                           scenarioValue[rubroKey] = {}; // Default is an empty object for this rubro entry
                                       } else if (Array.isArray(calcObjectType?.[rubroKey] ?? defaultTemplateValue?.[rubroKey] ?? defaultTemplateValue) && (calcObjectType?.[rubroKey] ?? defaultTemplateValue?.[rubroKey] ?? defaultTemplateValue).length >= 12) { // Is expected value an array of >=12 numbers?
                                            scenarioValue[rubroKey] = Array(12).fill(0); // Default is an array of 12 zeros
                                        } else {
                                            // Default to an empty object if template shape is unclear or primitive/other.
                                            scenarioValue[rubroKey] = {};
                                             console.warn(`Structure init: Default structure for calculated.${calcKey}.${rubroKey} unclear from template. Adding empty object.`);
                                        }
                                      structureChanged = true; // Structure was changed
                                 } // End if missing
                             }); // End loop over relevant rubros for this calcKey type object


                            // --- Clean up rubro keys *within* these calculated objects (like totalGastoRubroMes, gastoAjustado)
                            // that are NOT present in the global settings rubro lists anymore. ---
                           // Get keys *currently present* in the scenario's calculated object for this calculatedKey (e.g., Object.keys(scenarioData.calculated.totalGastoRubroMes)).
                           Object.keys(scenarioValue).forEach(currentCalcRubroKey => {
                                // Check if this rubroKey exists in EITHER the global settings.rubros.gastos list OR settings.rubros.ingresos list.
                                const isInSettingsList = (settingsForTemplate.rubros?.gastos || []).includes(currentCalcRubroKey) || (settingsForTemplate.rubros?.ingresos || []).includes(currentCalcRubroKey);

                                // If the rubro key is NOT found in any global rubro list AND it's not the '__TOTAL__' key (which is a valid key in annual totals), remove the entry.
                                // __TOTAL__ is a valid key only within calculated.annualTotals.gastos and calculated.annualTotals.ingresos.
                                const isTotalKeyInAnnuals = currentCalcRubroKey === '__TOTAL__' && (calcKey === 'annualTotals.gastos' || calcKey === 'annualTotals.ingresos'); // Not ideal check format

                                 // More general check: Only delete if NOT in settings lists AND NOT expected as a non-rubro key at this level (currently only __TOTAL__ in annualTotals).
                                if (!isInSettingsList) {
                                      // Check if this key is __TOTAL__ AND the parent calculated key indicates it should be an annual total object keyed by rubro (like annualTotals.gastos)
                                      const isTotalKeyInAnnualsObject = currentCalcRubroKey === '__TOTAL__' && ['annualTotals.gastos', 'annualTotals.ingresos'].includes(calcKey);

                                      if (!isTotalKeyInAnnualsObject) { // Only delete if it's an orphaned rubro key or other unexpected key
                                           console.log(`Structure init: Calculated entry for "${calcKey}.${currentCalcRubroKey}" exists but rubro is not in settings lists or is not expected non-rubro key. Removing entry.`);
                                          delete scenarioValue[currentCalcRubroKey];
                                          structureChanged = true;
                                      }
                                 }
                             }); // End cleanup loop over current keys
                       }
                       // Other primitive calculated values (fondoReserva etc at top level of calculated) are already handled by initial type check or arrays check.
                  }
             }); // End iteration over default template calc keys


              // Final consistency check for structures that hold rubros/details (data, monthStatus)
              ['data', 'monthStatus'].forEach(parentKey => {
                   ['gastos', 'ingresos'].forEach(type => {
                       // Get the object for this type within the parent (e.g., scenarioData.data.gastos). Ensure it's an object.
                       const typeObject = scenarioData[parentKey]?.[type];
                        if (!isObject(typeObject)) return; // Skip if type object doesn't exist or is wrong type (handled earlier, but defensive)


                       // Clean up rubro keys *within* these objects (data.gastos, data.ingresos, monthStatus.gastos/ingresos)
                       // that are NOT present in the global settings rubro lists anymore.
                       const settingsRubrosForType = settingsForTemplate.rubros?.[type] || [];

                       // Iterate over keys *currently present* in the scenario's object for this parent/type.
                       Object.keys(typeObject).forEach(rubroKey => {
                           // If the rubro key is NOT found in the global settings rubros list for this type...
                           if (!settingsRubrosForType.includes(rubroKey)) {
                                console.warn(`Structure init: Entry for "${parentKey}.${type}.${rubroKey}" exists but rubro is not in settings list. Removing entry.`);
                               delete typeObject[rubroKey]; // Remove the orphaned rubro entry
                               structureChanged = true;
                           } else {
                                // If rubro key IS in settings list, ensure its internal structure is okay (detailsData object/array, detailOrder array etc).
                                // --- Detail Level Structure Validation ---
                                if (parentKey === 'data') {
                                     const rubroDataObject = typeObject[rubroKey]; // Object mapping detail names to monthly data arrays
                                     // Ensure it's an object
                                     if (!isObject(rubroDataObject)) { console.warn(`Structure init: data.${type}.${rubroKey} expected object but is not. Removing rubro entry.`); delete typeObject[rubroKey]; structureChanged=true; return; }
                                     // Ensure detailOrder is an array
                                     rubroDataObject.detailOrder ??= []; if (!Array.isArray(rubroDataObject.detailOrder)) { console.warn(`Structure init: data.${type}.${rubroKey}.detailOrder not array. Resetting.`); rubroDataObject.detailOrder = []; structureChanged=true; }
                                     // Ensure detailsData is an object
                                     rubroDataObject.detailsData ??= {}; if (!isObject(rubroDataObject.detailsData)) { console.warn(`Structure init: data.${type}.${rubroKey}.detailsData not object. Resetting.`); rubroDataObject.detailsData = {}; structureChanged=true;}

                                     // Clean up detail keys *within* detailsData/detailOrder that don't match each other.
                                     const detailsDataKeys = Object.keys(rubroDataObject.detailsData); // Get keys from detailsData object
                                     // Filter detailOrder array to keep only keys that also exist in the detailsData object.
                                     const correctedDetailOrder = rubroDataObject.detailOrder.filter(dk => detailsDataKeys.includes(dk));
                                      if (JSON.stringify(correctedDetailOrder) !== JSON.stringify(rubroDataObject.detailOrder)){
                                          console.warn(`Structure init: Correcting detailOrder for "${type}.${rubroKey}" based on detailsData existence.`);
                                           rubroDataObject.detailOrder = correctedDetailOrder;
                                           structureChanged = true;
                                      }
                                      // Also add any keys from detailsData that are *missing* in detailOrder (might happen from old Excel loads).
                                       detailsDataKeys.forEach(dk => {
                                           if (!rubroDataObject.detailOrder.includes(dk)){
                                                console.warn(`Structure init: Detail "${rubroKey}/${dk}" found in detailsData but not in detailOrder. Adding to order.`);
                                                rubroDataObject.detailOrder.push(dk);
                                                structureChanged = true;
                                           }
                                       });
                                        // Sort detailOrder after adding/cleaning.
                                      rubroDataObject.detailOrder.sort((a,b) => a.localeCompare(b));
                                       // Ensure monetary arrays within detailsData are 12 numbers >= 0. (Already done in migrateState / processSheetData robustness)

                                } else if (parentKey === 'monthStatus' && type === 'gastos') {
                                    // monthStatus for gastos maps rubro -> { detail: [s1..s12] }
                                     const rubroStatusObject = typeObject[rubroKey]; // Object mapping detail names to status arrays
                                     // Ensure it's an object
                                     if (!isObject(rubroStatusObject)) { console.warn(`Structure init: monthStatus.${type}.${rubroKey} expected object but is not. Removing rubro entry.`); delete typeObject[rubroKey]; structureChanged=true; return; }

                                     // Clean up detail keys *within* monthStatus that don't match details in the *data* structure for this rubro.
                                     // Need to access the corresponding data object's detail keys to filter status.
                                     const correspondingDetailsDataKeys = Object.keys(scenarioData.data?.[type]?.[rubroKey]?.detailsData || {}); // Safely get keys from data object details

                                      Object.keys(rubroStatusObject).forEach(detailKey => {
                                           // If status exists for a detail BUT that detail does not exist in the corresponding data object's detailsData...
                                           if (!correspondingDetailsDataKeys.includes(detailKey)) {
                                                console.warn(`Structure init: monthStatus entry exists for detail "${rubroKey}/${detailKey}" but corresponding data entry is missing. Removing monthStatus entry.`);
                                               delete rubroStatusObject[detailKey];
                                                structureChanged = true;
                                            } else {
                                                 // If corresponding data exists, ensure status array is array of 12 strings.
                                                const statusArray = rubroStatusObject[detailKey];
                                                 if (!Array.isArray(statusArray) || statusArray.length !== 12 || !statusArray.every(s => typeof s === 'string')) {
                                                      console.warn(`Structure init: monthStatus array for detail "${rubroKey}/${detailKey}" corrupted. Resetting to 'Estimado'.`);
                                                      rubroStatusObject[detailKey] = Array(12).fill('Estimado'); // Reset array
                                                      structureChanged = true;
                                                 }
                                            }
                                         }); // End detailKey loop within rubroStatus object

                                     // Add missing status arrays if detail exists in data but status is missing (e.g., new detail loaded in Excel)
                                      correspondingDetailsDataKeys.forEach(detailKey => {
                                           if (rubroStatusObject[detailKey] === undefined) {
                                               console.log(`Structure init: Status missing for detail "${rubroKey}/${detailKey}". Adding default 'Estimado' array.`);
                                               rubroStatusObject[detailKey] = Array(12).fill('Estimado');
                                               structureChanged = true;
                                           }
                                       });


                               } // End monthStatus validation
                            }
                       }); // End rubroKey loop within type object

                   }); // End type loop (gastos/ingresos)

             }); // End parentKey loop (data/monthStatus)


             // console.log(`Initialization for scenario structure completed. Structure changed: ${structureChanged}.`, scenarioData);
             // Return whether the scenarioData structure object was modified during this process.
             return structureChanged;

         }
    </script>

<!-- Keeping old commented blocks just in case for reference during development, but these are likely obsolete -->
<!-- Toggle Rubros -->
<script>
// Old Toggle Rubros script - The main script now uses event delegation for this
// This block is likely vestigial.
/*
// Note: This section seems to be remnants of an older toggle implementation.
// The current toggle logic uses event delegation on the table rows themselves
// via addCollapsibleListeners and toggleRubroDetails. Keeping it here
// for now just in case, but it might not be actively used by the main script.
// Consider removing if testing confirms it's unused.
function initRubrosToggle(){
  document.querySelectorAll('.rubro-header').forEach(h=>{
    h.addEventListener('click', ()=> toggleDetail(h));
  });
}
function toggleDetail(header){
  const detail = header.nextElementSibling;
  if(detail){
    detail.classList.toggle('collapsed');
    const icon = header.querySelector('.arrow');
    if(icon) icon.textContent = detail.classList.contains('collapsed') ? '▼' : '▲';
  }
}
// Botones globales
function toggleSection(sectionId, collapse){
  document.querySelectorAll('#'+sectionId+' .rubro-detail').forEach(d=>{
     if(collapse===undefined){
        d.classList.toggle('collapsed');
     }else{
        d.classList.toggle('collapsed', collapse);
     }
  });
  // actualizar iconos
  document.querySelectorAll('#'+sectionId+' .rubro-header .arrow').forEach(i=>{
     const header=i.closest('.rubro-header');
     const det=header.nextElementSibling;
     i.textContent = det.classList.contains('collapsed') ? '▼':'▲';
  });
}
// document.addEventListener('DOMContentLoaded', initRubrosToggle); // This line is likely commented out or should be if not used.
*/
</script>
<!-- End Toggle Rubros -->


<!-- Expensa Real Auto‑Fill v4 -->
<script>
// Old Auto-Fill script for Expensa Real - This functionality is now fully
// integrated into the calculateAll function which computes the value directly
// from the main Ord Expensa rubro and UF count. This block is vestigial and
// could potentially cause issues if uncommented. Keeping it commented out.
/*
// Note: This script seems to be an old attempt to auto-fill the "Expensa Real"
// column based on an old data structure (appState.ingresos).
// The main script now calculates calculated.cuotaRealBaseMes directly from
// scenarioData.data.ingresos[CUOTA_RUBRO_NAME].detailsData, which is more robust.
// This script is likely obsolete and could be removed. It might interfere or
// be redundant. Let's keep it commented out or remove it entirely to avoid confusion.
// The patching part commented out in the previous version reinforces its obsolescence.
// Leave this block commented entirely.
(function(){
  const FULL = ['enero','febrero','marzo','abril','mayo','junio','julio','agosto','septiembre','octubre','noviembre','diciembre'];
  const ABBR = ['ene','feb','mar','abr','may','jun','jul','ago','sep','oct','nov','dic'];

  function findMonthIndex(key){
     key = key.toLowerCase().trim();
     if(key.match(/^m\d+$/)) return parseInt(key.slice(1))-1;
     let idx = FULL.indexOf(key);
     if(idx>-1) return idx;
     idx = ABBR.indexOf(key.slice(0,3));
     return idx;
  }

  function getExpensasRow(){
     // This structure appState.ingresos no longer exists in the current state structure
     // It was likely from a previous version
     if(!window.appState || !appState.ingresos) return null;
     return appState.ingresos.find(r=>{
       const rub=(r.rubro||'').toString().toLowerCase().trim();
       const det=(r.detalle||'').toString().toLowerCase().trim();
       return rub==='expensas' && det==='expensas ordinarias';
     });
  }

  function getMonthlyArray(row){
     const arr = new Array(12).fill(0);
     if(!row) return arr;
     Object.entries(row).forEach(([k,v])=>{
        const idx = findMonthIndex(k);
        if(idx>=0 && idx<12) arr[idx]=Number(v||0;
     });
     return arr;
  }

  function writeToTable(){
     const table=document.querySelector('#dashboard-summary');
     if(!table) return false;
     // Search for the column index
     let colIdx = -1;
     const headers = table.querySelectorAll('thead th');
     for(let i=0; i < headers.length; i++){
        if (headers[i].textContent.toLowerCase().includes('expensa real ($/uf)')) {
           colIdx = i;
           break;
        }
        if (headers[i].textContent.toLowerCase().includes('expensa real ($)')) { // Fallback to older name
            colIdx = i;
            break;
        }
     }

     if(colIdx === -1) {
         // console.warn("Expensa Real column not found in summary table header.");
         return false; // Column not found
     }


     const rows=table.querySelectorAll('tbody tr');
     if(rows.length < 12) {
         // console.warn("Summary table tbody doesn't have 12 rows yet.");
         return false; // Table not fully populated yet
     }

     // This part relies on the old data structure and function, which is no longer used.
     // The main calculateAll already populates the cuotaRealBaseMes and updates the summary table correctly.
     // So, the data obtained here would likely be from the old, defunct structure.
     // Calling this part would try to write potentially incorrect/stale data.
     // const data=getMonthlyArray(getExpensasRow());
     // if(data.every(v => v === 0)){
         // console.log("Old Expensa Real data is all zeros, likely not populated in old structure.");
         // return true; // Found column, but no data in old structure, assume modern code will handle
     // }

     // const fmt=new Intl.NumberFormat('es-AR',{style:'currency',currency:'ARS',minimumFractionDigits:2});
     // data.forEach((val,i)=>{
         // If the cell *already* has content (meaning the main script populated it), don't overwrite.
     //    if(i < rows.length && rows[i].children[colIdx].textContent.trim() === formatCurrency(0).trim()){ // Only overwrite if cell is effectively $0.00
     //       rows[i].children[colIdx].textContent=fmt.format(val);
     //    }
     // });

     return true; // Indicate that the column was found
  }

  // function waitAndWrite(attempt=0){
  //    if(writeToTable()) return; // Stop waiting once column is found
  //    if(attempt<20) setTimeout(()=>waitAndWrite(attempt+1),300); // Retry for a few seconds
  // }

  // The patching functions (patching handleFileUpload, cargarEscenario) are also obsolete
  // as they rely on the old flow. Remove or leave commented. Keeping commented for history.

  // Instead of patching or trying to run writeToTable manually, this entire block
  // related to auto-filling the old Expensa Real from an old structure should be removed.
  // The functionality is replaced by calculateAll populating calculated.cuotaRealBaseMes
  // which is then displayed correctly by updateDashboardTables.
  // If the column is still not colored correctly after this v2.7 update, the CSS or
  // updateDashboardTables logic for colors might need refinement, NOT adding back old auto-fill.
})();
*/
</script>

</body>
</html>
