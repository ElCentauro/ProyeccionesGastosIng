<!DOCTYPE html>

<html lang="es">
<head>
<!-- build: 09-May-25 v3 (early toNumber) -->
<script>
/* Early global toNumber to guarantee availability */
window.toNumber = function toNumber(val){
    if (typeof val === 'number') return val;
    if (val === null || val === undefined) return 0;
    let s = val.toString().trim().replace(/[$\s]/g, '').replace(/\./g, '');
    s = s.replace(/,/g, '.');
    const n = parseFloat(s);
    return isNaN(n) ? 0 : n;
};
console.log('%c⚙️ Global toNumber injected (v3)','color:green');
</script>

<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<!-- Favicon -->
<link href="favicon.png" rel="icon" type="image/png"/>
<title>Proyección Expensas - Barrio El Centauro</title>
<!-- Librería SheetJS (js-xlsx) para leer/escribir Excel -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
<!-- Librería Chart.js para gráficos -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- Plugin doughnut 3D shadow -->
<script>
/* Plugin: doughnutShadow3D
   Añade una sombra suave debajo de cada porción para simular profundidad 3 D.
   Seguro para todos los datasets (evita NaN en createRadialGradient). */
const doughnutShadow3D = {
  id: 'doughnutShadow3D',
  afterDatasetDraw(chart, args, opts) {
    const {ctx} = chart;
    if (args.meta.type !== 'doughnut') return;

    args.meta.data.forEach(segment => {
      const {x, y, startAngle, endAngle, innerRadius, outerRadius} = segment;
      if (!isFinite(x) || !isFinite(y) || !isFinite(innerRadius) || !isFinite(outerRadius)) return;

      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.15)';      // shadow color
      ctx.translate(0, 4);                     // vertical offset
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.arc(x, y, outerRadius, startAngle, endAngle);
      ctx.arc(x, y, innerRadius, endAngle, startAngle, true);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    });
  }
};
// Registrar plugin globalmente
if (window.Chart && !Chart.registry.plugins.get('doughnutShadow3D')) {
  Chart.register(doughnutShadow3D);
}
</script>
<!-- Font Awesome para iconos -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet"/>
<!-- Google Fonts (Inter) -->
<link href="https://fonts.googleapis.com" rel="preconnect"/>
<link crossorigin="" href="https://fonts.gstatic.com" rel="preconnect"/>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&amp;display=swap" rel="stylesheet"/>
<style>
        /* --- Reset Básico y Fuentes --- */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; /* Base font size */ }
        body {
            font-family: 'Inter', 'Segoe UI', sans-serif;
            line-height: 1.7; /* Improved readability */
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* --- Variables de Color (Paleta Refinada) --- */
        :root {
            --bg-color: #f8f9fa;              /* Slightly off-white */
            --text-color: #343a40;            /* Darker gray */
            --primary-color: #007bff;          /* Classic blue */
            --primary-color-darker: #0056b3;   /* Darker blue for hover */
            --secondary-color: #6c757d;        /* Standard gray */
            --secondary-color-darker: #5a6268; /* Darker gray for hover */
            --accent-color: #28a745;           /* Vibrant green */
            --accent-color-darker: #218838;    /* Darker green for hover */
            --danger-color: #dc3545;           /* Red */
            --danger-color-darker: #c82333;    /* Darker red */
            --warning-color: #ffc107;           /* Yellow */
            --warning-color-darker: #e0a800;   /* Darker yellow */
            --info-color: #17a2b8;             /* Teal */
            --info-color-darker: #138496;      /* Darker teal */
            --success-color: var(--accent-color); /* Alias for consistency */
            --success-color-darker: var(--accent-color-darker); /* Alias */

            --border-color: #dee2e6;           /* Light gray border */
            --header-bg: #ffffff;              /* White header */
            --card-bg: #ffffff;                /* White cards */
            --shadow-color: rgba(0, 0, 0, 0.08); /* Softer shadow */
            --input-bg: #ffffff;
            --input-border: #ced4da;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(0, 123, 255, 0.25);
            --button-text: #ffffff;
            --button-warning-text: #212529; /* Dark text for yellow button */
            --table-header-bg: #eef2f7;        /* Lighter table header */
            --table-row-hover: #f1f3f5;        /* Subtle hover */
            --expandable-row-bg: #f8f9fa;      /* Same as body bg for subtle diff */
            --clickable-row-hover: #e9ecef;    /* Slightly darker hover for clickable rows */
            --disabled-bg: #e9ecef;
            --disabled-text: #6c757d;
            --disabled-border: #ced4da;

            /* >>> COLORES REAL/ESTIMADO <<< */
            --real-month-bg: #d1f7d9; /* Light, fresh green */
            --estimated-month-bg: #fff3cd; /* Soft Yellow */
             --estimated-month-border: #ffda6a; /* Yellow border for input */
        }

        body.dark-mode {
            --bg-color: #1a1a1a;              /* Very dark gray */
            --text-color: #e0e0e0;            /* Light gray text */
            --primary-color: #58a6ff;          /* Brighter blue */
            --primary-color-darker: #79b8ff;   /* Lighter blue for hover */
            --secondary-color: #8b949e;        /* Lighter gray */
            --secondary-color-darker: #a0a8b0; /* Lighter gray hover */
            --accent-color: #56d364;           /* Brighter green */
            --accent-color-darker: #6bde7a;    /* Lighter green hover */
            --danger-color: #f85149;           /* Bright red */
            --danger-color-darker: #fa6a61;    /* Lighter red */
            --warning-color: #f0b41e;          /* Bright yellow */
            --warning-color-darker: #f2c037;   /* Lighter yellow */
            --info-color: #6cb6f1;             /* Bright teal */
            --info-color-darker: #85c3f4;      /* Lighter teal */
            --success-color: var(--accent-color);
            --success-color-darker: var(--accent-color-darker);

            --border-color: #444c56;           /* Darker border */
            --header-bg: #2c2c2c;              /* Dark card background */
            --card-bg: #2c2c2c;                /* Dark card background */
            --shadow-color: rgba(255, 255, 255, 0.05); /* Subtle white shadow */
            --input-bg: #3a3f44;
            --input-border: #5a6268;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(88, 166, 255, 0.25);
            --button-text: #1a1a1a; /* Dark text on bright buttons */
            --button-warning-text: #1a1a1a;
            --table-header-bg: #343a40;        /* Darker header */
            --table-row-hover: #3e444a;        /* Subtle dark hover */
            --expandable-row-bg: #343a40;      /* Darker expandable row bg */
            --clickable-row-hover: #495057;    /* Darker hover for clickable */
            --disabled-bg: #495057;
            --disabled-text: #adb5bd;
            --disabled-border: #5a6268;

            /* >>> COLORES REAL/ESTIMADO OSCURO <<< */
            --real-month-bg: #1c4a2b; /* Darker Green */
            --estimated-month-bg: #5a4a1d; /* Dark Yellow/Brown */
            --estimated-month-border: #f0b41e; /* Brighter Yellow border for input */
        }

        /* --- Estilos Generales --- */
        .container { width: 95%; max-width: 1700px; margin: 0 auto; padding: 25px 20px; }
        h1, h2, h3, h4 { color: var(--primary-color); margin-bottom: 1em; font-weight: 600; }
        h1 { font-size: 2.2rem; text-align: center; }
        h2 { font-size: 1.8rem; border-bottom: 2px solid var(--accent-color); padding-bottom: 0.4em; }
        h3 { font-size: 1.4rem; margin-top: 1.8em; }
        h4 { font-size: 1.15rem; color: var(--secondary-color); margin-top: 1.2em; margin-bottom: 0.6em; }
        a { color: var(--primary-color); text-decoration: none; transition: color 0.2s ease; }
        a:hover { color: var(--primary-color-darker); text-decoration: underline; }

        button {
            padding: 12px 22px;
            border: 1px solid transparent; /* Added border for consistency */
            border-radius: 6px;
            background-color: var(--primary-color);
            color: var(--button-text);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out, transform 0.1s ease, box-shadow 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center; /* Center content */
            gap: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            line-height: 1.5; /* Ensure consistent height */
            text-align: center; /* Ensure text aligns center */
        }
        button:hover {
            background-color: var(--primary-color-darker);
            border-color: var(--primary-color-darker);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        button:focus {
            outline: none;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        button:disabled {
            background-color: var(--disabled-bg);
            color: var(--disabled-text);
            border-color: var(--disabled-border);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        button i { margin-right: 2px; /* Keep small margin */ }

        /* Button variants */
        .button-primary { background-color: var(--primary-color); border-color: var(--primary-color); color: var(--button-text); }
        .button-primary:hover { background-color: var(--primary-color-darker); border-color: var(--primary-color-darker); }
        .button-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: var(--button-text); }
        .button-secondary:hover { background-color: var(--secondary-color-darker); border-color: var(--secondary-color-darker); }
        .button-success { background-color: var(--success-color); border-color: var(--success-color); color: var(--button-text); }
        .button-success:hover { background-color: var(--success-color-darker); border-color: var(--success-color-darker); }
        .button-danger { background-color: var(--danger-color); border-color: var(--danger-color); color: var(--button-text); }
        .button-danger:hover { background-color: var(--danger-color-darker); border-color: var(--danger-color-darker); }
        .button-warning { background-color: var(--warning-color); border-color: var(--warning-color); color: var(--button-warning-text); }
        .button-warning:hover { background-color: var(--warning-color-darker); border-color: var(--warning-color-darker); }
        .button-info { background-color: var(--info-color); border-color: var(--info-color); color: var(--button-text); }
        .button-info:hover { background-color: var(--info-color-darker); border-color: var(--info-color-darker); }
        .button-sm { padding: 6px 12px; font-size: 0.85rem; gap: 6px;}

        /* --- Header --- */
        header {
            background-color: var(--header-bg);
            padding: 15px 0;
            box-shadow: 0 2px 5px var(--shadow-color);
            position: sticky; top: 0; z-index: 1000;
            border-bottom: 1px solid var(--border-color);
        }
        header .container { display: flex; justify-content: space-between; align-items: center; padding-top: 0; padding-bottom: 0; }
        .app-title { font-size: 1.6rem; font-weight: 700; color: var(--primary-color); }
        #theme-toggle { font-size: 1.3rem; background: none; border: none; color: var(--text-color); cursor: pointer; padding: 5px; border-radius: 50%; transition: background-color 0.2s;}
        #theme-toggle:hover { background-color: var(--table-row-hover); }

        /* --- Navegación / Pestañas --- */
        .tabs {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 5px;
        }
        .tab-link {
            padding: 12px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-bottom: -1px; /* Overlap bottom border */
            background-color: transparent;
            color: var(--secondary-color);
            font-size: 1rem;
            font-weight: 600;
            border-radius: 6px 6px 0 0;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            display: inline-flex; /* Align icon and text */
            align-items: center;
            gap: 8px;
        }
        .tab-link:hover {
             color: var(--primary-color);
             background-color: var(--table-row-hover);
        }
        .tab-link.active {
            background-color: var(--card-bg);
            border-color: var(--border-color);
            border-bottom-color: var(--card-bg); /* Hide bottom border part */
            color: var(--primary-color);
            font-weight: 700;
        }
        .tab-content {
            display: none;
            padding: 30px;
            border: 1px solid var(--border-color);
            border-top: none;
            background-color: var(--card-bg);
            border-radius: 0 0 6px 6px;
            box-shadow: 0 5px 15px var(--shadow-color);
        }
        .tab-content.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Formularios y Entradas --- */
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-color); font-size: 0.95rem;}
        input[type="text"], input[type="number"], input[type="file"], select, textarea {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid var(--input-border);
            border-radius: 6px;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        input:focus, select:focus, textarea:focus {
            border-color: var(--input-focus-border);
            outline: 0;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        input:disabled, select:disabled, textarea:disabled {
             background-color: var(--disabled-bg);
             color: var(--disabled-text);
             border-color: var(--disabled-border);
             cursor: not-allowed;
        }
        input[type="number"] { text-align: right; -moz-appearance: textfield; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { margin: 0; }
        input[type="file"] { padding: 8px; line-height: 1.5; } /* Adjust file input padding */
        .input-group { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
        .input-group label { margin-bottom: 0; font-weight: normal;}
        .input-group input[type="radio"] { width: auto; margin-right: 5px; }
        .input-small { width: 150px; display: inline-block; margin-left: 10px; }

        /* --- Tablas --- */
        .table-container { overflow-x: auto; margin-top: 25px; border: 1px solid var(--border-color); border-radius: 6px; }
        table { width: 100%; border-collapse: collapse; background-color: var(--card-bg); font-size: 0.9rem; }
        th, td {
            padding: 12px 15px;
            border: none;
            border-bottom: 1px solid var(--border-color);
            text-align: left;
            vertical-align: middle;
            white-space: nowrap;
        }
        th {
            background-color: var(--table-header-bg);
            font-weight: 600;
            position: sticky; top: 0; z-index: 10;
            border-bottom-width: 2px;
        }
        tbody tr:last-child td { border-bottom: none; }
        tbody tr:hover { background-color: var(--table-row-hover); }
        th:first-child, td:first-child { border-left: none; padding-left: 20px; /* More padding for first col */ }
        th:last-child, td:last-child { border-right: none; padding-right: 20px; /* More padding for last col */}

        /* Cell specific styles */
        td.real-month-cell { background-color: var(--real-month-bg) !important; /* Use important to override hover */ }
        td.estimated-month-cell { background-color: var(--estimated-month-bg) !important; }
        td.number-cell { text-align: right; font-variant-numeric: tabular-nums; }
        td.input-cell input { width: 100px; padding: 6px; font-size: 0.9rem; text-align: right; }
        td.input-cell input:disabled { background-color: transparent; border: none; color: var(--disabled-text);}
        .text-muted { color: var(--secondary-color); font-style: italic; font-size: 0.9em;}

        /* --- Tablas Desplegables --- */
        .collapsible-table tbody tr.rubro-total-row { font-weight: bold; cursor: pointer; background-color: var(--expandable-row-bg); transition: background-color 0.2s; }
        .collapsible-table tbody tr.rubro-total-row:hover { background-color: var(--clickable-row-hover); }
        .collapsible-table tbody tr.rubro-total-row td:first-child::before {
            content: '\f078'; /* fa-chevron-down */
            font-family: 'Font Awesome 6 Free'; font-weight: 900; margin-right: 12px; display: inline-block; transition: transform 0.2s ease-in-out; color: var(--primary-color);
        }
        .collapsible-table tbody tr.rubro-total-row.collapsed td:first-child::before { transform: rotate(-90deg); }
        .collapsible-table tbody tr.detail-row { display: table-row; background-color: var(--card-bg); transition: background-color 0.3s; }
        .collapsible-table tbody tr.detail-row.hidden { display: none; }
        .collapsible-table tbody tr.detail-row td { font-size: 0.85rem; color: var(--secondary-color); border-color: var(--border-color); }
        .collapsible-table tbody tr.detail-row td:first-child { padding-left: 40px; /* Indent details more */ }
        body.dark-mode .collapsible-table tbody tr.detail-row { background-color: #353535; }
        .collapsible-table tfoot tr { font-weight: bold; background-color: var(--table-header-bg); border-top: 2px solid var(--border-color); }

         /* Styles for Group/Ungroup All buttons */
        .table-actions {
            margin-bottom: 15px;
             display: flex;
             justify-content: flex-end; /* Align buttons to the right */
             gap: 10px;
             flex-wrap: wrap;
        }


        /* --- Componentes UI Específicos --- */
        #dashboard-summary { border-collapse: separate; border-spacing: 0; }
        #dashboard-summary th, #dashboard-summary td { text-align: center; white-space: normal; }
        #dashboard-summary tbody td, #dashboard-summary tfoot td { padding: 10px 8px; }
        #dashboard-summary .month-header { font-weight: bold; }

        .chart-container {
            margin-top: 35px; padding: 30px;
            background-color: var(--card-bg); border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-color);
            position: relative; min-height: 200px; /* Adjusted min height */
        }
        .chart-container canvas { max-width: 100%; height: 380px !important; }
        .chart-no-data { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--secondary-color); font-style: italic; font-size: 1.1rem; text-align: center; }

        #file-upload-area {
            border: 2px dashed var(--primary-color);
            padding: 45px; text-align: center; background-color: var(--bg-color);
            border-radius: 8px; margin-bottom: 25px; transition: background-color 0.2s ease, border-color 0.2s ease; cursor: pointer;
        }
        #file-upload-area:hover { background-color: var(--table-row-hover); border-color: var(--primary-color-darker); }
        #file-upload-area p { margin-bottom: 15px; font-size: 1.1rem; color: var(--secondary-color); }
        #file-upload-area i.fa-file-excel { font-size: 3rem; margin-bottom: 10px; color: var(--accent-color); }
        #file-upload-feedback { margin-top: 15px; font-weight: bold; white-space: pre-wrap; font-size: 0.95rem; min-height: 2em; }

        #reserve-fund-panel { margin-top: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 20px;} /* MODIFICADO: Usar grid como IPC */
        #reserve-fund-panel .month-config { /* Removed flex styles, grid handles layout */ padding: 0; border-radius: 0; background-color: transparent; transition: none; }
        #reserve-fund-panel .month-config label { width: 100%; margin-bottom: 5px; font-weight: 600;}
        #reserve-fund-panel .month-config input { width: 100%; }
        #reserve-fund-panel .month-config span { margin-left: 5px; color: var(--secondary-color); font-size: 0.9em; } /* Style the unit */


        .config-section {
            border: 1px solid var(--border-color); border-radius: 8px; padding: 25px;
            margin-bottom: 30px; background-color: var(--card-bg);
            box-shadow: 0 3px 7px var(--shadow-color);
        }
        .config-section h4 { border-bottom: 1px solid var(--border-color); padding-bottom: 0.6em; margin-bottom: 1.2em;}
        .management-list { list-style: none; padding: 0; max-height: 350px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 6px; padding: 10px; background-color: var(--bg-color); }
        body.dark-mode .management-list { background-color: #3a3f44; }
        .management-list li { display: flex; justify-content: space-between; align-items: center; padding: 10px 8px; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s; }
        .management-list li:last-child { border-bottom: none;}
        .management-list li:hover { background-color: var(--table-row-hover); }
        .management-list li span { flex-grow: 1; margin-right: 15px; font-weight: 500; }
        .management-list li select { width: 200px; font-size: 0.88rem; padding: 6px 8px; flex-shrink: 0; }
        .management-list li button { flex-shrink: 0; }

         /* Styles for the NEW Coefficient Editor */
         #coefficient-editor { margin-top: 25px; }
         #coefficient-editor h4 { margin-bottom: 15px;}
         #coefficient-values-editor {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); /* Similar grid to IPC */
             gap: 20px;
             padding: 20px; /* Add padding */
             border: 1px solid var(--border-color); /* Add border */
             border-radius: 6px; /* Add border-radius */
             background-color: var(--bg-color); /* Background like other lists/panels */
         }
         body.dark-mode #coefficient-values-editor { background-color: #3a3f44; }

         #coefficient-values-editor .form-group { margin-bottom: 0; } /* Adjust form-group margin inside grid */
         #coefficient-values-editor .form-group label { margin-bottom: 5px; font-weight: 600; width: 100%;} /* Adjust label */
         #coefficient-values-editor .form-group input { width: 100%; max-width: none; } /* Allow input to fill grid cell */
         #coefficient-values-editor .text-muted { grid-column: 1 / -1; text-align: center; padding: 20px; } /* Center and span info message */


         /* --- Snackbar --- */
        #snackbar {
            visibility: hidden; min-width: 300px; max-width: 90%;
            background-color: var(--success-color); /* Default to success */
            color: var(--button-text); text-align: center;
            border-radius: 6px; padding: 18px 25px; position: fixed; z-index: 1001;
            left: 50%; transform: translateX(-50%); bottom: 30px;
            font-size: 1.05rem; font-weight: 500;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            opacity: 0; transition: visibility 0s 0.5s, opacity 0.5s ease-out, bottom 0.5s ease-out;
        }
        #snackbar.show {
            visibility: visible; opacity: 1; bottom: 60px;
            transition: opacity 0.5s ease-in, bottom 0.5s ease-in;
        }
        #snackbar.error { background-color: var(--danger-color); color: var(--button-text); }
        #snackbar.warning { background-color: var(--warning-color); color: var(--button-warning-text); }
        #snackbar.info { background-color: var(--info-color); color: var(--button-text); }


        /* --- Footer --- */
        footer {
            margin-top: auto; padding: 20px 0; text-align: center; font-size: 0.95em;
            color: var(--secondary-color); background-color: var(--header-bg);
            border-top: 1px solid var(--border-color);
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 1200px) { .container { width: 98%; } .chart-container canvas { height: 320px !important; } }
        @media (max-width: 992px) {
             h1 { font-size: 2rem; } h2 { font-size: 1.6rem; } h3 { font-size: 1.3rem; }
             .tabs { justify-content: flex-start; }
             .tab-link { padding: 10px 18px; font-size: 0.95rem;}
             table { font-size: 0.88rem; } th,td {padding: 10px 12px;}
             .management-list li select { width: 150px; } /* Reduce select width */
        }
        @media (max-width: 768px) {
            body { line-height: 1.6; }
            .app-title { font-size: 1.3rem;} #theme-toggle { font-size: 1.1rem;}
            .chart-container { padding: 20px;} .chart-container canvas { height: 280px !important; }
            .input-group { flex-direction: column; align-items: stretch; gap: 10px;}
            .input-small { margin-left: 0; margin-top: 8px; width: 100%; }
            /* Adjust Reserve Fund and Coefficient Editor grid columns */
            #reserve-fund-panel, #coefficient-values-editor, #ipc-inputs { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px;}
            #reserve-fund-panel .month-config label { width: 100%; text-align: left; margin-bottom: 5px; }
            #reserve-fund-panel .month-config input { width: 100%; }
            table { font-size: 0.85rem; } th, td { padding: 9px 8px; white-space: normal; } /* Allow wrap */
            th:first-child, td:first-child { padding-left: 15px; }
            th:last-child, td:last-child { padding-right: 15px; }
            td.input-cell input { width: 80px; padding: 5px; }
            .management-list li { flex-wrap: wrap; gap: 8px; }
            .management-list li span { flex-basis: 100%; margin-right: 0; } /* Name takes full width */
            .management-list li select { width: calc(100% - 50px); margin-top: 5px; } /* Select almost full width */
            .management-list li button { margin-left: auto; } /* Push button right */
            button { font-size: 0.95rem; padding: 10px 18px;}
            .tabs { gap: 2px; }
            .tab-link { padding: 8px 10px; font-size: 0.85rem;}
             .table-actions { justify-content: center; }
        }
        @media (max-width: 576px) {
            h1 { font-size: 1.7rem; } .app-title { display: none; } header .container { justify-content: flex-end; }
            .tab-link { padding: 8px 10px; font-size: 0.85rem;}
            th, td { padding: 8px 6px; }
            th:first-child, td:first-child { padding-left: 10px; }
            th:last-child, td:last-child { padding-right: 10px; }
            .chart-container canvas { height: 220px !important; }
            #snackbar { min-width: 90%; bottom: 20px; font-size: 1rem; padding: 15px 20px; }
            #snackbar.show { bottom: 40px; }
            #file-upload-area { padding: 30px; }
            .management-list li select { width: 100%; } /* Select full width on smallest screens */
             /* Adjust Reserve Fund and Coefficient Editor grid columns */
             #reserve-fund-panel, #coefficient-values-editor, #ipc-inputs { grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px;}
        }
    </style>
<!-- PATCH START -->
<style id="legend-fix">
.chartjs-legend li span,
.chart-legend li span,
.chartjs-legend li.hidden span,
.chart-legend li.hidden span,
.chartjs-legend li.hidden,
.chart-legend li.hidden { text-decoration:none !important; }
</style>
<script id="patch-recalc">
(function(){
  // ---------- util ----------
  function toNumber(val){
    if(val===null||val===undefined) return 0;
    if(typeof val==='number') return val;
    let s = val.toString().trim();
    if(!s) return 0;
    s = s.replace(/[^0-9,.,\-]/g,'');  // keep digits, dot, comma, dash
    if(s.includes('.') && s.includes(',')){
        if(s.lastIndexOf('.')>s.lastIndexOf(',')){ s = s.replace(/,/g,''); }
        else { s = s.replace(/\./g,'').replace(',','.'); }
    } else if (s.includes(',') && !s.includes('.')){
        s = s.replace(/\./g,'').replace(',','.');
    } else {
        s = s.replace(/,/g,'');
    }
    const n = parseFloat(s);
    return isNaN(n)?0:n;
  
    window.toNumber = toNumber; // expose globally
}

  function syncIPC(){
    const ipcVals = (appState?.settings?.ipcManual)||[];
    if(ipcVals.length!==12) return;
    Object.keys(appState.settings.coefficientTypes).forEach(k=>{
        const ct = appState.settings.coefficientTypes[k];
        const n = (ct.name||k).toLowerCase();
        if(n.includes('ipc')){
            ct.values = ipcVals.map(v => window.toNumber(v || 0));
            ct.isDefault = true;
        }
    });
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    try{ syncIPC(); }catch(e){ console.error('syncIPC',e); }

    window.recalculateEstimates = function(){
      const scenarioData = getCurrentScenarioData();
      if(!scenarioData){ showSnackbar("No hay escenario activo.", true,'error'); return; }
      const { data, monthStatus } = scenarioData;
      const { rubroConfig={}, coefficientTypes={} } = appState.settings;

      const resolveCoef = key=>{
        if(!key) key='None';
        if(coefficientTypes[key]) return (coefficientTypes[key].values||[]).map(toNumber);
        const alt = Object.keys(coefficientTypes).find(k=>(coefficientTypes[k].name||'').toLowerCase()===key.toLowerCase());
        return alt ? (coefficientTypes[alt].values||[]).map(toNumber) : Array(12).fill(0);
      };

      const isReal = s=>(s||'').toString().trim().toUpperCase()==='REAL';
      let updated=0;

      for(const rubro of Object.keys(data.gastos||{})){
        const rData = data.gastos[rubro];
        const coefKey = (rubroConfig[rubro]?.coefficientType)||'None';
        const coefVals = resolveCoef(coefKey);

        for(const det of Object.keys(rData.detailsData||{})){
          const vals = rData.detailsData[det];
          const statRow = (monthStatus.gastos && monthStatus.gastos[rubro] && monthStatus.gastos[rubro][det])
                            ? monthStatus.gastos[rubro][det] : Array(12).fill('');

          // buscar último mes con valor >0 y marcado REAL o sin marca (considerar real)
          let lastIdx=-1;
          for(let i=11;i>=0;i--){
              if(toNumber(vals[i])>0 && (isReal(statRow[i])||statRow[i]==='')){
                  lastIdx=i; break;
              }
          }
          if(lastIdx===-1 || lastIdx===11) continue;
          let prev=toNumber(vals[lastIdx]);

          for(let m=lastIdx+1;m<12;m++){
              if(isReal(statRow[m])){ prev=toNumber(vals[m]); continue; }
              let newVal;
              if(coefKey==='None'||coefKey.toLowerCase().includes('sin coef')){
                  newVal = prev;
              } else {
                  const pct = toNumber(coefVals[m]);
                  const mult = 1 + pct/100;
                  newVal = isFinite(mult) ? prev*mult : prev;
              }
              vals[m] = newVal;
              prev = newVal;
              updated++;
          }
        }
      }
      if(updated){ showSnackbar(`Estimados recalculados: ${updated} celdas.`, false,'success'); saveState(); updateUI();}
      else{ showSnackbar('No se proyectó nada.', false,'info'); }
    };
  });
})();
</script>
<!-- PATCH END -->
</head>
<body>
<header>
<div class="container">
<span class="app-title">Proyección Expensas - El Centauro</span>
<button id="theme-toggle" title="Cambiar tema"><i class="fas fa-moon"></i></button>
</div>
</header>
<div class="container">
<div class="tabs">
<button class="tab-link active" onclick="openTab(event, 'dashboard')"><i class="fas fa-tachometer-alt"></i> Dashboard</button>
<button class="tab-link" onclick="openTab(event, 'upload')"><i class="fas fa-upload"></i> Cargar Datos</button>
<button class="tab-link" onclick="openTab(event, 'reserve')"><i class="fas fa-piggy-bank"></i> Fondo Reserva</button>
<button class="tab-link" onclick="openTab(event, 'settings')"><i class="fas fa-cog"></i> Configuración</button>
<button class="tab-link" onclick="openTab(event, 'reports')"><i class="fas fa-download"></i> Reportes</button>
</div>
<!-- ==================== DASHBOARD ==================== -->
<div class="tab-content active" id="dashboard">
<h2><i class="fas fa-tachometer-alt"></i> Dashboard Anual - <span id="dashboard-year"></span> (<span id="dashboard-scenario">Base</span>)</h2>
<div class="form-group input-group">
<label for="scenario-selector" style="flex-shrink: 0;">Escenario:</label>
<select id="scenario-selector" style="flex-grow: 1;"></select>
<button class="button-primary button-sm" onclick="createScenario()" title="Crear Escenario Nuevo"><i class="fas fa-plus"></i> Crear</button>
<button class="button-secondary button-sm" onclick="cloneScenario()" title="Clonar Escenario Actual"><i class="fas fa-clone"></i> Clonar</button>
<button class="button-danger button-sm" onclick="deleteScenario()" title="Eliminar Escenario Actual"><i class="fas fa-trash"></i> Eliminar</button>
<button class="button-warning button-sm" id="btnBorrarDatos" onclick="clearScenarioData()" title="Borrar Datos del Escenario Actual (Gastos, Ingresos, Status)"><i class="fas fa-broom"></i> Borrar Datos</button>
<button class="button-info button-sm" onclick="recalculateEstimates()" title="Proyectar meses estimados basados en último mes real y coeficientes (acumulativo)"><i class="fas fa-calculator"></i> Calcular Estimados</button>
</div>
<h4>Resumen Mensual General</h4>
<div class="table-container">
<table id="dashboard-summary">
<thead>
<tr>
<th>Mes</th>
<th>Gasto ($)</th>
<th>Fondo ($)</th>
<th>Cuota s/Gs ($/UF)</th> <!-- Basado en Gasto+Fondo / UF -->
<th>IPC (%)</th>
<th>Cuota IPC ($/UF)</th> <!-- NUEVO: Cuota s/Gs * (1 + IPC%) -->
<!-- MODIFICACIÓN INICIO - Encabezado de tabla -->
<th>Expensa Real ($/UF)</th> <!-- Ahora muestra el valor del rubro Expensas Ordinarias / UF -->
<!-- MODIFICACIÓN FIN -->
</tr>
</thead>
<tbody><!-- Contenido generado por JS --></tbody>
<tfoot><!-- Contenido generado por JS --></tfoot>
</table>
</div>
<h4 style="margin-top: 30px;">Detalle de Gastos Proyectados ($)</h4>
<p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar los detalles. Las celdas mensuales de detalle se colorean según su origen: <span style="background-color: var(--real-month-bg); padding: 1px 4px; border-radius: 3px;">REAL</span> (cargado desde Excel con número) o <span style="background-color: var(--estimated-month-bg); padding: 1px 4px; border-radius: 3px;">ESTIMADO</span> (cargado sin número o proyectado/calculado).</p>
<!-- Added Group/Ungroup Buttons for Gastos -->
<div class="table-actions">
<button class="button-secondary button-sm" onclick="toggleAllRubroDetails('gastos', false)" title="Expandir todos los detalles de gastos"><i class="fas fa-expand"></i> Expandir Todo</button>
<button class="button-secondary button-sm" onclick="toggleAllRubroDetails('gastos', true)" title="Colapsar todos los detalles de gastos"><i class="fas fa-compress"></i> Colapsar Todo</button>
</div>
<div class="table-container">
<table class="collapsible-table" id="gastos-detail-table">
<thead>
<tr>
<th>Rubro / Detalle</th>
<th>Coef. Aplicado</th> <!-- Add Coef. column header -->
<!-- Meses y Total Anual generados por JS -->
</tr>
</thead>
<tbody><!-- Contenido generado por JS --></tbody>
<tfoot><!-- Contenido generado por JS --></tfoot>
</table>
</div>
<h4 style="margin-top: 30px;">Detalle de Ingresos Proyectados ($)</h4>
<p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar. Los valores aquí son la base de cálculo (valor individual o por UF). El Total de Ingresos en el Resumen General puede incluir la multiplicación por UF.</p>
<!-- Added Group/Ungroup Buttons for Ingresos -->
<div class="table-actions">
<button class="button-secondary button-sm" onclick="toggleAllRubroDetails('ingresos', false)" title="Expandir todos los detalles de ingresos"><i class="fas fa-expand"></i> Expandir Todo</button>
<button class="button-secondary button-sm" onclick="toggleAllRubroDetails('ingresos', true)" title="Colapsar todos los detalles de ingresos"><i class="fas fa-compress"></i> Colapsar Todo</button>
</div>
<div class="table-container">
<table class="collapsible-table" id="ingresos-detail-table">
<thead>
<tr>
<th>Rubro / Detalle</th>
<!-- Meses y Total Anual generados por JS -->
</tr>
</thead>
<tbody><!-- Contenido generado por JS --></tbody>
<tfoot><!-- Contenido generado por JS --></tfoot>
</table>
</div>
<div class="chart-container">
<h3>Evolutivo Expensa Mensual ($/UF)</h3> <!-- MODIFICADO -->
<canvas id="evolutivoCuotaChart"></canvas>
<div class="chart-no-data" style="display: none;">No hay datos suficientes para graficar.</div>
</div>
<div style="display: flex; gap: 25px; flex-wrap: wrap; margin-top: 35px;">
<div class="chart-container" style="flex: 1; min-width: 320px;">
<h3>Participación Gastos (%)</h3>
<canvas id="participacionGastosChart"></canvas>
<div class="chart-no-data" style="display: none;">No hay datos de gastos<br/>para mostrar el gráfico.</div>
</div>
<div class="chart-container" style="flex: 1; min-width: 320px;">
<h3>Participación Ingresos (%)</h3>
<canvas id="participacionIngresosChart"></canvas>
<div class="chart-no-data" style="display: none;">No hay datos de ingresos<br/>para mostrar el gráfico.</div>
</div>
</div>
</div>
<!-- ==================== UPLOAD ==================== -->
<div class="tab-content" id="upload">
<h2><i class="fas fa-upload"></i> Cargar Datos Reales / Base</h2>
<div class="form-group input-group">
<label for="exercise-year">Año del Ejercicio:</label>
<input id="exercise-year" max="2099" min="2020" style="width: 120px;" type="number" value="2024"/>
<button class="button-success" onclick="createNewExercise()"><i class="fas fa-calendar-plus"></i> Crear/Seleccionar Año</button>
</div>
<p>Sube tu archivo Excel con las hojas <strong>"Gastos"</strong> e <strong>"Ingresos"</strong>. Los rubros nuevos se añadirán automáticamente a la sección de Configuración.</p>
<p><strong>Importante:</strong>
<ul style="margin-left: 20px; margin-bottom: 15px;">
<li>Las celdas con **números** en la hoja "Gastos" marcarán ese mes/detalle como '<strong style="color: var(--accent-color)">REAL</strong>' (fondo verde claro en detalle). Las celdas vacías o con texto se considerarán '<strong style="color: var(--warning-color)">ESTIMADO</strong>'.</li>
<li>Los rubros de Ingreso llamados "<strong id="cuota-rubro-name-info">Expensas Ordinarias</strong>" y "<strong>Expensas Extraordinarias</strong>" tendrán sus valores base multiplicados por la cantidad de UF (definida en Configuración) al calcular el *total* de ingresos en el Resumen General. La columna "Expensa Real ($/UF)" en el resumen muestra el valor del rubro "<strong id="cuota-rubro-name-info2">Expensas Ordinarias</strong>" <strong style="color: var(--primary-color)">dividido por la cantidad de UF</strong>.</li>
</ul>
</p>
<div id="file-upload-area" onclick="document.getElementById('excel-file-input').click()">
<p><i class="fas fa-file-excel"></i><br/>Arrastra tu archivo Excel aquí (.xlsx, .xls) o haz clic para seleccionar</p>
<input accept=".xlsx, .xls" id="excel-file-input" onchange="handleFileUpload(this.files)" style="display: none;" type="file"/>
<button class="button-primary" onclick="event.stopPropagation(); document.getElementById('excel-file-input').click()" style="pointer-events: auto;" type="button"><i class="fas fa-folder-open"></i> Seleccionar Archivo</button>
<button class="button-secondary" onclick="event.stopPropagation(); loadSampleData()" style="margin-left: 10px; pointer-events: auto;" type="button"><i class="fas fa-database"></i> Cargar Datos Ejemplo</button>
</div>
<div id="file-upload-feedback"></div>
<a href="#" onclick="event.preventDefault(); downloadTemplate();" title="Descargar archivo Excel con estructura de ejemplo"><i class="fas fa-download"></i> Descargar Plantilla Ejemplo</a>
</div>
<!-- ==================== RESERVE FUND ==================== -->
<div class="tab-content" id="reserve">
<h2><i class="fas fa-piggy-bank"></i> Configurar Fondo de Reserva - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
<div class="form-group">
<label>Método de Cálculo del Fondo:</label>
<div class="input-group">
<input checked="" id="reserve-type-percent" name="reserve-type" onchange="updateReserveUI()" type="radio" value="percent"/>
<label for="reserve-type-percent">Porcentaje (%) sobre Gastos Mensuales</label>
<input id="reserve-type-fixed" name="reserve-type" onchange="updateReserveUI()" type="radio" value="fixed"/>
<label for="reserve-type-fixed">Valor Fijo Mensual ($)</label>
</div>
</div>
<div id="reserve-fund-panel">
<!-- Inputs generados por JS -->
</div>
<button class="button-success button-lg" onclick="saveReserveFund()" style="margin-top: 25px; width: 100%; padding: 15px;" title="Guardar los valores mensuales y el tipo de cálculo del fondo">
<i class="fas fa-save"></i> GUARDAR FONDO DE RESERVA Y RECALCULAR
            </button>
</div>
<!-- ==================== SETTINGS ==================== -->
<div class="tab-content" id="settings">
<h2><i class="fas fa-cog"></i> Configuración General y de Cálculo</h2>
<div class="config-section">
<h4><i class="fas fa-building"></i> Ajustes Generales del Barrio</h4>
<div class="form-group">
<label for="cantidad-unidades">Cantidad Total de Unidades Funcionales (UF):</label>
<input id="cantidad-unidades" min="1" style="width: 180px;" title="Número total de UF para calcular cuotas base" type="number" value="100"/>
</div>
</div>
<div class="config-section">
<h4><i class="fas fa-list-alt"></i> Gestión de Rubros (Categorías)</h4>
<div style="display: flex; gap: 30px; flex-wrap: wrap;">
<div style="flex: 1; min-width: 320px;">
<h5><i class="fas fa-arrow-down" style="color:var(--danger-color)"></i> Rubros de GASTOS</h5>
<div class="form-group input-group">
<input id="new-gasto-rubro-name" placeholder="Nombre nuevo rubro de gasto" style="flex-grow: 1;" type="text"/>
<button class="button-sm button-success" onclick="addRubro('gastos')" title="Añadir este nuevo rubro a la lista de gastos"><i class="fas fa-plus"></i> Añadir</button>
</div>
<ul class="management-list" id="gasto-rubro-list"></ul>
</div>
<div style="flex: 1; min-width: 320px;">
<h5><i class="fas fa-arrow-up" style="color:var(--success-color)"></i> Rubros de INGRESOS</h5>
<div class="form-group input-group">
<input id="new-ingreso-rubro-name" placeholder="Nombre nuevo rubro de ingreso" style="flex-grow: 1;" type="text"/>
<button class="button-sm button-success" onclick="addRubro('ingresos')" title="Añadir este nuevo rubro a la lista de ingresos"><i class="fas fa-plus"></i> Añadir</button>
</div>
<ul class="management-list" id="ingreso-rubro-list"></ul>
</div>
</div>
</div>
<div class="config-section">
<h4><i class="fas fa-percentage"></i> Gestión de Coeficientes de Ajuste (para Gastos Estimados)</h4>
<p class="text-muted" style="font-size: 0.9em;">Define tipos de coeficientes (ej. Inflación, Aumento Gremial) y asigna uno a cada rubro de Gasto. Al usar "Calcular Estimados" en el Dashboard, el sistema proyectará los meses sin datos '<strong style="color: var(--accent-color)">REAL</strong>' (marcados en amarillo) multiplicando el último valor '<strong style="color: var(--accent-color)">REAL</strong>' por el coeficiente acumulado correspondiente a cada mes futuro.</p>
<div style="display: flex; gap: 30px; flex-wrap: wrap;">
<div style="flex: 1; min-width: 280px;">
<h5>Tipos de Coeficientes Disponibles</h5>
<div class="form-group input-group">
<input id="new-coefficient-type-name" placeholder="Nuevo tipo (ej: Aumento Sindicato)" style="flex-grow: 1;" type="text"/>
<button class="button-sm button-success" onclick="addCoefficientType()" title="Añadir este nuevo tipo de coeficiente a la lista"><i class="fas fa-plus"></i> Añadir Tipo</button>
</div>
<ul class="management-list" id="coefficient-type-list"></ul>
</div>
<div id="coefficient-editor" style="flex: 2; min-width: 450px;">
<h5><i class="fas fa-edit"></i> Editar Valores Mensuales para: <span id="editing-coefficient-name" style="color: var(--primary-color); font-weight: bold;"></span></h5>
<!-- MODIFICACIÓN FIX: Reemplazar tabla por grid similar a IPC -->
<div id="coefficient-values-editor">
<p class="text-muted">Selecciona un tipo de coeficiente (que no sea "Sin Coeficiente") de la lista de la izquierda para editar sus valores porcentuales (%) mes a mes.</p>
</div>
<!-- END MODIFICACIÓN FIX -->
</div>
</div>
</div>
<div class="config-section">
<h4><i class="fas fa-chart-line"></i> Índices IPC Mensuales de Referencia (%)</h4>
<p class="text-muted">Introduce el porcentaje (%) de IPC estimado o real para cada mes. Se usa únicamente para calcular la columna "Cuota IPC ($/UF)" como referencia en el Dashboard.</p>
<div id="ipc-inputs" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 20px;">
<!-- Inputs generados por JS -->
</div>
</div>
<button class="button-success button-lg" onclick="saveSettings()" style="margin-top: 20px; width: 100%; padding: 15px;" title="Guardar todos los cambios realizados en esta pestaña (UF, Rubros, Coeficientes, IPC) y recalcular el escenario actual">
<i class="fas fa-save"></i> GUARDAR TODA LA CONFIGURACIÓN Y RECALCULAR
             </button>
</div>
<!-- ==================== REPORTS ==================== -->
<div class="tab-content" id="reports">
<h2><i class="fas fa-download"></i> Descargar Reportes - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
<p>Genera y descarga los datos del ejercicio y escenario actual en formato Excel, incluyendo detalles y resumen.</p>
<button class="button-success" onclick="exportToExcel()" title="Descargar un archivo .xlsx con el detalle y resumen del escenario actual"><i class="fas fa-file-excel"></i> Descargar Reporte Completo (.xlsx)</button>
<h3 style="margin-top: 35px;">Exportar Gráficos Individuales</h3>
<div style="display: flex; gap: 15px; flex-wrap: wrap;">
<button class="button-secondary" onclick="exportChart('evolutivoCuotaChart', 'evolutivo_expensa.png')" title="Descargar el gráfico de evolución de expensas como imagen PNG"><i class="fas fa-chart-line"></i> Gráfico Evolutivo (PNG)</button> <!-- MODIFICADO -->
<button class="button-secondary" onclick="exportChart('participacionGastosChart', 'participacion_gastos.png')" title="Descargar el gráfico de torta de gastos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Gastos (PNG)</button>
<button class="button-secondary" onclick="exportChart('participacionIngresosChart', 'participacion_ingresos.png')" title="Descargar el gráfico de torta de ingresos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Ingresos (PNG)</button>
</div>
</div>
</div> <!-- /container -->
<footer>
<div class="container">
            © <span id="footer-year"></span> Proyección Expensas El Centauro. v2.7 (Coef. % Fix)
        </div>
</footer>
<div id="snackbar">Mensaje</div>
<!-- ==================== SCRIPT PRINCIPAL ==================== -->
<script>
        // --- Constantes y Estado Global ---
        const MONTHS = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
        const FULL_MONTHS = ["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"];
        const GASTOS_SHEET_NAME = "Gastos";
        const INGRESOS_SHEET_NAME = "Ingresos";
        // --- MODIFICACIÓN FIX: Version bump for coefficient interpretation change and UI ---
        const STORAGE_KEY = 'expensasAppCentauroState_v2.7_CoefPercFix';
        // --- END MODIFICACIÓN FIX ---
        const CUOTA_RUBRO_NAME = "Expensas Ordinarias"; // Rubro principal para multiplicar x UF y base de Expensa Real
        const EXTRA_CUOTA_RUBRO_NAME = "Expensas Extraordinarias"; // Otro rubro a multiplicar x UF
        const SPECIAL_INGRESO_RUBROS = [CUOTA_RUBRO_NAME, EXTRA_CUOTA_RUBRO_NAME]; // Actualizado automáticamente

        let appState = getDefaultAppState(); // Iniciar con estado por defecto limpio

        // Chart instances (moved to scope variables)
        let evolutivoCuotaChart_instance = null;
        let participacionGastosChart_instance = null;
        let participacionIngresosChart_instance = null;


        // --- Inicialización ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log(`DOM Cargado. Inicializando App ${STORAGE_KEY}...`);
            loadState(); // Cargar estado guardado si existe
            initTheme(); // Aplicar tema (antes de cualquier render que dependa de él)

            // Asegurar que exista al menos un escenario activo y válido
            validateAndSetActiveScenario();

            // --- MODIFICADO: Update UI instructions with the correct name ---
            const cuotaInfoSpan = document.getElementById('cuota-rubro-name-info');
            if (cuotaInfoSpan) cuotaInfoSpan.textContent = CUOTA_RUBRO_NAME;
             // MODIFICACIÓN INICIO - Segunda referencia al nombre del rubro
            const cuotaInfoSpan2 = document.getElementById('cuota-rubro-name-info2');
            if (cuotaInfoSpan2) cuotaInfoSpan2.textContent = CUOTA_RUBRO_NAME;
            // MODIFICACIÓN FIN

            initUI(); // Inicializar elementos de la UI que dependen del estado inicial
            addEventListeners(); // Añadir listeners globales
            updateUI(); // Renderizar todo con el estado actual/cargado
            console.log(`App ${STORAGE_KEY} Inicializada.`);
        });

        // --- Validación y Selección de Escenario Activo ---
        function validateAndSetActiveScenario() {
            let activeKeyIsValid = false;
            // Check if activeScenarioKey exists and points to a valid scenario
            if (appState.activeScenarioKey && appState.scenarios && appState.scenarios[appState.activeScenarioKey]) {
                 const activeYear = parseInt(appState.activeScenarioKey.split('_')[0]);
                 // Optionally check if the year in the key matches the stored currentYear,
                 // although currentYear should ideally follow activeScenarioKey's year.
                 // Let's prioritize the key's year if mismatch.
                if (!isNaN(activeYear) && appState.scenarios[appState.activeScenarioKey].year === activeYear) {
                   appState.currentYear = activeYear; // Ensure currentYear is in sync
                   activeKeyIsValid = true;
                } else {
                   console.warn(`Active scenario key "${appState.activeScenarioKey}" does not match its stored year or is invalid.`);
                   // Invalidate the key if data mismatch or year is invalid
                   appState.activeScenarioKey = null;
                }
            } else {
                console.warn(`Invalid or missing active scenario key: ${appState.activeScenarioKey}`);
                 appState.activeScenarioKey = null; // Ensure it's null if validation failed
            }


            if (!activeKeyIsValid) {
                console.warn(`Clave activa inválida o ausente. Buscando alternativa...`);
                // Try finding Base for the default/current year
                const defaultYear = new Date().getFullYear();
                const defaultYearBaseKey = `${defaultYear}_Base`;

                // Try finding *any* scenario for the default year first
                const firstKeyForDefaultYear = Object.keys(appState.scenarios || {}).find(k => k.startsWith(`${defaultYear}_`));

                // Try finding the very first scenario available globally
                const firstKeyOverall = Object.keys(appState.scenarios || {})[0];


                let fallbackKey = null;
                if (appState.scenarios?.[defaultYearBaseKey]) {
                    fallbackKey = defaultYearBaseKey;
                } else if (firstKeyForDefaultYear) {
                    fallbackKey = firstKeyForDefaultYear;
                } else if (firstKeyOverall) {
                    fallbackKey = firstKeyOverall;
                }

                if (fallbackKey) {
                    console.log(`Cambiando a escenario de fallback: ${fallbackKey}`);
                    appState.activeScenarioKey = fallbackKey;
                    // Ensure currentYear is updated based on the fallback key
                    appState.currentYear = parseInt(fallbackKey.split('_')[0]);
                } else {
                    // No scenarios exist at all, create the default Base for the current year
                    console.log("No existen escenarios. Creando Base para el año actual.");
                    appState.currentYear = new Date().getFullYear(); // Use actual current year
                    initScenarioData(appState.currentYear); // Creates Base by default
                    appState.activeScenarioKey = `${appState.currentYear}_Base`;
                }
                saveState(); // Save potentially corrected state
            }

             // Ensure the selected scenario data structure is complete
             const currentScenario = getCurrentScenarioData();
             if (currentScenario) {
                initializeScenarioDataForRubros(currentScenario);
             } else {
                 // This case should ideally not happen if fallback logic works,
                 // but as a last resort, ensure default Base is created if all else fails.
                  const defaultYear = new Date().getFullYear();
                  const defaultBaseKey = `${defaultYear}_Base`;
                  if (!appState.scenarios?.[defaultBaseKey]) {
                       console.warn("validateAndSetActiveScenario: Fallback logic failed, no valid scenario found. Creating default Base.");
                       appState.currentYear = defaultYear;
                       initScenarioData(appState.currentYear);
                       appState.activeScenarioKey = defaultBaseKey;
                       saveState();
                  }
             }
        }


        // --- Gestión de Datos del Escenario ---
        function getCurrentScenarioData() {
             // Return the scenario data if the active key exists and is valid
             if (appState.activeScenarioKey && appState.scenarios && appState.scenarios[appState.activeScenarioKey]) {
                 return appState.scenarios[appState.activeScenarioKey];
             }
             // If not valid, attempt to re-validate and set an active scenario
             console.warn("getCurrentScenarioData: No active scenario found. Attempting validation.");
             validateAndSetActiveScenario(); // This might set a new activeScenarioKey
             // Return the scenario data *after* potential validation
             return appState.scenarios?.[appState.activeScenarioKey] || null;
        }

        function initScenarioData(year, scenarioName = 'Base') {
            const key = `${year}_${scenarioName.replace(/\s+/g, '_').replace(/[^\w-]/g, '')}`; // Sanitize key
            if (!appState.scenarios[key]) {
                console.log(`Inicializando nuevo escenario: ${key}`);
                // Start with a deep copy of the default structure's scenario part
                 // Define a base scenario structure if the default state doesn't provide one (safety)
                 const baseScenarioStructure = {
                     year: year,
                     scenarioName: scenarioName,
                     rubroOrder: { gastos: [], ingresos: [] },
                     data: { gastos: {}, ingresos: {} },
                     monthStatus: { gastos: {}, ingresos: {} }, // Only used for Gastos
                     reserveFund: { type: 'percent', values: Array(12).fill(5) }, // Default 5%
                     calculated: {
                         gastoAjustado: {}, totalGastoRubroMes: {}, totalGastoProyectadoMes: Array(12).fill(0),
                         ingresoAjustado: {}, totalIngresoRubroMes: {}, totalIngresoProyectadoMes: Array(12).fill(0),
                         fondoReservaMes: Array(12).fill(0),
                         cuotaSobreGastosMes: Array(12).fill(0),
                         ipcManual: Array(12).fill(0), // Snapshot of IPC from settings
                         cuotaIpcMes: Array(12).fill(0),
                         cuotaRealBaseMes: Array(12).fill(0),
                         annualTotals: {
                             gastos: {__TOTAL__:0}, ingresos: {__TOTAL__:0}, fondoReserva: 0,
                             cuotaSobreGastos: 0, cuotaIpc: 0, cuotaRealBase: 0
                         }
                     }
                 };
                 // Deep copy the base structure
                 appState.scenarios[key] = JSON.parse(JSON.stringify(baseScenarioStructure));

                 // Copy GLOBAL settings IPC into the new scenario's IPC snapshot
                 if (Array.isArray(appState.settings?.ipcManual) && appState.settings.ipcManual.length === 12) {
                      appState.scenarios[key].calculated.ipcManual = [...appState.settings.ipcManual];
                 } else {
                      appState.scenarios[key].calculated.ipcManual = Array(12).fill(0);
                 }


                 // Ensure structures for existing global rubros are created within this new scenario
                initializeScenarioDataForRubros(appState.scenarios[key]);
            }
            return appState.scenarios[key];
        }


        function initializeScenarioDataForRubros(scenarioData) {
             if (!scenarioData) {
                console.warn("initializeScenarioDataForRubros llamado sin datos de escenario.");
                return;
             }

             // Ensure top-level structures exist (using nullish coalescing and default values)
             scenarioData.rubroOrder = scenarioData.rubroOrder ?? { gastos: [], ingresos: [] };
             scenarioData.rubroOrder.gastos = scenarioData.rubroOrder.gastos ?? [];
             scenarioData.rubroOrder.ingresos = scenarioData.rubroOrder.ingresos ?? [];

             scenarioData.data = scenarioData.data ?? { gastos: {}, ingresos: {} };
             scenarioData.data.gastos = scenarioData.data.gastos ?? {};
             scenarioData.data.ingresos = scenarioData.data.ingresos ?? {};

             scenarioData.monthStatus = scenarioData.monthStatus ?? { gastos: {}, ingresos: {} };
             scenarioData.monthStatus.gastos = scenarioData.monthStatus.gastos ?? {};
             // Note: monthStatus is currently only used/relevant for Gastos. Ingresos status isn't tracked per cell.

             scenarioData.reserveFund = scenarioData.reserveFund ?? { type: 'percent', values: Array(12).fill(5) };
             // Ensure reserveFund values array is 12 elements
              if (!Array.isArray(scenarioData.reserveFund.values) || scenarioData.reserveFund.values.length !== 12) {
                  scenarioData.reserveFund.values = Array(12).fill(scenarioData.reserveFund.type === 'fixed' ? 0 : 5);
              }


             scenarioData.calculated = scenarioData.calculated ?? {}; // Ensure calculated object exists
             // Ensure default calculated arrays/objects exist if missing
             const defaultCalcStructure = getDefaultAppState().scenarios.BaseExample?.calculated || {
                  gastoAjustado: {}, totalGastoRubroMes: {}, totalGastoProyectadoMes: Array(12).fill(0),
                  ingresoAjustado: {}, totalIngresoRubroMes: {}, totalIngresoProyectadoMes: Array(12).fill(0),
                  fondoReservaMes: Array(12).fill(0), cuotaSobreGastosMes: Array(12).fill(0),
                  ipcManual: Array(12).fill(0), cuotaIpcMes: Array(12).fill(0), cuotaRealBaseMes: Array(12).fill(0),
                  annualTotals: { gastos: {__TOTAL__:0}, ingresos: {__TOTAL__:0}, fondoReserva: 0, cuotaSobreGastos: 0, cuotaIpc: 0, cuotaRealBase: 0 }
             };

             for(const key in defaultCalcStructure) {
                // Only initialize if missing, don't deep copy arrays/objects here,
                // as they might contain existing loaded data.
                if(scenarioData.calculated[key] === undefined || scenarioData.calculated[key] === null) {
                     // For arrays/objects, create fresh empty ones
                     if (Array.isArray(defaultCalcStructure[key])) {
                         scenarioData.calculated[key] = Array(defaultCalcStructure[key].length).fill(0);
                     } else if (typeof defaultCalcStructure[key] === 'object' && defaultCalcStructure[key] !== null) {
                          scenarioData.calculated[key] = {};
                     } else {
                          scenarioData.calculated[key] = defaultCalcStructure[key];
                     }
                }
             }
              // Specifically ensure calculated.annualTotals substructures exist
              scenarioData.calculated.annualTotals = scenarioData.calculated.annualTotals ?? {};
              scenarioData.calculated.annualTotals.gastos = scenarioData.calculated.annualTotals.gastos ?? { __TOTAL__: 0 };
              scenarioData.calculated.annualTotals.ingresos = scenarioData.calculated.annualTotals.ingresos ?? { __TOTAL__: 0 };

             // Ensure ipcManual array exists and has 12 elements (copy from settings if scenario one is bad)
             if (!Array.isArray(scenarioData.calculated.ipcManual) || scenarioData.calculated.ipcManual.length !== 12) {
                console.warn(`Scenario ${scenarioData.year}-${scenarioData.scenarioName} IPC snapshot invalid. Copying from settings.`);
                scenarioData.calculated.ipcManual = [...(appState.settings?.ipcManual || Array(12).fill(0))];
             }


             // Iterate through GLOBAL rubro lists from settings to ensure scenario structures exist for them
             ['gastos', 'ingresos'].forEach(type => {
                 const globalRubros = appState.settings?.rubros?.[type] || [];
                 globalRubros.forEach(rubro => {
                     // Ensure data/status structures for the rubro exist in the scenario
                     if (!scenarioData.data[type][rubro]) {
                         scenarioData.data[type][rubro] = { detailOrder: [], detailsData: {} };
                     }
                     if (type === 'gastos' && !scenarioData.monthStatus[type][rubro]) {
                         scenarioData.monthStatus[type][rubro] = {}; // Initialize as object for details
                     }
                     // Initialize detailOrder/detailsData inside data[type][rubro] if they are missing
                     scenarioData.data[type][rubro].detailOrder = scenarioData.data[type][rubro].detailOrder ?? [];
                     scenarioData.data[type][rubro].detailsData = scenarioData.data[type][rubro].detailsData ?? {};


                     // Initialize calculated substructures for this rubro if missing
                     if (type === 'gastos') {
                        scenarioData.calculated.gastoAjustado = scenarioData.calculated.gastoAjustado ?? {};
                        scenarioData.calculated.totalGastoRubroMes = scenarioData.calculated.totalGastoRubroMes ?? {};
                        if (!scenarioData.calculated.gastoAjustado[rubro]) scenarioData.calculated.gastoAjustado[rubro] = {};
                        if (!scenarioData.calculated.totalGastoRubroMes[rubro]) scenarioData.calculated.totalGastoRubroMes[rubro] = Array(12).fill(0);
                     } else { // ingresos
                        scenarioData.calculated.ingresoAjustado = scenarioData.calculated.ingresoAjustado ?? {};
                        scenarioData.calculated.totalIngresoRubroMes = scenarioData.calculated.totalIngresoRubroMes ?? {};
                         if (!scenarioData.calculated.ingresoAjustado[rubro]) scenarioData.calculated.ingresoAjustado[rubro] = {};
                         if (!scenarioData.calculated.totalIngresoRubroMes[rubro]) scenarioData.calculated.totalIngresoRubroMes[rubro] = Array(12).fill(0);
                     }

                     // Initialize annual totals for the rubro if missing
                     if (scenarioData.calculated.annualTotals[type][rubro] === undefined) {
                         scenarioData.calculated.annualTotals[type][rubro] = 0;
                     }

                     // Ensure detail structures within the rubro data/status are initialized
                     const detailOrder = scenarioData.data[type][rubro].detailOrder ?? [];
                     detailOrder.forEach(detail => {
                         if(scenarioData.data[type][rubro].detailsData[detail] === undefined) {
                              scenarioData.data[type][rubro].detailsData[detail] = Array(12).fill(0);
                         } else if (!Array.isArray(scenarioData.data[type][rubro].detailsData[detail]) || scenarioData.data[type][rubro].detailsData[detail].length !== 12) {
                             // If it exists but is not a valid 12-element array, replace it
                             console.warn(`Detail data for ${type}/${rubro}/${detail} is invalid. Resetting.`);
                             scenarioData.data[type][rubro].detailsData[detail] = Array(12).fill(0);
                         }

                         if (type === 'gastos') {
                              if (scenarioData.monthStatus[type][rubro]?.[detail] === undefined) {
                                  scenarioData.monthStatus[type][rubro][detail] = Array(12).fill('Estimado');
                              } else if (!Array.isArray(scenarioData.monthStatus[type][rubro][detail]) || scenarioData.monthStatus[type][rubro][detail].length !== 12) {
                                   // If it exists but is not a valid 12-element array, replace it
                                   console.warn(`Detail status for ${type}/${rubro}/${detail} is invalid. Resetting.`);
                                  scenarioData.monthStatus[type][rubro][detail] = Array(12).fill('Estimado');
                              }
                         }
                          // calculated.[gasto/ingreso]Ajustado is initialized per rubro above, details are handled inside calculateAll
                     });

                 });
             });
             // After ensuring structures exist, clean up any detail data that might be orphaned (rubro no longer exists)
             ['gastos', 'ingresos'].forEach(type => {
                 const globalRubros = appState.settings?.rubros?.[type] || [];
                 const scenarioRubros = Object.keys(scenarioData.data[type] || {});
                  scenarioRubros.forEach(rubro => {
                      if (!globalRubros.includes(rubro)) {
                           console.warn(`Rubro "${rubro}" in scenario data but not in global settings. Removing from scenario.`);
                           delete scenarioData.data[type][rubro];
                           if (type === 'gastos') delete scenarioData.monthStatus[type][rubro];
                           // Calculated data will be rebuilt in calculateAll
                           // rubroOrder will be rebuilt from remaining data or global settings
                      }
                  });
             });
         }


        // --- Lógica de Negocio y Cálculos ---
        function calculateAll(scenarioData) {
             console.log(`Recalculando TODO para: ${scenarioData?.year} - ${scenarioData?.scenarioName}`);
             if (!scenarioData) { console.error("CalculateAll: No scenario data provided."); renderEmptyState(); return; }

             // Ensure structures are complete and valid before calculating
             initializeScenarioDataForRubros(scenarioData);

             const { data, monthStatus, reserveFund, rubroOrder } = scenarioData;
             const { settings } = appState;
             const { rubros, rubroConfig, coefficientTypes, cantidadUnidades } = settings;
             const calculated = scenarioData.calculated; // Direct reference

             // Ensure calculated.ipcManual snapshot is up-to-date with settings before using it
             if (Array.isArray(settings.ipcManual) && settings.ipcManual.length === 12) {
                 calculated.ipcManual = [...settings.ipcManual];
             } else {
                 calculated.ipcManual = Array(12).fill(0); // Fallback
             }


             // --- Reset Calculated Values ---
             calculated.gastoAjustado = {}; calculated.totalGastoRubroMes = {}; calculated.totalGastoProyectadoMes = Array(12).fill(0);
             calculated.ingresoAjustado = {}; calculated.totalIngresoRubroMes = {}; calculated.totalIngresoProyectadoMes = Array(12).fill(0);
             calculated.fondoReservaMes = Array(12).fill(0);
             calculated.cuotaSobreGastosMes = Array(12).fill(0);
             calculated.cuotaIpcMes = Array(12).fill(0);
             calculated.cuotaRealBaseMes = Array(12).fill(0);

             calculated.annualTotals = {
                gastos: { __TOTAL__: 0 },
                ingresos: { __TOTAL__: 0 },
                fondoReserva: 0,
                cuotaSobreGastos: 0,
                cuotaIpc: 0,
                cuotaRealBase: 0
             };
             // Ensure annual total objects exist (redundant with initialize, but safe)
             calculated.annualTotals.gastos = { __TOTAL__: 0 };
             calculated.annualTotals.ingresos = { __TOTAL__: 0 };
             // --- End Reset ---


             // 1. Gastos Ajustados y Totales
             // Use scenario-specific rubro order if available, otherwise process all in data that are in global settings
             const gastoRubrosToProcess = (Array.isArray(rubroOrder?.gastos) && rubroOrder.gastos.length > 0
                                          ? rubroOrder.gastos
                                          : Object.keys(data?.gastos || {}))
                                          .filter(rubro => settings.rubros.gastos.includes(rubro)); // Filter by global settings

             gastoRubrosToProcess.forEach(rubro => {
                 // Ensure data structure exists for this rubro
                 if (!data.gastos || !data.gastos[rubro]) {
                    console.warn(`Data missing for gasto rubro "${rubro}" during calculation.`);
                    return;
                 }

                 // Initialize calculated structures for this rubro
                 calculated.gastoAjustado[rubro] = {};
                 calculated.totalGastoRubroMes[rubro] = Array(12).fill(0);
                 calculated.annualTotals.gastos[rubro] = 0;

                 const config = rubroConfig[rubro] || {};
                 const coefTypeKey = config.coefficientType || 'None';
                 // Get coefficient values (percentages). Ensure it's an array of 12 numbers.
                  // --- MODIFICACIÓN FIX: Ensure coefValues is a valid array of 12 numbers (percentages) ---
                 const coefValuesRaw = coefficientTypes[coefTypeKey]?.values;
                 const coefPercentages = (Array.isArray(coefValuesRaw) && coefValuesRaw.length === 12)
                                         ? coefValuesRaw.map(v => window.toNumber(v || 0))
                                         : Array(12).fill(0); // Default to 0% increase
                 // --- END MODIFICACIÓN FIX ---


                 // Use scenario-specific detail order if available, otherwise process all in data
                 const detailOrder = (Array.isArray(data.gastos[rubro].detailOrder) && data.gastos[rubro].detailOrder.length > 0
                                     ? data.gastos[rubro].detailOrder
                                     : Object.keys(data.gastos[rubro].detailsData || {}))
                                     .filter(detail => data.gastos[rubro].detailsData[detail] !== undefined); // Ensure detail data exists

                 detailOrder.forEach(detail => {
                      // Ensure data and status arrays exist before accessing them
                    const baseValues = Array.isArray(data.gastos[rubro].detailsData[detail]) && data.gastos[rubro].detailsData[detail].length === 12
                                       ? data.gastos[rubro].detailsData[detail].map(v => window.toNumber(v || 0))
                                       : Array(12).fill(0);

                    const statusArray = (monthStatus.gastos && monthStatus.gastos[rubro] && Array.isArray(monthStatus.gastos[rubro][detail]) && monthStatus.gastos[rubro][detail].length === 12)
                                         ? monthStatus.gastos[rubro][detail]
                                         : Array(12).fill('Estimado'); // Default to Estimado if no status or invalid

                     calculated.gastoAjustado[rubro][detail] = Array(12).fill(0); // Initialize adjusted array for detail

                     // The `calculated.gastoAjustado` array for a detail should directly store the final value for each month:
                     // - The loaded value if the month is REAL.
                     // - The *projected* value if the month is ESTIMADO *after* the last REAL month (this is handled by `recalculateEstimates`).
                     // - The loaded value (likely 0) if the month is ESTIMADO *before* the first REAL month.
                     // So, in `calculateAll`, we just use the values already placed in `data.gastos[rubro].detailsData[detail]` by the load or recalculateEstimates process.

                     const finalDetailValues = Array(12).fill(0); // Array to store final values for this detail

                     for (let i = 0; i < 12; i++) {
                          // Use the value directly from the source data, which has been populated by load or recalculateEstimates
                          finalDetailValues[i] = baseValues[i]; // baseValues is derived from scenarioData.data here

                          // Add to monthly total for the rubro using this final value
                          calculated.totalGastoRubroMes[rubro][i] += finalDetailValues[i];
                     }
                     calculated.gastoAjustado[rubro][detail] = finalDetailValues; // Store the final values


                 });

                 // Sum monthly totals for the rubro to overall monthly/annual totals
                 for (let i = 0; i < 12; i++) {
                     const monthTotalRubro = calculated.totalGastoRubroMes[rubro]?.[i] || 0;
                     calculated.totalGastoProyectadoMes[i] += monthTotalRubro;
                     calculated.annualTotals.gastos[rubro] += monthTotalRubro;
                 }
             });
             calculated.annualTotals.gastos.__TOTAL__ = calculated.totalGastoProyectadoMes.reduce((a, b) => a + (b || 0), 0);


             // 2. Ingresos Ajustados & Totales & Expensa Real Base Extraction
             const unidades = parseInt(cantidadUnidades) || 1;
             // Use scenario-specific rubro order if available, otherwise process all in data that are in global settings
             const ingresoRubrosToProcess = (Array.isArray(rubroOrder?.ingresos) && rubroOrder.ingresos.length > 0
                                            ? rubroOrder.ingresos
                                            : Object.keys(data?.ingresos || {}))
                                            .filter(rubro => settings.rubros.ingresos.includes(rubro)); // Filter by global settings


             ingresoRubrosToProcess.forEach(rubro => {
                  // Ensure data structure exists for this rubro
                  if (!data.ingresos || !data.ingresos[rubro]) {
                     console.warn(`Data missing for ingreso rubro "${rubro}" during calculation.`);
                     return;
                  }

                 calculated.ingresoAjustado[rubro] = {}; // Stores BASE values for detail display
                 calculated.totalIngresoRubroMes[rubro] = Array(12).fill(0); // Stores FINAL calculated value (incl. UF mult)
                 calculated.annualTotals.ingresos[rubro] = 0;

                 // Use scenario-specific detail order if available, otherwise process all in data
                 const detailOrder = (Array.isArray(data.ingresos[rubro].detailOrder) && data.ingresos[rubro].detailOrder.length > 0
                                     ? data.ingresos[rubro].detailOrder
                                     : Object.keys(data.ingresos[rubro].detailsData || {}))
                                     .filter(detail => data.ingresos[rubro].detailsData[detail] !== undefined); // Ensure detail data exists


                 detailOrder.forEach(detail => {
                      const baseValues = Array.isArray(data.ingresos[rubro].detailsData[detail]) && data.ingresos[rubro].detailsData[detail].length === 12
                                         ? data.ingresos[rubro].detailsData[detail].map(v => window.toNumber(v || 0))
                                         : Array(12).fill(0);

                     // Store BASE values in 'ingresoAjustado' for the detail table display
                     calculated.ingresoAjustado[rubro][detail] = baseValues;

                     // Calculate the contribution of this detail's BASE value to the monthly rubro total (before UF mult)
                     for (let i = 0; i < 12; i++) {
                         calculated.totalIngresoRubroMes[rubro][i] += baseValues[i];
                     }
                 });

                 // After summing all details for the rubro, apply multiplication if it's a special rubro
                 if (SPECIAL_INGRESO_RUBROS.includes(rubro)) {
                     for (let i = 0; i < 12; i++) {
                         calculated.totalIngresoRubroMes[rubro][i] *= unidades;
                     }
                 }

                 // Sum the final calculated monthly totals for the rubro to the overall ingreso totals and annuals
                 for (let i = 0; i < 12; i++) {
                     const monthTotalRubroFinal = calculated.totalIngresoRubroMes[rubro]?.[i] || 0;
                     calculated.totalIngresoProyectadoMes[i] += monthTotalRubroFinal;
                     calculated.annualTotals.ingresos[rubro] += monthTotalRubroFinal;
                 }
             });
             calculated.annualTotals.ingresos.__TOTAL__ = calculated.totalIngresoProyectadoMes.reduce((a, b) => a + (b || 0), 0);

            // MODIFICACIÓN INICIO - Cálculo de Expensa Real ($/UF)
             // --- Calcular Expensa Real ($/UF) dividiendo el total del rubro CUOTA_RUBRO_NAME por UF ---
             // Obtener la cantidad de UF desde settings (ya obtenida arriba, pero la re-obtenemos por claridad en el bloque)
             const unidadesParaExpensaReal = parseInt(settings.cantidadUnidades) || 1;

             if (unidadesParaExpensaReal <= 0) {
                  console.warn("Cantidad de Unidades Funcionales es cero o inválida. No se puede calcular Cuota Real Base por UF.");
                  // Si las unidades son cero o menos, la Expensa Real por UF es cero. Asegurar array de 12 ceros.
                 calculated.cuotaRealBaseMes = Array(12).fill(0);
             } else if (calculated.totalIngresoRubroMes?.[CUOTA_RUBRO_NAME]) {
                 // Si el rubro CUOTA_RUBRO_NAME existe y tiene totales calculados (ya multiplicados por UF)...
                 calculated.cuotaRealBaseMes = Array(12); // Reinicializar array para este cálculo
                 for (let i = 0; i < 12; i++) {
                     const totalRubroMes = calculated.totalIngresoRubroMes[CUOTA_RUBRO_NAME][i] || 0;
                     // ... dividir ese total (que ya incluye la mult. por UF) por la cantidad de UF para obtener el valor por UF
                     calculated.cuotaRealBaseMes[i] = totalRubroMes / unidadesParaExpensaReal;
                 }
             } else {
                 // Si el rubro CUOTA_RUBRO_NAME no existe, la Expensa Real por UF es cero. Asegurar array de 12 ceros.
                 calculated.cuotaRealBaseMes = Array(12).fill(0);
             }

             // Calcular el total anual para la Expensa Real por UF (basado en los valores mensuales recién calculados)
             calculated.annualTotals.cuotaRealBase = calculated.cuotaRealBaseMes.reduce((a,b)=>a+(b||0),0);
            // MODIFICACIÓN FIN


             // 3. Fondo Reserva
             // Ensure reserveFund values array is 12 elements (validated in initialize, but check again for safety)
              const reserveValues = Array.isArray(reserveFund?.values) && reserveFund.values.length === 12
                                     ? reserveFund.values.map(v => window.toNumber(v || 0))
                                     : Array(12).fill(reserveFund?.type === 'fixed' ? 0 : 5);

             for (let i = 0; i < 12; i++) {
                 const reserveValueInput = reserveValues[i];
                 calculated.fondoReservaMes[i] = reserveFund?.type === 'percent'
                     ? (calculated.totalGastoProyectadoMes[i] || 0) * (reserveValueInput / 100)
                     : reserveValueInput;
             }
             calculated.annualTotals.fondoReserva = calculated.fondoReservaMes.reduce((a, b) => a + (b || 0), 0);


             // 4. Cuota Sobre Gastos (Gasto + Fondo / UF)
             const unidadesParaCuotaSobreGastos = parseInt(settings.cantidadUnidades) || 1;
             for (let i = 0; i < 12; i++) {
                 const totalGastoYFondo = (calculated.totalGastoProyectadoMes[i] || 0) + (calculated.fondoReservaMes[i] || 0);
                 calculated.cuotaSobreGastosMes[i] = unidadesParaCuotaSobreGastos > 0 ? totalGastoYFondo / unidadesParaCuotaSobreGastos : 0;
             }
             calculated.annualTotals.cuotaSobreGastos = calculated.cuotaSobreGastosMes.reduce((a,b)=>a+(b||0),0);


             // 5. Cuota IPC usando Expensa Real ($/UF) de Enero como base y acumulando IPC mes a mes
             // Este bloque utiliza calculated.cuotaRealBaseMes que contiene el valor por UF
             {
                 const baseEnero = (calculated.cuotaRealBaseMes?.[0] || 0); // Usa el valor de Enero de la columna "Expensa Real ($/UF)"
                  // Ensure ipcManual snapshot is a valid array of 12 numbers (percentages)
                  const ipcSnapshot = (Array.isArray(calculated.ipcManual) && calculated.ipcManual.length === 12)
                                      ? calculated.ipcManual.map(v => window.toNumber(v || 0))
                                      : Array(12).fill(0); // Default to 0%

                 const ipcEnero  = ipcSnapshot[0];
                 // --- MODIFICACIÓN FIX: Apply IPC as cumulative multiplier ---
                 calculated.cuotaIpcMes[0] = baseEnero * (1 + ipcEnero / 100);
                 for (let i = 1; i < 12; i++) {
                     const ipc = ipcSnapshot[i];
                      calculated.cuotaIpcMes[i] = (calculated.cuotaIpcMes[i - 1] || 0) * (1 + ipc / 100); // Acumula sobre el mes anterior
                 }
                  // --- END MODIFICACIÓN FIX ---
             }
             // 6. Calculate Annual Totals for new/modified columns
             calculated.annualTotals.cuotaIpc = calculated.cuotaIpcMes.reduce((a, b) => a + (b || 0), 0);


             console.log("Recálculo Finalizado.", calculated);
             saveState(); // Save state after successful calculation
             updateUI(); // Update the display
             showSnackbar("Cálculos actualizados correctamente.", false, 'success');
        }

        // --- Recalcular Estimados (ACUMULATIVO) ---
        function recalculateEstimates() {
            const scenarioData = getCurrentScenarioData();
            if (!scenarioData) { showSnackbar("No hay escenario activo para calcular estimados.", true, 'error'); return; }
            console.log(`Calculando estimados (Acumulativo) para: ${scenarioData.scenarioName}`);

            const { data, monthStatus, rubroOrder } = scenarioData;
            const { settings } = appState;
            const { rubros, rubroConfig, coefficientTypes } = settings;
            let changesMade = false;
             let projectedCount = 0;
             let rubrosProjected = 0;
             let detailsProjected = 0;


            // Ensure rubroOrder.gastos exists and is an array, filter by global settings
             const gastoRubrosToProcess = (Array.isArray(rubroOrder?.gastos) ? rubroOrder.gastos : [])
                                          .filter(rubro => settings.rubros.gastos.includes(rubro));

            if (gastoRubrosToProcess.length === 0) {
                 showSnackbar("No hay rubros de gasto definidos para proyectar.", false, 'info');
                 return;
            }

            gastoRubrosToProcess.forEach(rubro => {
                if (!data.gastos || !data.gastos[rubro]) return; // Skip if rubro data missing

                // Ensure detailOrder exists and is an array, filter by data existence
                const detailOrder = (Array.isArray(data.gastos[rubro].detailOrder) ? data.gastos[rubro].detailOrder : [])
                                     .filter(detail => data.gastos[rubro].detailsData[detail] !== undefined && Array.isArray(data.gastos[rubro].detailsData[detail]) && data.gastos[rubro].detailsData[detail].length === 12); // Ensure valid detail data array

                 if (detailOrder.length === 0) {
                     // console.log(`  Rubro "${rubro}": Sin detalles con datos válidos para proyectar.`);
                     return; // Skip if no details with valid data
                 }

                 rubrosProjected++;

                const rubroCoefConfig = rubroConfig[rubro] || {};
                const coefTypeKey = rubroCoefConfig.coefficientType || 'None';
                const currentCoefficientType = coefficientTypes[coefTypeKey];
                 // Get coefficient values (percentages). Ensure it's an array of 12 numbers.
                 // --- MODIFICACIÓN FIX: Ensure coefValues is a valid array of 12 numbers (percentages) ---
                const coefValuesRaw = currentCoefficientType?.values;
                const coefPercentages = (Array.isArray(coefValuesRaw) && coefValuesRaw.length === 12)
                                        ? coefValuesRaw.map(v => window.toNumber(v || 0))
                                        : Array(12).fill(0); // Default to 0% increase
                // --- END MODIFICACIÓN FIX ---

                detailOrder.forEach(detail => {
                    // Ensure data and status arrays exist before accessing them
                    const currentStatuses = (monthStatus.gastos && monthStatus.gastos[rubro] && Array.isArray(monthStatus.gastos[rubro][detail]) && monthStatus.gastos[rubro][detail].length === 12)
                                            ? monthStatus.gastos[rubro][detail]
                                            : Array(12).fill('Estimado');
                    // Use the *base* data values from scenarioData.data as the starting point for REAL months
                    const currentDataValues = Array.isArray(data.gastos[rubro].detailsData[detail]) && data.gastos[rubro].detailsData[detail].length === 12
                                            ? data.gastos[rubro].detailsData[detail].map(v => window.toNumber(v || 0))
                                            : Array(12).fill(0);


                    let lastRealMonthIndex = -1;
                    for (let i = currentStatuses.length - 1; i >= 0; i--) { // Iterate backwards to find the LAST REAL month index
                        if (currentStatuses[i] === 'REAL') {
                            lastRealMonthIndex = i;
                            break;
                        }
                    }

                    if (lastRealMonthIndex === -1 || lastRealMonthIndex === 11) {
                         // console.log(`   - ${rubro}/${detail}: Sin mes REAL encontrado o último mes es Diciembre. No se proyectará.`);
                         return; // Skip projection if no REAL month found or the last REAL is Dec
                    }

                     detailsProjected++;

                    // Start projecting from the month *after* the last REAL month
                    let previousMonthValue = currentDataValues[lastRealMonthIndex]; // Base value from the last REAL month

                    for (let j = lastRealMonthIndex + 1; j < 12; j++) {
                        // Only project if the current month 'j' is marked as 'Estimado'
                        // This handles cases where there might be a REAL month *after* the last overall REAL month.
                        if (currentStatuses[j] === 'Estimado') {
                             // Get the percentage coefficient for month 'j'
                             // --- MODIFICACIÓN FIX: Use percentage coefficient ---
                            const percentage = coefPercentages[j];
                            const multiplier = 1 + percentage / 100;
                            // --- END MODIFICACIÓN FIX ---

                            // Accumulative calculation: multiply the PREVIOUS month's value by the CURRENT month's multiplier
                            const projectedValue = previousMonthValue * multiplier;

                            // Update the data value for month 'j' in the scenario data
                            data.gastos[rubro].detailsData[detail][j] = projectedValue;
                            // Status is already 'Estimado' here.

                            changesMade = true;
                            projectedCount++;
                            // console.log(`     * ${MONTHS[j]} (${rubro}/${detail}): ${projectedValue.toFixed(2)} (Prev: ${previousMonthValue.toFixed(2)} * Multiplier: ${multiplier.toFixed(3)})`);

                            // Update previousMonthValue for the next iteration *using the newly calculated projected value*
                            previousMonthValue = projectedValue;
                        } else {
                            // If the current month 'j' is REAL (e.g., there was a number in Excel later),
                            // the projection stops for this detail at this point. The value from Excel is kept.
                            // The 'previousMonthValue' for the *next* estimated month should become this new REAL value.
                             previousMonthValue = currentDataValues[j]; // Use the actual value from the data for the next step
                            // console.log(`     * ${MONTHS[j]} (${rubro}/${detail}): Mes REAL. Deteniendo proyección acumulativa para este detalle aquí.`);
                             // Continue the loop to potentially pick up a new REAL month, but the cumulative projection chain is broken until the *next* ESTIMADO month after this REAL one.
                             // However, the current logic projects *all* estimated months after the LAST REAL month. If there's a REAL month mid-projection,
                             // recalculateEstimates should probably stop projecting from the previous REAL and, if there are *further* ESTIMATED months after this new REAL one,
                             // it should ideally start a *new* projection chain from *this* new REAL month.
                             // Let's adjust the logic: Find the LAST REAL month overall *first*, then project all months after it that are ESTIMATED.

                             // REVISED Logic: Find LAST REAL month overall, then project ALL subsequent ESTIMADO months from that point.
                             // The current inner loop already does this implicitly by checking `currentStatuses[j] === 'Estimado'`.
                             // Let's ensure the `previousMonthValue` correctly takes the value from the data *if* the month was REAL.

                              // If month 'j' is REAL, the base for the *next* month's projection (if it's Estimated) should be the value from month 'j'.
                              // If month 'j' is Estimated, the base for the *next* month's projection should be the projected value calculated for month 'j'.
                              // So, `previousMonthValue` should always be updated with the final determined value for month 'j'.
                              previousMonthValue = data.gastos[rubro].detailsData[detail][j]; // Use the value from the data array for the next iteration's base.
                              // This value is either the original loaded value (if REAL or ESTIMATED loaded) or the projected value (if just calculated).

                        }
                    }
                });
            });

             if (rubrosProjected === 0) {
                 showSnackbar("No se encontraron rubros de gasto con datos reales para proyectar.", false, 'info');
                 return;
             }


            if (changesMade) {
                console.log(`Se proyectaron ${projectedCount} celdas en ${detailsProjected} detalles de ${rubrosProjected} rubros. Recalculando todo...`);
                showSnackbar(`Meses estimados recalculados (${projectedCount} celdas). Actualizando dashboard...`, false, 'info', 4000);
                calculateAll(scenarioData); // Recalculate everything after projections
            } else {
                console.log("No se necesitaron cambios en los estimados.");
                showSnackbar("No se encontraron meses estimados que requieran recalcular.", false, 'info', 3000);
            }
        }


        // --- Actualización de la Interfaz (UI) ---
        function initUI() {
             document.getElementById('exercise-year')?.setAttribute('value', appState.currentYear);
             document.getElementById('footer-year').textContent = new Date().getFullYear();
             updateScenarioSelector(); // Populate selector based on loaded state
             updateCurrentYearAndScenarioInUI(); // Set initial text based on active scenario/year
        }

        function updateUI() {
             console.log("Actualizando UI completa...");
             const scenarioData = getCurrentScenarioData(); // Get current data
             if (!scenarioData) {
                 console.error("updateUI: No hay escenario activo o datos disponibles. Renderizando estado vacío.");
                 renderEmptyState(); // Show empty state if no data
                 updateCurrentYearAndScenarioInUI(); // Still update year/scenario display (might show 'Ninguno')
                 updateScenarioSelector(); // Update selector too (might show empty)
                 updateReportsPanel(); // Disable report buttons
                 updateSettingsPanel(); // Update settings lists and inputs
                 return; // Stop further UI updates
             }

             // If we have data, ensure it's properly initialized
             initializeScenarioDataForRubros(scenarioData);

             // Update all relevant UI sections
             updateCurrentYearAndScenarioInUI();
             updateScenarioSelector(); // Ensure selector reflects current state
             updateDashboardTables(scenarioData); // Update summary and detail tables
             updateCharts(scenarioData); // Update all charts
             updateReserveFundPanel(scenarioData); // Update reserve fund inputs
             updateSettingsPanel(); // Update settings lists and inputs
             updateReportsPanel(); // Enable/disable report buttons
             console.log("UI Actualizada.");
        }

        function renderEmptyState() {
            console.log("Renderizando estado vacío...");
            // Clear tables
            const summaryTable = document.getElementById('dashboard-summary');
            const summaryTbody = summaryTable?.querySelector('tbody');
            const summaryTfoot = summaryTable?.querySelector('tfoot');
            const summaryHeaderCells = summaryTable?.querySelector('thead tr')?.cells?.length || 8; // Now 8 columns
            if(summaryTbody) summaryTbody.innerHTML = `<tr><td colspan="${summaryHeaderCells}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos calculados para este escenario. Carga datos o usa los de ejemplo.</td></tr>`;
            if(summaryTfoot) summaryTfoot.innerHTML = '';

            const gastosTable = document.getElementById('gastos-detail-table');
             // MODIFICACIÓN FIX: Gastos table now has 16 cells (Rubro, Detalle, Coef, 12 Months, Total)
            const gastosTheadCells = gastosTable?.querySelector('thead tr')?.cells?.length || (2 + 1 + 12 + 1); // Rubro, Detalle, Coef, 12 Months, Total Anual
            const gastosTbody = gastosTable?.querySelector('tbody');
            const gastosTfoot = gastosTable?.querySelector('tfoot');
            if(gastosTbody) gastosTbody.innerHTML = `<tr><td colspan="${gastosTheadCells}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos de gastos.</td></tr>`;
            if(gastosTfoot) gastosTfoot.innerHTML = '';

            const ingresosTable = document.getElementById('ingresos-detail-table');
            const ingresosTheadCells = ingresosTable?.querySelector('thead tr')?.cells?.length || (2 + 12 + 1); // Rubro, Detalle, 12 Months, Total Anual
            const ingresosTbody = ingresosTable?.querySelector('tbody');
            const ingresosTfoot = ingresosTable?.querySelector('tfoot');
            if(ingresosTbody) ingresosTbody.innerHTML = `<tr><td colspan="${ingresosTheadCells}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos de ingresos.</td></tr>`;
            if(ingresosTfoot) ingresosTfoot.innerHTML = '';


            // Clear charts
            destroyChart('evolutivoCuotaChart'); displayChartNoData('evolutivoCuotaChart', true);
            destroyChart('participacionGastosChart'); displayChartNoData('participacionGastosChart', true);
            destroyChart('participacionIngresosChart'); displayChartNoData('participacionIngresosChart', true);

            // Clear coefficient editor
            const coefEditor = document.getElementById('coefficient-values-editor');
            const coefNameSpan = document.getElementById('editing-coefficient-name');
            if(coefEditor) editorDiv.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente (que no sea "Sin Coeficiente") de la lista de la izquierda para editar sus valores porcentuales (%) mes a mes.</p>';
            if(coefNameSpan) coefNameSpan.textContent = 'Ninguno';
            if(appState.uiState) appState.uiState.editingCoefficientType = null;
        }

        function destroyChart(canvasId) {
             const instance = window[`${canvasId}_instance`];
             if (instance) {
                instance.destroy();
                window[`${canvasId}_instance`] = null;
                // console.log(`Chart ${canvasId} destroyed.`);
             }
         }

        function displayChartNoData(canvasId, show) {
            const container = document.getElementById(canvasId)?.parentElement;
            const noDataElement = container?.querySelector('.chart-no-data');
            if (noDataElement) {
                noDataElement.style.display = show ? 'block' : 'none';
            }
            const canvasElement = document.getElementById(canvasId);
             if (canvasElement) {
                 canvasElement.style.display = show ? 'none' : 'block'; // Hide canvas if no data
             }
        }

        function updateCurrentYearAndScenarioInUI() {
            const scenarioData = getCurrentScenarioData();
            const year = scenarioData ? scenarioData.year : appState.currentYear;
            const scenarioName = scenarioData ? scenarioData.scenarioName : '(Ninguno)';
            // Update dashboard titles
            document.getElementById('dashboard-year').textContent = year;
            document.getElementById('dashboard-scenario').textContent = scenarioName;
            // Update titles in other tabs
            document.querySelectorAll('.current-year').forEach(el => el.textContent = year);
            document.querySelectorAll('.current-scenario').forEach(el => el.textContent = scenarioName);
            // Update year input in Upload tab if it differs
            const yearInput = document.getElementById('exercise-year');
            if (yearInput && yearInput.value !== String(year)) {
                 yearInput.value = year;
            }
        }

        function updateDashboardTables(scenarioData) {
             if (!scenarioData || !scenarioData.calculated) {
                 console.error("Faltan datos calculados en updateDashboardTables. Renderizando vacío.");
                 renderEmptyState();
                 return;
             }

             const { calculated } = scenarioData;
             // Use the IPC snapshot stored in 'calculated' for consistency
             // --- MODIFICACIÓN FIX: Ensure IPC snapshot is a valid array of 12 numbers (percentages) ---
             const ipcSnapshot = (Array.isArray(calculated.ipcManual) && calculated.ipcManual.length === 12)
                                 ? calculated.ipcManual.map(v => window.toNumber(v || 0))
                                 : Array(12).fill(0); // Default to 0%
             // --- END MODIFICACIÓN FIX ---

             const summaryTable = document.getElementById('dashboard-summary');
             const summaryTbody = summaryTable?.querySelector('tbody');
             const summaryTfoot = summaryTable?.querySelector('tfoot');

             if (!summaryTable || !summaryTbody || !summaryTfoot) {
                console.error("Elementos de la tabla de resumen no encontrados.");
                return;
             }
             const summaryHeaderCells = summaryTable.querySelector('thead tr')?.cells?.length || 8;


             summaryTbody.innerHTML = '';
             summaryTfoot.innerHTML = '';

             const hasData = calculated.totalGastoProyectadoMes?.some(v => v !== 0) || calculated.cuotaSobreGastosMes?.some(v => v !== 0) || calculated.cuotaRealBaseMes?.some(v => v !== 0); // Check Expensa Real data too
             if (!hasData) {
                summaryTbody.innerHTML = `<tr><td colspan="${summaryHeaderCells}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos calculados para mostrar en el resumen. Carga datos o usa los de ejemplo.</td></tr>`;
                // Clear detail tables as well if summary is empty
                 updateCollapsibleTable('gastos', scenarioData);
                 updateCollapsibleTable('ingresos', scenarioData);
                return;
            }

             // Populate tbody
             for (let i = 0; i < 12; i++) {
                 const row = summaryTbody.insertRow();
                 row.insertCell().textContent = FULL_MONTHS[i]; // Mes (usar nombre completo)

                 // Gasto ($)
                 const gastoCell = row.insertCell();
                 gastoCell.textContent = formatCurrency(calculated.totalGastoProyectadoMes?.[i] || 0);
                 gastoCell.classList.add('number-cell');

                 // Fondo ($)
                 const fondoCell = row.insertCell();
                 fondoCell.textContent = formatCurrency(calculated.fondoReservaMes?.[i] || 0);
                 fondoCell.classList.add('number-cell');

                 // Cuota s/Gs ($/UF) - Asumimos que siempre es por UF aquí
                 const cuotaGsCell = row.insertCell();
                 cuotaGsCell.textContent = formatCurrency(calculated.cuotaSobreGastosMes?.[i] || 0);
                 cuotaGsCell.classList.add('number-cell');

                 // IPC (%)
                 const ipcVal = ipcSnapshot[i]; // Use validated snapshot value
                 const ipcCell = row.insertCell();
                 ipcCell.textContent = `${ipcVal}%`;
                 ipcCell.classList.add('number-cell'); // Center align percentage

                 // Cuota IPC ($/UF) - Use pre-calculated value (ahora basado en Expensa Real $/UF de Enero)
                 const cuotaIpcCell = row.insertCell();
                 cuotaIpcCell.textContent = formatCurrency(calculated.cuotaIpcMes?.[i] || 0);
                 cuotaIpcCell.classList.add('number-cell', 'estimated-month-cell'); // Mark as calculated/estimated

                 // Expensa Real ($/UF) - Use pre-calculated value (ahora el valor del rubro 'Expensas Ordinarias' / UF)
                 const cuotaRealCell = row.insertCell();
                 cuotaRealCell.textContent = formatCurrency(calculated.cuotaRealBaseMes?.[i] || 0);
                 cuotaRealCell.classList.add('number-cell', 'real-month-cell'); // Mark as 'real' input visually (though it's derived)
             }

             // Populate tfoot with annual totals
             const tfootRow = summaryTfoot.insertRow();
             tfootRow.insertCell().textContent = "TOTAL ANUAL";

             // Gasto Total
             const gastoFootCell = tfootRow.insertCell();
             gastoFootCell.textContent = formatCurrency(calculated.annualTotals?.gastos?.__TOTAL__ || 0);
             gastoFootCell.classList.add('number-cell');

             // Fondo Total
             const fondoFootCell = tfootRow.insertCell();
             fondoFootCell.textContent = formatCurrency(calculated.annualTotals?.fondoReserva || 0);
             fondoFootCell.classList.add('number-cell');

             // Cuota s/Gs Total (Este total anual es menos significativo si la base es variable)
             const cuotaGsFootCell = tfootRow.insertCell();
             cuotaGsFootCell.textContent = formatCurrency(calculated.cuotaSobreGastosMes.reduce((a,b)=>a+(b||0),0)); // Suma los valores mensuales de Cuota s/Gs
             cuotaGsFootCell.classList.add('number-cell');

             // IPC Total (Not applicable)
             tfootRow.insertCell().textContent = "-";

             // Cuota IPC Total (Sumar los valores mensuales POR UF)
             const cuotaIpcFootCell = tfootRow.insertCell();
             cuotaIpcFootCell.textContent = formatCurrency(calculated.cuotaIpcMes.reduce((a,b)=>a+(b||0),0)); // Suma los valores mensuales de Cuota IPC
             cuotaIpcFootCell.classList.add('number-cell', 'estimated-month-cell');

             // Expensa Real ($/UF) Total (Sumar los valores mensuales POR UF)
             const cuotaRealFootCell = tfootRow.insertCell();
             cuotaRealFootCell.textContent = formatCurrency(calculated.cuotaRealBaseMes.reduce((a,b)=>a+(b||0),0)); // Suma los valores mensuales de Expensa Real
             cuotaRealFootCell.classList.add('number-cell', 'real-month-cell');

             // --- Update detail tables AFTER summary ---
             updateCollapsibleTable('gastos', scenarioData);
             updateCollapsibleTable('ingresos', scenarioData);
         }

        function updateCollapsibleTable(type, scenarioData) {
             const tableId = `${type}-detail-table`;
             const table = document.getElementById(tableId);
             if (!table) { console.warn(`Tabla ${tableId} no encontrada.`); return; }

             const thead = table.querySelector('thead');
             const tbody = table.querySelector('tbody');
             const tfoot = table.querySelector('tfoot');

             if (!thead || !tbody || !tfoot) { console.error(`Elementos internos de ${tableId} no encontrados.`); return;}

             tbody.innerHTML = '';
             tfoot.innerHTML = '';

             if (!scenarioData || !scenarioData.data || !scenarioData.calculated || !scenarioData.rubroOrder || !appState.settings || !appState.settings.rubros) {
                  // MODIFICACIÓN FIX: Use correct cell count for colspan
                 const cols = (type === 'gastos' ? 16 : 15);
                 tbody.innerHTML = `<tr><td colspan="${cols}" class="text-muted" style="text-align: center; padding: 20px;">Faltan datos o configuración para mostrar el detalle.</td></tr>`;
                 return;
             }

             const { data, calculated, monthStatus, rubroOrder } = scenarioData;
             const config = appState.settings.rubroConfig || {};
             // Use 'gastoAjustado' for gastos (includes coefficient effect)
             // Use 'ingresoAjustado' for ingresos (stores BASE values for display consistency)
             const calculatedSet = calculated[type === 'gastos' ? 'gastoAjustado' : 'ingresoAjustado'] || {};
             // Use 'totalGastoRubroMes' or 'totalIngresoRubroMes' for rubro totals (includes UF mult for ingresos)
             const totalRubroSet = calculated[type === 'gastos' ? 'totalGastoRubroMes' : 'totalIngresoRubroMes'] || {};
             const annualRubroTotals = calculated.annualTotals?.[type] || { __TOTAL__: 0 };
             // --- FIX: Use scenario-specific rubro order, filter by global settings ---
             const orderedRubros = (Array.isArray(rubroOrder[type]) ? rubroOrder[type] : [])
                                   .filter(rubro => appState.settings.rubros[type].includes(rubro));


             // --- Dynamically add Month Headers if not present or incorrect ---
             let theadRow = thead.querySelector('tr');
             if (!theadRow) {
                 theadRow = thead.insertRow();
             }
             // Expected headers: Rubro/Detalle + (Coef for Gastos) + 12 Months + Total Anual
             const expectedHeaderCount = (type === 'gastos' ? 2 : 1) + MONTHS.length + 1;

              // Check if headers need rebuilding or adjusting
             let headersNeedRebuild = false;
             if (theadRow.cells.length !== expectedHeaderCount) {
                 headersNeedRebuild = true;
             } else if (type === 'gastos' && theadRow.cells[1]?.textContent !== "Coef. Aplicado") {
                 headersNeedRebuild = true;
             } else if (theadRow.cells[0]?.textContent !== "Rubro / Detalle") {
                 headersNeedRebuild = true;
             } else {
                 // Check month names
                 for(let i=0; i<12; i++) {
                      if (theadRow.cells[ (type === 'gastos' ? 2 : 1) + i]?.textContent !== MONTHS[i]) {
                          headersNeedRebuild = true; break;
                      }
                 }
                  if (!headersNeedRebuild && theadRow.cells[expectedHeaderCount - 1]?.textContent !== "Total Anual") {
                       headersNeedRebuild = true;
                  }
             }


             if (headersNeedRebuild) {
                 theadRow.innerHTML = ''; // Clear existing headers
                 theadRow.insertCell().textContent = "Rubro / Detalle";
                 if (type === 'gastos') {
                       const thCoef = document.createElement('th');
                       thCoef.textContent = "Coef. Aplicado";
                       theadRow.appendChild(thCoef);
                   }

                 MONTHS.forEach(month => {
                     const th = document.createElement('th');
                     th.textContent = month;
                     th.classList.add('number-cell');
                     theadRow.appendChild(th);
                 });
                 const thTotal = document.createElement('th');
                 thTotal.textContent = "Total Anual";
                 thTotal.classList.add('number-cell');
                 theadRow.appendChild(thTotal);
             }
             // --- End Dynamic Header ---


             if (orderedRubros.length === 0) {
                 tbody.innerHTML = `<tr><td colspan="${expectedHeaderCount}" class="text-muted" style="text-align: center; padding: 20px;">No hay rubros definidos o cargados con datos para ${type} en este escenario.</td></tr>`;
                 return;
             }

             // Build table body rows
             let totalRubroAdded = 0;
             orderedRubros.forEach(rubro => {
                // Ensure data exists for this rubro in the scenario
                if (!data[type]?.[rubro]) return;

                 const rubroData = data[type][rubro];
                 // --- FIX: Use scenario-specific detail order, filter by data existence ---
                 const orderedDetails = (Array.isArray(rubroData.detailOrder) ? rubroData.detailOrder : [])
                                     .filter(detail => rubroData.detailsData?.[detail] !== undefined);

                 // Only add the rubro row if there are details with data
                 if (orderedDetails.length === 0) return;

                 totalRubroAdded++;

                 // Use global config for collapsed state, ensure it exists
                 const rubroUiConfig = appState.settings.rubroConfig?.[rubro] || { detailsCollapsed: true };


                 // --- Rubro Total Row ---
                 const totalRow = tbody.insertRow();
                 totalRow.classList.add('rubro-total-row');
                 if (rubroUiConfig.detailsCollapsed) totalRow.classList.add('collapsed');
                 totalRow.dataset.rubro = rubro;
                 totalRow.dataset.type = type;

                 totalRow.insertCell().textContent = rubro;
                 if(type === 'gastos') totalRow.insertCell().textContent = ''; // Empty cell for Coef. Aplicado in total row


                 const monthlyTotals = totalRubroSet[rubro] || Array(12).fill(0);
                 monthlyTotals.forEach(val => {
                     const cell = totalRow.insertCell();
                     cell.textContent = formatCurrency(val);
                     cell.classList.add('number-cell');
                 });

                 const cellAnnualTotal = totalRow.insertCell();
                 cellAnnualTotal.textContent = formatCurrency(annualRubroTotals[rubro] || 0);
                 cellAnnualTotal.classList.add('number-cell');
                 // --- End Rubro Total Row ---


                 // --- Detail Rows (if any) ---
                 const coefName = type === 'gastos' ? (appState.settings.coefficientTypes[config[rubro]?.coefficientType || 'None']?.name || 'N/A') : ''; // Get coef name for Gastos details

                 orderedDetails.forEach(detail => {
                      // --- FIX: Ensure detail data exists in calculatedSet before rendering row ---
                      if (!calculatedSet[rubro] || calculatedSet[rubro][detail] === undefined) {
                         console.warn(`Detalle calculado no encontrado para ${type}/${rubro}/${detail}. Omitiendo fila.`);
                         return;
                      }


                     const detailRow = tbody.insertRow();
                     detailRow.classList.add('detail-row');
                     detailRow.dataset.rubro = rubro;
                     detailRow.dataset.type = type;
                     if (rubroUiConfig.detailsCollapsed) detailRow.classList.add('hidden');

                     const cellDetailName = detailRow.insertCell();
                     cellDetailName.textContent = detail;
                     cellDetailName.classList.add('text-muted');

                      if (type === 'gastos') {
                         const cellCoef = detailRow.insertCell();
                         cellCoef.textContent = coefName; // Show assigned coef name
                         cellCoef.classList.add('text-muted');
                     }

                     // Monthly value cells for the detail
                     const detailValues = calculatedSet[rubro][detail]; // Use pre-validated calculated values (gastoAjustado or ingresoAjustado)
                     // monthStatus only exists for Gastos in the current structure
                     const detailStatuses = (type === 'gastos' && monthStatus[type]?.[rubro]?.[detail] && Array.isArray(monthStatus[type][rubro][detail]) && monthStatus[type][rubro][detail].length === 12)
                                            ? monthStatus.gastos[rubro][detail]
                                            : Array(12).fill('Estimado'); // Default to Estimado if no status or type is Ingresos
                     let annualDetailTotal = 0;

                     detailValues.forEach((val, index) => {
                         const cell = detailRow.insertCell();
                         cell.textContent = formatCurrency(val);
                         cell.classList.add('number-cell');
                         // Apply color only for Gastos based on status loaded from Excel
                          if (type === 'gastos') {
                             // Use original status from monthStatus for coloring
                             const originalStatus = (monthStatus.gastos?.[rubro]?.[detail]?.[index] || 'Estimado');
                             cell.classList.add(originalStatus === 'REAL' ? 'real-month-cell' : 'estimated-month-cell');
                          }
                         annualDetailTotal += val;
                     });

                     // Annual total cell for the detail
                     const cellAnnualDetail = detailRow.insertCell();
                     cellAnnualDetail.textContent = formatCurrency(annualDetailTotal);
                     cellAnnualDetail.classList.add('number-cell');
                 });
                 // --- End Detail Rows ---
             });

             // --- Check if tbody is empty *after* loops ---
             if (totalRubroAdded === 0) {
                 tbody.innerHTML = `<tr><td colspan="${expectedHeaderCount}" class="text-muted" style="text-align: center; padding: 20px;">No hay rubros con datos para mostrar en el detalle de ${type}. Carga datos desde Excel.</td></tr>`;
             } else {
                 // Build table footer row (Overall Total) only if there was content
                 const tfootRow = tfoot.insertRow();
                 tfootRow.insertCell().textContent = `TOTAL GENERAL ${type.toUpperCase()}`;
                 if(type === 'gastos') tfootRow.insertCell().textContent = ''; // Empty cell for Coef. Aplicado in footer

                 // Use totalGastoProyectadoMes or totalIngresoProyectadoMes for footer totals
                 const totalGeneralMensual = calculated[type === 'gastos' ? 'totalGastoProyectadoMes' : 'totalIngresoProyectadoMes'] || Array(12).fill(0);
                 totalGeneralMensual.forEach(val => {
                     const cell = tfootRow.insertCell();
                     cell.textContent = formatCurrency(val);
                     cell.classList.add('number-cell');
                 });

                 const cellTotalAnualGeneral = tfootRow.insertCell();
                 cellTotalAnualGeneral.textContent = formatCurrency(annualRubroTotals.__TOTAL__ || 0);
                 cellTotalAnualGeneral.classList.add('number-cell');
             }

             // Ensure listeners are present (safe to call multiple times if logic prevents duplicates)
             addCollapsibleListeners();
         }


        function updateCharts(scenarioData) {
             if (!scenarioData || !scenarioData.calculated || !scenarioData.calculated.annualTotals) {
                 console.warn("Datos insuficientes para actualizar gráficos.");
                 destroyChart('evolutivoCuotaChart'); displayChartNoData('evolutivoCuotaChart', true);
                 destroyChart('participacionGastosChart'); displayChartNoData('participacionGastosChart', true);
                 destroyChart('participacionIngresosChart'); displayChartNoData('participacionIngresosChart', true);
                 return;
             }

             const { calculated } = scenarioData;
             const labels = MONTHS;

             // Get current theme colors dynamically
             const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
             const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim();
             const secondaryColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color').trim();
             const cardBg = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim();
             const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();


             const chartColors = [ // Define a consistent palette
                primaryColor, accentColor, '#ffc107', '#6f42c1', '#fd7e14', '#17a2b8',
                '#dc3545', secondaryColor, '#20c997', '#0d6efd', '#198754', '#adb5bd' // More colors
             ];

             // --- Evolutivo Expensa Chart (Line) ---
             destroyChart('evolutivoCuotaChart');
             const ctxEvolutivo = document.getElementById('evolutivoCuotaChart')?.getContext('2d');
             // Check if either Cuota s/Gtos OR Expensa Real Base has non-zero data
             const evolutivoHasData = (calculated.cuotaSobreGastosMes?.some(v => v !== 0) ?? false) || (calculated.cuotaRealBaseMes?.some(v => v !== 0) ?? false);
             displayChartNoData('evolutivoCuotaChart', !evolutivoHasData);

             if (ctxEvolutivo && evolutivoHasData) {
                window.evolutivoCuotaChart_instance = new Chart(ctxEvolutivo, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            { // Cuota s/Gtos (Calculated from expenses + reserve / UF)
                                label: 'Cuota s/Gtos ($/UF)',
                                data: calculated.cuotaSobreGastosMes,
                                borderColor: primaryColor,
                                backgroundColor: hexToRgba(primaryColor, 0.1),
                                tension: 0.2,
                                fill: true,
                                yAxisID: 'yCuota'
                            },
                            { // Expensa Real Base (From Ingresos base data / UF)
                                label: 'Expensa Real ($/UF)',
                                data: calculated.cuotaRealBaseMes,
                                borderColor: accentColor,
                                backgroundColor: hexToRgba(accentColor, 0.1),
                                tension: 0.2,
                                fill: true,
                                yAxisID: 'yCuota' // Same axis for direct comparison
                            },
                             { // Cuota IPC (Calculated based on Expensa Real Base Enero $/UF and IPC ref)
                                label: 'Cuota IPC ($/UF)',
                                data: calculated.cuotaIpcMes,
                                borderColor: secondaryColor, // Use secondary color
                                backgroundColor: hexToRgba(secondaryColor, 0.1),
                                tension: 0.2,
                                fill: false, // Don't fill this one to avoid clutter
                                borderDash: [5, 5], // Dashed line for reference value
                                yAxisID: 'yCuota' // Same axis
                            }
                        ]
                    },
                    options: commonChartOptions('yCuota')
                 });
             }


             // --- Participación Gastos Chart (Doughnut) ---
             destroyChart('participacionGastosChart');
             const ctxGastos = document.getElementById('participacionGastosChart')?.getContext('2d');
             // Filter labels based on *global* settings first, then check for > 0 value
             // Filter out zero values before mapping to labels/data
             const activeGastoRubros = (appState.settings.rubros?.gastos || []).filter(rubro =>
                  (calculated.annualTotals?.gastos?.[rubro] || 0) > 0
             );
             const gastoLabels = activeGastoRubros;
             const gastoData = activeGastoRubros.map(rubro => calculated.annualTotals.gastos[rubro]);

             displayChartNoData('participacionGastosChart', gastoData.length === 0);

             if (ctxGastos && gastoData.length > 0) {
                 window.participacionGastosChart_instance = new Chart(ctxGastos, {
                     type: 'doughnut', // Changed to doughnut
                     data: {
                         labels: gastoLabels,
                         datasets: [{
                             data: gastoData,
                             backgroundColor: generateColors(gastoData.length, chartColors, 0.8), // Use helper
                             borderColor: cardBg,
                             borderWidth: 2
                         }]
                     },
                     options: pieChartOptions('Gasto Anual') // Use pie chart options (works for doughnut)
                 });
             }


             // --- Participación Ingresos Chart (Doughnut) ---
             destroyChart('participacionIngresosChart');
             const ctxIngresos = document.getElementById('participacionIngresosChart')?.getContext('2d');
             // Filter labels based on *global* settings first, then check for > 0 value
              // Filter out zero values before mapping to labels/data
             const activeIngresoRubros = (appState.settings.rubros?.ingresos || []).filter(rubro =>
                  (calculated.annualTotals?.ingresos?.[rubro] || 0) > 0
              );
             const ingresoLabels = activeIngresoRubros;
             const ingresoData = activeIngresoRubros.map(rubro => calculated.annualTotals.ingresos[rubro]);

             displayChartNoData('participacionIngresosChart', ingresoData.length === 0);

             if (ctxIngresos && ingresoData.length > 0) {
                 window.participacionIngresosChart_instance = new Chart(ctxIngresos, {
                     type: 'doughnut', // Changed to doughnut
                     data: {
                         labels: ingresoLabels,
                         datasets: [{
                             data: ingresoData,
                             // Use different colors or reverse order from gastos chart
                             backgroundColor: generateColors(ingresoData.length, chartColors.slice().reverse(), 0.8), // Use helper
                             borderColor: cardBg,
                             borderWidth: 2
                         }]
                     },
                     options: pieChartOptions('Ingreso Anual') // Use pie chart options
                 });
             }
         }

         // Helper to generate enough colors for pie charts, repeating palette if necessary
         function generateColors(count, palette, alpha = 1) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                colors.push(hexToRgba(palette[i % palette.length], alpha));
            }
            return colors;
         }

        function commonChartOptions(mainYAxisID = 'y', additionalScales = {}) {
            const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
            const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
            return {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    [mainYAxisID]: {
                        beginAtZero: true,
                        ticks: { color: textColor, padding: 10, callback: value => formatCurrency(value).replace(",00", "") },
                        grid: { color: borderColor, drawTicks: false }, // Hide grid ticks
                        border: { color: borderColor } // Axis line color
                    },
                    x: {
                        ticks: { color: textColor, padding: 10 },
                        grid: { display: false }, // Hide vertical grid lines for cleaner look
                        border: { color: borderColor }
                    },
                    ...additionalScales // Include any additional axes passed in
                },
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: {
                            color: textColor,
                            boxWidth: 15,
                            padding: 20
                        }
                    },
                    tooltip: {
                        backgroundColor: hexToRgba(getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim(), 0.9),
                        titleColor: textColor,
                        bodyColor: textColor,
                        borderColor: getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim(),
                        borderWidth: 1,
                        padding: 10,
                        callbacks: {
                             title: tooltipItems => tooltipItems[0]?.label ? FULL_MONTHS[MONTHS.indexOf(tooltipItems[0].label)] : '',
                             label: context => {
                                 let label = context.dataset.label || '';
                                 if (label) label += ': ';
                                 if (context.parsed.y !== null) label += formatCurrency(context.parsed.y);
                                 return label;
                            }
                        }
                    }
                },
                interaction: { mode: 'index', intersect: false },
            };
         }

        function pieChartOptions(labelPrefix = '') {
             const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
             const cardBg = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim();
             const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
             const baseFontSize = parseFloat(getComputedStyle(document.body).fontSize); // Get actual computed font size
             const legendFontSize = Math.round(baseFontSize * 1.2); // Increase by 20%


             return {
                 responsive: true,
                 maintainAspectRatio: false,
                 plugins: {
                     legend: {
                         position: 'right',
                         labels: {
                            color: textColor,
                            boxWidth: 15,
                            padding: 15,
                            font: { // Apply font settings here
                                 size: legendFontSize, // Apply increased size
                            },
                             generateLabels: chart => {
                                const data = chart.data;
                                if (!data.labels.length || !data.datasets.length) return [];
                                const { labels } = data; const dataset = data.datasets[0];
                                const total = dataset.data.reduce((a, b) => a + (b || 0), 0);
                                return labels.map((label, i) => {
                                    const value = dataset.data[i] || 0;
                                     const percentage = total > 0 ? ((value / total) * 100).toFixed(1) + '%' : '0.0%';
                                     const textLabel = `${label} (${percentage})`; // Format: "Label (Percentage)"

                                    return {
                                        text: textLabel, // Use the custom text label
                                        fillStyle: dataset.backgroundColor[i],
                                        strokeStyle: dataset.borderColor || dataset.backgroundColor[i],
                                        lineWidth: dataset.borderWidth || 0,
                                        hidden: chart.getDataVisibility(i) || value === 0, // Hide if data is zero as well
                                        index: i
                                    };
                                });
                             }
                         }
                     },
                     tooltip: {
                         backgroundColor: hexToRgba(cardBg, 0.9),
                         titleColor: textColor, bodyColor: textColor,
                         borderColor: borderColor, borderWidth: 1, padding: 10,
                         callbacks: {
                            label: context => {
                                 let label = context.label || ''; // context.label is the original label text
                                 if (context.parsed !== null) {
                                     const total = context.dataset.data.reduce((a, b) => a + (b || 0), 0);
                                     const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) + '%' : '0.0%';
                                     // Show original label + formatted value and percentage in tooltip
                                     label = `${label}: ${formatCurrency(context.parsed)} (${percentage})`;
                                 }
                                 return label;
                            }
                         }
                     }
                 },
                 cutout: '30%' // Define cutout for Doughnut chart
             };
         }

        function updateReserveFundPanel(scenarioData) {
             const panel = document.getElementById('reserve-fund-panel');
             if (!panel) return;
             panel.innerHTML = ''; // Clear previous inputs

             // Use scenarioData if available, otherwise use default type and values for UI
             const reserveFundData = scenarioData?.reserveFund ?? { type: document.getElementById('reserve-type-percent')?.checked ? 'percent' : 'fixed', values: Array(12).fill(document.getElementById('reserve-type-percent')?.checked ? 5 : 0) };

             const uiSelectedType = document.getElementById('reserve-type-percent').checked ? 'percent' : 'fixed'; // Use selected radio for UI
             const uiUnitLabel = uiSelectedType === 'percent' ? '%' : '$';
             const uiCurrentStep = uiSelectedType === 'percent' ? '0.1' : '100';


             // Ensure values array has 12 elements
              const reserveValues = Array.isArray(reserveFundData.values) && reserveFundData.values.length === 12
                                     ? reserveFundData.values.map(v => window.toNumber(v || 0))
                                     : Array(12).fill(uiSelectedType === 'percent' ? 5 : 0); // Default based on UI selected type


             for (let i = 0; i < 12; i++) {
                 const monthDiv = document.createElement('div');
                 monthDiv.classList.add('form-group'); // Use form-group class for consistency

                 const label = document.createElement('label');
                 label.textContent = FULL_MONTHS[i];
                 label.htmlFor = `reserve-month-${i}`;

                 const input = document.createElement('input');
                 input.type = 'number';
                 input.id = `reserve-month-${i}`;
                 input.dataset.month = i;
                 input.value = reserveValues[i]; // Use validated array
                 input.step = uiCurrentStep;
                 input.min = '0';
                 input.placeholder = uiUnitLabel; // Use unit as placeholder
                 input.style.textAlign = 'right';
                 input.title = `Valor de fondo de reserva para ${FULL_MONTHS[i]} (${uiUnitLabel})`;


                 // No need for separate unit span element, placeholder is sufficient and simpler.
                 // Or, if keeping unit span, move it next to input and style flex if needed.
                 // Let's keep it simple with placeholder for now.

                 monthDiv.appendChild(label);
                 monthDiv.appendChild(input);
                 panel.appendChild(monthDiv);
             }
        }

        function updateSettingsPanel() {
            const ufInput = document.getElementById('cantidad-unidades');
            if (ufInput) ufInput.value = appState.settings.cantidadUnidades;

            updateRubroList('gastos', 'gasto-rubro-list');
            updateRubroList('ingresos', 'ingreso-rubro-list');

            updateCoefficientTypeList();
            const currentEditing = appState.uiState.editingCoefficientType;
            if (currentEditing && appState.settings.coefficientTypes?.[currentEditing] && !appState.settings.coefficientTypes[currentEditing].isDefault) { // Only try to render editor for non-default types
                renderCoefficientValuesEditor(currentEditing);
            } else {
                const editorDiv = document.getElementById('coefficient-values-editor');
                const nameSpan = document.getElementById('editing-coefficient-name');
                if (editorDiv) editorDiv.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente (que no sea "Sin Coeficiente") de la lista de la izquierda para editar sus valores porcentuales (%) mes a mes.</p>';
                if (nameSpan) nameSpan.textContent = 'Ninguno';
                if(appState.uiState.editingCoefficientType !== null && (!appState.settings.coefficientTypes?.[appState.uiState.editingCoefficientType] || appState.settings.coefficientTypes[appState.uiState.editingCoefficientType].isDefault)) {
                   appState.uiState.editingCoefficientType = null; // Reset if type became invalid or is default
                   updateCoefficientTypeList(); // Update list to remove highlight
                }
            }
            updateIPCManualInputs();
        }

        function updateRubroList(type, listId) {
             const list = document.getElementById(listId);
             if (!list) return;
             list.innerHTML = '';

             const rubros = appState.settings.rubros[type]?.slice().sort((a, b) => a.localeCompare(b)) || [];
             const config = appState.settings.rubroConfig || {};
             const coefTypes = appState.settings.coefficientTypes || {};

             if (rubros.length === 0) {
                 list.innerHTML = '<li class="text-muted" style="padding: 10px 8px;">No hay rubros definidos. Añade uno o carga un Excel.</li>';
                 return;
             }

             rubros.forEach(rubro => {
                 const li = document.createElement('li');
                 const span = document.createElement('span');
                 span.textContent = rubro;
                 li.appendChild(span);

                 if (type === 'gastos') {
                     const select = document.createElement('select');
                     select.title = `Asignar coeficiente de ajuste para ${rubro}`;
                     select.dataset.rubro = rubro;
                     select.onchange = handleCoefficientAssignmentChange;

                     // Sort coefficient types alphabetically by name for the dropdown
                     // Ensure 'None' is always first
                     const sortedCoefKeys = Object.keys(coefTypes)
                        .sort((a, b) => {
                            if (a === 'None') return -1;
                            if (b === 'None') return 1;
                            return (coefTypes[a]?.name || '').localeCompare(coefTypes[b]?.name || ''); // Sort safely
                        });


                     sortedCoefKeys.forEach(coefKey => {
                         const coefType = coefTypes[coefKey];
                         if (!coefType) return; // Skip if type data is missing
                         const option = document.createElement('option');
                         option.value = coefKey;
                         option.textContent = coefType.name;
                         // Check if this coefficient is currently assigned to the rubro, or if 'None' should be default
                         if (config[rubro]?.coefficientType === coefKey) {
                             option.selected = true;
                         } else if (config[rubro]?.coefficientType === undefined && coefKey === 'None') {
                             // Default to 'None' if no config is set yet for this rubro
                              option.selected = true;
                         }
                         select.appendChild(option);
                     });
                     li.appendChild(select);
                 }

                 const deleteBtn = document.createElement('button');
                 deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                 deleteBtn.classList.add('button-danger', 'button-sm');
                 deleteBtn.title = `Eliminar rubro "${rubro}" (¡no se puede deshacer!)`;
                 deleteBtn.onclick = () => deleteRubro(type, rubro);
                 li.appendChild(deleteBtn);

                 list.appendChild(li);
             });
        }

        function updateCoefficientTypeList() {
             const list = document.getElementById('coefficient-type-list');
             if (!list) return;
             list.innerHTML = '';

             const types = appState.settings.coefficientTypes || {};
             const currentEditing = appState.uiState.editingCoefficientType;

             // Sort coefficient types alphabetically by name for the dropdown
             // Ensure 'None' is always first
             const sortedKeys = Object.keys(types)
                .sort((a, b) => {
                    if (a === 'None') return -1;
                    if (b === 'None') return 1;
                    return (types[a]?.name || '').localeCompare(types[b]?.name || ''); // Sort safely
                });

             if (sortedKeys.length === 0) {
                 list.innerHTML += '<li class="text-muted" style="padding: 10px 8px;">No hay tipos de coeficientes definidos. Añade uno.</li>';
                 return;
             }

             sortedKeys.forEach(key => {
                 const typeData = types[key];
                  if (!typeData) return; // Skip if type data is missing

                 const li = document.createElement('li');

                 const span = document.createElement('span');
                 span.textContent = typeData.name;
                 li.appendChild(span);

                 const actionsDiv = document.createElement('div');
                 actionsDiv.style.marginLeft = 'auto'; // Push actions right
                 actionsDiv.style.display = 'flex';
                 actionsDiv.style.alignItems = 'center';
                 actionsDiv.style.gap = '5px';

                 if (key === 'None' || typeData.isDefault) { // Cannot edit/delete 'None' or default types
                     const lockIcon = document.createElement('i');
                     lockIcon.className = 'fas fa-lock fa-fw';
                     lockIcon.title = `Tipo por defecto ("${typeData.name}") (no eliminable ni editable).`;
                     lockIcon.style.color = 'var(--secondary-color)';
                     actionsDiv.appendChild(lockIcon);
                     li.style.opacity = '0.7'; // Visually distinct
                     li.style.cursor = 'default';
                 } else {
                     li.style.cursor = 'pointer';
                     li.onclick = () => selectCoefficientTypeForEditing(key); // Add click listener to the list item

                     if (key === currentEditing) {
                          li.style.backgroundColor = 'var(--clickable-row-hover)';
                          li.style.fontWeight = 'bold';
                      }

                     const deleteBtn = document.createElement('button');
                     deleteBtn.innerHTML = '<i class="fas fa-trash-alt"></i>';
                     deleteBtn.classList.add('button-danger', 'button-sm');
                     deleteBtn.title = `Eliminar tipo "${typeData.name}"`;
                     deleteBtn.onclick = (e) => { e.stopPropagation(); deleteCoefficientType(key); }; // Stop propagation so li click doesn't fire
                     actionsDiv.appendChild(deleteBtn);
                 }
                li.appendChild(actionsDiv);
                 list.appendChild(li);
             });
        }

        function selectCoefficientTypeForEditing(typeKey) {
             const typeData = appState.settings.coefficientTypes?.[typeKey]; // Check if type exists
             if (!typeData || typeKey === 'None' || typeData.isDefault) {
                showSnackbar(`El tipo "${typeData?.name || typeKey}" no es editable.`, false, 'info', 3000);
                appState.uiState.editingCoefficientType = null; // Ensure non-editable types are not the editing type
                 renderCoefficientValuesEditor(null); // Clear the editor
                updateCoefficientTypeList(); // Update list appearance
                return;
             }
             if (appState.settings.coefficientTypes[typeKey]) {
                 appState.uiState.editingCoefficientType = typeKey;
                 updateCoefficientTypeList(); // Re-render list to show selection highlight
                 renderCoefficientValuesEditor(typeKey);
             } else {
                 console.error(`Intentando editar tipo de coeficiente inexistente: ${typeKey}`);
             }
        }

        // --- MODIFICACIÓN FIX: Improved Coefficient Editor UI ---
        function renderCoefficientValuesEditor(typeKey) {
             const editorDiv = document.getElementById('coefficient-values-editor');
             const nameSpan = document.getElementById('editing-coefficient-name');
             if (!editorDiv || !nameSpan) return;
             editorDiv.innerHTML = ''; // Clear previous content

             const typeData = appState.settings.coefficientTypes?.[typeKey]; // Check if type exists
             if (!typeKey || !typeData || typeKey === 'None' || typeData.isDefault) {
                 editorDiv.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente (que no sea "Sin Coeficiente") de la lista de la izquierda para editar sus valores porcentuales (%) mes a mes.</p>';
                 nameSpan.textContent = 'Ninguno';
                 appState.uiState.editingCoefficientType = null;
                 return;
             }


             nameSpan.textContent = typeData.name;

             // Ensure values array exists and has 12 elements (percentages)
             const values = Array.isArray(typeData.values) && typeData.values.length === 12
                             ? typeData.values.map(v => window.toNumber(v || 0)) // Ensure values are numbers
                             : Array(12).fill(0); // Default to 0%

             MONTHS.forEach((month, index) => {
                 const monthDiv = document.createElement('div');
                 monthDiv.classList.add('form-group'); // Use form-group for layout consistent with IPC

                 const label = document.createElement('label');
                 label.textContent = FULL_MONTHS[index];
                 label.htmlFor = `coef-${typeKey}-${index}`;

                 const input = document.createElement('input');
                 input.type = 'number';
                 input.id = `coef-${typeKey}-${index}`;
                 input.dataset.month = index;
                 input.dataset.typeKey = typeKey;
                 input.value = values[index]; // Display the percentage value
                 input.step = '0.1'; // Allow 0.1% increments
                 input.min = '-100'; // Allow negative percentages, down to -100%
                 input.placeholder = '%'; // Indicate percentage input
                 input.style.textAlign = 'right';
                 input.title = `Ajuste porcentual (%) para ${FULL_MONTHS[index]} (${typeData.name})`;

                 input.addEventListener('change', handleCoefficientValueChange); // Add event listener

                 monthDiv.appendChild(label);
                 monthDiv.appendChild(input);
                 editorDiv.appendChild(monthDiv);
             });
        }

         function handleCoefficientValueChange(event) {
             const input = event.target;
             const monthIndex = parseInt(input.dataset.month);
             const typeKey = input.dataset.typeKey;
             const value = parseFloat(input.value); // Read the value as percentage

             if (typeKey && appState.settings.coefficientTypes?.[typeKey] && !isNaN(monthIndex) && monthIndex >= 0 && monthIndex < 12) {
                  const typeData = appState.settings.coefficientTypes[typeKey];
                 // Ensure values array exists and has 12 elements before modifying
                 if (!Array.isArray(typeData.values) || typeData.values.length !== 12) {
                    console.warn(`Coef type "${typeKey}" values array invalid. Resetting.`);
                    typeData.values = Array(12).fill(0); // Default to 0%
                 }

                 // Validate the percentage value (must be a number >= -100)
                 if (!isNaN(value) && value >= -100) {
                     typeData.values[monthIndex] = value;
                     console.log(`Valor mes ${MONTHS[monthIndex]} para "${typeKey}" actualizado a ${value}%.`);
                     saveState(); // Save immediately
                     // showSnackbar(`Valor actualizado a ${value}%.`, false); // Too chatty? Maybe remove.
                 } else {
                     // Revert invalid input to the last saved value
                     const lastSavedValue = typeData.values[monthIndex] ?? 0; // Default to 0 if somehow undefined
                     input.value = lastSavedValue;
                     showSnackbar(`Valor inválido para ${FULL_MONTHS[monthIndex]}. Debe ser un número mayor o igual a -100.`, true, 'error', 4000);
                 }
             } else {
                 console.error("Error al manejar cambio de valor de coeficiente.", { typeKey, monthIndex, value });
                 showSnackbar("Error interno al actualizar coeficiente.", true, 'error', 6000);
             }
         }
        // --- END MODIFICACIÓN FIX ---


        function updateIPCManualInputs() {
             const ipcDiv = document.getElementById('ipc-inputs');
             if (!ipcDiv) return;
             ipcDiv.innerHTML = '';

             // Ensure IPC array exists and has 12 elements (percentages)
             const ipcValues = Array.isArray(appState.settings.ipcManual) && appState.settings.ipcManual.length === 12
                                ? appState.settings.ipcManual.map(v => window.toNumber(v || 0)) // Ensure numbers
                                : Array(12).fill(0); // Default to 0%


             for (let i = 0; i < 12; i++) {
                 const monthDiv = document.createElement('div');
                 monthDiv.classList.add('form-group');

                 const label = document.createElement('label');
                 label.textContent = FULL_MONTHS[i];
                 label.htmlFor = `ipc-month-${i}`;

                 const input = document.createElement('input');
                 input.type = 'number';
                 input.id = `ipc-month-${i}`;
                 input.dataset.month = i;
                 input.value = ipcValues[i]; // Use validated array (percentage)
                 input.step = '0.1';
                 input.min = '0'; // IPC generally non-negative
                 input.placeholder = '%';
                 input.style.textAlign = 'right';
                 input.style.maxWidth = '120px';
                 input.title = `IPC de referencia para ${FULL_MONTHS[i]} (%)`;

                 input.addEventListener('change', (event) => { // Use addEventListener
                     const monthIndex = parseInt(event.target.dataset.month);
                     const value = parseFloat(event.target.value);
                      if (!isNaN(monthIndex) && monthIndex >= 0 && monthIndex < 12) {
                          // Allow 0 and positive numbers for IPC
                          // Ensure the global array exists before writing
                          if (!Array.isArray(appState.settings.ipcManual) || appState.settings.ipcManual.length !== 12) {
                            console.warn("IPC settings array invalid. Resetting.");
                            appState.settings.ipcManual = Array(12).fill(0);
                          }
                          // Store the value directly (it's already a percentage)
                          appState.settings.ipcManual[monthIndex] = (!isNaN(value) && value >= 0) ? value : 0;
                          // No saveState/recalc here; happens on main Save button
                      } else {
                          console.error("Invalid month index or value for IPC input.");
                          // Revert invalid input
                          event.target.value = appState.settings.ipcManual[monthIndex] ?? 0; // Revert to last saved or 0
                          showSnackbar(`Valor IPC inválido para ${FULL_MONTHS[monthIndex]}. Debe ser un número >= 0.`, true, 'error', 4000);
                      }
                 });

                 monthDiv.appendChild(label);
                 monthDiv.appendChild(input);
                 ipcDiv.appendChild(monthDiv);
             }
        }


        // --- Manejo de Eventos ---
        function addEventListeners() {
             document.getElementById('theme-toggle')?.addEventListener('click', toggleTheme);

             document.getElementById('scenario-selector')?.addEventListener('change', (event) => {
                 const newKey = event.target.value;
                 if (newKey && appState.scenarios?.[newKey]) { // Check if scenario exists
                     appState.activeScenarioKey = newKey;
                     // Ensure currentYear is updated based on the new key
                     const yearFromKey = parseInt(newKey.split('_')[0]);
                     if (!isNaN(yearFromKey)) {
                        appState.currentYear = yearFromKey;
                     } else {
                         console.warn(`Invalid year in scenario key: ${newKey}. Current year remains ${appState.currentYear}.`);
                     }
                     console.log(`Escenario cambiado a: ${newKey}`);
                     saveState();
                     updateUI(); // Refresh UI for the new scenario
                 } else if (newKey === "") {
                     console.warn("Selector de escenario cambió a valor vacío (puede ocurrir si no hay escenarios).");
                     // Do nothing, validateAndSetActiveScenario will handle empty state
                 } else {
                      console.error(`Intento de cambiar a escenario inválido o no encontrado: ${newKey}`);
                      // Try to revert the selector to the last valid key, but updateUI will eventually fix it.
                       const currentValidKey = appState.activeScenarioKey;
                       if (currentValidKey && appState.scenarios?.[currentValidKey]) {
                           event.target.value = currentValidKey;
                       } else {
                            // If even the current one is invalid, just let updateUI sort it out
                           validateAndSetActiveScenario(); // Attempt to find *any* valid scenario
                           updateUI(); // Update based on whatever validate finds
                       }
                 }
             });

             // Drag & Drop Upload Area
             const uploadArea = document.getElementById('file-upload-area');
             if (uploadArea) {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, preventDefaults, false);
                    document.body.addEventListener(eventName, preventDefaults, false); // Prevent browser opening file
                });
                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => uploadArea.style.backgroundColor = 'var(--clickable-row-hover)', false);
                });
                ['dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => uploadArea.style.backgroundColor = 'var(--bg-color)', false);
                });
                 uploadArea.addEventListener('drop', (event) => {
                    const files = event.dataTransfer.files;
                    if (files.length > 0) handleFileUpload(files);
                 }, false);
             }

             // Add collapsible listeners only once using delegation
             addCollapsibleListeners();
        }

        function preventDefaults (e) {
            e.preventDefault();
            e.stopPropagation();
        }

        let collapsibleListenersAdded = false; // Flag to prevent adding multiple times
        function addCollapsibleListeners() {
             // Use event delegation on a parent element that exists reliably (e.g., the main container)
             const container = document.querySelector('.container');
             // Only add the listener once
             if (!container || collapsibleListenersAdded) return;

             container.addEventListener('click', (event) => {
                 // Find the closest ancestor that is a collapsible total row
                 const targetRow = event.target.closest('tr.rubro-total-row');
                 // Check if the click happened inside one of the detail tables
                 if (targetRow && (targetRow.closest('#gastos-detail-table') || targetRow.closest('#ingresos-detail-table'))) {
                     const rubro = targetRow.dataset.rubro;
                     const type = targetRow.dataset.type;
                     if (rubro && type) {
                         toggleRubroDetails(type, rubro);
                     }
                 }
             });

             collapsibleListenersAdded = true; // Set flag
             console.log("Listeners delegados para filas colapsables añadidos al contenedor.");
        }


        function toggleRubroDetails(type, rubro) {
             // Toggle state in GLOBAL settings.rubroConfig
             // Ensure the config object exists for the rubro
             if (!appState.settings.rubroConfig[rubro]) {
                 // Default collapsed state for new rubros not yet in config
                 appState.settings.rubroConfig[rubro] = { coefficientType: 'None', detailsCollapsed: false }; // Default expanded on first click if config didn't exist
             } else {
                 // Toggle the existing value, default to false (expanded) if property doesn't exist
                 appState.settings.rubroConfig[rubro].detailsCollapsed = !(appState.settings.rubroConfig[rubro].detailsCollapsed ?? false);
             }
             const isNowCollapsed = appState.settings.rubroConfig[rubro].detailsCollapsed;
             console.log(`Toggling ${type}/${rubro}. Now collapsed: ${isNowCollapsed}`);

             // Update UI for the current table
             const tableId = `${type}-detail-table`;
             const totalRow = document.querySelector(`#${tableId} tr.rubro-total-row[data-rubro="${rubro}"]`);
             const detailRows = document.querySelectorAll(`#${tableId} tr.detail-row[data-rubro="${rubro}"]`);

             if (totalRow) {
                totalRow.classList.toggle('collapsed', isNowCollapsed);
             } else {
                 console.warn(`Total row not found for ${type}/${rubro} during toggle.`);
             }

             detailRows.forEach(row => {
                 row.classList.toggle('hidden', isNowCollapsed);
             });

             saveState(); // Save the changed collapsed preference
        }

         // New function to toggle all rubro details for a given type
         function toggleAllRubroDetails(type, collapse) {
             console.log(`${collapse ? 'Colapsando' : 'Expandiendo'} todos los rubros de ${type}...`);
             const scenarioData = getCurrentScenarioData();
             if (!scenarioData) { showSnackbar("No hay escenario activo.", true, 'error'); return; }

             // Get the actual rubros displayed in the table, as they are filtered by data existence
              const tableId = `${type}-detail-table`;
              const displayedRubros = Array.from(document.querySelectorAll(`#${tableId} tr.rubro-total-row`)).map(row => row.dataset.rubro);

             if (displayedRubros.length === 0) {
                  showSnackbar(`No hay rubros de ${type} con datos para expandir/colapsar.`, false, 'info');
                  return;
             }


             let changesMade = false;

             displayedRubros.forEach(rubro => {
                 // Ensure config object exists before modifying
                 if (!appState.settings.rubroConfig[rubro]) {
                     appState.settings.rubroConfig[rubro] = { coefficientType: 'None', detailsCollapsed: true }; // Default collapsed
                 }
                 if ((appState.settings.rubroConfig[rubro].detailsCollapsed ?? true) !== collapse) { // Only change if different
                      appState.settings.rubroConfig[rubro].detailsCollapsed = collapse;
                      changesMade = true;
                 }
             });

             if (changesMade) {
                 saveState(); // Save the changed collapsed preferences
                 // Update UI for the affected table directly
                 const totalRows = document.querySelectorAll(`#${tableId} tr.rubro-total-row`);
                 const detailRows = document.querySelectorAll(`#${tableId} tr.detail-row`);

                 totalRows.forEach(row => {
                     const rubro = row.dataset.rubro;
                      const isCollapsed = appState.settings.rubroConfig[rubro]?.detailsCollapsed ?? true;
                      row.classList.toggle('collapsed', isCollapsed);
                 });

                 detailRows.forEach(row => {
                     const rubro = row.dataset.rubro;
                      const isCollapsed = appState.settings.rubroConfig[rubro]?.detailsCollapsed ?? true;
                      row.classList.toggle('hidden', isCollapsed);
                 });

                 showSnackbar(`${collapse ? 'Todos los detalles colapsados.' : 'Todos los detalles expandidos.'}`, false, 'info', 3000);
             } else {
                  showSnackbar(`Los detalles ya están ${collapse ? 'colapsados' : 'expandidos'}.`, false, 'info', 3000);
             }
         }


         function handleCoefficientAssignmentChange(event) {
             const select = event.target;
             const rubro = select.dataset.rubro;
             const newCoefType = select.value;

             if (rubro && newCoefType !== undefined) {
                 // Ensure config object exists before assigning
                 if (!appState.settings.rubroConfig[rubro]) {
                     appState.settings.rubroConfig[rubro] = { detailsCollapsed: true }; // Keep default collapsed state
                 }
                 appState.settings.rubroConfig[rubro].coefficientType = newCoefType;
                 console.log(`Coeficiente para "${rubro}" asignado a "${newCoefType}".`);
                 saveState(); // Save assignment immediately
                  showSnackbar(`Coeficiente para "${rubro}" asignado. Guardar Configuración recalculará los estimados.`, false, 'info', 3000);
             } else {
                  console.error("Error al asignar coeficiente: falta rubro o valor.", {rubro, newCoefType});
             }
         }

         // handleCoefficientValueChange is modified above

        // --- Funciones de Acción (Botones, etc.) ---
        function createNewExercise(year = null) {
             const inputYearElement = document.getElementById('exercise-year');
             const inputYear = year || parseInt(inputYearElement?.value);

             if (!inputYear || isNaN(inputYear) || inputYear < 2000 || inputYear > 2099) {
                 showSnackbar("Año inválido. Introduce un año entre 2000 y 2099.", true, 'error', 4000);
                 if(inputYearElement) inputYearElement.focus();
                 return;
             }

             console.log(`Creando o seleccionando Ejercicio ${inputYear}`);
             // Initialize the 'Base' scenario if it doesn't exist
             initScenarioData(inputYear, 'Base');

             // Set the application's current year and active scenario
             appState.currentYear = inputYear;
             appState.activeScenarioKey = `${inputYear}_Base`;

             saveState();

             // Update UI elements
             updateScenarioSelector();
             const selector = document.getElementById('scenario-selector');
             if (selector) selector.value = appState.activeScenarioKey;

             updateUI(); // Refresh UI for the new/selected year
             showSnackbar(`Ejercicio ${inputYear} (Escenario Base) seleccionado/creado.`, false, 'success');
        }

        function createScenario(){
             const year = appState.currentYear;
             const existingScenariosCount = Object.keys(appState.scenarios || {}).filter(k => k.startsWith(year + '_')).length;
             const defaultName = `Escenario ${existingScenariosCount + 1}`;

             let nombre = prompt(`Nombre para el nuevo escenario del año ${year}:`, defaultName);
             if (nombre === null) { showSnackbar("Creación cancelada.", false, 'info', 3000); return; } // Handle Cancel
             nombre = nombre.trim();
             if (!nombre) { showSnackbar("El nombre no puede estar vacío.", true, 'error', 4000); return; }

             const key = `${year}_${nombre.replace(/\s+/g,'_').replace(/[^\w-]/g, '')}`; // Sanitize key
             if (appState.scenarios?.[key]) { // Check if scenario exists
                 showSnackbar(`El escenario "${nombre}" ya existe para ${year}. Elige otro nombre.`, true, 'warning', 5000);
                 return;
             }

             // Create a fresh, empty scenario
             console.log("Creando un escenario nuevo vacío.");
             initScenarioData(year, nombre); // Initialize with the new name

             appState.activeScenarioKey = key;
             saveState();

             updateScenarioSelector();
             const selector = document.getElementById('scenario-selector');
             if(selector) selector.value = key;
             updateUI();
             showSnackbar(`Escenario "${nombre}" creado y seleccionado.`, false, 'success');
        }

        function cloneScenario() {
             const currentScenario = getCurrentScenarioData();
             if (!currentScenario) {
                 showSnackbar("No hay un escenario activo para clonar.", true, 'error', 4000);
                 return;
             }

             const currentName = currentScenario.scenarioName;
             const defaultNewName = `${currentName} - Copia`;
             let newScenarioName = prompt(`Nombre para la copia del escenario "${currentName}":`, defaultNewName);

             if (newScenarioName === null) { showSnackbar("Clonación cancelada.", false, 'info', 3000); return; }
             const trimmedNewName = newScenarioName.trim();
             if (!trimmedNewName) { showSnackbar("El nombre no puede estar vacío.", true, 'error', 4000); return; }

             const newKey = `${currentScenario.year}_${trimmedNewName.replace(/\s+/g, '_').replace(/[^\w-]/g, '')}`; // Sanitize key
             if (appState.scenarios?.[newKey]) { // Check if scenario exists
                 showSnackbar(`Ya existe un escenario "${trimmedNewName}" para ${currentScenario.year}.`, true, 'warning', 5000);
                 return;
             }

             // Deep clone using JSON methods for safety
             const clonedScenarioData = JSON.parse(JSON.stringify(currentScenario));
             // Update specific properties for the new scenario
             clonedScenarioData.scenarioName = trimmedNewName;
             clonedScenarioData.year = currentScenario.year; // Ensure year is correct

             appState.scenarios[newKey] = clonedScenarioData;

             appState.activeScenarioKey = newKey;
             console.log(`Escenario clonado: ${currentScenario.year}_${currentName} -> ${newKey}`);
             saveState();

             updateScenarioSelector();
             const selector = document.getElementById('scenario-selector');
             if(selector) selector.value = newKey;
             updateUI();
             showSnackbar(`Escenario "${trimmedNewName}" clonado y seleccionado.`, false, 'success');
        }

        function deleteScenario() {
             const keyToDelete = appState.activeScenarioKey;
             const scenarioToDelete = appState.scenarios?.[keyToDelete]; // Check if scenario exists

             if (!scenarioToDelete) {
                 showSnackbar("No hay escenario activo para eliminar.", true, 'error', 4000);
                 return;
             }

             const scenariosForYear = Object.keys(appState.scenarios || {}).filter(k => k.startsWith(`${scenarioToDelete.year}_`));
             if (scenariosForYear.length <= 1) {
                 showSnackbar(`No se puede eliminar el último escenario ("${scenarioToDelete.scenarioName}") para ${scenarioToDelete.year}.`, true, 'warning', 6000);
                 return;
             }

             if (confirm(`¿Seguro que quieres eliminar el escenario "${scenarioToDelete.scenarioName}"?\n\n¡Esta acción no se puede deshacer!`)) {
                 const year = scenarioToDelete.year;
                 const deletedName = scenarioToDelete.scenarioName;

                 delete appState.scenarios[keyToDelete];
                 console.log(`Escenario eliminado: ${keyToDelete}`);

                 // Determine next active scenario
                 const baseKey = `${year}_Base`;
                 const remainingKeysForYear = Object.keys(appState.scenarios || {}).filter(k => k.startsWith(`${year}_`));
                 const firstGlobalKey = Object.keys(appState.scenarios || {})[0];

                 let nextActiveKey = null;
                 if (appState.scenarios?.[baseKey]) { nextActiveKey = baseKey; }
                 else if (remainingKeysForYear.length > 0) { nextActiveKey = remainingKeysForYear.sort((a,b) => (appState.scenarios[a]?.scenarioName || '').localeCompare(appState.scenarios[b]?.scenarioName || ''))[0]; } // Sort safely
                 else if (firstGlobalKey) { nextActiveKey = firstGlobalKey; }

                 appState.activeScenarioKey = nextActiveKey;

                 if (!appState.activeScenarioKey) {
                     console.log("No quedan escenarios, creando uno base para el año actual.");
                     appState.currentYear = new Date().getFullYear();
                     initScenarioData(appState.currentYear);
                     appState.activeScenarioKey = `${appState.currentYear}_Base`;
                 } else {
                     // Update currentYear based on the new active key
                     const yearFromKey = parseInt(appState.activeScenarioKey.split('_')[0]);
                      if (!isNaN(yearFromKey)) {
                        appState.currentYear = yearFromKey;
                     } else {
                        console.warn(`Invalid year in new active scenario key: ${appState.activeScenarioKey}. Current year remains ${appState.currentYear}.`);
                     }
                 }

                 saveState();

                 updateScenarioSelector();
                 const selector = document.getElementById('scenario-selector');
                 if (selector && appState.activeScenarioKey) selector.value = appState.activeScenarioKey;
                 updateUI();
                 showSnackbar(`Escenario "${deletedName}" eliminado.`, false, 'success');
             } else {
                 showSnackbar("Eliminación cancelada.", false, 'info', 3000);
             }
        }


        function updateScenarioSelector() {
            const selector = document.getElementById('scenario-selector');
            if (!selector) return;
            const currentActiveKey = appState.activeScenarioKey; // Store current key before clearing
            selector.innerHTML = '';

            const currentYearScenariosKeys = Object.keys(appState.scenarios || {}) // Use || {} for safety
                .filter(key => key.startsWith(`${appState.currentYear}_`))
                .sort((a, b) => (appState.scenarios[a]?.scenarioName || '').localeCompare(appState.scenarios[b]?.scenarioName || '')); // Sort safely

            if (currentYearScenariosKeys.length === 0) {
                const opt = document.createElement('option');
                opt.value = "";
                opt.textContent = `(No hay escenarios para ${appState.currentYear})`;
                opt.disabled = true;
                selector.appendChild(opt);
                selector.disabled = true;
                 // If the active key was from this year and it's now empty, clear active key
                if (currentActiveKey && currentActiveKey.startsWith(`${appState.currentYear}_`)) {
                     appState.activeScenarioKey = null; // Clear the invalid key
                }
                return;
            }

            selector.disabled = false;
            let activeKeyFoundInList = false;
            currentYearScenariosKeys.forEach(key => {
                const scenario = appState.scenarios[key];
                if (scenario) {
                    const opt = document.createElement('option');
                    opt.value = key;
                    opt.textContent = scenario.scenarioName;
                    if (key === currentActiveKey) {
                        opt.selected = true;
                        activeKeyFoundInList = true;
                    }
                    selector.appendChild(opt);
                }
            });

            // If the previously active key wasn't found in the current year's list (e.g. changed year),
            // default to the first one in the list, update state, and save.
            if (!activeKeyFoundInList && currentYearScenariosKeys.length > 0) {
                 const newActiveKey = currentYearScenariosKeys[0];
                 console.warn(`Active scenario key "${currentActiveKey}" not valid for year ${appState.currentYear}. Defaulting to "${newActiveKey}".`);
                 appState.activeScenarioKey = newActiveKey;
                 selector.value = newActiveKey; // Update selector display
                 saveState(); // Save the corrected active key
            } else if (activeKeyFoundInList) {
                 selector.value = currentActiveKey; // Ensure visual selection matches state
            }
         }

        // --- Carga de Archivo Excel ---
        function handleFileUpload(files) {
             if (!files || files.length === 0) { showSnackbar("No se seleccionó archivo.", true, 'warning', 3000); return; }
             const file = files[0];
             const validTypes = ['application/vnd.openxmlformats-officedocument.spreadsheetml.sheet', 'application/vnd.ms-excel'];
             if (!validTypes.includes(file.type)) { showSnackbar("Archivo inválido. Sube .xlsx o .xls.", true, 'error', 5000); return; }

             const reader = new FileReader();
             const feedbackDiv = document.getElementById('file-upload-feedback');
             feedbackDiv.textContent = `Procesando: ${file.name}...`;
             feedbackDiv.style.color = 'var(--info-color)';

             reader.onload = (e) => {
                 try {
                     const data = new Uint8Array(e.target.result);
                     // --- FIX: Set cellDates to false and cellNF to false to read values directly, not dates or formatted strings ---
                     const workbook = XLSX.read(data, { type: 'array', cellDates: false, cellNF: false, raw: true }); // Added raw: true
                     // --- END FIX ---


                     const gastosSheet = workbook.Sheets[GASTOS_SHEET_NAME];
                     const ingresosSheet = workbook.Sheets[INGRESOS_SHEET_NAME];

                     if (!gastosSheet) throw new Error(`Hoja "${GASTOS_SHEET_NAME}" no encontrada.`);
                     if (!ingresosSheet) throw new Error(`Hoja "${INGRESOS_SHEET_NAME}" no encontrada.`);

                     const scenarioData = getCurrentScenarioData();
                     if (!scenarioData) throw new Error("No hay escenario activo para cargar datos.");

                     // --- Reset specific data parts for the current scenario before processing ---
                     scenarioData.data = { gastos: {}, ingresos: {} };
                     scenarioData.monthStatus = { gastos: {}, ingresos: {} }; // Status is only tracked for Gastos
                     scenarioData.rubroOrder = { gastos: [], ingresos: [] }; // Will be rebuilt from Excel data rows
                     // Calculated data is reset inside calculateAll which is called later

                     let newRubrosFound = { gastos: [], ingresos: [] };

                     // Process sheets - This populates scenarioData.data, .monthStatus (for gastos), and .rubroOrder
                     processSheetData(gastosSheet, scenarioData, 'gastos', newRubrosFound);
                     processSheetData(ingresosSheet, scenarioData, 'ingresos', newRubrosFound);

                     let addedMessage = ""; let settingsChanged = false;

                     // Add new rubros found to global settings & initialize config
                     ['gastos', 'ingresos'].forEach(type => {
                         newRubrosFound[type].forEach(rubro => {
                             if (!appState.settings.rubros[type].includes(rubro)) {
                                 appState.settings.rubros[type].push(rubro);
                                 settingsChanged = true;
                                 if (type === 'gastos' && !appState.settings.rubroConfig[rubro]) {
                                     // --- FIX: Set default collapsed state and default coef for new rubros ---
                                     appState.settings.rubroConfig[rubro] = { coefficientType: 'None', detailsCollapsed: true };
                                 } else if (!appState.settings.rubroConfig[rubro]) {
                                     // For ingresos, just initialize the object if missing
                                     appState.settings.rubroConfig[rubro] = {};
                                 }
                                 addedMessage += `\n- Nuevo rubro (${type}): ${rubro} (añadido a Configuración)`;
                             }
                         });
                     });

                    // --- FIX: Ensure data structures for all rubros (including new ones) are initialized IN THE CURRENT SCENARIO
                    // and ALSO in ALL other scenarios if global settings changed ---
                    initializeScenarioDataForRubros(scenarioData); // Ensure current one is fully initialized with potentially new details etc.
                     if(settingsChanged) {
                        // Re-initialize all scenarios to include the new global rubro definitions
                        Object.values(appState.scenarios || {}).forEach(scenario => { // Iterate safely
                            initializeScenarioDataForRubros(scenario);
                        });
                     }

                     feedbackDiv.textContent = `Archivo "${file.name}" procesado.${addedMessage}`;
                     feedbackDiv.style.color = 'var(--success-color)';
                     document.getElementById('excel-file-input').value = ''; // Reset file input

                     if (settingsChanged) {
                         saveState(); // Save updated global settings
                         updateSettingsPanel(); // Update the settings UI to show new rubros/configs
                     }

                     // Recalculate everything after processing the data
                     calculateAll(scenarioData); // This also saves state and updates UI
                     showSnackbar("Datos del Excel cargados y procesados.", false, 'success');

                 } catch (error) {
                     console.error("Error procesando archivo Excel:", error);
                     feedbackDiv.textContent = `Error: ${error.message}`;
                     feedbackDiv.style.color = 'var(--danger-color)';
                     showSnackbar(`Error procesando Excel: ${error.message}`, true, 'error', 6000);
                 }
             };
             reader.onerror = (e) => {
                 console.error("Error leyendo archivo:", e);
                 feedbackDiv.textContent = "Error al leer el archivo.";
                 feedbackDiv.style.color = 'var(--danger-color)';
                 showSnackbar("Error al intentar leer el archivo.", true, 'error', 6000);
             };
             reader.readAsArrayBuffer(file);
        }

        function processSheetData(sheet, scenarioData, type, newRubrosTracker) {
            // raw: true ensures values are read as is (e.g., numbers as numbers, not formatted strings)
            // defval: null handles empty cells as null
            // header: 1 means the first row is the header
            const jsonData = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: null, raw: true });
            if (jsonData.length < 2) { console.warn(`Hoja "${type}" vacía o sin datos.`); return; }

            const header = jsonData[0].map(h => String(h ?? '').trim().toLowerCase());
            const rubroColIndex = header.indexOf('rubro');
            const detailColIndex = header.indexOf('detalle');
            if (rubroColIndex === -1) throw new Error(`Columna "Rubro" no encontrada en hoja "${type}".`);
            if (detailColIndex === -1) throw new Error(`Columna "Detalle" no encontrada en hoja "${type}".`);

            const monthColIndices = MONTHS.map(mShort => {
                const mShortLower = mShort.toLowerCase();
                // Allow full month name match as well (e.g., 'enero', 'febrero')
                const fullMonthLower = FULL_MONTHS[MONTHS.indexOf(mShort)].toLowerCase();
                 // Check for short name first, then full name, return the first match
                 const shortIndex = header.findIndex(h => h && h.startsWith(mShortLower) && (h.length === mShortLower.length || h === mShortLower + '.')); // Allow slight variations like "Ene."
                 if (shortIndex !== -1) return shortIndex;
                 const fullIndex = header.findIndex(h => h === fullMonthLower);
                 return fullIndex;
            });

            const missingMonths = MONTHS.filter((_, i) => monthColIndices[i] === -1);
            if (missingMonths.length > 0) console.warn(`Meses no encontrados en hoja "${type}": [${missingMonths.join(', ')}]. Se usarán ceros.`);

             // Ensure scenario-level structures exist (these were reset just before calling this)
             scenarioData.rubroOrder[type] = scenarioData.rubroOrder[type] ?? [];
             scenarioData.data[type] = scenarioData.data[type] ?? {};
             if (type === 'gastos') { // Status is only for gastos
                 scenarioData.monthStatus[type] = scenarioData.monthStatus[type] ?? {};
             }


            // --- Row Processing ---
            for (let i = 1; i < jsonData.length; i++) {
                const row = jsonData[i];
                // Skip empty/null rows or rows where Rubro/Detalle are missing
                if (!row || !Array.isArray(row) || row.every(cell => cell === null) ||
                    !String(row[rubroColIndex] ?? '').trim() || !String(row[detailColIndex] ?? '').trim()
                   ) {
                    // console.warn(`Fila ${i+1} (${type}) omitida (vacía o falta Rubro/Detalle).`, row);
                    continue;
                   }


                const rubro = String(row[rubroColIndex]).trim();
                const detail = String(row[detailColIndex]).trim();
                 // Re-check after trimming, just in case trimming resulted in empty string
                if (!rubro || !detail) { console.warn(`Fila ${i+1} (${type}) omitida (Rubro/Detalle vacío después de limpiar).`); continue; }


                // Add rubro to SCENARIO order if new
                if (!scenarioData.rubroOrder[type].includes(rubro)) {
                    scenarioData.rubroOrder[type].push(rubro);
                }
                // Initialize structures for the rubro in SCENARIO if first time
                if (!scenarioData.data[type][rubro]) {
                    scenarioData.data[type][rubro] = { detailOrder: [], detailsData: {} };
                }
                 // Initialize monthStatus object for the rubro if needed (only for gastos)
                 if (type === 'gastos' && !scenarioData.monthStatus[type][rubro]) {
                    scenarioData.monthStatus[type][rubro] = {};
                 }
                 // Add detail to SCENARIO order if new for this rubro
                 if (!scenarioData.data[type][rubro].detailOrder.includes(detail)) {
                    scenarioData.data[type][rubro].detailOrder.push(detail);
                 }
                // Initialize arrays for the specific detail in SCENARIO if first time
                if (!scenarioData.data[type][rubro].detailsData[detail] || !Array.isArray(scenarioData.data[type][rubro].detailsData[detail]) || scenarioData.data[type][rubro].detailsData[detail].length !== 12) {
                     scenarioData.data[type][rubro].detailsData[detail] = Array(12).fill(0);
                }
                 // Initialize status array for the detail if needed (only for gastos)
                 if (type === 'gastos' && (!scenarioData.monthStatus[type][rubro]?.[detail] || !Array.isArray(scenarioData.monthStatus[type][rubro][detail]) || scenarioData.monthStatus[type][rubro][detail].length !== 12)) {
                     scenarioData.monthStatus[type][rubro][detail] = Array(12).fill('Estimado');
                 }


                // Track new rubros for GLOBAL update later
                 if (!appState.settings.rubros[type].includes(rubro) && !newRubrosTracker[type].includes(rubro)) {
                    newRubrosTracker[type].push(rubro);
                 }

                // --- Process Monthly Values ---
                for (let m = 0; m < 12; m++) {
                    const colIndex = monthColIndices[m];
                    let value = 0;
                    let status = 'Estimado'; // Default status for Gastos if no number found

                    if (colIndex !== -1 && row[colIndex] !== null) {
                        const cellValue = row[colIndex];
                         // Check if the value is a number according to Excel's raw read
                         if (typeof cellValue === 'number') {
                              value = cellValue;
                             if (type === 'gastos') status = 'REAL'; // Mark GASTOS with numbers as REAL
                         } else if (typeof cellValue === 'string' && cellValue.trim() !== '') {
                             // If it's a non-empty string, try parsing it. Treat as Estimated.
                             // The raw:true option minimizes this but might still happen for complex formats.
                              const cleanedValue = cellValue.replace(/[$.]/g, '').replace(',', '.'); // Basic currency/thousands cleaning
                              const parsedNum = parseFloat(cleanedValue);
                             if (!isNaN(parsedNum)) {
                                  value = parsedNum;
                                  // If we parsed a number from a string, is it REAL or ESTIMADO?
                                  // Let's stick to the rule: only native 'number' type from Excel is REAL.
                                  // Parsed strings are ESTIMADO (unless they match the regex check below).
                                  status = 'ESTIMADO'; // Default for parsed strings
                             } else {
                                  // console.warn(`Valor no numérico o parseable "${cellValue}" en ${type}/${rubro}/${detail} - ${MONTHS[m]}. Usando 0.`);
                                  value = 0;
                                   status = 'ESTIMADO'; // Ensure status is Estimated for non-numeric garbage
                             }
                         } else { // cellValue is null, undefined, boolean, etc.
                              value = 0;
                              status = 'ESTIMADO';
                         }
                    }
                    // Assign value to SCENARIO data
                    scenarioData.data[type][rubro].detailsData[detail][m] = value;
                     // Assign status ONLY for gastos based on Excel content analysis above
                     if (type === 'gastos') {
                         scenarioData.monthStatus[type][rubro][detail][m] = status;
                     }
                     // For Ingresos, status isn't determined cell by cell from Excel based on number presence.
                     // The distinction between REAL/ESTIMADO coloring in the Ingresos detail table is not driven by cell status
                     // but by whether the data came from the file (colored) vs being manually added later (not colored).
                     // Let's keep the coloring for Ingresos detail based on "came from file" vs not.
                     // The processSheetData implies "came from file". So maybe Ingresos should *also* be colored?
                     // The original style only applies coloring to `td.real-month-cell` and `td.estimated-month-cell`.
                     // These classes are only added in updateCollapsibleTable for `type === 'gastos'`.
                     // Let's maintain that only Gastos detail gets the color status.
                }
            }
             console.log(`Hoja "${type}" procesada. Rubros en orden: [${scenarioData.rubroOrder[type].join(', ')}]`);
        }


        function loadSampleData() {
            console.log("Cargando datos de ejemplo...");
            const scenarioData = getCurrentScenarioData();
            if (!scenarioData) { showSnackbar("No hay escenario activo. Crea o selecciona un año.", true, 'error', 4000); return; }

            // Reset current scenario data
            scenarioData.data = { gastos: {}, ingresos: {} };
            scenarioData.monthStatus = { gastos: {}, ingresos: {} }; // Status is only for Gastos
            scenarioData.rubroOrder = { gastos: [], ingresos: [] };
            // Calculated reset happens in calculateAll

            const sampleGastosRubros = ["Seguridad", "Jardinería", "Mantenimiento", "Administración", "Servicios Públicos"];
             const sampleIngresosRubros = [CUOTA_RUBRO_NAME, "Alquiler SUM", "Ingresos Extra", EXTRA_CUOTA_RUBRO_NAME];
            let settingsChanged = false;

            // Ensure sample rubros exist globally and locally
            sampleGastosRubros.forEach(r => {
                if (!appState.settings.rubros.gastos.includes(r)) { appState.settings.rubros.gastos.push(r); settingsChanged = true; }
                 // Ensure config exists for new rubros
                if (!appState.settings.rubroConfig[r]) appState.settings.rubroConfig[r] = { coefficientType: 'None', detailsCollapsed: true };
                if (!scenarioData.rubroOrder.gastos.includes(r)) scenarioData.rubroOrder.gastos.push(r);
            });
            sampleIngresosRubros.forEach(r => {
                 if (!appState.settings.rubros.ingresos.includes(r)) { appState.settings.rubros.ingresos.push(r); settingsChanged = true; }
                 // Ensure config exists for new rubros (even if empty)
                 if (!appState.settings.rubroConfig[r]) appState.settings.rubroConfig[r] = {};
                 if (!scenarioData.rubroOrder.ingresos.includes(r)) scenarioData.rubroOrder.ingresos.push(r);
            });

             // Initialize structures in the current scenario for these rubros AND ensure others are initialized
             initializeScenarioDataForRubros(scenarioData);
             if (settingsChanged) {
                 // Re-initialize all scenarios if global settings changed
                Object.values(appState.scenarios || {}).forEach(scen => initializeScenarioDataForRubros(scen)); // Iterate safely
                // Save settings early if they changed
                saveState();
             }

            // --- Gastos Data & Status ---
            scenarioData.data.gastos["Seguridad"].detailOrder = ["Vigilador Dia", "Vigilador Noche", "Monitoreo Cámaras"];
            scenarioData.data.gastos["Seguridad"].detailsData = {
                "Vigilador Dia":   [50000, 50500, 51000, 51500,    0,     0,     0,     0,     0,     0,     0,     0], // Last REAL is Abril (idx 3)
                "Vigilador Noche": [55000, 55500, 56000, 56500,    0,     0,     0,     0,     0,     0,     0,     0], // Last REAL is Abril (idx 3)
                "Monitoreo Cámaras": [10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000] // All REAL example
            };
            scenarioData.monthStatus.gastos["Seguridad"] = {
                "Vigilador Dia":   ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'],
                "Vigilador Noche": ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'],
                "Monitoreo Cámaras": ['REAL','REAL','REAL','REAL','REAL','REAL','REAL','REAL','REAL','REAL','REAL','REAL']
            };
             scenarioData.data.gastos["Jardinería"].detailOrder = ["Mantenimiento Parque", "Reposición Plantas"];
             scenarioData.data.gastos["Jardinería"].detailsData = {
                 "Mantenimiento Parque": [30000, 30000, 30500, 30500,    0,     0,     0,     0,     0,     0,     0,     0], // Last REAL Abril (idx 3)
                 "Reposición Plantas":   [0,     0,     5000,  0,     0,     0,     0,     0,     6000,  0,     0,     0] // Last REAL Sep (idx 8)
             };
             scenarioData.monthStatus.gastos["Jardinería"] = {
                 "Mantenimiento Parque": ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'],
                 "Reposición Plantas":   ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','REAL','Estimado','Estimado','Estimado']
             };
            scenarioData.data.gastos["Mantenimiento"].detailOrder = ["Bomba Agua Pozo", "Limpieza Tanques", "Pintura General"];
            scenarioData.data.gastos["Mantenimiento"].detailsData = {
                "Bomba Agua Pozo":  [0,     12000, 0,     0,     0,     0,     0,     13500, 0,     0,     0,     0], // Last REAL Ago (idx 7)
                "Limpieza Tanques": [0,     0,     0,     15000, 0,     0,     0,     0,     0,     15000, 0,     0], // Last REAL Oct (idx 9)
                "Pintura General":  [0,     0,     0,     0,     0,     0,     0,     0,     45000, 0,     0,     0] // Last REAL Sep (idx 8)
            };
             scenarioData.monthStatus.gastos["Mantenimiento"] = {
                "Bomba Agua Pozo":  ['REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','REAL','Estimado','Estimado','Estimado','Estimado'],
                "Limpieza Tanques": ['Estimado','Estimado','Estimado','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','REAL','Estimado','Estimado'],
                "Pintura General":  ['Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','REAL','Estimado','Estimado','Estimado']
             };
             scenarioData.data.gastos["Administración"].detailOrder = ["Honorarios Admin", "Gastos Bancarios", "Papelería"];
            scenarioData.data.gastos["Administración"].detailsData = {
                "Honorarios Admin": [40000, 40000, 40000, 40000,    0,     0,     0,     0,     0,     0,     0,     0], // Last REAL Abril (idx 3)
                "Gastos Bancarios": [500,   500,   550,   550,    0,     0,     0,     0,     0,     0,     0,     0], // Last REAL Abril (idx 3)
                "Papelería":        [1000,  0,     0,     1200,  0,     0,     1500,  0,     0,     1000,  0,     0] // Last REAL Oct (idx 9)
            };
             scenarioData.monthStatus.gastos["Administración"] = {
                 "Honorarios Admin": ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'],
                 "Gastos Bancarios": ['REAL','REAL','REAL','REAL','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado','Estimado'],
                 "Papelería":        ['REAL','REAL','REAL','REAL','Estimado','Estimado','REAL','Estimado','Estimado','REAL','Estimado','Estimado']
             };
            scenarioData.data.gastos["Servicios Públicos"].detailOrder = ["Luz Espacios Comunes", "Agua Riego"];
            scenarioData.data.gastos["Servicios Públicos"].detailsData = {
                "Luz Espacios Comunes": [18000, 19500, 21000, 20500, 19000, 18500, 19000, 20000, 22000, 23000, 21500, 20000], // All REAL example
                "Agua Riego":           [5000,  6000,  7500,  8000,  7000,  6500,  6000,  7000,  8500,  9000,  8000,  6000] // All REAL example
            };
             scenarioData.monthStatus.gastos["Servicios Públicos"] = {
                 "Luz Espacios Comunes": ['REAL','REAL','REAL','REAL','REAL','REAL','REAL','REAL','REAL','REAL','REAL','REAL'],
                 "Agua Riego":           ['REAL','REAL','REAL','REAL','REAL','REAL','REAL','REAL','REAL','REAL','REAL','REAL']
             };


            // --- Ingresos Data --- (No monthStatus here, it's only for Gastos)
             scenarioData.data.ingresos[CUOTA_RUBRO_NAME].detailOrder = ["Valor Base 1 UF"];
            scenarioData.data.ingresos[CUOTA_RUBRO_NAME].detailsData = { "Valor Base 1 UF": [1500, 1500, 1550, 1550, 1600, 1600, 1650, 1650, 1700, 1700, 1750, 1750] }; // Varied example
            scenarioData.data.ingresos["Alquiler SUM"].detailOrder = ["Eventos Fin de Semana", "Eventos Semana"];
            scenarioData.data.ingresos["Alquiler SUM"].detailsData = {
                "Eventos Fin de Semana": [5000, 6000, 4000, 7000, 8000, 9000, 5000, 6000, 7500, 8500, 9500, 10000],
                "Eventos Semana":        [1000, 1500, 1000, 2000, 2500, 2000, 1500, 1800, 2200, 2500, 2000, 1500]
            };
            scenarioData.data.ingresos["Ingresos Extra"].detailOrder = ["Multas Reglamento", "Donaciones"];
            scenarioData.data.ingresos["Ingresos Extra"].detailsData = {
                "Multas Reglamento": [0,    1000, 500,  0,    1500, 0,    0,    500,  0,    1000, 0,    0],
                "Donaciones":        [0,    0,    0,    0,    5000, 0,    0,    0,    0,    0,    10000,0]
            };
            scenarioData.data.ingresos[EXTRA_CUOTA_RUBRO_NAME].detailOrder = ["Cuota Obra Pileta"];
            scenarioData.data.ingresos[EXTRA_CUOTA_RUBRO_NAME].detailsData = { "Cuota Obra Pileta": [0, 0, 0, 500, 500, 500, 500, 500, 0, 0, 0, 0] };


             // Update Settings panel if new rubros were added globally
            if (settingsChanged) {
                updateSettingsPanel();
            }

            const feedbackDiv = document.getElementById('file-upload-feedback');
            feedbackDiv.textContent = "Datos de ejemplo cargados.";
            feedbackDiv.style.color = 'var(--success-color)';

            // Recalculate with sample data
            calculateAll(scenarioData); // This also saves state & updates UI
            showSnackbar("Datos de ejemplo cargados y procesados.", false, 'success');
         }

        function downloadTemplate() {
             const wb = XLSX.utils.book_new();
             const year = appState.currentYear;

             // Gastos Sheet
             const ws_gastos_data = [
                 ["Rubro", "Detalle", "Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"],
                 ["Seguridad", "Vigilador Dia", 50000, 50500, 51000, null, null, null, null, null, null, null, null, null], // null = Estimado (will be 0 in data, status=Estimado)
                 ["Seguridad", "Monitoreo Cámaras", 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000], // Con valor = REAL
                 ["Jardinería", "Mantenimiento Parque", 30000, 30000, null, null, null, null, null, null, null, null, null, null],
                 ["Mantenimiento", "Limpieza Pileta", null, null, 5000, 5000, null, null, null, null, null, 5500, null, null], // Gastos esporádicos
                 ["Administración", "Honorarios Admin", 40000, 40000, 40000, 40000, null, null, null, null, null, null, null, null],
                 ["Servicios Públicos", "Luz Espacios Comunes", 18000, 19500, 21000, 20500, null, null, null, null, null, null, null, null] // Added sample row
             ];
             const ws_gastos = XLSX.utils.aoa_to_sheet(ws_gastos_data);
             ws_gastos['!cols'] = [ {wch:20}, {wch:25}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10} ];
             XLSX.utils.book_append_sheet(wb, ws_gastos, GASTOS_SHEET_NAME);

             // Ingresos Sheet - MODIFICADO
             const ws_ingresos_data = [
                 ["Rubro", "Detalle", "Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"],
                 [CUOTA_RUBRO_NAME, `Valor Base 1 UF`, 1500, 1500, 1500, 1600, 1600, 1600, 1700, 1700, 1700, 1800, 1800, 1800], // VALOR POR UF
                 [EXTRA_CUOTA_RUBRO_NAME, `Cuota Extra Obra (x UF)`, null, null, null, 500, 500, 500, 500, null, null, null, null, null], // VALOR POR UF
                 ["Alquiler SUM", "Evento Sabado", 5000, null, 6000, null, null, 7000, null, null, 8000, null, null, 9000], // Ingresos esporádicos
                 ["Ingresos Extra", "Multa Atraso", null, 1000, 500,  0,    1500, null, null, 500, null, null, null, null]
             ];
             const ws_ingresos = XLSX.utils.aoa_to_sheet(ws_ingresos_data);
             ws_ingresos['!cols'] = [ {wch:25}, {wch:25}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10}, {wch:10} ];
             XLSX.utils.book_append_sheet(wb, ws_ingresos, INGRESOS_SHEET_NAME);

             XLSX.writeFile(wb, `Plantilla_Expensas_${year}.xlsx`);
             showSnackbar("Plantilla de ejemplo descargada.", false, 'success');
        }

        function saveReserveFund() {
             console.log("Guardando config fondo reserva...");
             const scenarioData = getCurrentScenarioData();
             if (!scenarioData) { showSnackbar("No hay escenario activo.", true, 'error', 4000); return; }

             // Ensure reserveFund object and values array exist
             scenarioData.reserveFund = scenarioData.reserveFund ?? { type: 'percent', values: Array(12).fill(5) };
             if (!Array.isArray(scenarioData.reserveFund.values) || scenarioData.reserveFund.values.length !== 12) {
                 scenarioData.reserveFund.values = Array(12).fill(scenarioData.reserveFund.type === 'fixed' ? 0 : 5);
             }

             const newType = document.getElementById('reserve-type-percent').checked ? 'percent' : 'fixed';
             let valuesChanged = scenarioData.reserveFund.type !== newType;
             scenarioData.reserveFund.type = newType;

             const inputs = document.querySelectorAll('#reserve-fund-panel input[type="number"]');
             let validationOk = true;
             const newValues = Array(12).fill(0); // Initialize with 12 zeros


             inputs.forEach(input => {
                 const monthIndex = parseInt(input.dataset.month);
                 const value = parseFloat(input.value);

                 if (!isNaN(value) && value >= 0 && monthIndex >= 0 && monthIndex < 12) {
                     newValues[monthIndex] = value;
                     if (scenarioData.reserveFund.values[monthIndex] !== value) {
                         valuesChanged = true;
                     }
                 } else {
                      // Revert display to current state value (before potential invalid input)
                      const currentValue = scenarioData.reserveFund.values[monthIndex] ?? (newType === 'percent' ? 5 : 0); // Use 0 or 5 default if state value is missing
                      input.value = currentValue;
                     showSnackbar(`Valor inválido para ${FULL_MONTHS[monthIndex]}. Debe ser >= 0.`, true, 'error', 4000);
                     validationOk = false;
                 }
             });

             if (!validationOk) { console.warn("Guardado fondo reserva cancelado por valores inválidos."); return; }

             // Assign the new, validated values array
             scenarioData.reserveFund.values = newValues;


             if (valuesChanged) {
                 console.log("Cambios detectados en fondo reserva. Recalculando...");
                 // Recalculate handles saveState and success message
                 calculateAll(scenarioData);
             } else {
                 showSnackbar("No se detectaron cambios en la configuración del fondo.", false, 'info', 3000);
             }
        }

        function saveSettings() {
             console.log("Guardando configuración general...");
             const oldSettingsJson = JSON.stringify(appState.settings); // Capture state BEFORE changes


             // --- Save Cantidad UF ---
             const cantidadInput = document.getElementById('cantidad-unidades');
             const newCantidadUnidades = parseInt(cantidadInput?.value); // Use optional chaining
             if (!isNaN(newCantidadUnidades) && newCantidadUnidades > 0) {
                 appState.settings.cantidadUnidades = newCantidadUnidades;
             } else {
                 // Revert display if invalid, use current state value
                 cantidadInput.value = appState.settings.cantidadUnidades ?? 100;
                 showSnackbar("Cantidad de UF inválida (> 0).", true, 'error', 4000);
                 return; // Stop saving
             }

             // --- Manual IPC Inputs are already saved in state by their onchange handlers ---
             // --- Rubro Config (Coef assignments, collapsed state) saved by handlers ---
             // --- Coefficient Type Values saved by handlers (handled by handleCoefficientValueChange) ---

             // --- Ensure IPC Manual array is valid before saving ---
             if (!Array.isArray(appState.settings.ipcManual) || appState.settings.ipcManual.length !== 12) {
                console.warn("IPC settings array invalid during save. Resetting.");
                appState.settings.ipcManual = Array(12).fill(0);
             }
              // Ensure Coefficient values arrays are valid before saving (12 elements, numbers >= -100)
              Object.keys(appState.settings.coefficientTypes || {}).forEach(key => { // Iterate safely
                   const type = appState.settings.coefficientTypes[key];
                   if (!type) return; // Skip if somehow type is missing

                   if (!Array.isArray(type.values) || type.values.length !== 12) {
                        console.warn(`Coef type "${key}" values array invalid during save. Resetting.`);
                       type.values = Array(12).fill(key === 'None' ? 1 : 0); // Default 'None' to 1, others to 0%
                   }
                   // Ensure each value is a valid percentage (>= -100) for non-'None' types
                   type.values = type.values.map(val => {
                       const numVal = parseFloat(val);
                       if (key === 'None') return 1; // 'None' is a special case multiplier
                       return (!isNaN(numVal) && numVal >= -100) ? numVal : 0; // Default invalid percentage to 0%
                   });
              });


             // Capture state AFTER changes but BEFORE recalculation
             const newSettingsJson = JSON.stringify(appState.settings);

             // Recalculate ONLY IF settings that affect calculations have changed
             // Simple comparison of stringified objects is a decent check
             const settingsChangedForCalc = newSettingsJson !== oldSettingsJson;

             // Always save the state, even if settings didn't change, in case UI state (like editingCoefType) needs persisting or other minor changes occurred.
             // But primarily, settings changes are saved here.
             saveState();


             if (settingsChangedForCalc) {
                 console.log("Configuración cambiada, recalculando escenario activo...");
                 const scenarioData = getCurrentScenarioData();
                 if (scenarioData) {
                     // calculateAll handles saveState and success message
                     calculateAll(scenarioData);
                 } else {
                     showSnackbar("Configuración guardada, pero no hay escenario activo para recalcular.", false, 'warning', 6000);
                      updateUI(); // Just refresh UI based on potentially changed settings lists/inputs
                 }
             } else {
                 showSnackbar("Configuración guardada (sin cambios que requieran recálculo).", false, 'success', 3000);
                 // Refresh the panel UI just in case (e.g., if UF was reverted)
                 updateSettingsPanel();
             }
        }

        function addRubro(type) {
            const inputId = `new-${type}-rubro-name`;
            const input = document.getElementById(inputId);
            if (!input) { console.error(`Input no encontrado: ${inputId}`); showSnackbar("Error interno.", true, 5000); return; }
            const newRubroName = input.value.trim();

            if (!newRubroName) { showSnackbar("Nombre de rubro vacío.", true, 'warning', 3000); input.focus(); return; }

             // Check for duplicates case-insensitively
            if (appState.settings.rubros[type].some(r => r.toLowerCase() === newRubroName.toLowerCase())) {
                showSnackbar(`Rubro "${newRubroName}" ya existe en ${type}.`, true, 'warning', 5000);
                input.select(); return;
            }

            // Add to global settings
            appState.settings.rubros[type].push(newRubroName);
            if (type === 'gastos' && !appState.settings.rubroConfig[newRubroName]) {
                appState.settings.rubroConfig[newRubroName] = { coefficientType: 'None', detailsCollapsed: true }; // Default for new gasto rubros
            } else if (!appState.settings.rubroConfig[newRubroName]) {
                 appState.settings.rubroConfig[newRubroName] = {}; // Initialize config object for new ingreso rubros
            }


            // Initialize data structures for this new rubro in ALL existing scenarios
            Object.values(appState.scenarios || {}).forEach(scenario => { // Iterate safely
                 initializeScenarioDataForRubros(scenario); // This function handles adding empty structures for new global rubros
            });

            input.value = '';
            console.log(`Rubro ${type} añadido: ${newRubroName}`);
            saveState(); // Save updated settings and scenario structures

            updateRubroList(type, `${type}-rubro-list`);
            // Update the other list too if needed (e.g., if adding a coef type changes the select options)
            // Adding a rubro doesn't change coef types, so no need to update the other list here.

            showSnackbar(`Rubro "${newRubroName}" (${type}) añadido.`, false, 'success', 3000);
        }

        function deleteRubro(type, rubroToDelete) {
             if (!confirm(`¿Seguro que quieres eliminar el rubro "${rubroToDelete}" (${type})?\n\nSe borrarán todos sus datos en TODOS los escenarios.\n¡No se puede deshacer!`)) {
                 showSnackbar("Eliminación cancelada.", false, 'info', 3000); return;
             }

             // --- Remove from Global Settings ---
             appState.settings.rubros[type] = appState.settings.rubros[type].filter(r => r !== rubroToDelete);
             delete appState.settings.rubroConfig[rubroToDelete];
             console.log(`Rubro "${rubroToDelete}" eliminado de config global.`);

             // --- Remove from ALL Scenarios ---
             Object.keys(appState.scenarios || {}).forEach(scenarioKey => { // Iterate safely
                 const scenario = appState.scenarios[scenarioKey];
                 if (scenario) {
                     // Clean up scenario data structures for the deleted rubro
                     if (scenario.data?.[type]?.[rubroToDelete]) {
                         delete scenario.data[type][rubroToDelete];
                     }
                     if (type === 'gastos' && scenario.monthStatus?.[type]?.[rubroToDelete]) {
                         delete scenario.monthStatus[type][rubroToDelete];
                     }
                     // Calculated data will be rebuilt correctly by calculateAll based on remaining data/rubros
                     // rubroOrder needs manual cleanup
                     if (scenario.rubroOrder?.[type]) {
                         scenario.rubroOrder[type] = scenario.rubroOrder[type].filter(r => r !== rubroToDelete);
                     }
                 }
             });

             saveState();

             const activeScenario = getCurrentScenarioData();
             if (activeScenario) {
                 // Recalculate handles saveState and success message
                 calculateAll(activeScenario);
             } else {
                 // If no active scenario, just update UI lists
                 updateUI();
                 showSnackbar(`Rubro "${rubroToDelete}" (${type}) eliminado.`, false, 'success', 3000);
             }
             // Update settings panel lists explicitly
             updateSettingsPanel();
        }

        function addCoefficientType() {
             const input = document.getElementById('new-coefficient-type-name');
             if (!input) { console.error("Input no encontrado: new-coefficient-type-name"); showSnackbar("Error interno.", true, 5000); return; }
             const name = input.value.trim();

             if (!name) { showSnackbar("Nombre de tipo vacío.", true, 'warning', 3000); input.focus(); return; }

             const key = name.replace(/\s+/g, '_').replace(/[^\w-]/g, '').toUpperCase(); // Sanitize key
             // Check if name or key already exists case-insensitively
             const nameExists = Object.values(appState.settings.coefficientTypes || {}).some(t => t.name.toLowerCase() === name.toLowerCase());
             const keyExists = appState.settings.coefficientTypes?.[key];
             if (keyExists || nameExists) {
                 showSnackbar(`Tipo "${name}" ya existe. Elige otro nombre.`, true, 'warning', 5000);
                 input.select(); return;
             }

             // --- MODIFICACIÓN FIX: Default values are 0% for new types ---
             appState.settings.coefficientTypes[key] = { name: name, values: Array(12).fill(0), isDefault: false };
             // --- END MODIFICACIÓN FIX ---

             input.value = '';
             console.log(`Tipo coeficiente añadido: "${name}" (${key})`);
             saveState();

             updateCoefficientTypeList();
             updateRubroList('gastos', 'gasto-rubro-list'); // Update selects in gasto list
             showSnackbar(`Tipo de coeficiente "${name}" añadido.`, false, 'success', 3000);
        }

        function deleteCoefficientType(typeKey) {
             const type = appState.settings.coefficientTypes?.[typeKey]; // Check if type exists
             if (!type) { showSnackbar("Tipo no encontrado.", true, 'error', 4000); return; }
             if (typeKey === 'None' || type.isDefault) { // Cannot delete 'None' or other defaults
                 showSnackbar(`Tipo por defecto "${type.name}" no se puede eliminar.`, true, 'warning', 5000); return;
             }

             const isInUse = appState.settings.rubros.gastos.some(rubro => appState.settings.rubroConfig[rubro]?.coefficientType === typeKey);
             if (isInUse) {
                 showSnackbar(`Tipo "${type.name}" está en uso por uno o más rubros de gasto. Reasigna los rubros (a 'Sin Coeficiente' u otro) antes de eliminar este tipo.`, true, 'warning', 9000);
                 return;
             }

             if (confirm(`¿Seguro que quieres eliminar el tipo de coeficiente "${type.name}"?`)) {
                 const deletedName = type.name;
                 delete appState.settings.coefficientTypes[typeKey];

                 if (appState.uiState.editingCoefficientType === typeKey) {
                     appState.uiState.editingCoefficientType = null;
                     renderCoefficientValuesEditor(null); // Clear editor
                 }

                 console.log(`Tipo coeficiente eliminado: ${deletedName} (${typeKey})`);
                 saveState();

                 updateCoefficientTypeList();
                 updateRubroList('gastos', 'gasto-rubro-list'); // Update selects in gasto list

                 showSnackbar(`Tipo de coeficiente "${deletedName}" eliminado.`, false, 'success', 3000);
             } else {
                 showSnackbar("Eliminación cancelada.", false, 'info', 3000);
             }
        }

        function updateReserveUI() {
             const panel = document.getElementById('reserve-fund-panel');
             if (!panel) return;

             const selectedType = document.getElementById('reserve-type-percent').checked ? 'percent' : 'fixed';

             const uiUnitLabel = selectedType === 'percent' ? '%' : '$';
             const uiCurrentStep = selectedType === 'percent' ? '0.1' : '100';

             // Find existing inputs to update them without rebuilding the panel
             const inputs = panel.querySelectorAll('input[type="number"]');
             inputs.forEach(input => {
                 input.step = uiCurrentStep;
                 input.placeholder = uiUnitLabel;
                 input.title = `Valor de fondo de reserva para ${FULL_MONTHS[parseInt(input.dataset.month)]} (${uiUnitLabel})`;
             });

              // If panel was empty, rebuild it with default values based on the selected type
             if (inputs.length === 0) {
                  console.log("Reserve fund panel empty, rebuilding...");
                  // Use scenarioData if available, otherwise use default type and values
                  const scenarioData = getCurrentScenarioData();
                 const reserveFundData = scenarioData?.reserveFund ?? { type: selectedType, values: Array(12).fill(selectedType === 'percent' ? 5 : 0) };
                 renderReserveFundInputs(panel, reserveFundData); // Helper to build inputs
             }
             // If inputs existed, the values should already match the scenario data's reserve fund type and values
             // from the last calculateAll or saveReserveFund call. We only updated the UI appearance (step, placeholder).


             console.log(`UI fondo reserva actualizada a tipo: ${uiSelectedType}`);
        }

        // Helper function to build the reserve fund inputs (called by updateReserveUI if empty)
        function renderReserveFundInputs(panelElement, reserveFundData) {
             panelElement.innerHTML = ''; // Clear panel

             const uiUnitLabel = reserveFundData.type === 'percent' ? '%' : '$';
             const uiCurrentStep = reserveFundData.type === 'percent' ? '0.1' : '100';

             // Ensure values array has 12 elements
             const reserveValues = Array.isArray(reserveFundData.values) && reserveFundData.values.length === 12
                                     ? reserveFundData.values.map(v => window.toNumber(v || 0))
                                     : Array(12).fill(reserveFundData.type === 'percent' ? 5 : 0); // Default based on type


             for (let i = 0; i < 12; i++) {
                 const monthDiv = document.createElement('div');
                 monthDiv.classList.add('form-group');

                 const label = document.createElement('label');
                 label.textContent = FULL_MONTHS[i];
                 label.htmlFor = `reserve-month-${i}`;

                 const input = document.createElement('input');
                 input.type = 'number';
                 input.id = `reserve-month-${i}`;
                 input.dataset.month = i;
                 input.value = reserveValues[i]; // Use validated array
                 input.step = uiCurrentStep;
                 input.min = '0';
                 input.placeholder = uiUnitLabel;
                 input.style.textAlign = 'right';
                 input.title = `Valor de fondo de reserva para ${FULL_MONTHS[i]} (${uiUnitLabel})`;

                 monthDiv.appendChild(label);
                 monthDiv.appendChild(input);
                 panelElement.appendChild(monthDiv);
             }
        }


        function exportToExcel() {
             console.log("Iniciando exportación Excel...");
             const scenarioData = getCurrentScenarioData();
             // --- FIX: Check for calculated data existence more thoroughly ---
             if (!scenarioData || !scenarioData.calculated || !scenarioData.calculated.annualTotals || !scenarioData.calculated.totalGastoProyectadoMes || !scenarioData.calculated.totalIngresoProyectadoMes || !scenarioData.calculated.cuotaRealBaseMes) {
                 showSnackbar("No hay datos calculados válidos para exportar. Carga datos desde Excel y recalcula.", true, 'error', 6000); return;
             }
             const { year, scenarioName, data, calculated, reserveFund, rubroOrder } = scenarioData;
             const { settings } = appState;
             const { rubros, rubroConfig, coefficientTypes, cantidadUnidades } = settings; // Use settings for rubro lists/config

             try {
                 const wb = XLSX.utils.book_new();

                 // Define basic cell formats (more complex styling is harder with aoa_to_sheet)
                 const headerStyle = { font: { bold: true }, alignment: { horizontal: "center" } };
                 const currencyFormat = "$ #,##0.00";
                 const percentFormat = "0.00%"; // Use two decimal places for percentages in export
                 const numberFormat = "#,##0.00"; // Non-currency number

                 // --- Helper to create data for sheets ---
                 const createSheetData = (title, headers, dataRows) => {
                     // Filter out rows that are just placeholders (like section headers) before adding data
                     const validDataRows = dataRows.filter(row => Array.isArray(row) && row.length > 0 && row[0]?.startsWith && !row[0].startsWith('---'));
                      const titleRow = [title];
                      // Span the title across all columns for better appearance
                      const totalCols = headers.length;
                      if (totalCols > 1) {
                           for(let i=1; i < totalCols; i++) titleRow.push(null); // Add nulls to span
                           titleRow['!merges'] = [{s: {r:0, c:0}, e: {r:0, c: totalCols - 1}}]; // Merge cells
                      }


                     return [titleRow, [], headers, ...validDataRows];
                 };

                 // --- Apply formatting to a range of cells ---
                  const applyRangeFormat = (ws, range, format) => {
                       if (!range || !range.s || !range.e) return;
                       const { s, e } = range;
                       for (let r = s.r; r <= e.r; r++) {
                           for (let c = s.c; c <= e.c; c++) {
                               const cellRef = XLSX.utils.encode_cell({r: r, c: c});
                               const cell = ws[cellRef];
                                if (cell && typeof cell.v === 'number') {
                                    cell.z = format;
                                    cell.t = 'n';
                                } else if (cell && cell.v === null) {
                                   cell.t = 'z'; // Empty cell
                                }
                           }
                       }
                  };


                 // --- 1. Detalle Gastos Sheet ---
                 const gastosHeaders = ["Rubro", "Detalle", "Coef. Asignado", ...FULL_MONTHS, "Total Anual"];
                 const gastosRows = [];
                 // Use scenario-specific rubro order, filter by global settings
                 const orderedGastosRubros = (Array.isArray(rubroOrder?.gastos) ? rubroOrder.gastos : [])
                                           .filter(rubro => settings.rubros.gastos.includes(rubro));


                 orderedGastosRubros.forEach(rubro => {
                     const config = rubroConfig[rubro] || {};
                     const coefName = coefficientTypes[config.coefficientType || 'None']?.name || 'N/A';
                     const detailOrder = data.gastos?.[rubro]?.detailOrder || [];
                     // Filter details by existence in data
                     const orderedDetails = detailOrder.filter(detail => data.gastos?.[rubro]?.detailsData?.[detail] !== undefined && Array.isArray(data.gastos[rubro].detailsData[detail]) && data.gastos[rubro].detailsData[detail].length === 12);

                     orderedDetails.forEach(detail => {
                         const values = calculated.gastoAjustado?.[rubro]?.[detail] || Array(12).fill(0);
                         const annualTotal = values.reduce((a, b) => a + (b || 0), 0);
                         gastosRows.push([rubro, detail, coefName, ...values, annualTotal]);
                     });
                 });
                 const ws_gastos_array = createSheetData(`DETALLE GASTOS ${year} - ${scenarioName}`, gastosHeaders, gastosRows);
                 const ws_gastos = XLSX.utils.aoa_to_sheet(ws_gastos_array);
                 // Basic Widths
                 ws_gastos['!cols'] = [{wch:20},{wch:25},{wch:18}, ...Array(12).fill({wch:12}), {wch:14}];
                 // Apply currency formatting to month columns and total column
                  const gastosDataRange = XLSX.utils.decode_range(ws_gastos['!ref'] || "A1"); // Get the sheet's used range
                  if (gastosDataRange.e.r >= (gastosHeaders.length > 0 ? 2 : 0)) { // Ensure there are data rows (starts below title & blank row, and headers)
                      const firstDataRow = (gastosHeaders.length > 0 ? 2 : 0); // Data starts at row index 2 (0-based) if headers exist
                      const monthColsStart = 3; // Months start at column D (index 3)
                      const totalCol = 3 + 12; // Total is after 12 months

                      const formatRange = { s: {r: firstDataRow, c: monthColsStart}, e: {r: gastosDataRange.e.r, c: totalCol} };
                      applyRangeFormat(ws_gastos, formatRange, currencyFormat);
                  }

                 XLSX.utils.book_append_sheet(wb, ws_gastos, "Detalle Gastos");


                 // --- 2. Detalle Ingresos Sheet (Shows BASE values) ---
                 const ingresosHeaders = ["Rubro", "Detalle", ...FULL_MONTHS, "Total Anual"];
                 const ingresosRows = [];
                 // Use scenario-specific rubro order, filter by global settings
                  const orderedIngresosRubros = (Array.isArray(rubroOrder?.ingresos) ? rubroOrder.ingresos : [])
                                              .filter(rubro => settings.rubros.ingresos.includes(rubro));

                 orderedIngresosRubros.forEach(rubro => {
                    const detailOrder = data.ingresos?.[rubro]?.detailOrder || [];
                     // Filter details by existence in data
                     const orderedDetails = detailOrder.filter(detail => data.ingresos?.[rubro]?.detailsData?.[detail] !== undefined && Array.isArray(data.ingresos[rubro].detailsData[detail]) && data.ingresos[rubro].detailsData[detail].length === 12);

                    orderedDetails.forEach(detail => {
                        const values = calculated.ingresoAjustado?.[rubro]?.[detail] || Array(12).fill(0); // BASE values
                        const annualTotal = values.reduce((a, b) => a + (b || 0), 0);
                        const rubroNote = SPECIAL_INGRESO_RUBROS.includes(rubro) ? ` (Valor Base)` : ''; // Note it's BASE value, not total * UF
                        ingresosRows.push([`${rubro}${rubroNote}`, detail, ...values, annualTotal]);
                    });
                 });
                 const ws_ingresos_array = createSheetData(`DETALLE INGRESOS (Valores Base) ${year} - ${scenarioName}`, ingresosHeaders, ingresosRows);
                 const ws_ingresos = XLSX.utils.aoa_to_sheet(ws_ingresos_array);
                 ws_ingresos['!cols'] = [{wch:25},{wch:25}, ...Array(12).fill({wch:12}), {wch:14}];
                 // Apply currency formatting to month columns and total column
                  const ingresosDataRange = XLSX.utils.decode_range(ws_ingresos['!ref'] || "A1");
                  if (ingresosDataRange.e.r >= (ingresosHeaders.length > 0 ? 2 : 0)) {
                       const firstDataRow = (ingresosHeaders.length > 0 ? 2 : 0);
                       const monthColsStart = 2; // Months start at column C (index 2)
                       const totalCol = 2 + 12; // Total is after 12 months

                       const formatRange = { s: {r: firstDataRow, c: monthColsStart}, e: {r: ingresosDataRange.e.r, c: totalCol} };
                       applyRangeFormat(ws_ingresos, formatRange, currencyFormat);
                  }
                 XLSX.utils.book_append_sheet(wb, ws_ingresos, "Detalle Ingresos (Base)");


                  // --- 3. Coeficientes de Ajuste Sheet (Show Percentages) ---
                   const coefHeaders = ["Tipo Coeficiente", ...FULL_MONTHS];
                   const coefRows = [];
                    // Sort coefficient types alphabetically by name, 'None' first
                   const sortedCoefKeys = Object.keys(appState.settings.coefficientTypes || {})
                       .sort((a, b) => {
                           if (a === 'None') return -1;
                           if (b === 'None') return 1;
                           return (appState.settings.coefficientTypes[a]?.name || '').localeCompare(appState.settings.coefficientTypes[b]?.name || '');
                       });

                   sortedCoefKeys.forEach(key => {
                        const typeData = appState.settings.coefficientTypes[key];
                        if (!typeData) return; // Skip if missing data
                        // Ensure values array is 12 elements (percentages)
                         const values = (Array.isArray(typeData.values) && typeData.values.length === 12)
                                        ? typeData.values.map(v => window.toNumber(v || 0))
                                        : Array(12).fill(key === 'None' ? 1 : 0); // Default 'None' to 1, others to 0%

                        coefRows.push([typeData.name, ...values]);
                   });
                   const ws_coef_array = createSheetData(`COEFICIENTES DE AJUSTE (%) ${year}`, coefHeaders, coefRows);
                   const ws_coef = XLSX.utils.aoa_to_sheet(ws_coef_array);
                   ws_coef['!cols'] = [{wch:25}, ...Array(12).fill({wch:10})];
                   // Apply percentage formatting to month columns
                    const coefDataRange = XLSX.utils.decode_range(ws_coef['!ref'] || "A1");
                     if (coefDataRange.e.r >= (coefHeaders.length > 0 ? 2 : 0)) {
                          const firstDataRow = (coefHeaders.length > 0 ? 2 : 0);
                          const monthColsStart = 1; // Months start at column B (index 1)
                          const monthColsEnd = 1 + 12 -1; // Last month column index

                          // --- MODIFICACIÓN FIX: Apply formatting directly based on calculated values ---
                          for (let r = firstDataRow; r <= coefDataRange.e.r; r++) {
                               const typeRowIndex = r - firstDataRow; // Index in coefRows array
                               const typeName = coefRows[typeRowIndex]?.[0]; // Get the type name from the array data
                               const typeKey = sortedCoefKeys.find(k => appState.settings.coefficientTypes[k]?.name === typeName) || typeName; // Find the key

                              for (let c = monthColsStart; c <= monthColsEnd; c++) {
                                  const cellRef = XLSX.utils.encode_cell({r: r, c: c});
                                  const cell = ws_coef[cellRef];
                                  if (cell && typeof cell.v === 'number') {
                                       if (typeKey !== 'None' && typeKey !== 1) { // Don't convert 'None' values (which are stored as 1)
                                            cell.v /= 100; // Convert stored percentage (e.g. 2.5) to Excel percentage (0.025)
                                            cell.z = percentFormat;
                                       } else {
                                            // 'None' values (which are 1) can be formatted as numbers
                                            cell.z = numberFormat;
                                       }
                                      cell.t = 'n'; // Ensure cell type is number
                                  } else if (cell && cell.v === null) {
                                      cell.t = 'z'; // Empty cell
                                  }
                              }
                          }
                         // --- END MODIFICACIÓN FIX ---
                     }
                  XLSX.utils.book_append_sheet(wb, ws_coef, "Coeficientes (%)");


                 // --- 4. Resumen General Sheet ---
                 const resumenHeaders = ["Concepto", ...FULL_MONTHS, "Total Anual"];
                 const resumenRows = [];
                 const addRow = (label, values, format, isPercentage = false, isUF = false) => { // Renamed isPercent to isPercentage
                    const numericValues = Array.isArray(values) ? values.map(v => window.toNumber(v || 0)) : [];
                    const annual = numericValues.reduce((a, b) => a + (b || 0), 0);
                    const rowData = [label, ...numericValues, annual];
                    const lastRowIndex = resumenRows.length; // 0-based index in resumenRows array BEFORE push
                    resumenRows.push(rowData);
                    // Store formatting info for this row (relative to headers)
                     rowData.formatInfo = { format, isPercentage, isUF };
                 };

                 // Gastos Section
                 resumenRows.push(["--- GASTOS ---"]);
                 // Use scenario-specific rubro order, filter by global settings
                 orderedGastosRubros.forEach(rubro => {
                     addRow(`Gasto - ${rubro}`, calculated.totalGastoRubroMes?.[rubro] || Array(12).fill(0), currencyFormat);
                 });
                 addRow("TOTAL GASTOS ($)", calculated.totalGastoProyectadoMes || [], currencyFormat);
                 resumenRows.push([]); // Spacer

                 // Ingresos Section (Calculated totals incl. UF mult)
                 resumenRows.push(["--- INGRESOS (Calculados) ---"]);
                 // Use scenario-specific rubro order, filter by global settings
                  orderedIngresosRubros.forEach(rubro => {
                      // Aclarar en el label si el rubro fue multiplicado por UF
                      const rubroLabel = SPECIAL_INGRESO_RUBROS.includes(rubro) ? `${rubro} (Total x UF)` : rubro;
                     addRow(`Ingreso - ${rubroLabel}`, calculated.totalIngresoRubroMes?.[rubro] || [], currencyFormat);
                 });
                 addRow("TOTAL INGRESOS ($)", calculated.totalIngresoProyectadoMes || [], currencyFormat);
                 resumenRows.push([]); // Spacer

                 // Fondo Reserva Section
                 resumenRows.push(["--- FONDO RESERVA ---"]);
                 // Ensure reserveFund object and values exist/are valid
                 const reserveValues = (Array.isArray(reserveFund?.values) && reserveFund.values.length === 12)
                                     ? reserveFund.values.map(v => window.toNumber(v || 0))
                                     : Array(12).fill(reserveFund?.type === 'fixed' ? 0 : 5); // Default based on type
                 const reserveType = reserveFund?.type === 'fixed' ? 'fixed' : 'percent'; // Default to percent
                 const reserveLabel = `Fondo Reserva Config (${reserveType === 'percent' ? '%' : '$'})`;
                 addRow(reserveLabel, reserveValues, reserveType === 'percent' ? percentFormat : currencyFormat, reserveType === 'percent');
                 addRow("Fondo Reserva Calculado ($)", calculated.fondoReservaMes || [], currencyFormat);
                 resumenRows.push([]); // Spacer

                 // Cuotas & IPC Section
                 resumenRows.push(["--- CUOTAS Y REFERENCIAS ---"]);
                 // UF row: put value only in first month column
                 const ufValues = Array(12).fill(null);
                 ufValues[0] = cantidadUnidades; // Put UF count in the first month column
                 addRow(`Unidades Funcionales (UF)`, ufValues, numberFormat, false, true); // Mark as UF row

                 addRow("Cuota s/Gtos Calculada ($/UF)", calculated.cuotaSobreGastosMes || [], currencyFormat);
                 // Use the snapshot stored in calculated.ipcManual for the report (percentages)
                 addRow("IPC Referencia (%)", calculated.ipcManual || Array(12).fill(0), percentFormat, true);
                 addRow("Cuota IPC Calculada ($/UF)", calculated.cuotaIpcMes || [], currencyFormat);
                 addRow("Cuota Real Base ($/UF)", calculated.cuotaRealBaseMes || [], currencyFormat);

                 // Create Resumen Sheet
                 const ws_resumen_array = createSheetData(`RESUMEN GENERAL ${year} - ${scenarioName}`, resumenHeaders, resumenRows);
                 const ws_resumen = XLSX.utils.aoa_to_sheet(ws_resumen_array);
                 ws_resumen['!cols'] = [{wch:35}, ...Array(12).fill({wch:12}), {wch:14}]; // Make Concept column wider

                  // Apply Formatting based on stored info
                  // Find the actual start row index for data in the sheet
                 const resumenHeadersRowIndex = ws_resumen_array.findIndex(row => row === resumenHeaders); // Find header row index
                 const resumenDataStartRow = resumenHeadersRowIndex + 1; // Data starts right after headers

                 if (resumenHeadersRowIndex !== -1) { // Ensure headers were found
                      // Apply header style (optional)
                      // const headerRowRef = XLSX.utils.encode_range({s: {r: resumenHeadersRowIndex, c: 0}, e: {r: resumenHeadersRowIndex, c: resumenHeaders.length -1}});
                      // applyRangeFormat(ws_resumen, XLSX.utils.decode_range(headerRowRef), headerStyle); // Basic header styling doesn't work well this way

                     for (let arrayRowIndex = 0; arrayRowIndex < resumenRows.length; arrayRowIndex++) {
                          const rowInfo = resumenRows[arrayRowIndex].formatInfo;
                          if (rowInfo) {
                               const sheetRowIndex = resumenDataStartRow + arrayRowIndex; // Calculate corresponding row index in the sheet

                               for (let col = 1; col < 13 + 1; col++) { // Months (1-12) + Total (13) (columns B through N)
                                   const cellRef = XLSX.utils.encode_cell({r: sheetRowIndex, c: col});
                                   const cell = ws_resumen[cellRef];

                                   // Only apply format if cell exists and contains a number
                                   if(cell && typeof cell.v === 'number') {
                                       if (rowInfo.isPercentage && !rowInfo.isUF) {
                                           cell.v /= 100; // Convert percentage (e.g., 5 to 0.05)
                                           cell.z = rowInfo.format;
                                       } else {
                                            cell.z = rowInfo.format;
                                       }
                                        cell.t = 'n'; // Ensure cell type is number
                                   } else if (rowInfo.isUF && col === 1 && cell && typeof cell.v === 'number') {
                                        // Apply number format specifically to the first month cell for UF row
                                        cell.z = rowInfo.format;
                                        cell.t = 'n';
                                   } else if (cell && cell.v === null) {
                                       // Ensure nulls are treated as empty cells, not errors in Excel
                                        cell.t = 'z'; // Type 'z' for empty cell
                                   }
                               }
                          }
                     }
                 }
                 XLSX.utils.book_append_sheet(wb, ws_resumen, "Resumen General");


                 // --- Write File ---
                 const filename = `Reporte_Expensas_${year}_${scenarioName.replace(/\s+/g, '_').replace(/[^\w-]/g, '')}.xlsx`; // Sanitize filename
                 XLSX.writeFile(wb, filename);
                 showSnackbar("Reporte Excel generado.", false, 'success');

             } catch (error) {
                  console.error("Error exportando a Excel:", error);
                  showSnackbar(`Error al generar Excel: ${error.message}`, true, 'error', 6000);
             }
        }


        function exportChart(canvasId, filename) {
             const canvas = document.getElementById(canvasId);
             const chartInstance = window[`${canvasId}_instance`];
             // Check if canvas and instance exist, and if there is any non-zero data in the first dataset
             if (!canvas || !chartInstance || !chartInstance.data || !chartInstance.data.datasets || chartInstance.data.datasets.length === 0) {
                 showSnackbar(`Gráfico "${canvasId}" no encontrado.`, true, 'warning', 4000);
                 return;
             }
             // Check if all datasets contain only zero/null/undefined data
             const hasAnyData = chartInstance.data.datasets.some(dataset =>
                  Array.isArray(dataset.data) && dataset.data.some(d => d !== null && d !== undefined && d !== 0)
             );
             if (!hasAnyData) {
                  showSnackbar(`Gráfico "${canvasId}" sin datos para exportar.`, true, 'warning', 4000);
                  return;
             }

             try {
                 chartInstance.update('none'); // Ensure rendered without animation for export
                 // Allow a small delay for the canvas to potentially re-render after update('none')
                 requestAnimationFrame(() => {
                    requestAnimationFrame(() => { // Double rAF for safety
                     const imageURL = canvas.toDataURL('image/png');
                     const link = document.createElement('a');
                     link.href = imageURL;
                     link.download = filename;
                     document.body.appendChild(link);
                     link.click();
                     document.body.removeChild(link);
                     showSnackbar(`Gráfico "${filename}" exportado como PNG.`, false, 'success');
                    });
                 });
             } catch (e) {
                 console.error(`Error exportando gráfico "${canvasId}":`, e);
                 showSnackbar("Error al exportar gráfico.", true, 'error', 6000);
             }
        }


        // --- Utilidades ---
        function formatCurrency(value) {
             const num = Number(value);
             if (isNaN(num)) return "$ 0,00";
             // Use es-AR locale for Argentinian Peso formatting
             return `$ ${num.toLocaleString('es-AR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
        }

        function hexToRgba(hex, alpha) {
            hex = String(hex).trim().replace('#', '');
            if (!/^[0-9A-F]{3,6}$/i.test(hex)) return `rgba(0,0,0,${alpha})`; // Fallback black
            if (hex.length === 3) hex = hex.split('').map(c => c + c).join('');
            const r = parseInt(hex.slice(0, 2), 16), g = parseInt(hex.slice(2, 4), 16), b = parseInt(hex.slice(4, 6), 16);
            return (isNaN(r) || isNaN(g) || isNaN(b)) ? `rgba(0,0,0,${alpha})` : `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function openTab(evt, tabName) {
             let i, tabcontent, tablinks;
             tabcontent = document.getElementsByClassName("tab-content");
             for (i = 0; i < tabcontent.length; i++) { tabcontent[i].classList.remove("active"); tabcontent[i].style.display = "none"; }
             tablinks = document.getElementsByClassName("tab-link");
             for (i = 0; i < tablinks.length; i++) { tablinks[i].classList.remove("active"); }
             const tabToShow = document.getElementById(tabName);
             if(tabToShow) { tabToShow.style.display = "block"; void tabToShow.offsetWidth; tabToShow.classList.add("active"); }
             if(evt?.currentTarget) evt.currentTarget.classList.add("active");

             if (tabName === 'dashboard') { // Resize charts when dashboard tab is shown
                 requestAnimationFrame(() => {
                    ['evolutivoCuotaChart', 'participacionGastosChart', 'participacionIngresosChart'].forEach(id => {
                        if (window[`${id}_instance`]) window[`${id}_instance`].resize();
                    });
                 });
             }
        }

        function showSnackbar(message, isError = false, level = null, duration = 4000) {
             const snackbar = document.getElementById('snackbar');
             if (!snackbar) return;
             snackbar.textContent = message;
             let effectiveLevel = level ?? (isError ? 'error' : 'success'); // Default to success if not error

             snackbar.className = 'show'; // Base class to make it visible and positioned
             snackbar.classList.remove('error', 'warning', 'info'); // Remove previous level classes
             if (effectiveLevel === 'error') snackbar.classList.add('error');
             else if (effectiveLevel === 'warning') snackbar.classList.add('warning');
             else if (effectiveLevel === 'info') snackbar.classList.add('info');
             // Success uses default style (no extra class needed)

             if (snackbar.timer) clearTimeout(snackbar.timer);
             snackbar.timer = setTimeout(() => {
                 snackbar.className = ''; // Remove all classes to hide
                 snackbar.timer = null;
             }, duration);
        }


        // --- Tema Oscuro/Claro ---
        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            // Check for window.matchMedia existence for older browsers/environments
            const prefersDark = window.matchMedia?.('(prefers-color-scheme: dark)')?.matches;
            appState.darkMode = (savedTheme === 'dark') || (!savedTheme && !!prefersDark); // Use saved or system pref

            // Only add listener if window.matchMedia is supported
            if (window.matchMedia) {
                 window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                    if (!localStorage.getItem('theme')) { // Only follow system if no explicit choice saved
                        appState.darkMode = event.matches;
                        applyTheme(); // Apply with transition/chart update
                        saveState(); // Save the implicit preference change
                    }
                });
            }

            applyTheme(false); // Apply initial theme without transition/chart update
        }

        function toggleTheme() {
            appState.darkMode = !appState.darkMode;
            localStorage.setItem('theme', appState.darkMode ? 'dark' : 'light'); // Save explicit choice
            applyTheme();
            saveState();
        }

        function applyTheme(updateCharts = true){
            const body = document.body;
            const toggleButton = document.getElementById('theme-toggle');
            body.classList.toggle('dark-mode', appState.darkMode);
            if (toggleButton) {
                 toggleButton.innerHTML = appState.darkMode ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
                 toggleButton.title = appState.darkMode ? 'Cambiar a tema claro' : 'Cambiar a tema oscuro';
            }

            if (updateCharts) { // Avoid updating charts on initial load before they exist
                 requestAnimationFrame(() => { // Defer chart updates slightly
                     const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
                     const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
                     // Update global defaults (Chart.js v3+)
                     Chart.defaults.color = textColor;
                     Chart.defaults.borderColor = borderColor;
                     // Update existing instances
                     ['evolutivoCuotaChart', 'participacionGastosChart', 'participacionIngresosChart'].forEach(id => {
                          if (window[`${id}_instance`]) window[`${id}_instance`].update();
                     });
                 });
            }
        }

        // --- Persistencia (localStorage) ---
        function saveState() {
             try {
                 const stateToSave = {
                     currentYear: appState.currentYear,
                     scenarios: appState.scenarios,
                     activeScenarioKey: appState.activeScenarioKey,
                     settings: appState.settings,
                     darkMode: appState.darkMode,
                     // Don't save uiState intentionally (editingCoefficientType is transient)
                 };
                 localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
                 // console.log("Estado guardado.");
             } catch (e) {
                 console.error("Error guardando estado:", e);
                 showSnackbar("Error al guardar estado.", true, 'error', 6000);
             }
         }

        function loadState() {
             try {
                 const savedState = localStorage.getItem(STORAGE_KEY);
                 if (savedState) {
                     const loadedState = JSON.parse(savedState);
                     // Use deepMerge to load state, providing defaults for any missing parts
                     appState = deepMerge(getDefaultAppState(), loadedState);
                     console.log(`Estado ${STORAGE_KEY} cargado.`);
                 } else {
                     console.log(`No hay estado guardado para ${STORAGE_KEY}. Usando estado por defecto.`);
                     appState = getDefaultAppState(); // Fallback to default
                 }
             } catch (e) {
                 console.error(`Error cargando estado ${STORAGE_KEY}:`, e);
                 showSnackbar(`Error cargando estado guardado (${STORAGE_KEY}). Usando valores por defecto.`, true, 'error', 8000);
                 appState = getDefaultAppState(); // Fallback on load error
             }
             // Post-load validation is now handled by validateAndSetActiveScenario in DOMContentLoaded
        }

        function getDefaultAppState() {
            const defaultYear = new Date().getFullYear();
            // Define a base scenario structure for cloning
            const baseScenarioStructure = {
                year: defaultYear,
                scenarioName: 'Base', // Will be overwritten if cloning
                rubroOrder: { gastos: [], ingresos: [] },
                data: { gastos: {}, ingresos: {} },
                monthStatus: { gastos: {}, ingresos: {} },
                reserveFund: { type: 'percent', values: Array(12).fill(5) },
                calculated: {
                    gastoAjustado: {}, totalGastoRubroMes: {}, totalGastoProyectadoMes: Array(12).fill(0),
                    ingresoAjustado: {}, totalIngresoRubroMes: {}, totalIngresoProyectadoMes: Array(12).fill(0),
                    fondoReservaMes: Array(12).fill(0),
                    cuotaSobreGastosMes: Array(12).fill(0),
                    ipcManual: Array(12).fill(0),
                    cuotaIpcMes: Array(12).fill(0),
                    cuotaRealBaseMes: Array(12).fill(0),
                    annualTotals: {
                        gastos: {__TOTAL__:0}, ingresos: {__TOTAL__:0}, fondoReserva: 0,
                        cuotaSobreGastos: 0, cuotaIpc: 0, cuotaRealBase: 0
                    }
                }
            };

             // --- MODIFICACIÓN FIX: Coefficient default values are percentages (0%) except 'None' ---
            return {
                 currentYear: defaultYear,
                 scenarios: {}, // Start with empty scenarios object
                 activeScenarioKey: null, // Will be set by validation logic
                 settings: {
                     cantidadUnidades: 100,
                     rubros: { gastos: [], ingresos: [] },
                     rubroConfig: {}, // Stores coefficientType assignment and collapsed state per rubro (global setting)
                     coefficientTypes: {
                         "None": { name: "Sin Coeficiente", values: Array(12).fill(1), isDefault: true }, // Multiplier 1
                         "IPC": { name: "IPC (Ejemplo)", values: [5, 4, 6, 3, 4, 5, 3, 4, 5, 6, 4, 5], isDefault: true }, // Percentages
                         "UTEDYC": { name: "UTEDYC (Ejemplo)", values: [0, 0, 10, 0, 0, 8, 0, 0, 7, 0, 0, 5], isDefault: true }, // Percentages
                         "Sueldos": { name: "Sueldos Generales", values: [0, 0, 8, 0, 0, 6, 0, 0, 5, 0, 0, 4], isDefault: false } // Percentages
                     },
                     ipcManual: [5, 4, 6, 3, 4, 5, 3, 4, 5, 6, 4, 5] // Default IPC ref values (%)
                 },
                 uiState: { // Transient state (not saved, reset on load)
                    editingCoefficientType: null
                 },
                 darkMode: false, // Default theme
                 // Store the base scenario structure here for cloning if needed
                 BaseScenarioStructureTemplate: baseScenarioStructure
             };
             // --- END MODIFICACIÓN FIX ---
        }

        function deepMerge(target, source) {
             const output = { ...target };
             if (isObject(target) && isObject(source)) {
                 Object.keys(source).forEach(key => {
                     const targetValue = target[key];
                     const sourceValue = source[key];
                     if (isObject(sourceValue) && isObject(targetValue)) {
                         // Recurse into objects
                         output[key] = deepMerge(targetValue, sourceValue);
                     } else if (Array.isArray(sourceValue)) { // Always overwrite arrays from source
                          output[key] = [...sourceValue];
                     } else {
                          // Overwrite primitive/non-object/non-array values from source
                          output[key] = sourceValue !== undefined ? sourceValue : targetValue;
                     }
                 });
             }
             return output;
         }

        function isObject(item) {
             return (item && typeof item === 'object' && !Array.isArray(item));
        }

        // --- Funciones Adicionales o de UI ---
        function updateReportsPanel() {
             const scenarioData = getCurrentScenarioData();
             const hasCalculatedData = scenarioData?.calculated && (
                (scenarioData.calculated.totalGastoProyectadoMes?.some(v => v !== 0) ?? false) ||
                (scenarioData.calculated.totalIngresoProyectadoMes?.some(v => v !== 0) ?? false) ||
                (scenarioData.calculated.cuotaRealBaseMes?.some(v => v !== 0) ?? false) // Check Expensa Real data too
             );
             const disable = !scenarioData || !hasCalculatedData;

             document.querySelectorAll('#reports button').forEach(btn => { btn.disabled = disable; });
        }

        function clearScenarioData() {
             const key = appState.activeScenarioKey;
             const scenario = appState.scenarios?.[key]; // Check if scenario exists
             if (!scenario) { showSnackbar('No hay escenario activo.', true, 'error', 4000); return; }

             if (!confirm(`¿Borrar TODOS los datos (gastos, ingresos, estado meses) del escenario "${scenario.scenarioName}"?\n\nLa Configuración de Fondo de Reserva y la asignación de Coeficientes se mantendrán.\n¡No se puede deshacer!`)) {
                 showSnackbar("Operación cancelada.", false, 'info', 3000); return;
             }

             // Reset data, keep reserve fund, rubro config, and calculated ipc snapshot
             scenario.rubroOrder = { gastos: [], ingresos: [] };
             scenario.data = { gastos: {}, ingresos: {} };
             scenario.monthStatus = { gastos: {}, ingresos: {} }; // Status only for Gastos
             // calculated data (except ipcManual snapshot) is reset within calculateAll

             console.log(`Datos borrados para escenario: ${key}`);
             saveState(); // Save cleared data structures
             // Recalculate to update totals to zero and refresh UI
             calculateAll(scenario); // Handles success message
        }

    </script>
<!-- Old or Unused Scripts (Commented Out or Removed) -->
<!-- The following script blocks were identified as potentially unused or replaced by newer logic.
     They are commented out or have been removed to avoid conflicts and confusion.
     - Toggle Rubros (replaced by addCollapsibleListeners)
     - Expensa Real Auto-Fill (replaced by calculation logic in calculateAll)
-->
</body>
</html>
