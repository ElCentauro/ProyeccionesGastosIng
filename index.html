<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Favicon -->
<link rel="icon" type="image/png" href="favicon.png">
    <title>Proyección Expensas - Barrio El Centauro</title>
    <!-- Librería SheetJS (js-xlsx) para leer/escribir Excel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- Librería Chart.js para gráficos -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<!-- Plugin doughnut 3D shadow -->
<script>
/* Plugin: doughnutShadow3D
   Añade una sombra suave debajo de cada porción para simular profundidad 3 D.
   Seguro para todos los datasets (evita NaN en createRadialGradient). */
const doughnutShadow3D = {
  id: 'doughnutShadow3D',
  afterDatasetDraw(chart, args, opts) {
    const {ctx} = chart;
    if (args.meta.type !== 'doughnut') return;

    args.meta.data.forEach(segment => {
      const {x, y, startAngle, endAngle, innerRadius, outerRadius} = segment;
      if (!isFinite(x) || !isFinite(y) || !isFinite(innerRadius) || !isFinite(outerRadius)) return;

      ctx.save();
      ctx.fillStyle = 'rgba(0,0,0,0.15)';      // shadow color
      ctx.translate(0, 4);                     // vertical offset
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.arc(x, y, outerRadius, startAngle, endAngle);
      ctx.arc(x, y, innerRadius, endAngle, startAngle, true);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    });
  }
};
// Registrar plugin globalmente
if (window.Chart && !Chart.registry.plugins.get('doughnutShadow3D')) {
  Chart.register(doughnutShadow3D);
}
</script>

    <!-- Font Awesome para iconos -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts (Inter) -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        /* --- Reset Básico y Fuentes --- */
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; /* Base font size */ }
        body {
            font-family: 'Inter', 'Segoe UI', sans-serif;
            line-height: 1.7; /* Improved readability */
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* --- Variables de Color (Paleta Refinada) --- */
        :root {
            --bg-color: #f8f9fa;              /* Slightly off-white */
            --text-color: #343a40;            /* Darker gray */
            --primary-color: #007bff;          /* Classic blue */
            --primary-color-darker: #0056b3;   /* Darker blue for hover */
            --secondary-color: #6c757d;        /* Standard gray */
            --secondary-color-darker: #5a6268; /* Darker gray for hover */
            --accent-color: #28a745;           /* Vibrant green */
            --accent-color-darker: #218838;    /* Darker green for hover */
            --danger-color: #dc3545;           /* Red */
            --danger-color-darker: #c82333;    /* Darker red */
            --warning-color: #ffc107;           /* Yellow */
            --warning-color-darker: #e0a800;   /* Darker yellow */
            --info-color: #17a2b8;             /* Teal */
            --info-color-darker: #138496;      /* Darker teal */
            --success-color: var(--accent-color); /* Alias for consistency */
            --success-color-darker: var(--accent-color-darker); /* Alias */

            --border-color: #dee2e6;           /* Light gray border */
            --header-bg: #ffffff;              /* White header */
            --card-bg: #ffffff;                /* White cards */
            --shadow-color: rgba(0, 0, 0, 0.08); /* Softer shadow */
            --input-bg: #ffffff;
            --input-border: #ced4da;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(0, 123, 255, 0.25);
            --button-text: #ffffff;
            --button-warning-text: #212529; /* Dark text for yellow button */
            --table-header-bg: #eef2f7;        /* Lighter table header */
            --table-row-hover: #f1f3f5;        /* Subtle hover */
            --expandable-row-bg: #f8f9fa;      /* Same as body bg for subtle diff */
            --clickable-row-hover: #e9ecef;    /* Slightly darker hover for clickable rows */
            --disabled-bg: #e9ecef;
            --disabled-text: #6c757d;
            --disabled-border: #ced4da;

            /* >>> COLORES REAL/ESTIMADO <<< */
            --real-month-bg: #d1f7d9; /* Light, fresh green */
            --estimated-month-bg: #fff3cd; /* Soft Yellow */
             --estimated-month-border: #ffda6a; /* Yellow border for input */
        }

        body.dark-mode {
            --bg-color: #1a1a1a;              /* Very dark gray */
            --text-color: #e0e0e0;            /* Light gray text */
            --primary-color: #58a6ff;          /* Brighter blue */
            --primary-color-darker: #79b8ff;   /* Lighter blue for hover */
            --secondary-color: #8b949e;        /* Lighter gray */
            --secondary-color-darker: #a0a8b0; /* Lighter gray hover */
            --accent-color: #56d364;           /* Brighter green */
            --accent-color-darker: #6bde7a;    /* Lighter green hover */
            --danger-color: #f85149;           /* Bright red */
            --danger-color-darker: #fa6a61;    /* Lighter red */
            --warning-color: #f0b41e;          /* Bright yellow */
            --warning-color-darker: #f2c037;   /* Lighter yellow */
            --info-color: #6cb6f1;             /* Bright teal */
            --info-color-darker: #85c3f4;      /* Lighter teal */
            --success-color: var(--accent-color);
            --success-color-darker: var(--accent-color-darker);

            --border-color: #444c56;           /* Darker border */
            --header-bg: #2c2c2c;              /* Dark card background */
            --card-bg: #2c2c2c;                /* Dark card background */
            --shadow-color: rgba(255, 255, 255, 0.05); /* Subtle white shadow */
            --input-bg: #3a3f44;
            --input-border: #5a6268;
            --input-focus-border: var(--primary-color);
            --input-focus-shadow: rgba(88, 166, 255, 0.25);
            --button-text: #1a1a1a; /* Dark text on bright buttons */
            --button-warning-text: #1a1a1a;
            --table-header-bg: #343a40;        /* Darker header */
            --table-row-hover: #3e444a;        /* Subtle dark hover */
            --expandable-row-bg: #343a40;      /* Darker expandable row bg */
            --clickable-row-hover: #495057;    /* Darker hover for clickable */
            --disabled-bg: #495057;
            --disabled-text: #adb5bd;
            --disabled-border: #5a6268;

            /* >>> COLORES REAL/ESTIMADO OSCURO <<< */
            --real-month-bg: #1c4a2b; /* Darker Green */
            --estimated-month-bg: #5a4a1d; /* Dark Yellow/Brown */
            --estimated-month-border: #f0b41e; /* Brighter Yellow border for input */
        }

        /* --- Estilos Generales --- */
        .container { width: 95%; max-width: 1700px; margin: 0 auto; padding: 25px 20px; }
        h1, h2, h3, h4 { color: var(--primary-color); margin-bottom: 1em; font-weight: 600; }
        h1 { font-size: 2.2rem; text-align: center; }
        h2 { font-size: 1.8rem; border-bottom: 2px solid var(--accent-color); padding-bottom: 0.4em; }
        h3 { font-size: 1.4rem; margin-top: 1.8em; }
        h4 { font-size: 1.15rem; color: var(--secondary-color); margin-top: 1.2em; margin-bottom: 0.6em; }
        a { color: var(--primary-color); text-decoration: none; transition: color 0.2s ease; }
        a:hover { color: var(--primary-color-darker); text-decoration: underline; }

        button {
            padding: 12px 22px;
            border: 1px solid transparent; /* Added border for consistency */
            border-radius: 6px;
            background-color: var(--primary-color);
            color: var(--button-text);
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out, transform 0.1s ease, box-shadow 0.2s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center; /* Center content */
            gap: 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            line-height: 1.5; /* Ensure consistent height */
            text-align: center; /* Ensure text aligns center */
        }
        button:hover {
            background-color: var(--primary-color-darker);
            border-color: var(--primary-color-darker);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        button:focus {
            outline: none;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        button:disabled {
            background-color: var(--disabled-bg);
            color: var(--disabled-text);
            border-color: var(--disabled-border);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        button i { margin-right: 2px; /* Keep small margin */ }

        /* Button variants */
        .button-primary { background-color: var(--primary-color); border-color: var(--primary-color); color: var(--button-text); }
        .button-primary:hover { background-color: var(--primary-color-darker); border-color: var(--primary-color-darker); }
        .button-secondary { background-color: var(--secondary-color); border-color: var(--secondary-color); color: var(--button-text); }
        .button-secondary:hover { background-color: var(--secondary-color-darker); border-color: var(--secondary-color-darker); }
        .button-success { background-color: var(--success-color); border-color: var(--success-color); color: var(--button-text); }
        .button-success:hover { background-color: var(--success-color-darker); border-color: var(--success-color-darker); }
        .button-danger { background-color: var(--danger-color); border-color: var(--danger-color); color: var(--button-text); }
        .button-danger:hover { background-color: var(--danger-color-darker); border-color: var(--danger-color-darker); }
        .button-warning { background-color: var(--warning-color); border-color: var(--warning-color); color: var(--button-warning-text); }
        .button-warning:hover { background-color: var(--warning-color-darker); border-color: var(--warning-color-darker); }
        .button-info { background-color: var(--info-color); border-color: var(--info-color); color: var(--button-text); }
        .button-info:hover { background-color: var(--info-color-darker); border-color: var(--info-color-darker); }
        .button-sm { padding: 6px 12px; font-size: 0.85rem; gap: 6px;}

        /* --- Header --- */
        header {
            background-color: var(--header-bg);
            padding: 15px 0;
            box-shadow: 0 2px 5px var(--shadow-color);
            position: sticky; top: 0; z-index: 1000;
            border-bottom: 1px solid var(--border-color);
        }
        header .container { display: flex; justify-content: space-between; align-items: center; padding-top: 0; padding-bottom: 0; }
        .app-title { font-size: 1.6rem; font-weight: 700; color: var(--primary-color); }
        #theme-toggle { font-size: 1.3rem; background: none; border: none; color: var(--text-color); cursor: pointer; padding: 5px; border-radius: 50%; transition: background-color 0.2s;}
        #theme-toggle:hover { background-color: var(--table-row-hover); }

        /* --- Navegación / Pestañas --- */
        .tabs {
            display: flex;
            margin-bottom: 30px;
            border-bottom: 1px solid var(--border-color);
            flex-wrap: wrap;
            gap: 5px;
        }
        .tab-link {
            padding: 12px 20px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-bottom: -1px; /* Overlap bottom border */
            background-color: transparent;
            color: var(--secondary-color);
            font-size: 1rem;
            font-weight: 600;
            border-radius: 6px 6px 0 0;
            transition: background-color 0.2s, color 0.2s, border-color 0.2s;
            display: inline-flex; /* Align icon and text */
            align-items: center;
            gap: 8px;
        }
        .tab-link:hover {
             color: var(--primary-color);
             background-color: var(--table-row-hover);
        }
        .tab-link.active {
            background-color: var(--card-bg);
            border-color: var(--border-color);
            border-bottom-color: var(--card-bg); /* Hide bottom border part */
            color: var(--primary-color);
            font-weight: 700;
        }
        .tab-content {
            display: none;
            padding: 30px;
            border: 1px solid var(--border-color);
            border-top: none;
            background-color: var(--card-bg);
            border-radius: 0 0 6px 6px;
            box-shadow: 0 5px 15px var(--shadow-color);
        }
        .tab-content.active { display: block; animation: fadeIn 0.5s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        /* --- Formularios y Entradas --- */
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; font-weight: 600; color: var(--text-color); font-size: 0.95rem;}
        input[type="text"], input[type="number"], input[type="file"], select, textarea {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid var(--input-border);
            border-radius: 6px;
            background-color: var(--input-bg);
            color: var(--text-color);
            font-size: 1rem;
            transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }
        input:focus, select:focus, textarea:focus {
            border-color: var(--input-focus-border);
            outline: 0;
            box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
        }
        input:disabled, select:disabled, textarea:disabled {
             background-color: var(--disabled-bg);
             color: var(--disabled-text);
             border-color: var(--disabled-border);
             cursor: not-allowed;
        }
        input[type="number"] { text-align: right; -moz-appearance: textfield; }
        input[type=number]::-webkit-inner-spin-button, input[type=number]::-webkit-outer-spin-button { margin: 0; }
        input[type="file"] { padding: 8px; line-height: 1.5; } /* Adjust file input padding */
        .input-group { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
        .input-group label { margin-bottom: 0; font-weight: normal;}
        .input-group input[type="radio"] { width: auto; margin-right: 5px; }
        .input-small { width: 150px; display: inline-block; margin-left: 10px; }

        /* --- Tablas --- */
        .table-container { overflow-x: auto; margin-top: 25px; border: 1px solid var(--border-color); border-radius: 6px; }
        table { width: 100%; border-collapse: collapse; background-color: var(--card-bg); font-size: 0.9rem; }
        th, td {
            padding: 12px 15px;
            border: none;
            border-bottom: 1px solid var(--border-color);
            text-align: left;
            vertical-align: middle;
            white-space: nowrap;
        }
        th {
            background-color: var(--table-header-bg);
            font-weight: 600;
            position: sticky; top: 0; z-index: 10;
            border-bottom-width: 2px;
        }
        tbody tr:last-child td { border-bottom: none; }
        tbody tr:hover { background-color: var(--table-row-hover); }
        th:first-child, td:first-child { border-left: none; padding-left: 20px; /* More padding for first col */ }
        th:last-child, td:last-child { border-right: none; padding-right: 20px; /* More padding for last col */}

        /* Cell specific styles */
        td.real-month-cell { background-color: var(--real-month-bg) !important; /* Use important to override hover */ }
        td.estimated-month-cell { background-color: var(--estimated-month-bg) !important; }
        td.number-cell { text-align: right; font-variant-numeric: tabular-nums; }
        td.input-cell input { width: 100px; padding: 6px; font-size: 0.9rem; text-align: right; }
        td.input-cell input:disabled { background-color: transparent; border: none; color: var(--disabled-text);}
        .text-muted { color: var(--secondary-color); font-style: italic; font-size: 0.9em;}

        /* --- Tablas Desplegables --- */
        .collapsible-table tbody tr.rubro-total-row { font-weight: bold; cursor: pointer; background-color: var(--expandable-row-bg); transition: background-color 0.2s; }
        .collapsible-table tbody tr.rubro-total-row:hover { background-color: var(--clickable-row-hover); }
        .collapsible-table tbody tr.rubro-total-row td:first-child::before {
            content: '\f078'; /* fa-chevron-down */
            font-family: 'Font Awesome 6 Free'; font-weight: 900; margin-right: 12px; display: inline-block; transition: transform 0.2s ease-in-out; color: var(--primary-color);
        }
        .collapsible-table tbody tr.rubro-total-row.collapsed td:first-child::before { transform: rotate(-90deg); }
        .collapsible-table tbody tr.detail-row { display: table-row; background-color: var(--card-bg); transition: background-color 0.3s; }
        .collapsible-table tbody tr.detail-row.hidden { display: none; }
        .collapsible-table tbody tr.detail-row td { font-size: 0.85rem; color: var(--secondary-color); border-color: var(--border-color); }
        .collapsible-table tbody tr.detail-row td:first-child { padding-left: 40px; /* Indent details more */ }
        body.dark-mode .collapsible-table tbody tr.detail-row { background-color: #353535; }
        .collapsible-table tfoot tr { font-weight: bold; background-color: var(--table-header-bg); border-top: 2px solid var(--border-color); }

         /* Styles for Group/Ungroup All buttons */
        .table-actions {
            margin-bottom: 15px;
             display: flex;
             justify-content: flex-end; /* Align buttons to the right */
             gap: 10px;
             flex-wrap: wrap;
        }


        /* --- Componentes UI Específicos --- */
        #dashboard-summary { border-collapse: separate; border-spacing: 0; }
        #dashboard-summary th, #dashboard-summary td { text-align: center; white-space: normal; }
        #dashboard-summary tbody td, #dashboard-summary tfoot td { padding: 10px 8px; }
        #dashboard-summary .month-header { font-weight: bold; }

        .chart-container {
            margin-top: 35px; padding: 30px;
            background-color: var(--card-bg); border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-color);
            position: relative; min-height: 200px; /* Adjusted min height */
        }
        .chart-container canvas { max-width: 100%; height: 380px !important; }
        .chart-no-data { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--secondary-color); font-style: italic; font-size: 1.1rem; text-align: center; }

        #file-upload-area {
            border: 2px dashed var(--primary-color);
            padding: 45px; text-align: center; background-color: var(--bg-color);
            border-radius: 8px; margin-bottom: 25px; transition: background-color 0.2s ease, border-color 0.2s ease; cursor: pointer;
        }
        #file-upload-area:hover { background-color: var(--table-row-hover); border-color: var(--primary-color-darker); }
        #file-upload-area p { margin-bottom: 15px; font-size: 1.1rem; color: var(--secondary-color); }
        #file-upload-area i.fa-file-excel { font-size: 3rem; margin-bottom: 10px; color: var(--accent-color); }
        #file-upload-feedback { margin-top: 15px; font-weight: bold; white-space: pre-wrap; font-size: 0.95rem; min-height: 2em; }

        #reserve-fund-panel { margin-top: 20px; display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 20px;} /* MODIFICADO: Usar grid como IPC */
        #reserve-fund-panel .month-config { /* Removed flex styles, grid handles layout */ padding: 0; border-radius: 0; background-color: transparent; transition: none; }
        #reserve-fund-panel .month-config label { width: 100%; margin-bottom: 5px; font-weight: 600;}
        #reserve-fund-panel .month-config input { width: 100%; }
        #reserve-fund-panel .month-config span { margin-left: 5px; color: var(--secondary-color); font-size: 0.9em; } /* Style the unit */


        .config-section {
            border: 1px solid var(--border-color); border-radius: 8px; padding: 25px;
            margin-bottom: 30px; background-color: var(--card-bg);
            box-shadow: 0 3px 7px var(--shadow-color);
        }
        .config-section h4 { border-bottom: 1px solid var(--border-color); padding-bottom: 0.6em; margin-bottom: 1.2em;}
        .management-list { list-style: none; padding: 0; max-height: 350px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 6px; padding: 10px; background-color: var(--bg-color); }
        body.dark-mode .management-list { background-color: #3a3f44; }
        .management-list li { display: flex; justify-content: space-between; align-items: center; padding: 10px 8px; border-bottom: 1px solid var(--border-color); transition: background-color 0.2s; }
        .management-list li:last-child { border-bottom: none;}
        .management-list li:hover { background-color: var(--table-row-hover); }
        .management-list li span { flex-grow: 1; margin-right: 15px; font-weight: 500; }
        .management-list li select { width: 200px; font-size: 0.88rem; padding: 6px 8px; flex-shrink: 0; }
        .management-list li button { flex-shrink: 0; }

         /* Styles for the NEW Coefficient Editor */
         #coefficient-editor { margin-top: 25px; }
         #coefficient-editor h4 { margin-bottom: 15px;}
         #coefficient-values-editor {
             display: grid;
             grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); /* Similar grid to IPC */
             gap: 20px;
             padding: 20px; /* Add padding */
             border: 1px solid var(--border-color); /* Add border */
             border-radius: 6px; /* Add border-radius */
             background-color: var(--bg-color); /* Background like other lists/panels */
         }
         body.dark-mode #coefficient-values-editor { background-color: #3a3f44; }

         #coefficient-values-editor .form-group { margin-bottom: 0; } /* Adjust form-group margin inside grid */
         #coefficient-values-editor .form-group label { margin-bottom: 5px; font-weight: 600; width: 100%;} /* Adjust label */
         #coefficient-values-editor .form-group input { width: 100%; max-width: none; } /* Allow input to fill grid cell */
         #coefficient-values-editor .text-muted { grid-column: 1 / -1; text-align: center; padding: 20px; } /* Center and span info message */


        /* --- Snackbar --- */
        #snackbar {
            visibility: hidden; min-width: 300px; max-width: 90%;
            background-color: var(--success-color); /* Default to success */
            color: var(--button-text); text-align: center;
            border-radius: 6px; padding: 18px 25px; position: fixed; z-index: 1001;
            left: 50%; transform: translateX(-50%); bottom: 30px;
            font-size: 1.05rem; font-weight: 500;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            opacity: 0; transition: visibility 0s 0.5s, opacity 0.5s ease-out, bottom 0.5s ease-out;
        }
        #snackbar.show {
            visibility: visible; opacity: 1; bottom: 60px;
            transition: opacity 0.5s ease-in, bottom 0.5s ease-in;
        }
        #snackbar.error { background-color: var(--danger-color); color: var(--button-text); }
        #snackbar.warning { background-color: var(--warning-color); color: var(--button-warning-text); }
        #snackbar.info { background-color: var(--info-color); color: var(--button-text); }


        /* --- Footer --- */
        footer {
            margin-top: auto; padding: 20px 0; text-align: center; font-size: 0.95em;
            color: var(--secondary-color); background-color: var(--header-bg);
            border-top: 1px solid var(--border-color);
        }

        /* --- Responsive Adjustments --- */
        @media (max-width: 1200px) { .container { width: 98%; } .chart-container canvas { height: 320px !important; } }
        @media (max-width: 992px) {
             h1 { font-size: 2rem; } h2 { font-size: 1.6rem; } h3 { font-size: 1.3rem; }
             .tabs { justify-content: flex-start; }
             .tab-link { padding: 10px 18px; font-size: 0.95rem;}
             table { font-size: 0.88rem; } th,td {padding: 10px 12px;}
             .management-list li select { width: 150px; } /* Reduce select width */
        }
        @media (max-width: 768px) {
            body { line-height: 1.6; }
            .app-title { font-size: 1.3rem;} #theme-toggle { font-size: 1.1rem;}
            .chart-container { padding: 20px;} .chart-container canvas { height: 280px !important; }
            .input-group { flex-direction: column; align-items: stretch; gap: 10px;}
            .input-small { margin-left: 0; margin-top: 8px; width: 100%; }
            /* Adjust Reserve Fund and Coefficient Editor grid columns */
            #reserve-fund-panel, #coefficient-values-editor, #ipc-inputs { grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px;}
            #reserve-fund-panel .month-config label { width: 100%; text-align: left; margin-bottom: 5px; }
            #reserve-fund-panel .month-config input { width: 100%; }
            table { font-size: 0.85rem; } th, td { padding: 9px 8px; white-space: normal; } /* Allow wrap */
            th:first-child, td:first-child { padding-left: 15px; }
            th:last-child, td:last-child { padding-right: 15px; }
            td.input-cell input { width: 80px; padding: 5px; }
            .management-list li { flex-wrap: wrap; gap: 8px; }
            .management-list li span { flex-basis: 100%; margin-right: 0; } /* Name takes full width */
            .management-list li select { width: calc(100% - 50px); margin-top: 5px; } /* Select almost full width */
            .management-list li button { margin-left: auto; } /* Push button right */
            button { font-size: 0.95rem; padding: 10px 18px;}
            .tabs { gap: 2px; }
            .tab-link { padding: 8px 10px; font-size: 0.85rem;}
             .table-actions { justify-content: center; }
        }
        @media (max-width: 576px) {
            h1 { font-size: 1.7rem; } .app-title { display: none; } header .container { justify-content: flex-end; }
            .tab-link { padding: 8px 10px; font-size: 0.85rem;}
            th, td { padding: 8px 6px; }
            th:first-child, td:first-child { padding-left: 10px; }
            th:last-child, td:last-child { padding-right: 10px; }
            .chart-container canvas { height: 220px !important; }
            #snackbar { min-width: 90%; bottom: 20px; font-size: 1rem; padding: 15px 20px; }
            #snackbar.show { bottom: 40px; }
            #file-upload-area { padding: 30px; }
            .management-list li select { width: 100%; } /* Select full width on smallest screens */
             /* Adjust Reserve Fund and Coefficient Editor grid columns */
             #reserve-fund-panel, #coefficient-values-editor, #ipc-inputs { grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px;}
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <span class="app-title">Proyección Expensas - El Centauro</span>
            <button id="theme-toggle" title="Cambiar tema"><i class="fas fa-moon"></i></button>
        </div>
    </header>

    <div class="container">
        <div class="tabs">
            <button class="tab-link active" onclick="openTab(event, 'dashboard')"><i class="fas fa-tachometer-alt"></i> Dashboard</button>
            <button class="tab-link" onclick="openTab(event, 'upload')"><i class="fas fa-upload"></i> Cargar Datos</button>
            <button class="tab-link" onclick="openTab(event, 'reserve')"><i class="fas fa-piggy-bank"></i> Fondo Reserva</button>
            <button class="tab-link" onclick="openTab(event, 'settings')"><i class="fas fa-cog"></i> Configuración</button>
            <button class="tab-link" onclick="openTab(event, 'reports')"><i class="fas fa-download"></i> Reportes</button>
        </div>

        <!-- ==================== DASHBOARD ==================== -->
        <div id="dashboard" class="tab-content active">
            <h2><i class="fas fa-tachometer-alt"></i> Dashboard Anual - <span id="dashboard-year"></span> (<span id="dashboard-scenario">Base</span>)</h2>
            <div class="form-group input-group">
                <label for="scenario-selector" style="flex-shrink: 0;">Escenario:</label>
                <select id="scenario-selector" style="flex-grow: 1;"></select>
                <button onclick="createScenario()" class="button-primary button-sm" title="Crear Escenario Nuevo"><i class="fas fa-plus"></i> Crear</button>
                <button onclick="cloneScenario()" class="button-secondary button-sm" title="Clonar Escenario Actual"><i class="fas fa-clone"></i> Clonar</button>
                <button onclick="deleteScenario()" class="button-danger button-sm" title="Eliminar Escenario Actual"><i class="fas fa-trash"></i> Eliminar</button>
                <button id="btnBorrarDatos" class="button-warning button-sm" title="Borrar Datos del Escenario Actual (Gastos, Ingresos, Status)" onclick="clearScenarioData()" ><i class="fas fa-broom"></i> Borrar Datos</button>
                <button onclick="recalculateEstimates()" class="button-info button-sm" title="Proyectar meses estimados basados en último mes real y coeficientes (acumulativo)"><i class="fas fa-calculator"></i> Calcular Estimados</button>
            </div>

            <h4>Resumen Mensual General</h4>
            <div class="table-container">
                <table id="dashboard-summary">
                    <thead>
                        <tr>
                            <th>Mes</th>
                            <th>Gasto ($)</th>
                            <th>Fondo ($)</th>
                            <th>Cuota s/Gs ($/UF)</th> <!-- Basado en Gasto+Fondo / UF -->
                            <th>IPC (%)</th>
                            <th>Cuota IPC ($/UF)</th>   <!-- NUEVO: Cuota s/Gs * (1 + IPC%) -->
                            <!-- MODIFICACIÓN INICIO - Encabezado de tabla -->
                            <th>Expensa Real ($/UF)</th> <!-- Ahora muestra el valor del rubro Expensas Ordinarias / UF -->
                            <!-- MODIFICACIÓN FIN -->
                        </tr>
                    </thead>
                    <tbody><!-- Contenido generado por JS --></tbody>
                    <tfoot><!-- Contenido generado por JS --></tfoot>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Detalle de Gastos Proyectados ($)</h4>
             <p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar los detalles. Las celdas mensuales de detalle se colorean según su origen: <span style="background-color: var(--real-month-bg); padding: 1px 4px; border-radius: 3px;">REAL</span> (cargado desde Excel con número) o <span style="background-color: var(--estimated-month-bg); padding: 1px 4px; border-radius: 3px;">ESTIMADO</span> (cargado sin número o proyectado/calculado).</p>

            <!-- Added Group/Ungroup Buttons for Gastos -->
            <div class="table-actions">
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('gastos', false)" title="Expandir todos los detalles de gastos"><i class="fas fa-expand"></i> Expandir Todo</button>
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('gastos', true)" title="Colapsar todos los detalles de gastos"><i class="fas fa-compress"></i> Colapsar Todo</button>
            </div>

            <div class="table-container">
                <table id="gastos-detail-table" class="collapsible-table">
                     <thead>
                        <tr>
                            <th>Rubro / Detalle</th>
                            <th>Coef. Aplicado</th> <!-- Add Coef. column header -->
                            <!-- Meses y Total Anual generados por JS -->
                         </tr>
                     </thead>
                     <tbody><!-- Contenido generado por JS --></tbody>
                     <tfoot><!-- Contenido generado por JS --></tfoot>
                </table>
            </div>

            <h4 style="margin-top: 30px;">Detalle de Ingresos Proyectados ($)</h4>
             <p class="text-muted" style="font-size: 0.9em;">Haga clic en una fila de rubro para expandir/colapsar. Los valores aquí son la base de cálculo (valor individual o por UF). El Total de Ingresos en el Resumen General puede incluir la multiplicación por UF.</p>

             <!-- Added Group/Ungroup Buttons for Ingresos -->
             <div class="table-actions">
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('ingresos', false)" title="Expandir todos los detalles de ingresos"><i class="fas fa-expand"></i> Expandir Todo</button>
                 <button class="button-secondary button-sm" onclick="toggleAllRubroDetails('ingresos', true)" title="Colapsar todos los detalles de ingresos"><i class="fas fa-compress"></i> Colapsar Todo</button>
            </div>

            <div class="table-container">
                 <table id="ingresos-detail-table" class="collapsible-table">
                      <thead>
                         <tr>
                            <th>Rubro / Detalle</th>
                             <!-- Meses y Total Anual generados por JS -->
                         </tr>
                       </thead>
                      <tbody><!-- Contenido generado por JS --></tbody>
                      <tfoot><!-- Contenido generado por JS --></tfoot>
                 </table>
            </div>

            <div class="chart-container">
                 <h3>Evolutivo Expensa Mensual ($/UF)</h3> <!-- MODIFICADO -->
                 <canvas id="evolutivoCuotaChart"></canvas>
                 <div class="chart-no-data" style="display: none;">No hay datos suficientes para graficar.</div>
            </div>

            <div style="display: flex; gap: 25px; flex-wrap: wrap; margin-top: 35px;">
                <div class="chart-container" style="flex: 1; min-width: 320px;">
                    <h3>Participación Gastos (%)</h3>
                    <canvas id="participacionGastosChart"></canvas>
                    <div class="chart-no-data" style="display: none;">No hay datos de gastos<br>para mostrar el gráfico.</div>
                </div>
                <div class="chart-container" style="flex: 1; min-width: 320px;">
                    <h3>Participación Ingresos (%)</h3>
                    <canvas id="participacionIngresosChart"></canvas>
                    <div class="chart-no-data" style="display: none;">No hay datos de ingresos<br>para mostrar el gráfico.</div>
                </div>
            </div>
        </div>

        <!-- ==================== UPLOAD ==================== -->
        <div id="upload" class="tab-content">
            <h2><i class="fas fa-upload"></i> Cargar Datos Reales / Base</h2>
            <div class="form-group input-group">
                <label for="exercise-year">Año del Ejercicio:</label>
                <input type="number" id="exercise-year" min="2020" max="2099" value="2024" style="width: 120px;">
                <button onclick="createNewExercise()" class="button-success"><i class="fas fa-calendar-plus"></i> Crear/Seleccionar Año</button>
             </div>
            <p>Sube tu archivo Excel con las hojas <strong>"Gastos"</strong> e <strong>"Ingresos"</strong>. Los rubros nuevos se añadirán automáticamente a la sección de Configuración.</p>
            <p><strong>Importante:</strong>
                <ul style="margin-left: 20px; margin-bottom: 15px;">
                    <li>Las celdas con **números** en la hoja "Gastos" marcarán ese mes/detalle como '<strong style="color: var(--accent-color)">REAL</strong>' (fondo verde claro en detalle). Las celdas vacías o con texto se considerarán '<strong style="color: var(--warning-color)">ESTIMADO</strong>'.</li>
                    <li>Los rubros de Ingreso llamados "<strong id="cuota-rubro-name-info">Expensas Ordinarias</strong>" y "<strong>Expensas Extraordinarias</strong>" tendrán sus valores base multiplicados por la cantidad de UF (definida en Configuración) al calcular el *total* de ingresos en el Resumen General. La columna "Expensa Real ($/UF)" en el resumen muestra el valor del rubro "<strong id="cuota-rubro-name-info2">Expensas Ordinarias</strong>" <strong style="color: var(--primary-color)">dividido por la cantidad de UF</strong>.</li>
                </ul>
            </p>
            <div id="file-upload-area" onclick="document.getElementById('excel-file-input').click()">
                 <p><i class="fas fa-file-excel"></i><br>Arrastra tu archivo Excel aquí (.xlsx, .xls) o haz clic para seleccionar</p>
                 <input type="file" id="excel-file-input" accept=".xlsx, .xls" style="display: none;" onchange="handleFileUpload(this.files)">
                 <button type="button" class="button-primary" onclick="event.stopPropagation(); document.getElementById('excel-file-input').click()" style="pointer-events: auto;"><i class="fas fa-folder-open"></i> Seleccionar Archivo</button>
                 <button type="button" onclick="event.stopPropagation(); loadSampleData()" style="margin-left: 10px; pointer-events: auto;" class="button-secondary"><i class="fas fa-database"></i> Cargar Datos Ejemplo</button>
            </div>
            <div id="file-upload-feedback"></div>
            <a href="#" onclick="event.preventDefault(); downloadTemplate();" title="Descargar archivo Excel con estructura de ejemplo"><i class="fas fa-download"></i> Descargar Plantilla Ejemplo</a>
        </div>

        <!-- ==================== RESERVE FUND ==================== -->
        <div id="reserve" class="tab-content">
             <h2><i class="fas fa-piggy-bank"></i> Configurar Fondo de Reserva - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
             <div class="form-group">
                 <label>Método de Cálculo del Fondo:</label>
                 <div class="input-group">
                     <input type="radio" id="reserve-type-percent" name="reserve-type" value="percent" checked onchange="updateReserveUI()">
                     <label for="reserve-type-percent">Porcentaje (%) sobre Gastos Mensuales</label>
                     <input type="radio" id="reserve-type-fixed" name="reserve-type" value="fixed" onchange="updateReserveUI()">
                     <label for="reserve-type-fixed">Valor Fijo Mensual ($)</label>
                 </div>
             </div>
             <div id="reserve-fund-panel">
                 <!-- Inputs generados por JS -->
             </div>
             <button onclick="saveReserveFund()" style="margin-top: 25px; width: 100%; padding: 15px;" class="button-success button-lg" title="Guardar los valores mensuales y el tipo de cálculo del fondo">
                 <i class="fas fa-save"></i> GUARDAR FONDO DE RESERVA Y RECALCULAR
            </button>
        </div>

        <!-- ==================== SETTINGS ==================== -->
        <div id="settings" class="tab-content">
             <h2><i class="fas fa-cog"></i> Configuración General y de Cálculo</h2>

             <div class="config-section">
                 <h4><i class="fas fa-building"></i> Ajustes Generales del Barrio</h4>
                 <div class="form-group">
                     <label for="cantidad-unidades">Cantidad Total de Unidades Funcionales (UF):</label>
                     <input type="number" id="cantidad-unidades" min="1" value="100" style="width: 180px;" title="Número total de UF para calcular cuotas base">
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-list-alt"></i> Gestión de Rubros (Categorías)</h4>
                 <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                     <div style="flex: 1; min-width: 320px;">
                         <h5><i class="fas fa-arrow-down" style="color:var(--danger-color)"></i> Rubros de GASTOS</h5>
                         <div class="form-group input-group">
                             <input type="text" id="new-gasto-rubro-name" placeholder="Nombre nuevo rubro de gasto" style="flex-grow: 1;">
                             <button onclick="addRubro('gastos')" class="button-sm button-success" title="Añadir este nuevo rubro a la lista de gastos"><i class="fas fa-plus"></i> Añadir</button>
                         </div>
                         <ul id="gasto-rubro-list" class="management-list"></ul>
                     </div>
                     <div style="flex: 1; min-width: 320px;">
                          <h5><i class="fas fa-arrow-up" style="color:var(--success-color)"></i> Rubros de INGRESOS</h5>
                          <div class="form-group input-group">
                              <input type="text" id="new-ingreso-rubro-name" placeholder="Nombre nuevo rubro de ingreso" style="flex-grow: 1;">
                              <button onclick="addRubro('ingresos')" class="button-sm button-success" title="Añadir este nuevo rubro a la lista de ingresos"><i class="fas fa-plus"></i> Añadir</button>
                          </div>
                          <ul id="ingreso-rubro-list" class="management-list"></ul>
                     </div>
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-percentage"></i> Gestión de Coeficientes de Ajuste (para Gastos Estimados)</h4>
                 <p class="text-muted" style="font-size: 0.9em;">Define tipos de coeficientes (ej. Inflación, Aumento Gremial) y asigna uno a cada rubro de Gasto. Al usar "Calcular Estimados" en el Dashboard, el sistema proyectará los meses sin datos '<strong style="color: var(--accent-color)">REAL</strong>' (marcados en amarillo) multiplicando el último valor '<strong style="color: var(--accent-color)">REAL</strong>' por el coeficiente acumulado correspondiente a cada mes futuro.</p>
                 <div style="display: flex; gap: 30px; flex-wrap: wrap;">
                     <div style="flex: 1; min-width: 280px;">
                         <h5>Tipos de Coeficientes Disponibles</h5>
                         <div class="form-group input-group">
                             <input type="text" id="new-coefficient-type-name" placeholder="Nuevo tipo (ej: Aumento Sindicato)" style="flex-grow: 1;">
                             <button onclick="addCoefficientType()" class="button-sm button-success" title="Añadir este nuevo tipo de coeficiente a la lista"><i class="fas fa-plus"></i> Añadir Tipo</button>
                         </div>
                         <ul id="coefficient-type-list" class="management-list"></ul>
                     </div>
                     <div id="coefficient-editor" style="flex: 2; min-width: 450px;">
                          <h5><i class="fas fa-edit"></i> Editar Valores Mensuales para: <span id="editing-coefficient-name" style="color: var(--primary-color); font-weight: bold;"></span></h5>
                           <!-- MODIFICACIÓN FIX: Reemplazar tabla por grid similar a IPC -->
                          <div id="coefficient-values-editor">
                              <p class="text-muted">Selecciona un tipo de coeficiente (que no sea "Sin Coeficiente" o "IPC") de la lista de la izquierda para editar sus valores porcentuales (%) mes a mes.</p>
                          </div>
                         <!-- END MODIFICACIÓN FIX -->
                     </div>
                 </div>
             </div>

             <div class="config-section">
                 <h4><i class="fas fa-chart-line"></i> Índices IPC Mensuales de Referencia (%)</h4>
                 <p class="text-muted">Introduce el porcentaje (%) de IPC estimado o real para cada mes. Se usa únicamente para calcular la columna "Cuota IPC ($/UF)" como referencia en el Dashboard y está disponible como tipo de coeficiente ("IPC"). Sus valores son gestionados en esta sección y se reflejan en la lista de tipos de coeficientes.</p> <!-- MODIFICACIÓN FIX: Clarify IPC usage -->
                 <div id="ipc-inputs" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 20px;">
                     <!-- Inputs generados por JS -->
                 </div>
             </div>

             <button onclick="saveSettings()" style="margin-top: 20px; width: 100%; padding: 15px;" class="button-success button-lg" title="Guardar todos los cambios realizados en esta pestaña (UF, Rubros, Coeficientes, IPC) y recalcular el escenario actual">
                 <i class="fas fa-save"></i> GUARDAR TODA LA CONFIGURACIÓN Y RECALCULAR
             </button>
        </div>

        <!-- ==================== REPORTS ==================== -->
        <div id="reports" class="tab-content">
             <h2><i class="fas fa-download"></i> Descargar Reportes - <span class="current-year"></span> (<span class="current-scenario">Base</span>)</h2>
             <p>Genera y descarga los datos del ejercicio y escenario actual en formato Excel, incluyendo detalles y resumen.</p>
             <button onclick="exportToExcel()" class="button-success" title="Descargar un archivo .xlsx con el detalle y resumen del escenario actual"><i class="fas fa-file-excel"></i> Descargar Reporte Completo (.xlsx)</button>

             <h3 style="margin-top: 35px;">Exportar Gráficos Individuales</h3>
             <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                 <button onclick="exportChart('evolutivoCuotaChart', 'evolutivo_expensa.png')" class="button-secondary" title="Descargar el gráfico de evolución de expensas como imagen PNG"><i class="fas fa-chart-line"></i> Gráfico Evolutivo (PNG)</button> <!-- MODIFICADO -->
                 <button onclick="exportChart('participacionGastosChart', 'participacion_gastos.png')" class="button-secondary" title="Descargar el gráfico de torta de gastos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Gastos (PNG)</button>
                 <button onclick="exportChart('participacionIngresosChart', 'participacion_ingresos.png')" class="button-secondary" title="Descargar el gráfico de torta de ingresos como imagen PNG"><i class="fas fa-chart-pie"></i> Gráfico Ingresos (PNG)</button>
             </div>
        </div>
    </div> <!-- /container -->

    <footer>
        <div class="container">
            &copy; <span id="footer-year"></span> Proyección Expensas El Centauro. v2.9 (Rubros Fix)
        </div>
    </footer>
    <div id="snackbar">Mensaje</div>

    <!-- ==================== SCRIPT PRINCIPAL ==================== -->
    <script>
        // --- Constantes y Estado Global ---
        const MONTHS = ["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"];
        const FULL_MONTHS = ["Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio","Agosto","Septiembre","Octubre","Noviembre","Diciembre"];
        const GASTOS_SHEET_NAME = "Gastos";
        const INGRESOS_SHEET_NAME = "Ingresos";
        const STORAGE_KEY = 'expensasAppCentauroState_v2.9_RubrosFix'; // Nueva version por corrección
        const CUOTA_RUBRO_NAME = "Expensas Ordinarias";
        const EXTRA_CUOTA_RUBRO_NAME = "Expensas Extraordinarias";
        const SPECIAL_INGRESO_RUBROS = [CUOTA_RUBRO_NAME, EXTRA_CUOTA_RUBRO_NAME];

        let appState = getDefaultAppState();

        let evolutivoCuotaChart_instance = null;
        let participacionGastosChart_instance = null;
        let participacionIngresosChart_instance = null;


        // --- Inicialización ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log(`DOM Cargado. Inicializando App ${STORAGE_KEY}...`);
            loadState();
            initTheme();
            validateAndSetActiveScenario();

            const cuotaInfoSpan = document.getElementById('cuota-rubro-name-info');
            if (cuotaInfoSpan) cuotaInfoSpan.textContent = CUOTA_RUBRO_NAME;
            const cuotaInfoSpan2 = document.getElementById('cuota-rubro-name-info2');
            if (cuotaInfoSpan2) cuotaInfoSpan2.textContent = CUOTA_RUBRO_NAME;

            initUI();
            addEventListeners();
            updateUI();
            console.log(`App ${STORAGE_KEY} Inicializada.`);
        });

        // --- Validación y Selección de Escenario Activo ---
        function validateAndSetActiveScenario() {
            console.log("Iniciando validación de escenario activo...");
            let activeKeyIsValid = false;
            let fallbackNeeded = true;

            if (appState.activeScenarioKey && appState.scenarios && appState.scenarios[appState.activeScenarioKey]) {
                 const scenario = appState.scenarios[appState.activeScenarioKey];
                 const activeYear = parseInt(appState.activeScenarioKey.split('_')[0]);
                 if (!isNaN(activeYear) && scenario.year === activeYear) {
                    console.log(`Valid active scenario key found: ${appState.activeScenarioKey}`);
                   appState.currentYear = activeYear;
                   activeKeyIsValid = true;
                   fallbackNeeded = false;
                 } else {
                   console.warn(`Active scenario key "${appState.activeScenarioKey}" invalid: key year (${activeYear}) != stored year (${scenario?.year}) or scenario data corrupted.`);
                   appState.activeScenarioKey = null;
                 }
            } else if (appState.activeScenarioKey !== null) {
                 console.warn(`Active scenario key "${appState.activeScenarioKey}" is missing in scenarios object.`);
                 appState.activeScenarioKey = null;
            } else {
                console.log("No active scenario key was set.");
            }

            if (!activeKeyIsValid) {
                console.log(`Clave activa inválida o ausente. Buscando alternativa o creando base...`);
                const defaultYear = new Date().getFullYear();
                const defaultYearBaseKey = `${defaultYear}_Base`;
                const scenariosForCurrentYear = Object.keys(appState.scenarios || {}).filter(k => appState.scenarios[k]?.year === appState.currentYear); // Corrected to use scenario.year
                 const scenariosForDefaultYear = Object.keys(appState.scenarios || {}).filter(k => appState.scenarios[k]?.year === defaultYear); // Corrected

                let fallbackKey = null;

                 if (appState.scenarios?.[`${appState.currentYear}_Base`]) {
                     fallbackKey = `${appState.currentYear}_Base`;
                 }
                 else if (scenariosForCurrentYear.length > 0) {
                    fallbackKey = scenariosForCurrentYear.sort((a,b) => (appState.scenarios[a]?.scenarioName || '').localeCompare(appState.scenarios[b]?.scenarioName || ''))[0];
                 }
                 else if (appState.scenarios?.[defaultYearBaseKey]) {
                    fallbackKey = defaultYearBaseKey;
                 }
                 else if (scenariosForDefaultYear.length > 0) {
                     fallbackKey = scenariosForDefaultYear.sort((a,b) => (appState.scenarios[a]?.scenarioName || '').localeCompare(appState.scenarios[b]?.scenarioName || ''))[0];
                 }
                else {
                    const allScenarioKeys = Object.keys(appState.scenarios || {}).sort((a,b) => a.localeCompare(b));
                    if (allScenarioKeys.length > 0 && appState.scenarios[allScenarioKeys[0]]) {
                         fallbackKey = allScenarioKeys[0];
                    }
                 }

                if (fallbackKey && appState.scenarios?.[fallbackKey]) {
                    console.log(`Cambiando a escenario de fallback: ${fallbackKey}`);
                    appState.activeScenarioKey = fallbackKey;
                     appState.currentYear = appState.scenarios[fallbackKey].year || parseInt(fallbackKey.split('_')[0]) || defaultYear;
                    fallbackNeeded = false;
                }
            }

            if (fallbackNeeded) {
                console.log("No se encontraron escenarios válidos. Creando escenario Base para el año actual.");
                const defaultYear = new Date().getFullYear();
                appState.currentYear = defaultYear;
                initScenarioData(appState.currentYear, 'Base');
                appState.activeScenarioKey = `${appState.currentYear}_Base`;
                 console.log(`Escenario "${appState.activeScenarioKey}" creado.`);
            }

             const currentScenario = getCurrentScenarioData();
             if (currentScenario) {
                 console.log(`Escenario activo final: ${appState.activeScenarioKey}. Año: ${appState.currentYear}`);
                initializeScenarioDataForRubros(currentScenario);
                 ensureDefaultCoefficientTypes();
             } else {
                 console.error("validateAndSetActiveScenario: Algo falló críticamente. No se pudo establecer un escenario activo válido.");
             }

             saveState();
             console.log("Validación de escenario activo completada.");
        }

        function ensureDefaultCoefficientTypes() {
              const defaultTypes = getDefaultAppState().settings.coefficientTypes;
             appState.settings.coefficientTypes = appState.settings.coefficientTypes || {};

             for (const key in defaultTypes) {
                 if (!appState.settings.coefficientTypes[key]) {
                     console.log(`Adding missing default coefficient type: ${key}`);
                     appState.settings.coefficientTypes[key] = JSON.parse(JSON.stringify(defaultTypes[key]));
                 } else {
                      appState.settings.coefficientTypes[key].isDefault = defaultTypes[key].isDefault ?? false;
                     if (key === 'IPC') {
                          const manualIPC = appState.settings.ipcManual;
                          if (!Array.isArray(manualIPC) || manualIPC.length !== 12) {
                               console.warn("ipcManual array invalid during default coef type sync. Resetting.");
                               appState.settings.ipcManual = Array(12).fill(0);
                          }
                           appState.settings.coefficientTypes[key].values = [...appState.settings.ipcManual.map(v => parseFloat(v||0))];
                           console.log(`Synced IPC coefficient values with ipcManual array.`);
                      } else if (key === 'None') {
                         appState.settings.coefficientTypes[key].values = Array(12).fill(1);
                      } else if (Array.isArray(appState.settings.coefficientTypes[key].values) && appState.settings.coefficientTypes[key].values.length === 12) {
                           appState.settings.coefficientTypes[key].values = appState.settings.coefficientTypes[key].values.map(val => {
                                const numVal = parseFloat(val);
                                return (!isNaN(numVal) && numVal >= -100) ? numVal : 0;
                           });
                      } else {
                          console.warn(`Coefficient type "${key}" has invalid values array structure.`);
                          appState.settings.coefficientTypes[key].values = Array(12).fill(0);
                      }
                 }
             }
         }

        // --- Gestión de Datos del Escenario ---
        function getCurrentScenarioData() {
             if (appState.activeScenarioKey && appState.scenarios && appState.scenarios[appState.activeScenarioKey] && appState.scenarios[appState.activeScenarioKey].year !== undefined) {
                 return appState.scenarios[appState.activeScenarioKey];
             }
             console.warn("getCurrentScenarioData: No valid active scenario found in current state. Attempting validation.");
             validateAndSetActiveScenario();
             return appState.scenarios?.[appState.activeScenarioKey] || null;
        }

        function initScenarioData(year, scenarioName = 'Base') {
             if (typeof year !== 'number' || year < 2000 || year > 2099) {
                  console.error(`initScenarioData: Año inválido "${year}". Usando año actual como fallback.`);
                  year = new Date().getFullYear();
             }
             const key = `${year}_${scenarioName.replace(/\s+/g, '_').replace(/[^\w-]/g, '')}`;

             if (appState.scenarios[key]) {
                 console.warn(`initScenarioData: Escenario "${key}" ya existe. No se inicializa de nuevo.`);
                return appState.scenarios[key];
             }

            console.log(`Inicializando nuevo escenario: ${key}`);
             const defaultScenarioTemplate = getDefaultAppState().BaseScenarioStructureTemplate;
             appState.scenarios[key] = JSON.parse(JSON.stringify(defaultScenarioTemplate));
            appState.scenarios[key].year = year;
            appState.scenarios[key].scenarioName = scenarioName;
            initializeScenarioDataForRubros(appState.scenarios[key]);
             return appState.scenarios[key];
        }

        function initializeScenarioDataForRubros(scenarioData) {
             if (!scenarioData || typeof scenarioData !== 'object' || scenarioData.year === undefined) {
                console.error("initializeScenarioDataForRubros llamado con datos de escenario inválidos.");
                return;
             }
            console.log(`Initializing structures for scenario ${scenarioData.year}_${scenarioData.scenarioName} based on global settings...`);

             scenarioData.rubroOrder = scenarioData.rubroOrder ?? { gastos: [], ingresos: [] };
             scenarioData.rubroOrder.gastos = Array.isArray(scenarioData.rubroOrder.gastos) ? scenarioData.rubroOrder.gastos : [];
             scenarioData.rubroOrder.ingresos = Array.isArray(scenarioData.rubroOrder.ingresos) ? scenarioData.rubroOrder.ingresos : [];

             scenarioData.data = scenarioData.data ?? { gastos: {}, ingresos: {} };
             scenarioData.data.gastos = scenarioData.data.gastos ?? {};
             scenarioData.data.ingresos = scenarioData.data.ingresos ?? {};

             scenarioData.monthStatus = scenarioData.monthStatus ?? { gastos: {}, ingresos: {} };
             scenarioData.monthStatus.gastos = scenarioData.monthStatus.gastos ?? {};

             scenarioData.reserveFund = scenarioData.reserveFund ?? { type: 'percent', values: Array(12).fill(5) };
              scenarioData.reserveFund.values = (Array.isArray(scenarioData.reserveFund.values) && scenarioData.reserveFund.values.length === 12)
                                                 ? scenarioData.reserveFund.values.map(v => parseFloat(v||0)) : Array(12).fill(scenarioData.reserveFund.type === 'fixed' ? 0 : 5);

             scenarioData.calculated = scenarioData.calculated ?? {};
             const defaultCalcTemplate = getDefaultAppState().BaseScenarioStructureTemplate?.calculated || {};

             for(const key in defaultCalcTemplate) {
                 if(scenarioData.calculated[key] === undefined || scenarioData.calculated[key] === null) {
                     if (Array.isArray(defaultCalcTemplate[key])) {
                          scenarioData.calculated[key] = Array(12).fill(0);
                     } else if (typeof defaultCalcTemplate[key] === 'object' && defaultCalcTemplate[key] !== null) {
                         scenarioData.calculated[key] = {};
                     } else {
                         scenarioData.calculated[key] = defaultCalcTemplate[key];
                     }
                 } else if (Array.isArray(scenarioData.calculated[key]) && scenarioData.calculated[key].length !== 12) {
                      console.warn(`Calculated array "${key}" in scenario ${scenarioData.scenarioName} has wrong length (${scenarioData.calculated[key].length}). Resetting to 12 zeros.`);
                     scenarioData.calculated[key] = Array(12).fill(0);
                 }
             }

              scenarioData.calculated.annualTotals = scenarioData.calculated.annualTotals ?? {};
              scenarioData.calculated.annualTotals.gastos = scenarioData.calculated.annualTotals.gastos ?? { __TOTAL__: 0 };
              scenarioData.calculated.annualTotals.ingresos = scenarioData.calculated.annualTotals.ingresos ?? { __TOTAL__: 0 };

             if (!Array.isArray(scenarioData.calculated.ipcManual) || scenarioData.calculated.ipcManual.length !== 12) {
                console.warn(`Scenario ${scenarioData.year}-${scenarioData.scenarioName} IPC snapshot invalid. Copying from settings.`);
                scenarioData.calculated.ipcManual = [...(appState.settings?.ipcManual || Array(12).fill(0))];
             } else {
                  scenarioData.calculated.ipcManual = scenarioData.calculated.ipcManual.map(v => parseFloat(v||0));
             }

             ['gastos', 'ingresos'].forEach(type => {
                 const globalRubros = (appState.settings && appState.settings.rubros && Array.isArray(appState.settings.rubros[type]))
                                    ? appState.settings.rubros[type]
                                    : [];
                 globalRubros.forEach(rubro => {
                      if (!scenarioData.data[type][rubro]) {
                           scenarioData.data[type][rubro] = { detailOrder: [], detailsData: {} };
                      }
                       scenarioData.data[type][rubro].detailOrder = Array.isArray(scenarioData.data[type][rubro].detailOrder) ? scenarioData.data[type][rubro].detailOrder : [];
                       scenarioData.data[type][rubro].detailsData = typeof scenarioData.data[type][rubro].detailsData === 'object' && scenarioData.data[type][rubro].detailsData !== null ? scenarioData.data[type][rubro].detailsData : {};

                       if (type === 'gastos') {
                           scenarioData.monthStatus[type][rubro] = typeof scenarioData.monthStatus[type][rubro] === 'object' && scenarioData.monthStatus[type][rubro] !== null ? scenarioData.monthStatus[type][rubro] : {};
                       }

                      if (type === 'gastos') {
                           scenarioData.calculated.gastoAjustado[rubro] = scenarioData.calculated.gastoAjustado[rubro] ?? {};
                           scenarioData.calculated.totalGastoRubroMes[rubro] = Array.isArray(scenarioData.calculated.totalGastoRubroMes[rubro]) && scenarioData.calculated.totalGastoRubroMes[rubro].length === 12 ? scenarioData.calculated.totalGastoRubroMes[rubro].map(v=>parseFloat(v||0)) : Array(12).fill(0);
                       } else {
                           scenarioData.calculated.ingresoAjustado[rubro] = scenarioData.calculated.ingresoAjustado[rubro] ?? {};
                           scenarioData.calculated.totalIngresoRubroMes[rubro] = Array.isArray(scenarioData.calculated.totalIngresoRubroMes[rubro]) && scenarioData.calculated.totalIngresoRubroMes[rubro].length === 12 ? scenarioData.calculated.totalIngresoRubroMes[rubro].map(v=>parseFloat(v||0)) : Array(12).fill(0);
                       }
                       scenarioData.calculated.annualTotals[type][rubro] = scenarioData.calculated.annualTotals[type][rubro] ?? 0;

                     const detailOrder = scenarioData.data[type][rubro].detailOrder;
                     Object.keys(scenarioData.data[type][rubro].detailsData).forEach(detail => {
                           if (!detailOrder.includes(detail)) {
                               console.warn(`Detail "${detail}" for ${type}/${rubro} found in data but not order. Adding to order.`);
                               detailOrder.push(detail);
                           }
                          if(scenarioData.data[type][rubro].detailsData[detail] === undefined || !Array.isArray(scenarioData.data[type][rubro].detailsData[detail]) || scenarioData.data[type][rubro].detailsData[detail].length !== 12) {
                               console.warn(`Detail data for ${type}/${rubro}/${detail} invalid length/type. Resetting to 12 zeros.`);
                               scenarioData.data[type][rubro].detailsData[detail] = Array(12).fill(0);
                           } else {
                                scenarioData.data[type][rubro].detailsData[detail] = scenarioData.data[type][rubro].detailsData[detail].map(v => parseFloat(v||0));
                           }
                           if (type === 'gastos') {
                                if (scenarioData.monthStatus[type][rubro]?.[detail] === undefined || !Array.isArray(scenarioData.monthStatus[type][rubro][detail]) || scenarioData.monthStatus[type][rubro][detail].length !== 12) {
                                    console.warn(`Detail status for ${type}/${rubro}/${detail} invalid length/type. Resetting to 12 'Estimado'.`);
                                   scenarioData.monthStatus[type][rubro][detail] = Array(12).fill('Estimado');
                               } else {
                                   scenarioData.monthStatus[type][rubro][detail] = scenarioData.monthStatus[type][rubro][detail].map(s => String(s || 'Estimado'));
                                }
                           }
                           if (type === 'gastos') scenarioData.calculated.gastoAjustado[rubro][detail] = Array.isArray(scenarioData.calculated.gastoAjustado[rubro][detail]) && scenarioData.calculated.gastoAjustado[rubro][detail].length === 12 ? scenarioData.calculated.gastoAjustado[rubro][detail].map(v=>parseFloat(v||0)) : Array(12).fill(0);
                           else scenarioData.calculated.ingresoAjustado[rubro][detail] = Array.isArray(scenarioData.calculated.ingresoAjustado[rubro][detail]) && scenarioData.calculated.ingresoAjustado[rubro][detail].length === 12 ? scenarioData.calculated.ingresoAjustado[rubro][detail].map(v=>parseFloat(v||0)) : Array(12).fill(0);
                       });
                 });

                ['gastos', 'ingresos'].forEach(type => {
                   const globalRubrosForType = (appState.settings && appState.settings.rubros && Array.isArray(appState.settings.rubros[type]))
                                        ? appState.settings.rubros[type]
                                        : [];
                   const scenarioRubrosInData = Object.keys(scenarioData.data[type] || {});
                   scenarioRubrosInData.forEach(rubro => {
                       if (!globalRubrosForType.includes(rubro)) {
                            console.warn(`Rubro "${rubro}" exists in scenario.data[${type}] but not in global settings. Removing from scenario data.`);
                           delete scenarioData.data[type][rubro];
                           if (type === 'gastos') delete scenarioData.monthStatus[type][rubro];
                       }
                   });
                     scenarioData.rubroOrder[type] = scenarioData.rubroOrder[type].filter(rubro => globalRubrosForType.includes(rubro));
                });
             });
            console.log(`Initialization for ${scenarioData.scenarioName} completed.`);
         }


        // --- Lógica de Negocio y Cálculos ---
        function calculateAll(scenarioData) {
             console.log(`Recalculando TODO para: ${scenarioData?.year} - ${scenarioData?.scenarioName}`);
             if (!scenarioData) { console.error("CalculateAll: No scenario data provided."); renderEmptyState(); return; }

             initializeScenarioDataForRubros(scenarioData);

             const { data, monthStatus, reserveFund } = scenarioData;
             const { settings } = appState;
             const { rubroConfig, coefficientTypes, cantidadUnidades } = settings;
             const calculated = scenarioData.calculated;

             if (Array.isArray(settings.ipcManual) && settings.ipcManual.length === 12) {
                 calculated.ipcManual = [...settings.ipcManual.map(v=>parseFloat(v||0))];
             } else {
                  console.warn("Global settings.ipcManual array invalid. Using 12 zeros for scenario snapshot.");
                 calculated.ipcManual = Array(12).fill(0);
             }

             calculated.gastoAjustado = {}; calculated.totalGastoRubroMes = {}; calculated.totalGastoProyectadoMes = Array(12).fill(0);
             calculated.ingresoAjustado = {}; calculated.totalIngresoRubroMes = {}; calculated.totalIngresoProyectadoMes = Array(12).fill(0);
             calculated.fondoReservaMes = Array(12).fill(0);
             calculated.cuotaSobreGastosMes = Array(12).fill(0);
             calculated.cuotaIpcMes = Array(12).fill(0);
             calculated.cuotaRealBaseMes = Array(12).fill(0);

             calculated.annualTotals = calculated.annualTotals ?? { gastos: {}, ingresos: {}, fondoReserva: 0, cuotaSobreGastos: 0, cuotaIpc: 0, cuotaRealBase: 0 };
             calculated.annualTotals.gastos = calculated.annualTotals.gastos ?? { __TOTAL__: 0 };
             calculated.annualTotals.ingresos = calculated.annualTotals.ingresos ?? { __TOTAL__: 0 };
             calculated.annualTotals.gastos.__TOTAL__ = 0;
             calculated.annualTotals.ingresos.__TOTAL__ = 0;
             calculated.annualTotals.fondoReserva = 0;
             calculated.annualTotals.cuotaSobreGastos = 0;
             calculated.annualTotals.cuotaIpc = 0;
             calculated.annualTotals.cuotaRealBase = 0;

            const globalGastosRubros = (settings && settings.rubros && Array.isArray(settings.rubros.gastos)) ? settings.rubros.gastos : [];
            const gastoRubros = (Array.isArray(scenarioData.rubroOrder?.gastos) && scenarioData.rubroOrder.gastos.length > 0)
                                ? scenarioData.rubroOrder.gastos.filter(rubro => globalGastosRubros.includes(rubro) && data.gastos?.[rubro]?.detailsData)
                                : (globalGastosRubros || []).filter(rubro => data.gastos?.[rubro]?.detailsData);

             gastoRubros.forEach(rubro => {
                 if (!data.gastos || !data.gastos[rubro] || !data.gastos[rubro].detailsData) {
                    console.warn(`Data missing for gasto rubro "${rubro}" filtered for calculation.`);
                    return;
                 }
                 calculated.gastoAjustado[rubro] = {};
                 calculated.totalGastoRubroMes[rubro] = Array(12).fill(0);
                 calculated.annualTotals.gastos[rubro] = 0;

                 const detailOrder = (Array.isArray(data.gastos[rubro].detailOrder) && data.gastos[rubro].detailOrder.length > 0)
                                     ? data.gastos[rubro].detailOrder.filter(detail => data.gastos[rubro].detailsData?.[detail] !== undefined && Array.isArray(data.gastos[rubro].detailsData[detail]) && data.gastos[rubro].detailsData[detail].length === 12)
                                     : Object.keys(data.gastos[rubro].detailsData || {}).filter(detail => Array.isArray(data.gastos[rubro].detailsData[detail]) && data.gastos[rubro].detailsData[detail].length === 12);

                  if (detailOrder.length === 0) {
                     console.warn(`No valid detail data found for gasto rubro "${rubro}". Skipping calculation for this rubro.`);
                     return;
                  }

                 const rubroCoefConfig = rubroConfig[rubro] || {};
                 const coefTypeKey = rubroCoefConfig.coefficientType || 'None';
                 const currentCoefficientType = coefficientTypes[coefTypeKey];
                 const rawCoefValues = currentCoefficientType?.values;
                 const monthlyMultipliers = Array(12).fill(1);

                 if (currentCoefficientType && coefTypeKey !== 'None' && Array.isArray(rawCoefValues) && rawCoefValues.length === 12) {
                      for(let i = 0; i < 12; i++) {
                           const percentage = parseFloat(rawCoefValues[i] || 0);
                            if (!isNaN(percentage)) {
                               monthlyMultipliers[i] = 1 + percentage / 100;
                            } else {
                                console.warn(`Coef type "${coefTypeKey}", month ${MONTHS[i]}: Invalid percentage value "${rawCoefValues[i]}". Using 0% (multiplier 1).`);
                            }
                      }
                 }

                 detailOrder.forEach(detail => {
                     const sourceDetailValues = Array.isArray(data.gastos[rubro]?.detailsData?.[detail]) && data.gastos[rubro].detailsData[detail].length === 12
                                       ? data.gastos[rubro].detailsData[detail].map(v => parseFloat(v || 0))
                                       : Array(12).fill(0);
                      const adjustedDetailValues = sourceDetailValues.map((value, index) => value * (monthlyMultipliers[index] ?? 1));
                     calculated.gastoAjustado[rubro][detail] = adjustedDetailValues;
                     for (let i = 0; i < 12; i++) {
                          calculated.totalGastoRubroMes[rubro][i] += (adjustedDetailValues[i] || 0);
                     }
                 });
                 for (let i = 0; i < 12; i++) {
                     const monthTotalRubro = calculated.totalGastoRubroMes[rubro]?.[i] || 0;
                     calculated.totalGastoProyectadoMes[i] += monthTotalRubro;
                 }
                 calculated.annualTotals.gastos[rubro] = calculated.totalGastoRubroMes[rubro].reduce((a, b) => a + (b || 0), 0);
             });
             calculated.annualTotals.gastos.__TOTAL__ = calculated.totalGastoProyectadoMes.reduce((a, b) => a + (b || 0), 0);

             const unidades = parseInt(cantidadUnidades) || 1;
             const unidadesForCuotaReal = unidades > 0 ? unidades : 1;

            const globalIngresosRubros = (settings && settings.rubros && Array.isArray(settings.rubros.ingresos)) ? settings.rubros.ingresos : [];
             const ingresoRubros = (Array.isArray(scenarioData.rubroOrder?.ingresos) && scenarioData.rubroOrder.ingresos.length > 0)
                                   ? scenarioData.rubroOrder.ingresos.filter(rubro => globalIngresosRubros.includes(rubro) && data.ingresos?.[rubro]?.detailsData)
                                   : (globalIngresosRubros || []).filter(rubro => data.ingresos?.[rubro]?.detailsData);

             ingresoRubros.forEach(rubro => {
                  if (!data.ingresos || !data.ingresos[rubro] || !data.ingresos[rubro].detailsData) return;
                 calculated.ingresoAjustado[rubro] = {};
                 calculated.totalIngresoRubroMes[rubro] = Array(12).fill(0);
                 calculated.annualTotals.ingresos[rubro] = 0;

                 const detailOrder = (Array.isArray(data.ingresos[rubro].detailOrder) && data.ingresos[rubro].detailOrder.length > 0)
                                     ? data.ingresos[rubro].detailOrder.filter(detail => data.ingresos[rubro].detailsData?.[detail] !== undefined && Array.isArray(data.ingresos[rubro].detailsData[detail]) && data.ingresos[rubro].detailsData[detail].length === 12)
                                     : Object.keys(data.ingresos[rubro].detailsData || {}).filter(detail => Array.isArray(data.ingresos[rubro].detailsData[detail]) && data.ingresos[rubro].detailsData[detail].length === 12);

                  if (detailOrder.length === 0) {
                     console.warn(`No valid detail data found for ingreso rubro "${rubro}". Skipping calculation for this rubro.`);
                     return;
                  }

                 detailOrder.forEach(detail => {
                      const baseValues = Array.isArray(data.ingresos[rubro]?.detailsData?.[detail]) && data.ingresos[rubro].detailsData[detail].length === 12
                                         ? data.ingresos[rubro].detailsData[detail].map(v => parseFloat(v || 0))
                                         : Array(12).fill(0);
                     calculated.ingresoAjustado[rubro][detail] = baseValues;
                     for (let i = 0; i < 12; i++) {
                          const detailFinalMonthly = SPECIAL_INGRESO_RUBROS.includes(rubro)
                                                    ? baseValues[i] * unidades
                                                    : baseValues[i];
                           calculated.totalIngresoRubroMes[rubro][i] += (detailFinalMonthly || 0);
                     }
                 });
                 for (let i = 0; i < 12; i++) {
                     const monthTotalRubroFinal = calculated.totalIngresoRubroMes[rubro]?.[i] || 0;
                     calculated.totalIngresoProyectadoMes[i] += monthTotalRubroFinal;
                 }
                 calculated.annualTotals.ingresos[rubro] = calculated.totalIngresoRubroMes[rubro].reduce((a, b) => a + (b || 0), 0);
             });
             calculated.annualTotals.ingresos.__TOTAL__ = calculated.totalIngresoProyectadoMes.reduce((a, b) => a + (b || 0), 0);

             if (unidadesForCuotaReal <= 0) {
                 calculated.cuotaRealBaseMes = Array(12).fill(0);
             } else if (calculated.totalIngresoRubroMes?.[CUOTA_RUBRO_NAME]) {
                 calculated.cuotaRealBaseMes = Array(12);
                 for (let i = 0; i < 12; i++) {
                     const totalRubroMes = calculated.totalIngresoRubroMes[CUOTA_RUBRO_NAME][i] || 0;
                     calculated.cuotaRealBaseMes[i] = totalRubroMes / unidadesForCuotaReal;
                 }
             } else {
                 calculated.cuotaRealBaseMes = Array(12).fill(0);
             }
             calculated.annualTotals.cuotaRealBase = calculated.cuotaRealBaseMes.reduce((a,b)=>a+(b||0),0);

             const reserveFundData = scenarioData.reserveFund ?? getDefaultAppState().BaseScenarioStructureTemplate.reserveFund;
             const reserveValues = (Array.isArray(reserveFundData.values) && reserveFundData.values.length === 12)
                                     ? reserveFundData.values.map(v => parseFloat(v || 0)) : Array(12).fill(reserveFundData.type === 'fixed' ? 0 : 5);
             const reserveType = reserveFundData.type === 'fixed' ? 'fixed' : 'percent';

             calculated.fondoReservaMes = Array(12);
             for (let i = 0; i < 12; i++) {
                 const reserveValueInput = reserveValues[i];
                 calculated.fondoReservaMes[i] = reserveType === 'percent'
                     ? (calculated.totalGastoProyectadoMes[i] || 0) * (reserveValueInput / 100)
                     : (reserveValueInput || 0);
             }
             calculated.annualTotals.fondoReserva = calculated.fondoReservaMes.reduce((a, b) => a + (b || 0), 0);

             calculated.cuotaSobreGastosMes = Array(12);
             for (let i = 0; i < 12; i++) {
                 const totalGastoYFondo = (calculated.totalGastoProyectadoMes[i] || 0) + (calculated.fondoReservaMes[i] || 0);
                 calculated.cuotaSobreGastosMes[i] = unidadesForCuotaReal > 0 ? totalGastoYFondo / unidadesForCuotaReal : 0;
             }
             calculated.annualTotals.cuotaSobreGastos = calculated.cuotaSobreGastosMes.reduce((a,b)=>a+(b||0),0);

             const ipcSnapshot = (Array.isArray(calculated.ipcManual) && calculated.ipcManual.length === 12)
                                  ? calculated.ipcManual.map(v => parseFloat(v || 0)) : Array(12).fill(0);
             calculated.cuotaIpcMes = Array(12).fill(0);
             const baseEneroCuotaReal = (calculated.cuotaRealBaseMes?.[0] || 0);
             if (baseEneroCuotaReal > 0) {
                  let accumulatedMultiplier = 1;
                  for (let i = 0; i < 12; i++) {
                     const monthlyIPC = ipcSnapshot[i];
                      const monthlyIPCMultiplier = (!isNaN(monthlyIPC) && monthlyIPC >= 0) ? (1 + monthlyIPC / 100) : 1;
                     accumulatedMultiplier *= monthlyIPCMultiplier;
                     calculated.cuotaIpcMes[i] = baseEneroCuotaReal * accumulatedMultiplier;
                  }
             }
             calculated.annualTotals.cuotaIpc = calculated.cuotaIpcMes.reduce((a, b) => a + (b || 0), 0);

             console.log("Recálculo Finalizado.", calculated);
             saveState();
             updateUI();
             showSnackbar("Cálculos actualizados correctamente.", false, 'success');
        }


        // --- Recalcular Estimados (ACUMULATIVO) ---
        function recalculateEstimates() {
            const scenarioData = getCurrentScenarioData();
            if (!scenarioData) { showSnackbar("No hay escenario activo para calcular estimados.", true, 'error'); return; }
            console.log(`Calculando estimados (Acumulativo) para: ${scenarioData.scenarioName}`);

            const { data, monthStatus, rubroOrder } = scenarioData;
            const { settings } = appState;
            const { rubroConfig, coefficientTypes } = settings; // Removed 'rubros' here, use 'settings.rubros'
            let changesMade = false;
            let projectedCellCount = 0;

            const globalGastosRubros = (settings && settings.rubros && Array.isArray(settings.rubros.gastos)) ? settings.rubros.gastos : [];
            const gastoRubrosToProcess = (Array.isArray(rubroOrder?.gastos) && rubroOrder.gastos.length > 0)
                                          ? rubroOrder.gastos.filter(rubro => globalGastosRubros.includes(rubro) && data.gastos?.[rubro]?.detailsData)
                                          : (globalGastosRubros || []).filter(rubro => data.gastos?.[rubro]?.detailsData);

            if (gastoRubrosToProcess.length === 0) {
                 showSnackbar("No hay rubros de gasto definidos o con datos cargados para proyectar.", false, 'info', 3000);
                 return;
            }
             let totalDetailsProcessed = 0;

            gastoRubrosToProcess.forEach(rubro => {
                if (!data.gastos || !data.gastos[rubro] || !data.gastos[rubro].detailsData) return;

                const detailOrder = (Array.isArray(data.gastos[rubro].detailOrder) && data.gastos[rubro].detailOrder.length > 0)
                                     ? data.gastos[rubro].detailOrder.filter(detail => data.gastos[rubro].detailsData?.[detail] !== undefined && Array.isArray(data.gastos[rubro].detailsData[detail]) && data.gastos[rubro].detailsData[detail].length === 12)
                                     : Object.keys(data.gastos[rubro].detailsData || {}).filter(detail => Array.isArray(data.gastos[rubro].detailsData[detail]) && data.gastos[rubro].detailsData[detail].length === 12);

                 if (detailOrder.length === 0) return;
                totalDetailsProcessed += detailOrder.length;

                const rubroCoefConfig = rubroConfig[rubro] || {};
                const coefTypeKey = rubroCoefConfig.coefficientType || 'None';
                const currentCoefficientType = coefficientTypes[coefTypeKey];
                 const rawCoefValues = currentCoefficientType?.values;
                 const monthlyMultipliers = Array(12).fill(1);

                 if (currentCoefficientType && coefTypeKey !== 'None' && Array.isArray(rawCoefValues) && rawCoefValues.length === 12) {
                      for(let i = 0; i < 12; i++) {
                           const percentage = parseFloat(rawCoefValues[i] || 0);
                            if (!isNaN(percentage)) {
                               monthlyMultipliers[i] = 1 + percentage / 100;
                            } else {
                                console.warn(`Coef type "${coefTypeKey}", month ${MONTHS[i]}: Invalid percentage value "${rawCoefValues[i]}" during estimate calculation. Using 0% (multiplier 1).`);
                            }
                      }
                 }

                detailOrder.forEach(detail => {
                    const currentStatuses = (monthStatus.gastos && monthStatus.gastos[rubro]?.[detail] && Array.isArray(monthStatus.gastos[rubro][detail]) && monthStatus.gastos[rubro][detail].length === 12)
                                            ? monthStatus.gastos[rubro][detail]
                                            : Array(12).fill('Estimado');
                    const currentDataValues = Array.isArray(data.gastos[rubro]?.detailsData?.[detail]) && data.gastos[rubro].detailsData[detail].length === 12
                                            ? data.gastos[rubro].detailsData[detail].map(v => parseFloat(v || 0))
                                            : Array(12).fill(0);

                    let lastRealMonthIndex = -1;
                    for (let i = 11; i >= 0; i--) {
                        if (currentStatuses[i] === 'REAL') {
                            lastRealMonthIndex = i;
                            break;
                        }
                    }

                    if (lastRealMonthIndex === -1 || lastRealMonthIndex === 11) {
                         return;
                    }

                    let previousMonthValue = currentDataValues[lastRealMonthIndex];

                    for (let j = lastRealMonthIndex + 1; j < 12; j++) {
                        if (currentStatuses[j] === 'Estimado') {
                             const multiplier = monthlyMultipliers[j];
                            const projectedValue = previousMonthValue * multiplier;
                            data.gastos[rubro].detailsData[detail][j] = projectedValue;
                            changesMade = true;
                            projectedCellCount++;
                            previousMonthValue = projectedValue;
                        } else if (currentStatuses[j] === 'REAL') {
                            previousMonthValue = currentDataValues[j];
                        }
                    }
                });
            });

             if (totalDetailsProcessed === 0) {
                  showSnackbar("No se encontraron detalles de gastos con datos válidos para proyectar.", false, 'info', 3000);
                  return;
             }

            if (changesMade) {
                console.log(`Se proyectaron ${projectedCellCount} celdas. Recalculando todo...`);
                showSnackbar(`Estimados recalculados (${projectedCellCount} celdas afectadas). Actualizando dashboard...`, false, 'info', 4000);
                calculateAll(scenarioData);
            } else {
                console.log("No se necesitaron cambios en los estimados.");
                showSnackbar("No se encontraron meses estimados que requieran recalcular (no hay meses estimados después del último REAL, o no se configuró coeficiente).", false, 'info', 4000);
            }
        }

        // --- Actualización de la Interfaz (UI) ---
        function initUI() {
             const yearInput = document.getElementById('exercise-year');
             const footerYear = document.getElementById('footer-year');
             if (yearInput) yearInput.setAttribute('value', appState.currentYear);
             if (footerYear) footerYear.textContent = new Date().getFullYear();
             updateScenarioSelector();
             updateCurrentYearAndScenarioInUI();
        }

        function updateUI() {
             console.log("Actualizando UI completa...");
             const scenarioData = getCurrentScenarioData();

             if (!scenarioData) {
                 console.warn("updateUI: No hay escenario activo o datos válidos disponibles. Renderizando estado vacío.");
                 renderEmptyState();
                 updateCurrentYearAndScenarioInUI();
                 updateScenarioSelector();
                 return;
             }

             updateCurrentYearAndScenarioInUI();
             updateScenarioSelector();
             updateDashboardTables(scenarioData);
             updateCharts(scenarioData);
             updateReserveFundPanel(scenarioData);
             updateSettingsPanel();
             updateReportsPanel();
             console.log("UI Actualizada.");
        }

        function updateDashboardTables(scenarioData) {
            const summaryTable = document.getElementById('dashboard-summary');
            if (!summaryTable) { console.warn("Dashboard summary table not found."); return; }

            const tbody = summaryTable.querySelector('tbody');
            const tfoot = summaryTable.querySelector('tfoot');
            if (!tbody || !tfoot) { console.error("Dashboard summary table body/foot not found."); return; }

            tbody.innerHTML = '';
            tfoot.innerHTML = '';

            if (!scenarioData || !scenarioData.calculated) {
                const headerCount = summaryTable.querySelector('thead tr')?.cells.length || 7;
                tbody.innerHTML = `<tr><td colspan="${headerCount}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos calculados para mostrar.</td></tr>`;
                return;
            }

            const calculated = scenarioData.calculated;
            const annualTotals = calculated.annualTotals || {};

            let annualGasto = 0;
            let annualFondo = 0;
            let annualCuotaSGs = 0;
            let annualCuotaIPC = 0;
            let annualExpensaReal = 0;

            for (let i = 0; i < 12; i++) {
                const row = tbody.insertRow();
                row.insertCell().textContent = MONTHS[i];

                const gastoMes = calculated.totalGastoProyectadoMes?.[i] || 0;
                row.insertCell().textContent = formatCurrency(gastoMes);
                annualGasto += gastoMes;

                const fondoMes = calculated.fondoReservaMes?.[i] || 0;
                row.insertCell().textContent = formatCurrency(fondoMes);
                annualFondo += fondoMes;

                const cuotaSGsMes = calculated.cuotaSobreGastosMes?.[i] || 0;
                row.insertCell().textContent = formatCurrency(cuotaSGsMes);
                annualCuotaSGs += cuotaSGsMes;

                const ipcMes = calculated.ipcManual?.[i] || 0;
                row.insertCell().textContent = `${ipcMes.toFixed(1)}%`;

                const cuotaIPCMes = calculated.cuotaIpcMes?.[i] || 0;
                row.insertCell().textContent = formatCurrency(cuotaIPCMes);
                annualCuotaIPC += cuotaIPCMes;

                const expensaRealMes = calculated.cuotaRealBaseMes?.[i] || 0;
                row.insertCell().textContent = formatCurrency(expensaRealMes);
                annualExpensaReal += expensaRealMes;
            }

            const footerRow = tfoot.insertRow();
            footerRow.insertCell().textContent = "TOTAL ANUAL";
            footerRow.cells[0].style.fontWeight = "bold";

            footerRow.insertCell().textContent = formatCurrency(annualTotals.gastos?.__TOTAL__ || annualGasto);
            footerRow.cells[1].style.fontWeight = "bold";
            footerRow.insertCell().textContent = formatCurrency(annualTotals.fondoReserva || annualFondo);
            footerRow.cells[2].style.fontWeight = "bold";
            footerRow.insertCell().textContent = formatCurrency(annualTotals.cuotaSobreGastos || annualCuotaSGs);
            footerRow.cells[3].style.fontWeight = "bold";
            footerRow.insertCell().textContent = "-";
            footerRow.insertCell().textContent = formatCurrency(annualTotals.cuotaIpc || annualCuotaIPC);
            footerRow.cells[5].style.fontWeight = "bold";
            footerRow.insertCell().textContent = formatCurrency(annualTotals.cuotaRealBase || annualExpensaReal);
            footerRow.cells[6].style.fontWeight = "bold";

            updateCollapsibleTable('gastos', scenarioData);
            updateCollapsibleTable('ingresos', scenarioData);
        }


        function updateScenarioSelector() {
            const selector = document.getElementById('scenario-selector');
            if (!selector) {
                console.warn("Scenario selector element not found.");
                return;
            }

            const previousValue = selector.value;
            selector.innerHTML = '';

            const scenariosForCurrentYear = Object.keys(appState.scenarios || {})
                .filter(key => appState.scenarios[key]?.year === appState.currentYear)
                .sort((a, b) => {
                    const nameA = appState.scenarios[a]?.scenarioName || a;
                    const nameB = appState.scenarios[b]?.scenarioName || b;
                    return nameA.localeCompare(nameB);
                });

            if (scenariosForCurrentYear.length === 0) {
                const option = document.createElement('option');
                option.value = "";
                option.textContent = "No hay escenarios para este año";
                option.disabled = true;
                selector.appendChild(option);
                selector.value = "";
            } else {
                scenariosForCurrentYear.forEach(key => {
                    const scenario = appState.scenarios[key];
                    if (scenario) {
                        const option = document.createElement('option');
                        option.value = key;
                        option.textContent = `${scenario.scenarioName} (${scenario.year})`;
                        selector.appendChild(option);
                    }
                });

                if (appState.activeScenarioKey && scenariosForCurrentYear.includes(appState.activeScenarioKey)) {
                    selector.value = appState.activeScenarioKey;
                } else if (scenariosForCurrentYear.includes(previousValue)) {
                     selector.value = previousValue;
                } else if (scenariosForCurrentYear.length > 0) {
                    const baseKeyForYear = `${appState.currentYear}_Base`;
                    if (scenariosForCurrentYear.includes(baseKeyForYear)) {
                        selector.value = baseKeyForYear;
                    } else {
                        selector.value = scenariosForCurrentYear[0];
                    }
                }
            }
            if (appState.activeScenarioKey && selector.value !== appState.activeScenarioKey && scenariosForCurrentYear.includes(appState.activeScenarioKey)) {
                console.warn(`Selector value (${selector.value}) differs from activeScenarioKey (${appState.activeScenarioKey}). Forcing selector to active key.`);
                selector.value = appState.activeScenarioKey;
            }
            console.log("Scenario selector updated. Current selection:", selector.value);
        }

        function updateCurrentYearAndScenarioInUI() {
            const dashboardYearSpan = document.getElementById('dashboard-year');
            const dashboardScenarioSpan = document.getElementById('dashboard-scenario');
            const currentYearSpans = document.querySelectorAll('.current-year');
            const currentScenarioSpans = document.querySelectorAll('.current-scenario');

            const scenarioData = getCurrentScenarioData();
            const yearToDisplay = scenarioData ? scenarioData.year : (appState.currentYear || new Date().getFullYear());
            const scenarioNameToDisplay = scenarioData ? scenarioData.scenarioName : "Ninguno";

            if (dashboardYearSpan) dashboardYearSpan.textContent = yearToDisplay;
            if (dashboardScenarioSpan) dashboardScenarioSpan.textContent = scenarioNameToDisplay;
            currentYearSpans.forEach(span => span.textContent = yearToDisplay);
            currentScenarioSpans.forEach(span => span.textContent = scenarioNameToDisplay);
        }

        function renderEmptyState() {
            console.log("Renderizando estado vacío...");
            const summaryTable = document.getElementById('dashboard-summary');
            const summaryTbody = summaryTable?.querySelector('tbody');
            const summaryTfoot = summaryTable?.querySelector('tfoot');
             const summaryHeaderCount = document.getElementById('dashboard-summary')?.querySelector('thead tr')?.cells.length || 7;

            if(summaryTbody) summaryTbody.innerHTML = `<tr><td colspan="${summaryHeaderCount}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos calculados para este escenario. Carga datos o usa los de ejemplo.</td></tr>`;
            if(summaryTfoot) summaryTfoot.innerHTML = '';

            const gastosTable = document.getElementById('gastos-detail-table');
             const gastosHeaderCount = document.getElementById('gastos-detail-table')?.querySelector('thead tr')?.cells.length || 16;
            const gastosTbody = gastosTable?.querySelector('tbody');
            const gastosTfoot = gastosTable?.querySelector('tfoot');
            if(gastosTbody) gastosTbody.innerHTML = `<tr><td colspan="${gastosHeaderCount}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos de gastos.</td></tr>`;
            if(gastosTfoot) gastosTfoot.innerHTML = '';

            const ingresosTable = document.getElementById('ingresos-detail-table');
             const ingresosHeaderCount = document.getElementById('ingresos-detail-table')?.querySelector('thead tr')?.cells.length || 15;
            const ingresosTbody = ingresosTable?.querySelector('tbody');
            const ingresosTfoot = ingresosTable?.querySelector('tfoot');
            if(ingresosTbody) ingresosTbody.innerHTML = `<tr><td colspan="${ingresosHeaderCount}" class="text-muted" style="text-align: center; padding: 20px;">No hay datos de ingresos.</td></tr>`;
            if(ingresosTfoot) ingresosTfoot.innerHTML = '';

            destroyChart('evolutivoCuotaChart'); displayChartNoData('evolutivoCuotaChart', true);
            destroyChart('participacionGastosChart'); displayChartNoData('participacionGastosChart', true);
            destroyChart('participacionIngresosChart'); displayChartNoData('participacionIngresosChart', true);

            const coefEditor = document.getElementById('coefficient-values-editor');
            const coefNameSpan = document.getElementById('editing-coefficient-name');
            if(coefEditor) coefEditor.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente (que no sea "Sin Coeficiente" o "IPC") de la lista de la izquierda para editar sus valores porcentuales (%) mes a mes.</p>';
            if(coefNameSpan) coefNameSpan.textContent = 'Ninguno';
            if(appState.uiState) appState.uiState.editingCoefficientType = null;

             const reservePercentRadio = document.getElementById('reserve-type-percent');
             const reserveFixedRadio = document.getElementById('reserve-type-fixed');
             if (reservePercentRadio && reserveFixedRadio) {
                  const defaultReserveData = getDefaultAppState().BaseScenarioStructureTemplate.reserveFund;
                 reservePercentRadio.checked = (appState.scenarios?.[appState.activeScenarioKey]?.reserveFund?.type ?? defaultReserveData.type) === 'percent';
                 reserveFixedRadio.checked = !(reservePercentRadio.checked);
                 updateReserveUI();
             }
             updateSettingsPanel();
             updateReportsPanel();
        }

        function updateCollapsibleTable(type, scenarioData) {
             const tableId = `${type}-detail-table`;
             const table = document.getElementById(tableId);
             if (!table) { console.warn(`Tabla ${tableId} no encontrada.`); return; }

             const thead = table.querySelector('thead');
             const tbody = table.querySelector('tbody');
             const tfoot = table.querySelector('tfoot');
             if (!thead || !tbody || !tfoot) { console.error(`Elementos internos de ${tableId} no encontrados.`); return;}

             tbody.innerHTML = '';
             tfoot.innerHTML = '';

             const expectedHeaderCount = (type === 'gastos' ? 2 : 1) + MONTHS.length + 1;

             if (!scenarioData || !scenarioData.data || !scenarioData.calculated || !appState.settings ) { // Removed !appState.settings.rubros for now, handled by globalRubrosForType
                 const actualHeaderCount = thead.querySelector('tr')?.cells.length || expectedHeaderCount;
                 tbody.innerHTML = `<tr><td colspan="${actualHeaderCount}" class="text-muted" style="text-align: center; padding: 20px;">Faltan datos o configuración para mostrar el detalle.</td></tr>`;
                 ensureCollapsibleTableHeaderFooterCells(thead, tfoot, type);
                 return;
             }
             const globalRubrosForType = (appState.settings && appState.settings.rubros && Array.isArray(appState.settings.rubros[type]))
                                        ? appState.settings.rubros[type]
                                        : [];
             if (globalRubrosForType.length === 0 && (type === 'gastos' || type === 'ingresos') ) { // Check if any rubros are defined
                console.warn(`No hay rubros globales definidos para el tipo "${type}" en appState.settings.rubros.`);
             }


             const { data, calculated, monthStatus, rubroOrder } = scenarioData;
             const config = appState.settings.rubroConfig || {};
             const calculatedDetailData = calculated[type === 'gastos' ? 'gastoAjustado' : 'ingresoAjustado'] || {};
             const totalRubroSet = calculated[type === 'gastos' ? 'totalGastoRubroMes' : 'totalIngresoRubroMes'] || {};
             const annualRubroTotals = calculated.annualTotals?.[type] || { __TOTAL__: 0 };


             const rubrosToDisplay = (Array.isArray(rubroOrder[type]) && rubroOrder[type].length > 0)
                                    ? rubroOrder[type].filter(rubro => globalRubrosForType.includes(rubro) && data[type]?.[rubro]?.detailsData)
                                    : (globalRubrosForType || []).filter(rubro => data[type]?.[rubro]?.detailsData);

             ensureCollapsibleTableHeaderFooterCells(thead, tfoot, type);
             const actualHeaderCount = thead.querySelector('tr')?.cells.length || expectedHeaderCount;

             if (rubrosToDisplay.length === 0) {
                 tbody.innerHTML = `<tr><td colspan="${actualHeaderCount}" class="text-muted" style="text-align: center; padding: 20px;">No hay rubros definidos o cargados con datos para ${type} en este escenario.</td></tr>`;
                 return;
             }

             rubrosToDisplay.forEach(rubro => {
                 if (!data[type]?.[rubro] || !data[type][rubro].detailsData || !calculatedDetailData[rubro] || !totalRubroSet[rubro] || annualRubroTotals[rubro] === undefined) {
                      console.warn(`Inconsistent data/calculated structures for rubro "${rubro}" in ${type}. Skipping render.`);
                     return;
                 }
                 const rubroData = data[type][rubro];
                  const detailsToDisplay = (Array.isArray(rubroData.detailOrder) && rubroData.detailOrder.length > 0)
                                            ? rubroData.detailOrder.filter(detail =>
                                                 rubroData.detailsData?.[detail] !== undefined && Array.isArray(rubroData.detailsData[detail]) && rubroData.detailsData[detail].length === 12 &&
                                                calculatedDetailData[rubro]?.[detail] !== undefined && Array.isArray(calculatedDetailData[rubro][detail]) && calculatedDetailData[rubro][detail].length === 12
                                              )
                                            : Object.keys(rubroData.detailsData || {}).filter(detail =>
                                                 Array.isArray(rubroData.detailsData[detail]) && rubroData.detailsData[detail].length === 12 &&
                                                calculatedDetailData[rubro]?.[detail] !== undefined && Array.isArray(calculatedDetailData[rubro][detail]) && calculatedDetailData[rubro][detail].length === 12
                                              );
                 if (detailsToDisplay.length === 0) return;
                 const isCollapsed = appState.settings.rubroConfig?.[rubro]?.detailsCollapsed ?? true;
                 const totalRow = tbody.insertRow();
                 totalRow.classList.add('rubro-total-row');
                 if (isCollapsed) totalRow.classList.add('collapsed');
                 totalRow.dataset.rubro = rubro;
                 totalRow.dataset.type = type;
                 totalRow.insertCell().textContent = rubro;
                 if(type === 'gastos') totalRow.insertCell().textContent = '';
                 const monthlyTotals = totalRubroSet[rubro] || Array(12).fill(0);
                 monthlyTotals.forEach(val => {
                     const cell = totalRow.insertCell();
                     cell.textContent = formatCurrency(val);
                     cell.classList.add('number-cell');
                 });
                 const cellAnnualTotal = totalRow.insertCell();
                 cellAnnualTotal.textContent = formatCurrency(annualRubroTotals[rubro] || 0);
                 cellAnnualTotal.classList.add('number-cell');

                 const coefName = type === 'gastos' ? (appState.settings.coefficientTypes[config[rubro]?.coefficientType || 'None']?.name || 'N/A') : '';
                 detailsToDisplay.forEach(detail => {
                     const detailValues = calculatedDetailData[rubro][detail];
                     const detailStatuses = (type === 'gastos' && monthStatus.gastos?.[rubro]?.[detail] && Array.isArray(monthStatus.gastos[rubro][detail]) && monthStatus.gastos[rubro][detail].length === 12)
                                            ? monthStatus.gastos[rubro][detail].map(s => String(s || 'Estimado'))
                                            : Array(12).fill('Estimado');
                     let annualDetailTotal = 0;
                     const detailRow = tbody.insertRow();
                     detailRow.classList.add('detail-row');
                     detailRow.dataset.rubro = rubro;
                     detailRow.dataset.type = type;
                      if (isCollapsed) detailRow.classList.add('hidden');
                     const cellDetailName = detailRow.insertCell();
                     cellDetailName.textContent = detail;
                     cellDetailName.classList.add('text-muted');
                      if (type === 'gastos') {
                         const cellCoef = detailRow.insertCell();
                         cellCoef.textContent = coefName;
                         cellCoef.classList.add('text-muted');
                     }
                     detailValues.forEach((val, index) => {
                         const cell = detailRow.insertCell();
                         cell.textContent = formatCurrency(val || 0);
                         cell.classList.add('number-cell');
                          if (type === 'gastos') {
                             const monthStatusValue = detailStatuses[index] || 'Estimado';
                             cell.classList.add(monthStatusValue === 'REAL' ? 'real-month-cell' : 'estimated-month-cell');
                          }
                         annualDetailTotal += (val || 0);
                     });
                     const cellAnnualDetail = detailRow.insertCell();
                     cellAnnualDetail.textContent = formatCurrency(annualDetailTotal);
                     cellAnnualDetail.classList.add('number-cell');
                 });
             });
             addCollapsibleListeners();
              ensureCollapsibleTableHeaderFooterCells(thead, tfoot, type);
        }

        function ensureCollapsibleTableHeaderFooterCells(thead, tfoot, type) {
             let theadRow = thead.querySelector('tr');
             if (!theadRow) theadRow = thead.insertRow();
             const expectedHeaderCellCount = (type === 'gastos' ? 2 : 1) + MONTHS.length + 1;
             let headersNeedRebuild = false;
             if (theadRow.cells.length !== expectedHeaderCellCount) headersNeedRebuild = true;
              if (!headersNeedRebuild) {
                   const firstCellText = theadRow.cells[0]?.textContent;
                   const coefCellText = type === 'gastos' ? theadRow.cells[1]?.textContent : null;
                   const totalCellText = theadRow.cells[theadRow.cells.length - 1]?.textContent;
                  if (firstCellText !== "Rubro / Detalle") headersNeedRebuild = true;
                  if (type === 'gastos' && coefCellText !== "Coef. Aplicado") headersNeedRebuild = true;
                  if (totalCellText !== "Total Anual") headersNeedRebuild = true;
              }
             if (headersNeedRebuild) {
                 console.warn(`Table head for ${type} is inconsistent or has wrong cell count (${theadRow.cells.length} vs ${expectedHeaderCellCount}). Rebuilding header.`);
                 theadRow.innerHTML = '';
                 theadRow.insertCell().textContent = "Rubro / Detalle";
                 if (type === 'gastos') {
                       const thCoef = document.createElement('th');
                       thCoef.textContent = "Coef. Aplicado";
                       theadRow.appendChild(thCoef);
                   }
                 MONTHS.forEach(month => {
                     const th = document.createElement('th');
                     th.textContent = month;
                     th.classList.add('number-cell');
                     theadRow.appendChild(th);
                 });
                 const thTotal = document.createElement('th');
                 thTotal.textContent = "Total Anual";
                 thTotal.classList.add('number-cell');
                 theadRow.appendChild(thTotal);
             }
            let tfootRow = tfoot.querySelector('tr');
             if (!tfootRow || tfootRow.cells.length === 0) {
                  tfootRow = tfoot.insertRow();
             }
             const footerDescriptionCols = type === 'gastos' ? 2 : 1;
             const expectedFooterCellCount = footerDescriptionCols + 12 + 1;
             let footerLabelCell = tfootRow.cells[0];
             if (!footerLabelCell) footerLabelCell = tfootRow.insertCell(0);
             footerLabelCell.colSpan = footerDescriptionCols;
             footerLabelCell.textContent = `TOTAL GENERAL ${type.toUpperCase()}`;
              footerLabelCell.classList.remove('number-cell');
              while (tfootRow.cells.length < expectedFooterCellCount) {
                  tfootRow.insertCell();
              }
              while (tfootRow.cells.length > expectedFooterCellCount) {
                   tfootRow.deleteCell(tfootRow.cells.length - 1);
              }
              for(let i = footerDescriptionCols; i < expectedFooterCellCount; i++) {
                  if(tfootRow.cells[i]) tfootRow.cells[i].classList.add('number-cell');
              }
              tfootRow.classList.add('font-weight-bold');
        }

        function updateCharts(scenarioData) {
             if (!scenarioData || !scenarioData.calculated || !scenarioData.calculated.annualTotals) {
                 console.warn("Datos insuficientes para actualizar gráficos.");
                 destroyChart('evolutivoCuotaChart'); displayChartNoData('evolutivoCuotaChart', true);
                 destroyChart('participacionGastosChart'); displayChartNoData('participacionGastosChart', true);
                 destroyChart('participacionIngresosChart'); displayChartNoData('participacionIngresosChart', true);
                 return;
             }

             const { calculated } = scenarioData;
             const labels = MONTHS;

             // Get current theme colors dynamically
             const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary-color').trim();
             const accentColor = getComputedStyle(document.documentElement).getPropertyValue('--accent-color').trim();
             const secondaryColor = getComputedStyle(document.documentElement).getPropertyValue('--secondary-color').trim();
             const cardBg = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim();
             const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();


             const chartColors = [ // Define a consistent palette
                primaryColor, accentColor, '#ffc107', '#6f42c1', '#fd7e14', '#17a2b8',
                '#dc3545', secondaryColor, '#20c997', '#0d6efd', '#198754', '#adb5bd' // More colors
             ];

             // --- Evolutivo Expensa Chart (Line) ---
             destroyChart('evolutivoCuotaChart');
             const ctxEvolutivo = document.getElementById('evolutivoCuotaChart')?.getContext('2d');
             const evolutivoHasData = (calculated.cuotaSobreGastosMes?.some(v => v !== 0) ?? false) || (calculated.cuotaRealBaseMes?.some(v => v !== 0) ?? false);
             displayChartNoData('evolutivoCuotaChart', !evolutivoHasData);

             if (ctxEvolutivo && evolutivoHasData) {
                window.evolutivoCuotaChart_instance = new Chart(ctxEvolutivo, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [
                            { // Cuota s/Gtos (Calculated from expenses + reserve)
                                label: 'Cuota s/Gtos ($)',
                                data: calculated.cuotaSobreGastosMes,
                                borderColor: primaryColor,
                                backgroundColor: hexToRgba(primaryColor, 0.1),
                                tension: 0.2,
                                fill: true,
                                yAxisID: 'yCuota'
                            },
                            { // Expensa Real Base (From Ingresos base data) - MODIFICADO
                                label: 'Expensa Real Base ($)',
                                data: calculated.cuotaRealBaseMes,
                                borderColor: accentColor,
                                backgroundColor: hexToRgba(accentColor, 0.1),
                                tension: 0.2,
                                fill: true,
                                yAxisID: 'yCuota' // Same axis for direct comparison
                            },
                             { // Cuota IPC (Calculated based on Cuota s/Gtos and IPC ref)
                                label: 'Cuota IPC ($)',
                                data: calculated.cuotaIpcMes,
                                borderColor: secondaryColor, // Use secondary color
                                backgroundColor: hexToRgba(secondaryColor, 0.1),
                                tension: 0.2,
                                fill: false, // Don't fill this one to avoid clutter
                                borderDash: [5, 5], // Dashed line for reference value
                                yAxisID: 'yCuota' // Same axis
                            }
                        ]
                    },
                    options: commonChartOptions('yCuota')
                 });
             }


             // --- Participación Gastos Chart (Doughnut) ---
             destroyChart('participacionGastosChart');
             const ctxGastos = document.getElementById('participacionGastosChart')?.getContext('2d');
             // Filter labels based on *global* settings first, then check for > 0 value
             // Filter out zero values before mapping to labels/data
             const activeGastoRubros = (appState.settings.rubros?.gastos || []).filter(rubro =>
                  (calculated.annualTotals?.gastos?.[rubro] || 0) > 0
             );
             const gastoLabels = activeGastoRubros;
             const gastoData = activeGastoRubros.map(rubro => calculated.annualTotals.gastos[rubro]);

             displayChartNoData('participacionGastosChart', gastoData.length === 0);

             if (ctxGastos && gastoData.length > 0) {
                 window.participacionGastosChart_instance = new Chart(ctxGastos, {
                     type: 'doughnut', // Changed to doughnut
                     data: {
                         labels: gastoLabels,
                         datasets: [{
                             data: gastoData,
                             backgroundColor: generateColors(gastoData.length, chartColors, 0.8), // Use helper
                             borderColor: cardBg,
                             borderWidth: 2
                         }]
                     },
                     options: pieChartOptions('Gasto Anual') // Use pie chart options (works for doughnut)
                 });
             }


             // --- Participación Ingresos Chart (Doughnut) ---
             destroyChart('participacionIngresosChart');
             const ctxIngresos = document.getElementById('participacionIngresosChart')?.getContext('2d');
             // Filter labels based on *global* settings first, then check for > 0 value
              // Filter out zero values before mapping to labels/data
             const activeIngresoRubros = (appState.settings.rubros?.ingresos || []).filter(rubro =>
                  (calculated.annualTotals?.ingresos?.[rubro] || 0) > 0
              );
             const ingresoLabels = activeIngresoRubros;
             const ingresoData = activeIngresoRubros.map(rubro => calculated.annualTotals.ingresos[rubro]);

             displayChartNoData('participacionIngresosChart', ingresoData.length === 0);

             if (ctxIngresos && ingresoData.length > 0) {
                 window.participacionIngresosChart_instance = new Chart(ctxIngresos, {
                     type: 'doughnut', // Changed to doughnut
                     data: {
                         labels: ingresoLabels,
                         datasets: [{
                             data: ingresoData,
                             // Use different colors or reverse order from gastos chart
                             backgroundColor: generateColors(ingresoData.length, chartColors.slice().reverse(), 0.8), // Use helper
                             borderColor: cardBg,
                             borderWidth: 2
                         }]
                     },
                     options: pieChartOptions('Ingreso Anual') // Use pie chart options
                 });
             }
         }

         function generateColors(count, palette, alpha = 1) {
            const colors = [];
            for (let i = 0; i < count; i++) {
                colors.push(hexToRgba(palette[i % palette.length], alpha));
            }
            return colors;
         }

        function commonChartOptions(mainYAxisID = 'y', additionalScales = {}) {
            const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
            const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
            return {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    [mainYAxisID]: {
                        beginAtZero: true,
                        ticks: { color: textColor, padding: 10, callback: value => formatCurrency(value).replace(",00", "") },
                        grid: { color: borderColor, drawTicks: false }, // Hide grid ticks
                        border: { color: borderColor } // Axis line color
                    },
                    x: {
                        ticks: { color: textColor, padding: 10 },
                        grid: { display: false }, // Hide vertical grid lines for cleaner look
                        border: { color: borderColor }
                    },
                    ...additionalScales // Include any additional axes passed in
                },
                plugins: {
                    legend: {
                        position: 'bottom',
                        labels: {
                            color: textColor,
                            boxWidth: 15,
                            padding: 20
                        }
                    },
                    tooltip: {
                        backgroundColor: hexToRgba(getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim(), 0.9),
                        titleColor: textColor,
                        bodyColor: textColor,
                        borderColor: getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim(),
                        borderWidth: 1,
                        padding: 10,
                        callbacks: {
                             title: tooltipItems => tooltipItems[0]?.label ? FULL_MONTHS[MONTHS.indexOf(tooltipItems[0].label)] : '',
                             label: context => {
                                 let label = context.dataset.label || '';
                                 if (label) label += ': ';
                                 if (context.parsed.y !== null) label += formatCurrency(context.parsed.y);
                                 return label;
                            }
                        }
                    }
                },
                interaction: { mode: 'index', intersect: false },
            };
         }

        function pieChartOptions(labelPrefix = '') {
             const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
             const cardBg = getComputedStyle(document.documentElement).getPropertyValue('--card-bg').trim();
             const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
             const baseFontSize = parseFloat(getComputedStyle(document.body).fontSize); // Get actual computed font size
             const legendFontSize = Math.round(baseFontSize * 1.2); // Increase by 20%


             return {
                 responsive: true,
                 maintainAspectRatio: false,
                 plugins: {
                     legend: {
                         position: 'right',
                         labels: {
                            color: textColor,
                            boxWidth: 15,
                            padding: 15,
                            font: { // Apply font settings here
                                 size: legendFontSize, // Apply increased size
                            },
                             generateLabels: chart => {
                                const data = chart.data;
                                if (!data.labels.length || !data.datasets.length) return [];
                                const { labels } = data; const dataset = data.datasets[0];
                                const total = dataset.data.reduce((a, b) => a + b, 0);
                                return labels.map((label, i) => {
                                    const value = dataset.data[i];
                                     // --- MODIFICADO: Generate label text without dashed description ---
                                     const percentage = total > 0 ? ((value / total) * 100).toFixed(1) + '%' : '0.0%';
                                     const textLabel = `${label} (${percentage})`; // Format: "Label (Percentage)"

                                    return {
                                        text: textLabel, // Use the custom text label
                                        fillStyle: dataset.backgroundColor[i],
                                        strokeStyle: dataset.borderColor || dataset.backgroundColor[i],
                                        lineWidth: dataset.borderWidth || 0,
                                        // Note: Chart.js automatically handles hiding legend entries for hidden data
                                        hidden: chart.getDataVisibility(i) || value === 0, // Hide if data is zero as well
                                        index: i
                                    };
                                });
                             }
                         }
                     },
                     tooltip: {
                         backgroundColor: hexToRgba(cardBg, 0.9),
                         titleColor: textColor, bodyColor: textColor,
                         borderColor: borderColor, borderWidth: 1, padding: 10,
                         callbacks: {
                            label: context => {
                                 let label = context.label || ''; // context.label is the original label text
                                 if (context.parsed !== null) {
                                     const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                     const percentage = total > 0 ? ((context.parsed / total) * 100).toFixed(1) + '%' : '0.0%';
                                     // Show original label + formatted value and percentage in tooltip
                                     label = `${label}: ${formatCurrency(context.parsed)} (${percentage})`;
                                 }
                                 return label;
                            }
                         }
                     }
                 },
                 cutout: '30%' // Define cutout for Doughnut chart
             };
         }

        function updateReserveFundPanel(scenarioData) {
             const panel = document.getElementById('reserve-fund-panel');
             const percentRadio = document.getElementById('reserve-type-percent');
             const fixedRadio = document.getElementById('reserve-type-fixed');
             if (!panel || !percentRadio || !fixedRadio) {
                console.warn("Reserve fund UI elements not found.");
                return;
             }
             const defaultReserveData = getDefaultAppState().BaseScenarioStructureTemplate.reserveFund;
             const reserveFundData = (scenarioData?.reserveFund && Array.isArray(scenarioData.reserveFund.values) && scenarioData.reserveFund.values.length === 12 && typeof scenarioData.reserveFund.type === 'string')
                                             ? scenarioData.reserveFund
                                             : defaultReserveData;
             const typeFromState = reserveFundData.type === 'fixed' ? 'fixed' : 'percent';
             percentRadio.checked = typeFromState === 'percent';
             fixedRadio.checked = typeFromState === 'fixed';
             const uiUnitLabel = typeFromState === 'percent' ? '%' : '$';
             const uiCurrentStep = typeFromState === 'percent' ? '0.1' : '100';
              const reserveValues = reserveFundData.values.map(v => parseFloat(v || 0));
             const inputs = panel.querySelectorAll('input[type="number"]');
             if (inputs.length === 12) {
                   console.log("Updating existing reserve fund inputs.");
                   inputs.forEach((input, i) => {
                       if (!isNaN(reserveValues[i])) {
                            input.value = reserveValues[i];
                       } else {
                            input.value = typeFromState === 'fixed' ? 0 : 5;
                            console.warn(`Reserve value for month ${i} is NaN. Displaying default.`);
                       }
                       input.step = uiCurrentStep;
                       input.placeholder = uiUnitLabel;
                       input.title = `Valor de fondo de reserva para ${FULL_MONTHS[i]} (${uiUnitLabel})`;
                   });
             } else {
                   console.log("Reserve fund inputs missing or count incorrect. Rebuilding panel.");
                   renderReserveFundInputsInPanel(panel, reserveFundData);
             }
        }

        function renderReserveFundInputsInPanel(panelElement, reserveFundData) {
             panelElement.innerHTML = '';
             const uiUnitLabel = reserveFundData.type === 'percent' ? '%' : '$';
             const uiCurrentStep = reserveFundData.type === 'percent' ? '0.1' : '100';
             const reserveValues = (Array.isArray(reserveFundData.values) && reserveFundData.values.length === 12)
                                     ? reserveFundData.values.map(v => parseFloat(v || 0))
                                     : Array(12).fill(reserveFundData.type === 'percent' ? 5 : 0);
             for (let i = 0; i < 12; i++) {
                 const monthDiv = document.createElement('div');
                 monthDiv.classList.add('form-group');
                 const label = document.createElement('label');
                 label.textContent = FULL_MONTHS[i];
                 label.htmlFor = `reserve-month-${i}`;
                 const input = document.createElement('input');
                 input.type = 'number';
                 input.id = `reserve-month-${i}`;
                 input.dataset.month = i;
                 input.value = reserveValues[i];
                 input.step = uiCurrentStep;
                 input.min = '0';
                 input.placeholder = uiUnitLabel;
                 input.style.textAlign = 'right';
                 input.title = `Valor de fondo de reserva para ${FULL_MONTHS[i]} (${uiUnitLabel})`;
                 monthDiv.appendChild(label);
                 monthDiv.appendChild(input);
                 panelElement.appendChild(monthDiv);
             }
             console.log(`Reserve fund inputs rendered.`);
        }

        function updateSettingsPanel() {
            const ufInput = document.getElementById('cantidad-unidades');
            appState.settings.cantidadUnidades = parseInt(appState.settings.cantidadUnidades) || 100;
             if(appState.settings.cantidadUnidades < 0) appState.settings.cantidadUnidades = 100;
            if (ufInput) ufInput.value = appState.settings.cantidadUnidades;
            updateRubroList('gastos', 'gasto-rubro-list');
            updateRubroList('ingresos', 'ingreso-rubro-list');
            ensureDefaultCoefficientTypes();
            updateCoefficientTypeList();
            const currentEditing = appState.uiState.editingCoefficientType;
            const editingTypeData = appState.settings.coefficientTypes?.[currentEditing];
            const canEditValuesInThisUI = currentEditing !== 'None' && currentEditing !== 'IPC' && editingTypeData;
            if (canEditValuesInThisUI) {
                 renderCoefficientValuesEditor(currentEditing);
             } else {
                 const editorDiv = document.getElementById('coefficient-values-editor');
                 const nameSpan = document.getElementById('editing-coefficient-name');
                 if (editorDiv) editorDiv.innerHTML = '<p class="text-muted">Selecciona un tipo de coeficiente (que no sea "Sin Coeficiente" o "IPC") de la lista de la izquierda para editar sus valores porcentuales (%) mes a mes.</p>';
                 if (nameSpan) nameSpan.textContent = 'Ninguno';
                  appState.uiState.editingCoefficientType = null;
             }
             updateIPCManualInputs();
        }

        // --- Manejo de Eventos ---
        function addEventListeners() {
             const themeToggle = document.getElementById('theme-toggle');
             const scenarioSelector = document.getElementById('scenario-selector');
             const uploadArea = document.getElementById('file-upload-area');

             themeToggle?.addEventListener('click', toggleTheme);
             scenarioSelector?.addEventListener('change', (event) => {
                 const newKey = event.target.value;
                 const newScenario = appState.scenarios?.[newKey];
                 if (newKey && newScenario) {
                     console.log(`Attempting to switch to scenario: ${newKey}`);
                     appState.activeScenarioKey = newKey;
                     appState.currentYear = newScenario.year || parseInt(newKey.split('_')[0]) || new Date().getFullYear();
                     console.log(`Switched scenario to: ${appState.activeScenarioKey} (Year ${appState.currentYear})`);
                     initializeScenarioDataForRubros(newScenario);
                      calculateAll(newScenario);
                 } else if (newKey === "") {
                      console.warn("Scenario selector changed to empty value. Attempting re-validation.");
                       appState.activeScenarioKey = null;
                      validateAndSetActiveScenario();
                      updateUI();
                 } else {
                      console.error(`Attempt to switch to invalid or non-existent scenario key: "${newKey}". Current key: "${appState.activeScenarioKey}".`);
                       showSnackbar(`Error: El escenario seleccionado no es válido o no fue encontrado.`, true, 'error', 5000);
                      if (appState.activeScenarioKey && appState.scenarios?.[appState.activeScenarioKey]) {
                         event.target.value = appState.activeScenarioKey;
                      } else {
                           // selector is not defined here, should be event.target.value = ""
                           event.target.value = "";
                      }
                       updateUI();
                 }
             });

             if (uploadArea) {
                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                     document.body.addEventListener(eventName, preventDefaults, false);
                 });
                ['dragenter', 'dragover'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => uploadArea.style.backgroundColor = 'var(--clickable-row-hover)', false);
                });
                ['dragleave', 'drop'].forEach(eventName => {
                    uploadArea.addEventListener(eventName, () => uploadArea.style.backgroundColor = 'var(--bg-color)', false);
                 });
                 uploadArea.addEventListener('drop', (event) => {
                    const files = event.dataTransfer.files;
                    if (files.length > 0) {
                         console.log(`File(s) dropped: ${files[0].name}`);
                        handleFileUpload(files);
                    }
                 }, false);
                 window.addEventListener('beforeunload', () => {
                     ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                           document.body.removeEventListener(eventName, preventDefaults, false);
                      });
                 });
             }
             addCollapsibleListeners();
        }

        function preventDefaults (e) {
            e.preventDefault();
            e.stopPropagation();
        }

        let collapsibleListenersAdded = false;
        function addCollapsibleListeners() {
             const container = document.querySelector('.container');
             if (!container || collapsibleListenersAdded) return;
             container.addEventListener('click', (event) => {
                 const targetRow = event.target.closest('tr.rubro-total-row');
                 if (targetRow && (targetRow.closest('#gastos-detail-table') || targetRow.closest('#ingresos-detail-table'))) {
                     const rubro = targetRow.dataset.rubro;
                     const type = targetRow.dataset.type;
                     if (rubro && type) {
                         toggleRubroDetails(type, rubro);
                     }
                 }
             });
             collapsibleListenersAdded = true;
             console.log("Listeners delegados para filas colapsables añadidos al contenedor.");
        }

        function toggleRubroDetails(type, rubro) {
              appState.settings.rubroConfig = appState.settings.rubroConfig ?? {};
              appState.settings.rubroConfig[rubro] = appState.settings.rubroConfig[rubro] ?? { detailsCollapsed: true };
              if (appState.settings.rubroConfig[rubro].detailsCollapsed === undefined) {
                   appState.settings.rubroConfig[rubro].detailsCollapsed = true;
              }
             const currentState = appState.settings.rubroConfig[rubro].detailsCollapsed;
             const newState = !currentState;
             appState.settings.rubroConfig[rubro].detailsCollapsed = newState;
             const tableId = `${type}-detail-table`;
             const totalRow = document.querySelector(`#${tableId} tr.rubro-total-row[data-rubro="${rubro}"][data-type="${type}"]`);
             if (!totalRow) {
                 console.warn(`Toggle: Could not find the total row element for type/rubro: ${type}/${rubro}`);
                 saveState();
                 return;
             }
             totalRow.classList.toggle('collapsed', newState);
             let nextSibling = totalRow.nextElementSibling;
             while (nextSibling) {
                 if (nextSibling.classList.contains('detail-row') &&
                     nextSibling.dataset.rubro === rubro && nextSibling.dataset.type === type) {
                     nextSibling.classList.toggle('hidden', newState);
                     nextSibling = nextSibling.nextElementSibling;
                 } else {
                     break;
                 }
             }
             saveState();
        }

         function toggleAllRubroDetails(type, collapse) {
             console.log(`${collapse ? 'Colapsando' : 'Expandiendo'} todos los rubros de ${type}...`);
             const tableId = `${type}-detail-table`;
             const table = document.getElementById(tableId);
             if (!table) { console.warn(`Table ${tableId} not found.`); return; }
             const tbody = table.querySelector('tbody');
             if (!tbody) { console.warn(`Table ${tableId} tbody not found.`); return; }
             const totalRows = tbody.querySelectorAll('tr.rubro-total-row');
             if (totalRows.length === 0) {
                  showSnackbar(`No hay rubros de ${type} con datos visibles para expandir/colapsar.`, false, 'info', 3000);
                  return;
             }
             let changesMade = false;
             totalRows.forEach(totalRow => {
                  const rubro = totalRow.dataset.rubro;
                  const rowType = totalRow.dataset.type;
                 if (!rubro || rowType !== type) return;
                  appState.settings.rubroConfig = appState.settings.rubroConfig ?? {};
                  appState.settings.rubroConfig[rubro] = appState.settings.rubroConfig[rubro] ?? { detailsCollapsed: true };
                 if (appState.settings.rubroConfig[rubro].detailsCollapsed === undefined) {
                      appState.settings.rubroConfig[rubro].detailsCollapsed = true;
                 }
                 const currentState = appState.settings.rubroConfig[rubro].detailsCollapsed;
                 if (currentState !== collapse) {
                      appState.settings.rubroConfig[rubro].detailsCollapsed = collapse;
                      changesMade = true;
                      totalRow.classList.toggle('collapsed', collapse);
                       let nextSibling = totalRow.nextElementSibling;
                       while (nextSibling) {
                           if (nextSibling.classList.contains('detail-row') &&
                               nextSibling.dataset.rubro === rubro && nextSibling.dataset.type === type) {
                               nextSibling.classList.toggle('hidden', collapse);
                               nextSibling = nextSibling.nextElementSibling;
                           } else {
                               break;
                           }
                       }
                 }
             });
             if (changesMade) {
                 saveState();
                 showSnackbar(`${collapse ? 'Todos los detalles colapsados.' : 'Todos los detalles expandidos.'}`, false, 'info', 3000);
             } else {
                  showSnackbar(`Los detalles de ${type} ya están todos ${collapse ? 'colapsados' : 'expandidos'}.`, false, 'info', 3000);
             }
         }

         function handleCoefficientAssignmentChange(event) {
             const select = event.target;
             const rubro = select.dataset.rubro;
             const newCoefType = select.value;
             if (rubro && newCoefType !== undefined && appState.settings.rubroConfig) {
                 appState.settings.rubroConfig[rubro] = appState.settings.rubroConfig[rubro] ?? {};
                 appState.settings.rubroConfig[rubro].coefficientType = newCoefType;
                 console.log(`Coeficiente para rubro "${rubro}" asignado a "${newCoefType}".`);
                 saveState();
                 showSnackbar(`Coeficiente para "${rubro}" asignado. Haz clic en "GUARDAR" para recalcular estimados.`, false, 'info', 3000);
             } else {
                  console.error("Error handling coefficient assignment change.", {rubro, newCoefType, rubroConfigExists: !!appState.settings.rubroConfig});
                 showSnackbar("Error interno al asignar coeficiente.", true, 'error', 6000);
             }
         }

         function handleCoefficientValueChange(event) {
             const input = event.target;
             const monthIndex = parseInt(input.dataset.month);
             const typeKey = input.dataset.typeKey;
             const value = parseFloat(input.value);
              const typeData = appState.settings.coefficientTypes?.[typeKey];
             if (!typeKey || !typeData || isNaN(monthIndex) || monthIndex < 0 || monthIndex > 11) {
                  console.error(`Error handling coefficient value change: Invalid type key "${typeKey}" or month index "${monthIndex}".`);
                 const lastSavedValue = (typeKey && typeData && Array.isArray(typeData.values) && typeData.values.length > monthIndex) ? typeData.values[monthIndex] : 0;
                 input.value = lastSavedValue;
                 showSnackbar("Error interno: Coeficiente o mes inválido.", true, 'error', 6000);
                 return;
             }
             const isNoneType = typeKey === 'None';
             const isValidValue = !isNaN(value) && (isNoneType || value >= -100);
             if (isValidValue) {
                 if (!Array.isArray(typeData.values) || typeData.values.length !== 12) {
                     console.warn(`Coefficient type "${typeKey}" values array in state is invalid (${typeData.values?.length || 'null/undefined'} elements). Resetting to 12 default values before updating.`);
                    typeData.values = Array(12).fill(isNoneType ? 1 : 0);
                 }
                  typeData.values[monthIndex] = value;
                  console.log(`Valor mes ${MONTHS[monthIndex]} para tipo "${typeData.name}" (${typeKey}) actualizado a ${value}%.`);
                  saveState();
             } else {
                  const errorMessage = `Valor inválido para ${FULL_MONTHS[monthIndex]}. Debe ser un número igual o mayor a -100 (o igual a 1 si es "Sin Coeficiente", lo cual se gestiona automáticamente).`;
                 console.warn(`Validation failed for coefficient value: "${input.value}". ${errorMessage}`);
                 const lastSavedValue = (typeKey && typeData && Array.isArray(typeData.values) && typeData.values.length > monthIndex)
                                       ? typeData.values[monthIndex]
                                        : (isNoneType ? 1 : 0);
                 input.value = lastSavedValue;
                 showSnackbar(errorMessage, true, 'error', 5000);
             }
         }

        function updateIPCManualInputs() {
             const ipcDiv = document.getElementById('ipc-inputs');
             if (!ipcDiv) { console.warn("IPC inputs container not found."); return; }
             ipcDiv.innerHTML = '';
             appState.settings.ipcManual = Array.isArray(appState.settings.ipcManual) && appState.settings.ipcManual.length === 12
                                ? appState.settings.ipcManual.map(v => parseFloat(v || 0))
                                : Array(12).fill(0);
             const ipcValues = appState.settings.ipcManual;
             const ipcCoefficientType = appState.settings.coefficientTypes?.['IPC'];
             for (let i = 0; i < 12; i++) {
                 const monthDiv = document.createElement('div');
                 monthDiv.classList.add('form-group');
                 const label = document.createElement('label');
                 label.textContent = FULL_MONTHS[i];
                 label.htmlFor = `ipc-month-${i}`;
                 const input = document.createElement('input');
                 input.type = 'number';
                 input.id = `ipc-month-${i}`;
                 input.dataset.month = i;
                 input.value = ipcValues[i];
                 input.step = '0.1';
                 input.min = '0';
                 input.placeholder = '%';
                 input.style.textAlign = 'right';
                 input.style.maxWidth = '120px';
                 input.title = `IPC de referencia para ${FULL_MONTHS[i]} (%)`;
                 input.addEventListener('change', (event) => {
                     const monthIndex = parseInt(event.target.dataset.month);
                     const value = parseFloat(event.target.value);
                     if (!isNaN(monthIndex) && monthIndex >= 0 && monthIndex < 12) {
                         const validatedValue = (!isNaN(value) && value >= 0) ? value : 0;
                         appState.settings.ipcManual[monthIndex] = validatedValue;
                          console.log(`IPC manual for ${FULL_MONTHS[monthIndex]} updated to ${validatedValue}%.`);
                          if(ipcCoefficientType && Array.isArray(ipcCoefficientType.values) && ipcCoefficientType.values.length === 12) {
                               ipcCoefficientType.values[monthIndex] = validatedValue;
                               console.log(`Synced IPC Coefficient type value for ${FULL_MONTHS[monthIndex]} to ${validatedValue}%.`);
                          } else {
                              console.warn("IPC Coefficient type not found or invalid during manual IPC change sync.");
                               if (!ipcCoefficientType || !Array.isArray(ipcCoefficientType.values) || ipcCoefficientType.values.length !== 12) {
                                    console.warn("Attempting to fix missing/invalid IPC coefficient type structure during IPC input change.");
                                     const defaultIpcCoefType = getDefaultAppState().settings.coefficientTypes['IPC'];
                                     if (defaultIpcCoefType && Array.isArray(defaultIpcCoefType.values) && defaultIpcCoefType.values.length === 12) {
                                         appState.settings.coefficientTypes['IPC'] = JSON.parse(JSON.stringify(defaultIpcCoefType));
                                         appState.settings.coefficientTypes['IPC'].values[monthIndex] = validatedValue;
                                     } else {
                                        console.error("Fixing IPC coefficient type structure failed.");
                                     }
                                }
                          }
                     } else {
                         const lastValidatedValue = appState.settings.ipcManual[monthIndex] ?? 0;
                         event.target.value = lastValidatedValue;
                         showSnackbar(`Valor IPC inválido para ${FULL_MONTHS[monthIndex]}. Debe ser un número >= 0.`, true, 'error', 4000);
                     }
                 });
                 monthDiv.appendChild(label);
                 monthDiv.appendChild(input);
                 ipcDiv.appendChild(monthDiv);
             }
        }

        // --- DEFINICIONES DE FUNCIONES NUEVAS ---
        function createNewExercise() {
            const yearInput = document.getElementById('exercise-year');
            if (!yearInput) {
                showSnackbar("Error: Elemento de entrada de año no encontrado.", true, 'error');
                return;
            }
            const newYear = parseInt(yearInput.value);

            if (isNaN(newYear) || newYear < 2000 || newYear > 2099) {
                showSnackbar("Año inválido. Por favor, ingrese un año entre 2000 y 2099.", true, 'error', 5000);
                yearInput.value = appState.currentYear;
                return;
            }

            if (newYear === appState.currentYear && appState.scenarios && Object.keys(appState.scenarios).some(k => appState.scenarios[k]?.year === newYear)) { // Corrected check
                showSnackbar(`El año ${newYear} ya está seleccionado y tiene escenarios.`, false, 'info');
                return;
            }

            console.log(`Cambiando/Creando ejercicio para el año: ${newYear}`);
            appState.currentYear = newYear;
            validateAndSetActiveScenario();
            updateUI();
            showSnackbar(`Ejercicio para el año ${appState.currentYear} seleccionado/creado.`, false, 'success');
            saveState();
        }

        function createScenario() {
            const scenarioName = prompt(`Ingrese el nombre para el nuevo escenario (Año ${appState.currentYear}):`, `Escenario ${Object.keys(appState.scenarios).filter(k => appState.scenarios[k]?.year === appState.currentYear).length + 1}`); // Corrected filter
            if (!scenarioName || scenarioName.trim() === '') {
                showSnackbar("Creación de escenario cancelada (nombre vacío).", false, 'info');
                return;
            }
            const sanitizedName = scenarioName.trim().replace(/\s+/g, '_').replace(/[^\w-]/g, '');
            if (sanitizedName === '') {
                showSnackbar("Nombre de escenario inválido después de sanitizar.", true, 'error');
                return;
            }
            const newKey = `${appState.currentYear}_${sanitizedName}`;
            if (appState.scenarios[newKey]) {
                showSnackbar(`El escenario "${scenarioName}" ya existe para el año ${appState.currentYear}.`, true, 'error', 5000);
                return;
            }
            initScenarioData(appState.currentYear, scenarioName.trim()); // Pass trimmed name
            appState.activeScenarioKey = newKey;
            initializeScenarioDataForRubros(appState.scenarios[newKey]);
            calculateAll(appState.scenarios[newKey]);
            showSnackbar(`Escenario "${scenarioName.trim()}" creado y activado.`, false, 'success');
        }

        function cloneScenario() {
            const currentScenario = getCurrentScenarioData();
            if (!currentScenario) {
                showSnackbar("No hay escenario activo para clonar.", true, 'error');
                return;
            }
            const newScenarioName = prompt(`Ingrese el nombre para el escenario clonado (base: "${currentScenario.scenarioName}"):`, `${currentScenario.scenarioName}_Copia`);
            if (!newScenarioName || newScenarioName.trim() === '') {
                showSnackbar("Clonación cancelada (nombre vacío).", false, 'info');
                return;
            }
            const sanitizedNewName = newScenarioName.trim().replace(/\s+/g, '_').replace(/[^\w-]/g, '');
             if (sanitizedNewName === '') {
                showSnackbar("Nombre de escenario inválido después de sanitizar.", true, 'error');
                return;
            }
            const newKey = `${currentScenario.year}_${sanitizedNewName}`;
            if (appState.scenarios[newKey]) {
                showSnackbar(`El escenario "${newScenarioName}" ya existe para el año ${currentScenario.year}.`, true, 'error', 5000);
                return;
            }
            appState.scenarios[newKey] = JSON.parse(JSON.stringify(currentScenario));
            appState.scenarios[newKey].scenarioName = newScenarioName.trim();
            appState.activeScenarioKey = newKey;
            appState.currentYear = currentScenario.year;
            initializeScenarioDataForRubros(appState.scenarios[newKey]);
            calculateAll(appState.scenarios[newKey]);
            showSnackbar(`Escenario "${currentScenario.scenarioName}" clonado como "${newScenarioName.trim()}" y activado.`, false, 'success');
        }

        function deleteScenario() {
            const currentKey = appState.activeScenarioKey;
            const currentScenario = getCurrentScenarioData();
            if (!currentScenario) {
                showSnackbar("No hay escenario activo para eliminar.", true, 'error');
                return;
            }
            const scenariosForCurrentYear = Object.keys(appState.scenarios).filter(k => appState.scenarios[k]?.year === currentScenario.year);
            if (scenariosForCurrentYear.length <= 1 && currentScenario.scenarioName.toLowerCase() === 'base') {
                 showSnackbar(`No se puede eliminar el único escenario "Base" del año ${currentScenario.year}.`, true, 'warning', 6000);
                 return;
            }
            if (!confirm(`¿Seguro que quieres eliminar el escenario "${currentScenario.scenarioName}" (Año ${currentScenario.year})?\n¡Esta acción no se puede deshacer!`)) {
                showSnackbar("Eliminación cancelada.", false, 'info');
                return;
            }
            delete appState.scenarios[currentKey];
            appState.activeScenarioKey = null;
            validateAndSetActiveScenario();
            updateUI();
            saveState();
            showSnackbar(`Escenario "${currentScenario.scenarioName}" eliminado.`, false, 'success');
        }

        function saveReserveFund() {
            const scenarioData = getCurrentScenarioData();
            if (!scenarioData) {
                showSnackbar("No hay escenario activo para guardar el fondo de reserva.", true, 'error');
                return;
            }
            const type = document.getElementById('reserve-type-percent').checked ? 'percent' : 'fixed';
            scenarioData.reserveFund.type = type;
            scenarioData.reserveFund.values = [];
            const inputs = document.querySelectorAll('#reserve-fund-panel input[type="number"]');
            let allValid = true;
            inputs.forEach((input, i) => {
                const val = parseFloat(input.value);
                if (isNaN(val) || val < 0) {
                    showSnackbar(`Valor inválido para ${FULL_MONTHS[i]} en Fondo de Reserva. Debe ser un número >= 0.`, true, 'error', 5000);
                    input.value = scenarioData.reserveFund.values[i] || (type === 'percent' ? 5 : 0);
                    allValid = false;
                    return; // from forEach callback
                }
                scenarioData.reserveFund.values[i] = val;
            });
            if (!allValid) return;
            showSnackbar("Fondo de reserva guardado. Recalculando...", false, 'info', 2000);
            calculateAll(scenarioData);
        }

        function saveSettings() {
            const ufInput = document.getElementById('cantidad-unidades');
            const cantidadUF = parseInt(ufInput.value);
            if (isNaN(cantidadUF) || cantidadUF < 1) {
                showSnackbar("Cantidad de Unidades Funcionales inválida. Debe ser un número mayor o igual a 1.", true, 'error', 5000);
                ufInput.value = appState.settings.cantidadUnidades;
                return;
            }
            appState.settings.cantidadUnidades = cantidadUF;
            const scenarioData = getCurrentScenarioData();
            if (!scenarioData) {
                showSnackbar("No hay escenario activo para aplicar la configuración.", true, 'error', 5000);
                saveState(); // Save settings even if no scenario active
                updateSettingsPanel();
                return;
            }
            showSnackbar("Configuración guardada. Recalculando escenario actual...", false, 'info', 2000);
            calculateAll(scenarioData); // This also saves state
        }

        function handleFileUpload(files) {
            const file = files[0];
            const feedbackDiv = document.getElementById('file-upload-feedback');
            if (!feedbackDiv) {
                console.error("File upload feedback div not found.");
                showSnackbar("Error interno: no se puede mostrar feedback de carga.", true, 'error');
                return;
            }
            feedbackDiv.textContent = '';

            if (!file) {
                feedbackDiv.textContent = "No se seleccionó ningún archivo.";
                feedbackDiv.style.color = 'var(--danger-color)';
                return;
            }
            if (!file.name.endsWith('.xlsx') && !file.name.endsWith('.xls')) {
                feedbackDiv.textContent = `Archivo no válido: ${file.name}. Por favor, sube un archivo Excel (.xlsx o .xls).`;
                feedbackDiv.style.color = 'var(--danger-color)';
                showSnackbar("Tipo de archivo no válido. Use .xlsx o .xls.", true, 'error');
                return;
            }
            feedbackDiv.textContent = `Cargando ${file.name}...`;
            feedbackDiv.style.color = 'var(--info-color)';

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array', cellDates: true });
                    const scenarioData = getCurrentScenarioData();
                    if (!scenarioData) {
                        showSnackbar("Error: No hay escenario activo para cargar datos. Intenta crear/seleccionar un año y escenario.", true, 'error', 6000);
                        feedbackDiv.textContent = "Error: No hay escenario activo.";
                        feedbackDiv.style.color = 'var(--danger-color)';
                        return;
                    }
                    let newGastosRubros = [];
                    let newIngresosRubros = [];
                    let newGastosDetails = {};
                    let newIngresosDetails = {};
                    let fileProcessedSuccessfully = false;

                    const gastosSheet = workbook.Sheets[GASTOS_SHEET_NAME];
                    if (gastosSheet) {
                        const gastosJson = XLSX.utils.sheet_to_json(gastosSheet, { header: 1, blankrows: false });
                        if (gastosJson.length > 1) {
                            scenarioData.data.gastos = {};
                            scenarioData.monthStatus.gastos = {};
                             // Ensure global rubros list for gastos exists
                            if (!Array.isArray(appState.settings.rubros.gastos)) appState.settings.rubros.gastos = [];

                            for (let i = 1; i < gastosJson.length; i++) {
                                const row = gastosJson[i];
                                const rubroName = String(row[0] || '').trim();
                                const detailName = String(row[1] || '').trim();
                                if (!rubroName || !detailName) continue;
                                if (!appState.settings.rubros.gastos.includes(rubroName)) {
                                    appState.settings.rubros.gastos.push(rubroName);
                                    if(!newGastosRubros.includes(rubroName)) newGastosRubros.push(rubroName);
                                    appState.settings.rubroConfig[rubroName] = appState.settings.rubroConfig[rubroName] || { coefficientType: 'None', detailsCollapsed: true };
                                }
                                if (!scenarioData.rubroOrder.gastos.includes(rubroName)) {
                                    scenarioData.rubroOrder.gastos.push(rubroName);
                                }
                                if (!scenarioData.data.gastos[rubroName]) {
                                    scenarioData.data.gastos[rubroName] = { detailOrder: [], detailsData: {} };
                                    scenarioData.monthStatus.gastos[rubroName] = {};
                                }
                                if (!scenarioData.data.gastos[rubroName].detailOrder.includes(detailName)) {
                                    scenarioData.data.gastos[rubroName].detailOrder.push(detailName);
                                    if (!newGastosDetails[rubroName]) newGastosDetails[rubroName] = [];
                                    if (!newGastosDetails[rubroName].includes(detailName)) newGastosDetails[rubroName].push(detailName);
                                }
                                scenarioData.data.gastos[rubroName].detailsData[detailName] = [];
                                scenarioData.monthStatus.gastos[rubroName][detailName] = [];
                                for (let m = 0; m < 12; m++) {
                                    const cellValue = row[2 + m];
                                    let numericValue = parseFloat(cellValue);
                                    if (typeof cellValue === 'number' && !isNaN(numericValue)) {
                                        scenarioData.data.gastos[rubroName].detailsData[detailName][m] = numericValue;
                                        scenarioData.monthStatus.gastos[rubroName][detailName][m] = 'REAL';
                                    } else {
                                        scenarioData.data.gastos[rubroName].detailsData[detailName][m] = 0;
                                        scenarioData.monthStatus.gastos[rubroName][detailName][m] = 'Estimado';
                                    }
                                }
                            }
                            fileProcessedSuccessfully = true;
                            console.log("Hoja Gastos procesada.");
                        } else {
                            feedbackDiv.textContent += `\nHoja "${GASTOS_SHEET_NAME}" está vacía o mal formateada.`;
                            feedbackDiv.style.color = 'var(--warning-color)';
                        }
                    } else {
                        feedbackDiv.textContent += `\nHoja "${GASTOS_SHEET_NAME}" no encontrada en el archivo.`;
                        feedbackDiv.style.color = 'var(--warning-color)';
                    }

                    const ingresosSheet = workbook.Sheets[INGRESOS_SHEET_NAME];
                    if (ingresosSheet) {
                        const ingresosJson = XLSX.utils.sheet_to_json(ingresosSheet, { header: 1, blankrows: false });
                        if (ingresosJson.length > 1) {
                            scenarioData.data.ingresos = {};
                            // Ensure global rubros list for ingresos exists
                            if (!Array.isArray(appState.settings.rubros.ingresos)) appState.settings.rubros.ingresos = [];

                            for (let i = 1; i < ingresosJson.length; i++) {
                                const row = ingresosJson[i];
                                const rubroName = String(row[0] || '').trim();
                                const detailName = String(row[1] || '').trim();
                                if (!rubroName || !detailName) continue;
                                if (!appState.settings.rubros.ingresos.includes(rubroName)) {
                                    appState.settings.rubros.ingresos.push(rubroName);
                                     if(!newIngresosRubros.includes(rubroName)) newIngresosRubros.push(rubroName);
                                    appState.settings.rubroConfig[rubroName] = appState.settings.rubroConfig[rubroName] || { detailsCollapsed: true };
                                }
                                if (!scenarioData.rubroOrder.ingresos.includes(rubroName)) {
                                    scenarioData.rubroOrder.ingresos.push(rubroName);
                                }
                                if (!scenarioData.data.ingresos[rubroName]) {
                                    scenarioData.data.ingresos[rubroName] = { detailOrder: [], detailsData: {} };
                                }
                                if (!scenarioData.data.ingresos[rubroName].detailOrder.includes(detailName)) {
                                    scenarioData.data.ingresos[rubroName].detailOrder.push(detailName);
                                     if (!newIngresosDetails[rubroName]) newIngresosDetails[rubroName] = [];
                                     if (!newIngresosDetails[rubroName].includes(detailName)) newIngresosDetails[rubroName].push(detailName);
                                }
                                scenarioData.data.ingresos[rubroName].detailsData[detailName] = [];
                                for (let m = 0; m < 12; m++) {
                                    const cellValue = row[2 + m];
                                    let numericValue = parseFloat(cellValue);
                                    scenarioData.data.ingresos[rubroName].detailsData[detailName][m] = (typeof cellValue === 'number' && !isNaN(numericValue)) ? numericValue : 0;
                                }
                            }
                            fileProcessedSuccessfully = fileProcessedSuccessfully || true;
                            console.log("Hoja Ingresos procesada.");
                        } else {
                            feedbackDiv.textContent += `\nHoja "${INGRESOS_SHEET_NAME}" está vacía o mal formateada.`;
                             feedbackDiv.style.color = 'var(--warning-color)';
                        }
                    } else {
                         feedbackDiv.textContent += `\nHoja "${INGRESOS_SHEET_NAME}" no encontrada en el archivo.`;
                         feedbackDiv.style.color = 'var(--warning-color)';
                    }

                    if (fileProcessedSuccessfully) {
                        let newItemsMessage = "";
                        if (newGastosRubros.length > 0) newItemsMessage += `\nNuevos rubros de Gasto: ${newGastosRubros.join(', ')}.`;
                        if (newIngresosRubros.length > 0) newItemsMessage += `\nNuevos rubros de Ingreso: ${newIngresosRubros.join(', ')}.`;
                        feedbackDiv.textContent = `Archivo "${file.name}" procesado.${newItemsMessage}\nRecalculando...`;
                        feedbackDiv.style.color = 'var(--success-color)';
                        initializeScenarioDataForRubros(scenarioData);
                        calculateAll(scenarioData);
                        showSnackbar(`Datos de "${file.name}" cargados y calculados. ${newItemsMessage}`, false, 'success', 6000);
                        updateSettingsPanel();
                    } else {
                        if (!feedbackDiv.textContent.includes("Error:")) {
                           feedbackDiv.textContent = "No se encontraron datos válidos para procesar en las hojas esperadas.";
                           feedbackDiv.style.color = 'var(--danger-color)';
                        }
                        showSnackbar("No se pudieron procesar datos del archivo.", true, 'error');
                    }
                } catch (error) {
                    console.error("Error procesando archivo Excel:", error);
                    feedbackDiv.textContent = `Error al procesar el archivo: ${error.message}`;
                    feedbackDiv.style.color = 'var(--danger-color)';
                    showSnackbar("Error grave al procesar el archivo Excel.", true, 'error');
                }
            };
            reader.onerror = function(error) {
                console.error("Error leyendo archivo:", error);
                feedbackDiv.textContent = "Error al leer el archivo.";
                feedbackDiv.style.color = 'var(--danger-color)';
                showSnackbar("Error al leer el archivo.", true, 'error');
            };
            reader.readAsArrayBuffer(file);
        }

        function downloadTemplate() {
            const wb = XLSX.utils.book_new();
            const gastosHeader = ["Rubro", "Detalle", ...MONTHS, "Total Anual (Calculado)"];
            const ingresosHeader = ["Rubro", "Detalle", ...MONTHS, "Total Anual (Calculado)"];
            const sampleGastoRow = ["Ej: Seguridad", "Ej: Vigilador Turno Noche", ...Array(12).fill(""), ""];
            const sampleIngresoRow = ["Ej: Expensas Ordinarias", "Base por UF", ...Array(12).fill(""), ""];
            const wsGastos = XLSX.utils.aoa_to_sheet([gastosHeader, sampleGastoRow]);
            const wsIngresos = XLSX.utils.aoa_to_sheet([ingresosHeader, sampleIngresoRow]);
            XLSX.utils.book_append_sheet(wb, wsGastos, GASTOS_SHEET_NAME);
            XLSX.utils.book_append_sheet(wb, wsIngresos, INGRESOS_SHEET_NAME);
            XLSX.writeFile(wb, `Plantilla_Expensas_${appState.currentYear}.xlsx`);
            showSnackbar("Plantilla de ejemplo descargada.", false, 'success');
        }

        function loadSampleData() {
            if (!confirm("¿Cargar datos de ejemplo? Esto reemplazará los datos del escenario actual si ya existen.")) {
                showSnackbar("Carga de datos de ejemplo cancelada.", false, 'info');
                return;
            }
            const scenario = getCurrentScenarioData();
            if (!scenario) {
                showSnackbar("No hay escenario activo. Por favor, cree o seleccione un año y escenario primero.", true, 'error', 6000);
                return;
            }
            appState.settings.rubros = {
                gastos: ["Seguridad", "Mantenimiento", "Administración"],
                ingresos: [CUOTA_RUBRO_NAME, "Alquiler SUM", "Intereses Plazo Fijo"]
            };
            appState.settings.cantidadUnidades = 150;
            appState.settings.ipcManual = [1.0, 1.2, 0.8, 1.5, 2.0, 1.3, 1.0, 0.5, 0.7, 1.1, 1.4, 1.0];
            ensureDefaultCoefficientTypes();
            appState.settings.coefficientTypes["SueldosAdmin"] = { name: "Sueldos Admin", values: Array(12).fill(2.5), isDefault: false };
            appState.settings.rubroConfig = {
                "Seguridad": { coefficientType: "UTEDYC", detailsCollapsed: false },
                "Mantenimiento": { coefficientType: "IPC", detailsCollapsed: true },
                "Administración": { coefficientType: "SueldosAdmin", detailsCollapsed: false },
                [CUOTA_RUBRO_NAME]: { detailsCollapsed: false },
                "Alquiler SUM": { detailsCollapsed: true },
                "Intereses Plazo Fijo": { detailsCollapsed: false }
            };
            scenario.data.gastos = {
                "Seguridad": { detailOrder: ["Vigiladores", "Monitoreo"], detailsData: { "Vigiladores": [100000, 101000, 102000, 103000, 110000, 111000, 112000, 113000, 120000, 121000, 122000, 123000], "Monitoreo": Array(12).fill(25000) } },
                "Mantenimiento": { detailOrder: ["Limpieza", "Jardinería"], detailsData: { "Limpieza": Array(12).fill(30000), "Jardinería": [15000, 15000, 16000, 16000, 17000, 17000, 18000, 18000, 19000, 19000, 20000, 20000] } },
                "Administración": { detailOrder: ["Honorarios Admin", "Gastos Bancarios"], detailsData: { "Honorarios Admin": Array(12).fill(50000), "Gastos Bancarios": Array(12).fill(5000) } }
            };
            scenario.monthStatus.gastos = {
                "Seguridad": { "Vigiladores": Array(12).fill('REAL'), "Monitoreo": Array(12).fill('REAL') },
                "Mantenimiento": { "Limpieza": Array(12).fill('REAL'), "Jardinería": Array(12).fill('REAL') },
                "Administración": { "Honorarios Admin": Array(12).fill('REAL'), "Gastos Bancarios": Array(12).fill('REAL') }
            };
            scenario.rubroOrder.gastos = ["Seguridad", "Mantenimiento", "Administración"];
            scenario.data.ingresos = {
                [CUOTA_RUBRO_NAME]: { detailOrder: ["Cuota Base UF"], detailsData: { "Cuota Base UF": Array(12).fill(35.50) } },
                "Alquiler SUM": { detailOrder: ["Eventos FinDeSemana"], detailsData: { "Eventos FinDeSemana": [5000, 0, 7000, 0, 10000, 0, 12000, 0, 8000, 0, 6000, 0] } },
                "Intereses Plazo Fijo": { detailOrder: ["Fondo Común Inv."], detailsData: { "Fondo Común Inv.": [1000,1100,1050,1200,1150,1300,1250,1400,1350,1500,1450,1600] } }
            };
            scenario.rubroOrder.ingresos = [CUOTA_RUBRO_NAME, "Alquiler SUM", "Intereses Plazo Fijo"];
            scenario.reserveFund = { type: 'percent', values: [5,5,5,6,6,6,7,7,7,8,8,8] };
            initializeScenarioDataForRubros(scenario);
            calculateAll(scenario);
            updateSettingsPanel();
            showSnackbar("Datos de ejemplo cargados y calculados.", false, 'success');
        }

        function exportToExcel() {
            const scenario = getCurrentScenarioData();
            if (!scenario) {
                showSnackbar("No hay datos de escenario para exportar.", true, 'error');
                return;
            }
            const wb = XLSX.utils.book_new();
            const summaryData = [ ["Mes", "Gasto ($)", "Fondo ($)", "Cuota s/Gs ($/UF)", "IPC (%)", "Cuota IPC ($/UF)", "Expensa Real ($/UF)"] ];
            for (let i = 0; i < 12; i++) {
                summaryData.push([ MONTHS[i], scenario.calculated.totalGastoProyectadoMes?.[i] || 0, scenario.calculated.fondoReservaMes?.[i] || 0, scenario.calculated.cuotaSobreGastosMes?.[i] || 0, scenario.calculated.ipcManual?.[i] || 0, scenario.calculated.cuotaIpcMes?.[i] || 0, scenario.calculated.cuotaRealBaseMes?.[i] || 0 ]);
            }
            summaryData.push([ "TOTAL ANUAL", scenario.calculated.annualTotals.gastos?.__TOTAL__ || 0, scenario.calculated.annualTotals.fondoReserva || 0, scenario.calculated.annualTotals.cuotaSobreGastos || 0, "-", scenario.calculated.annualTotals.cuotaIpc || 0, scenario.calculated.annualTotals.cuotaRealBase || 0 ]);
            const wsSummary = XLSX.utils.aoa_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, wsSummary, "Resumen General");

            const gastosReportData = [["Rubro", "Detalle", "Coef. Aplicado", ...MONTHS, "Total Anual"]];
            ((appState.settings && appState.settings.rubros && appState.settings.rubros.gastos) ? appState.settings.rubros.gastos : []).forEach(rubro => { // Use global rubro list for order
                if (!scenario.data.gastos[rubro]) return; // Skip if no data for this rubro in scenario
                const config = appState.settings.rubroConfig[rubro] || {};
                const coefTypeKey = config.coefficientType || 'None';
                const coefName = appState.settings.coefficientTypes[coefTypeKey]?.name || 'N/A';
                const rubroTotals = scenario.calculated.totalGastoRubroMes?.[rubro] || Array(12).fill(0);
                gastosReportData.push([ rubro, "TOTAL RUBRO", "", ...rubroTotals, scenario.calculated.annualTotals.gastos?.[rubro] || 0 ]);
                (scenario.data.gastos[rubro]?.detailOrder || []).forEach(detail => {
                    const detailValues = scenario.calculated.gastoAjustado?.[rubro]?.[detail] || Array(12).fill(0);
                    const annualDetailTotal = detailValues.reduce((s,v)=>s+v,0);
                    gastosReportData.push([ "", detail, coefName, ...detailValues, annualDetailTotal ]);
                });
            });
            const wsGastos = XLSX.utils.aoa_to_sheet(gastosReportData);
            XLSX.utils.book_append_sheet(wb, wsGastos, "Detalle Gastos");

            const ingresosReportData = [["Rubro", "Detalle", ...MONTHS, "Total Anual"]];
             ((appState.settings && appState.settings.rubros && appState.settings.rubros.ingresos) ? appState.settings.rubros.ingresos : []).forEach(rubro => { // Use global rubro list for order
                if (!scenario.data.ingresos[rubro]) return; // Skip if no data
                const rubroTotals = scenario.calculated.totalIngresoRubroMes?.[rubro] || Array(12).fill(0);
                ingresosReportData.push([ rubro, "TOTAL RUBRO (Calculado)", ...rubroTotals, scenario.calculated.annualTotals.ingresos?.[rubro] || 0 ]);
                (scenario.data.ingresos[rubro]?.detailOrder || []).forEach(detail => {
                    const detailBaseValues = scenario.calculated.ingresoAjustado?.[rubro]?.[detail] || Array(12).fill(0);
                    const annualDetailBaseTotal = detailBaseValues.reduce((s,v)=>s+v,0);
                    ingresosReportData.push([ "", detail + (SPECIAL_INGRESO_RUBROS.includes(rubro) ? " (Valor Base x UF)" : " (Valor Base)"), ...detailBaseValues, annualDetailBaseTotal ]);
                });
            });
            const wsIngresos = XLSX.utils.aoa_to_sheet(ingresosReportData);
            XLSX.utils.book_append_sheet(wb, wsIngresos, "Detalle Ingresos (Base)");

            const configData = [ ["Parámetro", "Valor"], ["Año Ejercicio", scenario.year], ["Nombre Escenario", scenario.scenarioName], ["Cantidad UF", appState.settings.cantidadUnidades], ["Fondo Reserva Tipo", scenario.reserveFund.type], ...scenario.reserveFund.values.map((val,i) => [`Fondo Reserva ${MONTHS[i]}`, val]), ...appState.settings.ipcManual.map((val,i) => [`IPC Manual ${MONTHS[i]} (%)`, val]), ];
            Object.entries(appState.settings.coefficientTypes).forEach(([key, type]) => {
                configData.push([`Coef. Tipo: ${type.name} (${key})`, "Valores Mensuales (%)"]);
                type.values.forEach((val,i) => configData.push([MONTHS[i], val]));
            });
            ((appState.settings && appState.settings.rubros && appState.settings.rubros.gastos) ? appState.settings.rubros.gastos : []).forEach(rubro => {
                const coefKey = appState.settings.rubroConfig[rubro]?.coefficientType || 'None';
                configData.push([`Rubro Gasto: ${rubro}`, `Coef. Asignado: ${appState.settings.coefficientTypes[coefKey]?.name || 'N/A'}`]);
            });
            const wsConfig = XLSX.utils.aoa_to_sheet(configData);
            XLSX.utils.book_append_sheet(wb, wsConfig, "Configuración Aplicada");

            XLSX.writeFile(wb, `Reporte_Expensas_${scenario.year}_${scenario.scenarioName.replace(/\s+/g, '_')}.xlsx`);
            showSnackbar("Reporte Excel generado.", false, 'success');
        }

        function exportChart(chartId, filename) {
            const chartInstance = window[`${chartId}_instance`];
            if (chartInstance) {
                try {
                    const image = chartInstance.toBase64Image();
                    const link = document.createElement('a');
                    link.href = image;
                    link.download = filename;
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    showSnackbar(`Gráfico "${filename}" descargado.`, false, 'success');
                } catch (e) {
                    console.error("Error exportando gráfico:", e);
                    showSnackbar("Error al exportar el gráfico.", true, 'error');
                }
            } else {
                showSnackbar("El gráfico no está disponible para exportar (sin datos o no renderizado).", true, 'warning');
            }
        }


        // --- Utilidades ---
        function formatCurrency(value) {
             const num = Number(value);
             if (isNaN(num) || !isFinite(num)) return "$ 0,00";
             try {
                 return `$ ${num.toLocaleString('es-AR', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
             } catch (e) {
                 console.error("Error formatting currency:", value, e);
                 return `$ ${num.toFixed(2).replace('.', ',').replace(/\B(?=(\d{3})+(?!\d))/g, '.')}`;
             }
        }

        function hexToRgba(hex, alpha) {
            hex = String(hex || '#000000').trim().replace('#', '');
            if (!/^[0-9A-F]{3,6}$/i.test(hex)) {
                 console.warn(`Invalid hex color provided: "${hex}". Using rgba(0,0,0,${alpha}).`);
                hex = '000000';
            }
            if (hex.length === 3) {
                hex = hex.split('').map(c => c + c).join('');
            }
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
             if (isNaN(r) || isNaN(g) || isNaN(b)) {
                  console.error(`Error parsing hex "${hex}" to RGB.`);
                  return `rgba(0,0,0,${alpha})`;
             }
             const validAlpha = typeof alpha === 'number' ? Math.max(0, Math.min(1, alpha)) : 1;
            return `rgba(${r}, ${g}, ${b}, ${validAlpha})`;
        }

        function openTab(evt, tabName) {
             if (typeof tabName !== 'string' || !tabName) {
                 console.error("Invalid tab name provided:", tabName);
                 return;
             }
             const tabcontents = document.getElementsByClassName("tab-content");
             for (let i = 0; i < tabcontents.length; i++) {
                 tabcontents[i].classList.remove("active");
                 tabcontents[i].style.display = "none";
             }
             const tablinks = document.getElementsByClassName("tab-link");
             for (let i = 0; i < tablinks.length; i++) {
                 tablinks[i].classList.remove("active");
             }
             const tabToShow = document.getElementById(tabName);
             if(tabToShow) {
                  tabToShow.style.display = "block";
                 void tabToShow.offsetWidth;
                 tabToShow.classList.add("active");
             } else {
                 console.warn(`Tab content element not found for id: ${tabName}`);
                 showSnackbar(`Error interno: Pestaña "${tabName}" no encontrada.`, true, 'error', 5000);
             }
             if(evt?.currentTarget) {
                  evt.currentTarget.classList.add("active");
             }
             if (tabName === 'dashboard') {
                 requestAnimationFrame(() => {
                    ['evolutivoCuotaChart', 'participacionGastosChart', 'participacionIngresosChart'].forEach(id => {
                        if (window[`${id}_instance`]) {
                             window[`${id}_instance`].resize();
                            console.log(`Resized chart: ${id}`);
                        } else {
                            console.log(`Chart instance not found to resize: ${id}`);
                        }
                    });
                 });
             }
         }

        function showSnackbar(message, isError = false, level = null, duration = 4000) {
             const snackbar = document.getElementById('snackbar');
             if (!snackbar) {
                 console.warn("Snackbar element not found. Message:", message);
                 return;
             }
             snackbar.textContent = message;
             let effectiveLevel = level ?? (isError ? 'error' : 'success');
             snackbar.className = 'show';
             snackbar.classList.remove('error', 'warning', 'info');
             if (effectiveLevel === 'error') snackbar.classList.add('error');
             else if (effectiveLevel === 'warning') snackbar.classList.add('warning');
             else if (effectiveLevel === 'info') snackbar.classList.add('info');
             if (snackbar.timer) {
                 clearTimeout(snackbar.timer);
                 snackbar.timer = null;
             }
             snackbar.timer = setTimeout(() => {
                 snackbar.className = '';
                 snackbar.timer = null;
             }, duration);
         }

        function initTheme() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia?.('(prefers-color-scheme: dark)')?.matches ?? false;
            appState.darkMode = (savedTheme === 'dark') || (!savedTheme && prefersDark);
            if (window.matchMedia) {
                 const systemThemeQuery = window.matchMedia('(prefers-color-scheme: dark)');
                 systemThemeQuery.addEventListener('change', event => {
                    if (!localStorage.getItem('theme')) {
                        appState.darkMode = event.matches;
                        applyTheme(true);
                         saveState();
                    }
                 });
            }
            applyTheme(false);
             console.log(`Initial theme set to ${appState.darkMode ? 'dark' : 'light'}.`);
        }

        function toggleTheme() {
            appState.darkMode = !appState.darkMode;
            localStorage.setItem('theme', appState.darkMode ? 'dark' : 'light');
            applyTheme(true);
            saveState();
             console.log(`Theme toggled to ${appState.darkMode ? 'dark' : 'light'}. Explicit choice saved.`);
        }

        function applyTheme(updateCharts = true){
            const body = document.body;
            const toggleButton = document.getElementById('theme-toggle');
            body.classList.toggle('dark-mode', appState.darkMode);
            if (toggleButton) {
                 toggleButton.innerHTML = appState.darkMode ? '<i class="fas fa-sun"></i>' : '<i class="fas fa-moon"></i>';
                 toggleButton.title = appState.darkMode ? 'Cambiar a tema claro' : 'Cambiar a tema oscuro';
            }
            if (updateCharts) {
                 requestAnimationFrame(() => {
                     const textColor = getComputedStyle(document.documentElement).getPropertyValue('--text-color').trim();
                     const borderColor = getComputedStyle(document.documentElement).getPropertyValue('--border-color').trim();
                     Chart.defaults.color = textColor;
                     ['evolutivoCuotaChart', 'participacionGastosChart', 'participacionIngresosChart'].forEach(id => {
                          if (window[`${id}_instance`]) {
                               window[`${id}_instance`].update();
                                console.log(`Updated theme colors for chart: ${id}`);
                           }
                     });
                 });
            }
        }

        function saveState() {
             try {
                 const stateToSave = {
                     currentYear: appState.currentYear,
                     scenarios: appState.scenarios,
                     activeScenarioKey: appState.activeScenarioKey,
                     settings: appState.settings,
                     darkMode: appState.darkMode,
                 };
                 const jsonState = JSON.stringify(stateToSave);
                 localStorage.setItem(STORAGE_KEY, jsonState);
                 console.log("Estado guardado a localStorage.");

             } catch (e) {
                 console.error(`Error guardando estado a localStorage con key "${STORAGE_KEY}":`, e);
                 showSnackbar("Error al guardar estado en el navegador.", true, 'error', 6000);
             }
         }

        function loadState() {
             try {
                 const savedState = localStorage.getItem(STORAGE_KEY);
                 if (savedState) {
                     console.log(`Encontrado estado guardado para key "${STORAGE_KEY}".`);
                     const loadedState = JSON.parse(savedState);
                     console.log("Estado guardado parseado:", loadedState);
                     appState = deepMerge(getDefaultAppState(), loadedState);
                     console.log(`Estado ${STORAGE_KEY} cargado y fusionado con estado por defecto.`);

                    // --- INICIO: Verificación adicional de estructura post-carga ---
                    if (!appState.settings) {
                        appState.settings = getDefaultAppState().settings;
                        console.warn("appState.settings estaba ausente después de la carga. Restaurado a default.");
                    }
                    if (!appState.settings.rubros || typeof appState.settings.rubros !== 'object' || appState.settings.rubros === null) { // Added null check
                        appState.settings.rubros = { gastos: [], ingresos: [] };
                        console.warn("appState.settings.rubros estaba ausente o no era un objeto. Restaurado a default.");
                    }
                    if (!Array.isArray(appState.settings.rubros.gastos)) {
                        appState.settings.rubros.gastos = [];
                        console.warn("appState.settings.rubros.gastos no era un array. Restaurado a array vacío.");
                    }
                    if (!Array.isArray(appState.settings.rubros.ingresos)) {
                        appState.settings.rubros.ingresos = [];
                        console.warn("appState.settings.rubros.ingresos no era un array. Restaurado a array vacío.");
                    }
                    // --- FIN: Verificación adicional ---

                 } else {
                     console.log(`No hay estado guardado para key "${STORAGE_KEY}". Usando estado por defecto.`);
                     appState = getDefaultAppState();
                 }
             } catch (e) {
                 console.error(`Error cargando estado desde localStorage con key "${STORAGE_KEY}":`, e);
                 showSnackbar(`Error cargando estado guardado (${STORAGE_KEY}). Usando valores por defecto. Si has actualizado la aplicación, esto puede ser normal.`, true, 'error', 8000);
                 appState = getDefaultAppState();
             }
        }

        function getDefaultAppState() {
            const defaultYear = new Date().getFullYear();
            const baseScenarioStructure = {
                year: defaultYear,
                scenarioName: 'Base',
                rubroOrder: { gastos: [], ingresos: [] },
                data: { gastos: {}, ingresos: {} },
                monthStatus: { gastos: {}, ingresos: {} },
                reserveFund: { type: 'percent', values: Array(12).fill(5) },
                calculated: {
                    gastoAjustado: {}, totalGastoRubroMes: {}, totalGastoProyectadoMes: Array(12).fill(0),
                    ingresoAjustado: {}, totalIngresoRubroMes: {}, totalIngresoProyectadoMes: Array(12).fill(0),
                    fondoReservaMes: Array(12).fill(0),
                    cuotaSobreGastosMes: Array(12).fill(0),
                    ipcManual: Array(12).fill(0),
                    cuotaIpcMes: Array(12).fill(0),
                    cuotaRealBaseMes: Array(12).fill(0),
                    annualTotals: { gastos: {__TOTAL__:0}, ingresos: {__TOTAL__:0}, fondoReserva: 0, cuotaSobreGastos: 0, cuotaIpc: 0, cuotaRealBase: 0 }
                }
            };
            const defaultSettings = {
                 cantidadUnidades: 100,
                 rubros: { gastos: [], ingresos: [] }, // ASEGURAR QUE ESTO SIEMPRE SEA UN OBJETO CON ARRAYS
                 rubroConfig: {},
                 coefficientTypes: {
                     "None": { name: "Sin Coeficiente", values: Array(12).fill(1), isDefault: true },
                     "IPC": { name: "IPC", values: Array(12).fill(0), isDefault: true },
                     "UTEDYC": { name: "UTEDYC (Ejemplo)", values: [0, 0, 10, 0, 0, 8, 0, 0, 7, 0, 0, 5], isDefault: true },
                 },
                 ipcManual: [5, 4, 6, 3, 4, 5, 3, 4, 5, 6, 4, 5]
            };
            return {
                 currentYear: defaultYear,
                 scenarios: {},
                 activeScenarioKey: null,
                 settings: defaultSettings,
                 uiState: { editingCoefficientType: null },
                 darkMode: false,
                 BaseScenarioStructureTemplate: baseScenarioStructure
             };
         }

        function deepMerge(target, source) {
             const output = { ...target };
             if (isObject(target) && isObject(source)) {
                 Object.keys(source).forEach(key => {
                     const targetValue = target[key];
                     const sourceValue = source[key];
                     if (isObject(sourceValue) && isObject(targetValue)) {
                         output[key] = deepMerge(targetValue, sourceValue);
                     } else if (Array.isArray(sourceValue)) {
                         output[key] = [...sourceValue];
                     } else {
                           output[key] = sourceValue;
                     }
                 });
             }
             return output;
         }

        function isObject(item) {
             return (item !== null && typeof item === 'object' && !Array.isArray(item));
        }

        function updateReportsPanel() {
             const reportsDiv = document.getElementById('reports');
             if (!reportsDiv) { console.warn("Reports panel not found."); return; }
             const scenarioData = getCurrentScenarioData();
             const hasMeaningfulCalculatedData = scenarioData?.calculated && (
                (scenarioData.calculated.totalGastoProyectadoMes?.some(v => (v || 0) !== 0) ?? false) ||
                (scenarioData.calculated.totalIngresoProyectadoMes?.some(v => (v || 0) !== 0) ?? false) ||
                (scenarioData.calculated.cuotaRealBaseMes?.some(v => (v || 0) !== 0) ?? false)
             );
             const disableButtons = !scenarioData || !hasMeaningfulCalculatedData;
             reportsDiv.querySelectorAll('button').forEach(btn => {
                 btn.disabled = disableButtons;
                 btn.classList.toggle('disabled', disableButtons);
             });
              console.log(`Reports panel buttons are ${disableButtons ? 'disabled' : 'enabled'}.`);
        }

        function clearScenarioData() {
             const key = appState.activeScenarioKey;
             const scenario = appState.scenarios?.[key];
             if (!scenario) {
                 showSnackbar('No hay escenario activo para borrar datos.', true, 'error', 4000);
                 return;
             }
             if (!confirm(`¿Seguro que quieres borrar TODOS los datos (gastos, ingresos, estado meses) del escenario "${scenario.scenarioName}" (Año ${scenario.year})?\n\nLa Configuración de Fondo de Reserva, los Coeficientes y la asignación de rubros se mantendrán.\n¡Esta acción no se puede deshacer!`)) {
                 showSnackbar("Operación cancelada.", false, 'info', 3000);
                 return;
             }
             scenario.data = { gastos: {}, ingresos: {} };
             scenario.monthStatus = { gastos: {}, ingresos: {} };
             scenario.rubroOrder = { gastos: [], ingresos: [] };
             console.log(`Datos de gastos, ingresos y status borrados para escenario: ${key}.`);
             saveState();
             calculateAll(scenario);
        }

    

function destroyChart(canvasId) {
             const instance = window[`${canvasId}_instance`];
             if (instance) {
                instance.destroy();
                window[`${canvasId}_instance`] = null;
                // console.log(`Chart ${canvasId} destroyed.`);
             }
         }



function displayChartNoData(canvasId, show) {
            const container = document.getElementById(canvasId)?.parentElement;
            const noDataElement = container?.querySelector('.chart-no-data');
            if (noDataElement) {
                noDataElement.style.display = show ? 'block' : 'none';
            }
            const canvasElement = document.getElementById(canvasId);
             if (canvasElement) {
                 canvasElement.style.display = show ? 'none' : 'block'; // Hide canvas if no data
             }
        }

</script>
</body>
</html>
```